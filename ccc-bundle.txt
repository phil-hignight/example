-~{File: package.json}~-
{
  "name": "ccc-claude-code-clone",
  "version": "1.0.0",
  "description": "Claude Code Clone - Clipboard-based bridge for internal Claude UI",
  "main": "src/node-server/coordinator.js",
  "scripts": {
    "compile": "./compile.sh",
    "start": "node src/node-server/coordinator.js",
    "mock": "node mock-env/server.js",
    "test": "./test.sh",
    "java:compile": "cd src/java-agent && ./compile.sh",
    "dev": "npm run compile && npm run test"
  },
  "keywords": [
    "claude",
    "clipboard",
    "automation",
    "bridge"
  ],
  "author": "",
  "license": "MIT",
  "engines": {
    "node": ">=14.0.0"
  },
  "dependencies": {},
  "devDependencies": {},
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/ccc-project.git"
  },
  "bugs": {
    "url": "https://github.com/yourusername/ccc-project/issues"
  },
  "homepage": "https://github.com/yourusername/ccc-project#readme"
}
-~{END}~-

-~{File: config.json}~-
{
  "coordinatorPort": 5555,
  "mockServerPort": 5556,
  "production": {
    "coordinatorPort": 5555,
    "mockServerPort": 5556
  },
  "development": {
    "coordinatorPort": 3000,
    "mockServerPort": 3001
  }
}
-~{END}~-

-~{File: src/java-agent/ClipboardAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;

public class ClipboardAgent {
    private static Clipboard clipboard;
    private static Robot robot;
    private static String savedClipboard = "";
    private static Point savedMousePosition = new Point(0, 0);
    private static volatile boolean stopClicking = false;
    private static TrayIcon trayIcon;
    private static ExecutorService executor;
    
    public static void main(String[] args) {
        try {
            // Initialize components
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            robot = new Robot();
            executor = Executors.newSingleThreadExecutor();
            
            // Setup system tray
            setupSystemTray();
            
            // Process commands from stdin
            Scanner scanner = new Scanner(System.in);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                processCommand(line);
            }
            
        } catch (Exception e) {
            sendError("Initialization failed: " + e.getMessage());
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            log("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create a simple icon (16x16 green square)
            Image image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics g = image.getGraphics();
            g.setColor(Color.GREEN);
            g.fillRect(0, 0, 16, 16);
            g.dispose();
            
            // Create tray icon
            trayIcon = new TrayIcon(image, "CCC Agent");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Ready");
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            log("System tray initialized");
            
        } catch (Exception e) {
            log("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void processCommand(String jsonCommand) {
        try {
            // Parse JSON manually (avoiding external dependencies)
            Map<String, Object> cmd = parseSimpleJson(jsonCommand);
            String command = (String) cmd.get("cmd");
            
            switch (command) {
                case "SAVE_CLIPBOARD":
                    saveClipboard();
                    break;
                    
                case "RESTORE_CLIPBOARD":
                    restoreClipboard();
                    break;
                    
                case "SET_CLIPBOARD":
                    setClipboard((String) cmd.get("data"));
                    break;
                    
                case "GET_CLIPBOARD":
                    getClipboard();
                    break;
                    
                case "SAVE_MOUSE":
                    saveMousePosition();
                    break;
                    
                case "GET_MOUSE":
                    getMousePosition();
                    break;
                    
                case "RESTORE_MOUSE":
                    restoreMousePosition();
                    break;
                    
                case "CLICK_LOOP":
                    startClickLoop(
                        parseInt(cmd.get("x")),
                        parseInt(cmd.get("y")),
                        parseInt(cmd.get("interval")),
                        parseInt(cmd.get("maxDuration"))
                    );
                    break;
                    
                case "STOP_CLICKING":
                    stopClicking();
                    break;
                    
                case "SET_STATUS":
                    setStatus((String) cmd.get("message"));
                    break;
                    
                case "PING":
                    sendResponse("pong", null);
                    break;
                    
                default:
                    sendError("Unknown command: " + command);
            }
            
        } catch (Exception e) {
            sendError("Command processing failed: " + e.getMessage());
        }
    }
    
    private static void saveClipboard() {
        try {
            Transferable contents = clipboard.getContents(null);
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                savedClipboard = (String) contents.getTransferData(DataFlavor.stringFlavor);
                sendResponse("clipboard_saved", savedClipboard.length() + " chars");
            } else {
                savedClipboard = "";
                sendResponse("clipboard_saved", "empty");
            }
        } catch (Exception e) {
            sendError("Failed to save clipboard: " + e.getMessage());
        }
    }
    
    private static void restoreClipboard() {
        try {
            StringSelection selection = new StringSelection(savedClipboard);
            clipboard.setContents(selection, null);
            sendResponse("clipboard_restored", savedClipboard.length() + " chars");
        } catch (Exception e) {
            sendError("Failed to restore clipboard: " + e.getMessage());
        }
    }
    
    private static void setClipboard(String data) {
        try {
            StringSelection selection = new StringSelection(data);
            clipboard.setContents(selection, null);
            sendResponse("clipboard_set", data.length() + " chars");
        } catch (Exception e) {
            sendError("Failed to set clipboard: " + e.getMessage());
        }
    }
    
    private static void getClipboard() {
        try {
            Transferable contents = clipboard.getContents(null);
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                String data = (String) contents.getTransferData(DataFlavor.stringFlavor);
                sendResponse("clipboard_content", data);
            } else {
                sendResponse("clipboard_content", "");
            }
        } catch (Exception e) {
            sendError("Failed to get clipboard: " + e.getMessage());
        }
    }
    
    private static void saveMousePosition() {
        savedMousePosition = MouseInfo.getPointerInfo().getLocation();
        sendResponse("mouse_saved", savedMousePosition.x + "," + savedMousePosition.y);
    }
    
    private static void getMousePosition() {
        Point currentPos = MouseInfo.getPointerInfo().getLocation();
        sendResponse("mouse_position", currentPos.x + "," + currentPos.y);
    }
    
    private static void restoreMousePosition() {
        robot.mouseMove(savedMousePosition.x, savedMousePosition.y);
        sendResponse("mouse_restored", savedMousePosition.x + "," + savedMousePosition.y);
    }
    
    private static void startClickLoop(int x, int y, int interval, int maxDuration) {
        stopClicking = false;
        
        executor.submit(() -> {
            try {
                long startTime = System.currentTimeMillis();
                int clickCount = 0;
                
                while (!stopClicking && (System.currentTimeMillis() - startTime) < maxDuration) {
                    // Move to position
                    robot.mouseMove(x, y);
                    robot.delay(50);
                    
                    // Click with hold time (like the proven test)
                    robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
                    robot.delay(80); // Hold for 80ms like the test
                    robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
                    clickCount++;
                    
                    // Wait for interval (use longer interval for more deliberate clicks)
                    Thread.sleep(Math.max(interval, 500)); // At least 500ms between clicks
                }
                
                sendResponse("click_loop_complete", clickCount + " clicks");
                
            } catch (Exception e) {
                sendError("Click loop failed: " + e.getMessage());
            }
        });
        
        sendResponse("click_loop_started", x + "," + y);
    }
    
    private static void stopClicking() {
        stopClicking = true;
        sendResponse("clicking_stopped", null);
    }
    
    private static void setStatus(String message) {
        if (trayIcon != null) {
            trayIcon.setToolTip("CCC Agent: " + message);
        }
        sendResponse("status_set", message);
    }
    
    // Helper methods
    private static Map<String, Object> parseSimpleJson(String json) {
        Map<String, Object> result = new HashMap<>();
        
        // Remove braces and split by comma
        json = json.trim();
        if (json.startsWith("{")) json = json.substring(1);
        if (json.endsWith("}")) json = json.substring(0, json.length() - 1);
        
        // Parse key-value pairs
        String[] pairs = json.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)");
        for (String pair : pairs) {
            String[] kv = pair.split(":", 2);
            if (kv.length == 2) {
                String key = kv[0].trim().replaceAll("\"", "");
                String value = kv[1].trim();
                
                // Remove quotes from string values
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    value = value.substring(1, value.length() - 1);
                    // Unescape JSON string
                    value = value.replace("\\\"", "\"")
                                 .replace("\\\\", "\\")
                                 .replace("\\n", "\n")
                                 .replace("\\r", "\r")
                                 .replace("\\t", "\t");
                }
                
                result.put(key, value);
            }
        }
        
        return result;
    }
    
    private static int parseInt(Object value) {
        if (value == null) return 0;
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            return 0;
        }
    }
    
    private static void sendResponse(String type, String data) {
        // For clipboard_content, send raw data without escaping
        if ("clipboard_content".equals(type) && data != null) {
            String response = String.format("{\"type\":\"%s\",\"data\":%s,\"timestamp\":%d}",
                type, escapeJson(data), System.currentTimeMillis());
            System.out.println(response);
        } else {
            String response = String.format("{\"type\":\"%s\",\"data\":\"%s\",\"timestamp\":%d}",
                type, data != null ? data : "", System.currentTimeMillis());
            System.out.println(response);
        }
        System.out.flush();
    }
    
    private static String escapeJson(String str) {
        return "\"" + str.replace("\\", "\\\\")
                         .replace("\"", "\\\"")
                         .replace("\n", "\\n")
                         .replace("\r", "\\r")
                         .replace("\t", "\\t") + "\"";
    }
    
    private static void sendError(String error) {
        String response = String.format("{\"type\":\"error\",\"error\":\"%s\",\"timestamp\":%d}",
            error, System.currentTimeMillis());
        System.out.println(response);
        System.out.flush();
    }
    
    private static void log(String message) {
        System.err.println("[Agent] " + message);
    }
}
-~{END}~-

-~{File: src/java-agent/StandaloneAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;

public class StandaloneAgent {
    private static Clipboard clipboard;
    private static Robot robot;
    private static String savedClipboard = "";
    private static Point clickPosition = null;
    private static volatile boolean calibrated = false;
    private static TrayIcon trayIcon;
    
    public static void main(String[] args) {
        try {
            // Initialize components
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            robot = new Robot();
            
            // Setup system tray
            setupSystemTray();
            
            // Start the demo flow
            runDemo();
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            System.out.println("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create icon (16x16 pixels)
            BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics2D g = image.createGraphics();
            g.setColor(Color.GREEN);
            g.fillOval(0, 0, 16, 16);
            g.dispose();
            
            trayIcon = new TrayIcon(image, "CCC Agent - Ready");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Waiting for calibration");
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            System.out.println("System tray initialized");
            
        } catch (Exception e) {
            System.out.println("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void runDemo() throws Exception {
        System.out.println("================================");
        System.out.println("CCC Demo - Java Standalone");
        System.out.println("================================");
        System.out.println();
        
        // Wait for bridge script to be pasted
        waitForBridgePaste();
        
        // Wait for calibration
        waitForCalibration();
        
        // Send test AI request
        sendAIRequest();
        
        // Wait for response
        waitForResponse();
        
        System.out.println("Demo completed!");
    }
    
    private static void waitForBridgePaste() throws Exception {
        System.out.println("Waiting for bridge script to be pasted...");
        System.out.println("1. Bridge script should already be in your clipboard");
        System.out.println("2. Go to http://localhost:5556/ or your internal Claude UI");
        System.out.println("3. Open Developer Console (F12) and paste the script");
        System.out.println("4. The script will signal when it's loaded");
        System.out.println();
        
        // Save current clipboard content first
        String originalClipboard = "";
        try {
            originalClipboard = getClipboardContent();
            if (originalClipboard != null) {
                System.out.println("[Demo] Saved original clipboard (" + originalClipboard.length() + " chars)");
            }
        } catch (Exception e) {
            System.out.println("[Demo] Could not save original clipboard: " + e.getMessage());
        }
        
        // Poll for bridge initialization message
        System.out.println("[Demo] Waiting for bridge script initialization...");
        while (true) {
            Thread.sleep(1000);
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null) {
                    // Debug output
                    String preview = clipboardText.length() > 50 ? clipboardText.substring(0, 50) + "..." : clipboardText;
                    System.out.println("[Demo] Clipboard check: " + clipboardText.length() + " chars - " + preview);
                    
                    if (clipboardText.startsWith("CCC_BRIDGE_INITIALIZED")) {
                        System.out.println("[Demo] Bridge script initialization detected!");
                        
                        // Restore original clipboard
                        if (originalClipboard != null && !originalClipboard.isEmpty()) {
                            setClipboard(originalClipboard);
                            System.out.println("[Demo] Original clipboard restored (" + originalClipboard.length() + " chars)");
                        } else {
                            setClipboard("");
                            System.out.println("[Demo] Clipboard cleared");
                        }
                        
                        Thread.sleep(500);
                        break;
                    }
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
        }
    }
    
    private static void waitForCalibration() throws Exception {
        System.out.println("[Demo] Waiting for calibration click...");
        System.out.println("[Demo] Ready to detect calibration (not clearing clipboard)...");
        
        while (!calibrated) {
            Thread.sleep(1000);
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null && !clipboardText.trim().isEmpty()) {
                    if (clipboardText.contains("CCC_CALIBRATION") && clipboardText.contains("|||CCC_END|||")) {
                        processCalibration(clipboardText);
                    }
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
        }
    }
    
    private static void processCalibration(String content) throws Exception {
        System.out.println("[Demo] Calibration click detected!");
        
        // Get current mouse position
        Point mousePos = MouseInfo.getPointerInfo().getLocation();
        clickPosition = mousePos;
        calibrated = true;
        
        System.out.println("[Demo] Captured mouse position: " + mousePos.x + ", " + mousePos.y);
        
        // Update tray icon
        if (trayIcon != null) {
            PopupMenu popup = trayIcon.getPopupMenu();
            if (popup.getItemCount() > 0) {
                MenuItem statusItem = popup.getItem(0);
                statusItem.setLabel("Status: Calibrated - Sending AI request");
            }
        }
        
        // Clear clipboard
        setClipboard("");
        Thread.sleep(1000);
    }
    
    private static void sendAIRequest() throws Exception {
        System.out.println("[Demo] Sending AI request...");
        
        // Create test request
        String request = String.format(
            "{\"type\":\"CCC_REQUEST\",\"id\":\"%s\",\"timestamp\":%d,\"action\":\"ai-complete\",\"payload\":{\"prompt\":\"Write a haiku about clipboard bridges between programs\"}}|||CCC_END|||",
            generateUUID(),
            System.currentTimeMillis()
        );
        
        // Set clipboard
        setClipboard(request);
        Thread.sleep(2000);
        
        // Click at calibrated position
        System.out.println("[Demo] Clicking at calibrated position...");
        robot.mouseMove(clickPosition.x, clickPosition.y);
        Thread.sleep(500);
        
        // Single click
        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
        robot.delay(100);
        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
        
        System.out.println("[Demo] Request sent, waiting for response...");
    }
    
    private static void waitForResponse() throws Exception {
        int timeout = 60; // 60 seconds timeout
        int elapsed = 0;
        
        while (elapsed < timeout) {
            Thread.sleep(1000);
            elapsed++;
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null && clipboardText.contains("BROWSER_RESPONSE")) {
                    processResponse(clipboardText);
                    return;
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
            
            if (elapsed % 5 == 0) {
                System.out.println("[Demo] Still waiting... (" + elapsed + "s)");
            }
        }
        
        System.out.println("[Demo] Response timeout after " + timeout + " seconds");
    }
    
    private static void processResponse(String content) throws Exception {
        try {
            String responseText = content.split("\\|\\|\\|BROWSER_END\\|\\|\\|")[0];
            // Simple JSON parsing for the response content
            if (responseText.contains("\"content\":")) {
                String contentStart = "\"content\":\"";
                int start = responseText.indexOf(contentStart) + contentStart.length();
                int end = responseText.indexOf("\",", start);
                if (end == -1) end = responseText.indexOf("\"}", start);
                
                if (start > 0 && end > start) {
                    String aiResponse = responseText.substring(start, end);
                    System.out.println();
                    System.out.println("================================");
                    System.out.println("AI Response Received!");
                    System.out.println("================================");
                    System.out.println(aiResponse);
                    System.out.println("================================");
                    System.out.println();
                }
            }
            
            // Update tray icon
            if (trayIcon != null) {
                PopupMenu popup = trayIcon.getPopupMenu();
                if (popup.getItemCount() > 0) {
                    MenuItem statusItem = popup.getItem(0);
                    statusItem.setLabel("Status: Success! Response received");
                }
            }
            
        } catch (Exception e) {
            System.out.println("[Demo] Error parsing response: " + e.getMessage());
        }
    }
    
    private static String getClipboardContent() throws Exception {
        Transferable contents = clipboard.getContents(null);
        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
            return (String) contents.getTransferData(DataFlavor.stringFlavor);
        }
        return null;
    }
    
    private static void setClipboard(String text) throws Exception {
        StringSelection selection = new StringSelection(text);
        clipboard.setContents(selection, null);
    }
    
    private static String generateUUID() {
        return UUID.randomUUID().toString();
    }
}
-~{END}~-

-~{File: src/java-agent/ChatServerAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;
import com.sun.net.httpserver.*;

public class ChatServerAgent {
    private static Clipboard clipboard;
    private static Robot robot;
    private static String savedClipboard = "";
    private static Point clickPosition = null;
    private static volatile boolean calibrated = false;
    private static TrayIcon trayIcon;
    private static HttpServer server;
    private static final int SERVER_PORT = 4444;
    private static final String FRONTEND_URL = "http://localhost:" + SERVER_PORT;
    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static Map<String, PendingRequest> pendingRequests = new ConcurrentHashMap<>();
    private static Map<String, Future<?>> clickingTasks = new ConcurrentHashMap<>();
    
    static class PendingRequest {
        String requestId;
        HttpExchange exchange;
        long timestamp;
        
        PendingRequest(String requestId, HttpExchange exchange) {
            this.requestId = requestId;
            this.exchange = exchange;
            this.timestamp = System.currentTimeMillis();
        }
    }
    
    public static void main(String[] args) {
        try {
            // Initialize components
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            robot = new Robot();
            
            // Setup system tray
            setupSystemTray();
            
            // Start HTTP server
            startHttpServer();
            
            // Launch Chrome
            launchChrome();
            
            // Start clipboard monitoring
            startClipboardMonitoring();
            
            // Keep running
            System.out.println("CCC Chat Server running. Press Ctrl+C to exit.");
            
            // Shutdown hook
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                System.out.println("Shutting down CCC Chat Server...");
                if (server != null) {
                    server.stop(0);
                }
                executor.shutdown();
            }));
            
            // Keep main thread alive
            while (true) {
                Thread.sleep(1000);
            }
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            System.out.println("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create icon (16x16 pixels)
            BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics2D g = image.createGraphics();
            g.setColor(Color.BLUE);
            g.fillOval(0, 0, 16, 16);
            g.dispose();
            
            trayIcon = new TrayIcon(image, "CCC Chat Server");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Starting...");
            MenuItem urlItem = new MenuItem("Open: " + FRONTEND_URL);
            MenuItem exitItem = new MenuItem("Exit");
            
            urlItem.addActionListener(e -> {
                try {
                    Desktop.getDesktop().browse(new URI(FRONTEND_URL));
                } catch (Exception ex) {
                    System.err.println("Could not open browser: " + ex.getMessage());
                }
            });
            
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.add(urlItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            System.out.println("System tray initialized");
            
        } catch (Exception e) {
            System.out.println("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void startHttpServer() throws Exception {
        server = HttpServer.create(new InetSocketAddress(SERVER_PORT), 0);
        
        // Serve static files
        server.createContext("/", new StaticFileHandler());
        
        // API endpoint for chat requests
        server.createContext("/api/chat", new ChatHandler());
        
        server.setExecutor(executor);
        server.start();
        
        System.out.println("HTTP server started on port " + SERVER_PORT);
        System.out.println("Frontend available at: " + FRONTEND_URL);
        
        updateTrayStatus("HTTP server running on port " + SERVER_PORT);
    }
    
    private static void launchChrome() {
        try {
            // Try different Chrome executable locations
            String[] chromePaths = {
                "google-chrome",
                "google-chrome-stable", 
                "chromium-browser",
                "chromium",
                "/usr/bin/google-chrome",
                "/usr/bin/chromium-browser",
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"
            };
            
            for (String chromePath : chromePaths) {
                try {
                    ProcessBuilder pb = new ProcessBuilder(chromePath, "--new-window", FRONTEND_URL);
                    Process process = pb.start();
                    System.out.println("Chrome launched successfully with: " + chromePath);
                    updateTrayStatus("Chrome launched - Ready for chat");
                    return;
                } catch (Exception e) {
                    // Try next path
                }
            }
            
            // Fallback to system default browser
            if (Desktop.isDesktopSupported()) {
                Desktop.getDesktop().browse(new URI(FRONTEND_URL));
                System.out.println("Opened default browser (Chrome not found)");
                updateTrayStatus("Browser opened - Ready for chat");
            } else {
                System.out.println("Could not launch browser automatically");
                System.out.println("Please open: " + FRONTEND_URL);
                updateTrayStatus("Manual browser open required");
            }
            
        } catch (Exception e) {
            System.err.println("Could not launch browser: " + e.getMessage());
            System.out.println("Please open: " + FRONTEND_URL);
            updateTrayStatus("Manual browser open required");
        }
    }
    
    private static void startClipboardMonitoring() {
        executor.submit(() -> {
            System.out.println("Starting clipboard monitoring for responses...");
            
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Thread.sleep(100); // Check every 100ms
                    
                    String clipboardText = getClipboardContent();
                    if (clipboardText != null) {
                        // Handle progress updates
                        if (clipboardText.contains("BROWSER_PROGRESS") && clipboardText.contains("|||BROWSER_PROGRESS|||")) {
                            handleProgressUpdate(clipboardText);
                        }
                        // Handle final responses
                        else if (clipboardText.contains("BROWSER_RESPONSE") && clipboardText.contains("|||BROWSER_END|||")) {
                            handleFinalResponse(clipboardText);
                        }
                    }
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (Exception e) {
                    // Ignore clipboard errors
                }
            }
        });
    }
    
    private static void handleProgressUpdate(String clipboardText) {
        try {
            String jsonText = clipboardText.split("\\|\\|\\|BROWSER_PROGRESS\\|\\|\\|")[0];
            // Simple JSON parsing for request ID
            String requestId = extractJsonField(jsonText, "id");
            String accumulated = extractJsonField(jsonText, "accumulated");
            
            if (requestId != null && accumulated != null) {
                PendingRequest pending = pendingRequests.get(requestId);
                if (pending != null) {
                    // Send SSE progress update to frontend
                    sendSSEUpdate(pending.exchange, "data: " + jsonText + "\n\n");
                }
            }
            
        } catch (Exception e) {
            System.err.println("Error handling progress update: " + e.getMessage());
        }
    }
    
    private static void handleFinalResponse(String clipboardText) {
        try {
            String jsonText = clipboardText.split("\\|\\|\\|BROWSER_END\\|\\|\\|")[0];
            String requestId = extractJsonField(jsonText, "id");
            
            if (requestId != null) {
                // Stop continuous clicking
                stopContinuousClicking(requestId);
                
                PendingRequest pending = pendingRequests.remove(requestId);
                if (pending != null) {
                    // Send final SSE response and close
                    sendSSEUpdate(pending.exchange, "data: " + jsonText + "\n\n");
                    sendSSEUpdate(pending.exchange, "data: [DONE]\n\n");
                    
                    try {
                        pending.exchange.getResponseBody().close();
                    } catch (IOException e) {
                        // Ignore close errors
                    }
                    
                    System.out.println("Response completed for request: " + requestId);
                }
            }
            
        } catch (Exception e) {
            System.err.println("Error handling final response: " + e.getMessage());
        }
    }
    
    private static void sendSSEUpdate(HttpExchange exchange, String data) {
        try {
            OutputStream os = exchange.getResponseBody();
            os.write(data.getBytes("UTF-8"));
            os.flush();
        } catch (Exception e) {
            System.err.println("Error sending SSE update: " + e.getMessage());
        }
    }
    
    private static String extractJsonField(String json, String field) {
        try {
            String pattern = "\"" + field + "\":\"";
            int start = json.indexOf(pattern);
            if (start == -1) return null;
            start += pattern.length();
            
            int end = json.indexOf("\"", start);
            if (end == -1) return null;
            
            return json.substring(start, end);
        } catch (Exception e) {
            return null;
        }
    }
    
    private static void updateTrayStatus(String status) {
        if (trayIcon != null) {
            PopupMenu popup = trayIcon.getPopupMenu();
            if (popup.getItemCount() > 0) {
                MenuItem statusItem = popup.getItem(0);
                statusItem.setLabel("Status: " + status);
            }
        }
    }
    
    // HTTP Handlers
    static class StaticFileHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String path = exchange.getRequestURI().getPath();
            
            if (path.equals("/") || path.equals("/index.html")) {
                sendChatInterface(exchange);
            } else {
                send404(exchange);
            }
        }
        
        private void sendChatInterface(HttpExchange exchange) throws IOException {
            String html = 
                "<!DOCTYPE html>" +
                "<html>" +
                "<head>" +
                "    <title>CCC Chat</title>" +
                "    <meta charset=\"UTF-8\">" +
                "    <style>" +
                "        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }" +
                "        .chat-container { max-width: 800px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }" +
                "        .chat-header { padding: 20px; border-bottom: 1px solid #eee; background: #4CAF50; color: white; border-radius: 8px 8px 0 0; }" +
                "        .chat-messages { height: 400px; overflow-y: auto; padding: 20px; }" +
                "        .message { margin: 10px 0; padding: 10px; border-radius: 8px; }" +
                "        .user { background: #e3f2fd; text-align: right; }" +
                "        .assistant { background: #f1f8e9; }" +
                "        .error { background: #ffebee; color: #c62828; border: 1px solid #f8bbd9; }" +
                "        .chat-input { display: flex; padding: 20px; border-top: 1px solid #eee; }" +
                "        .input-field { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; }" +
                "        .send-btn { margin-left: 10px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }" +
                "        .send-btn:disabled { background: #ccc; cursor: not-allowed; }" +
                "        .retry-btn { background: #ff9800; margin-left: 5px; padding: 5px 10px; font-size: 12px; cursor: pointer; border: none; border-radius: 3px; color: white; }" +
                "        .loading { opacity: 0.7; }" +
                "    </style>" +
                "</head>" +
                "<body>" +
                "    <div id=\"app\"></div>" +
                "    <script>" +
                "        class StateManager {" +
                "            constructor(initialState = {}) {" +
                "                this.state = initialState;" +
                "                this.subscribers = new Map();" +
                "                this.pendingNotifications = new Set();" +
                "                this.isFlushScheduled = false;" +
                "            }" +
                "            updateState(state, path, newValue) {" +
                "                this.setValueAtPath(state, path, newValue);" +
                "                this.scheduleNotifications(path);" +
                "            }" +
                "            onUpdate(paths, callback) {" +
                "                const pathArray = Array.isArray(paths) ? paths : [paths];" +
                "                const subscriptionId = Math.random().toString(36);" +
                "                this.subscribers.set(subscriptionId, { paths: pathArray, callback: callback });" +
                "                return () => this.subscribers.delete(subscriptionId);" +
                "            }" +
                "            get(path) { return this.getValueAtPath(this.state, path); }" +
                "            setValueAtPath(obj, path, value) {" +
                "                const parts = this.parsePath(path);" +
                "                let current = obj;" +
                "                for (let i = 0; i < parts.length - 1; i++) {" +
                "                    const part = parts[i];" +
                "                    if (!(part in current)) current[part] = {};" +
                "                    current = current[part];" +
                "                }" +
                "                current[parts[parts.length - 1]] = value;" +
                "            }" +
                "            getValueAtPath(obj, path) {" +
                "                const parts = this.parsePath(path);" +
                "                let current = obj;" +
                "                for (const part of parts) {" +
                "                    if (current == null || !(part in current)) return undefined;" +
                "                    current = current[part];" +
                "                }" +
                "                return current;" +
                "            }" +
                "            parsePath(path) { return path.split(/[\\\\.\\\\[\\\\]]/).filter(p => p !== ''); }" +
                "            scheduleNotifications(changedPath) {" +
                "                this.pendingNotifications.add(changedPath);" +
                "                if (!this.isFlushScheduled) {" +
                "                    this.isFlushScheduled = true;" +
                "                    queueMicrotask(() => this.flushNotifications());" +
                "                }" +
                "            }" +
                "            flushNotifications() {" +
                "                const changedPaths = Array.from(this.pendingNotifications);" +
                "                this.pendingNotifications.clear();" +
                "                this.isFlushScheduled = false;" +
                "                for (const [subscriptionId, subscription] of this.subscribers) {" +
                "                    const affectedPaths = subscription.paths.filter(subPath => " +
                "                        changedPaths.some(changed => changed.startsWith(subPath) || subPath.startsWith(changed))" +
                "                    );" +
                "                    if (affectedPaths.length > 0) {" +
                "                        const values = subscription.paths.map(path => this.get(path));" +
                "                        subscription.callback(...values);" +
                "                    }" +
                "                }" +
                "            }" +
                "        }" +
                "        function el(tag, attrs = {}, children = []) {" +
                "            const element = document.createElement(tag);" +
                "            Object.entries(attrs).forEach(([key, value]) => {" +
                "                if (key === 'class') element.className = value;" +
                "                else if (key.startsWith('on')) element.addEventListener(key.slice(2), value);" +
                "                else element.setAttribute(key, value);" +
                "            });" +
                "            children.forEach(child => {" +
                "                if (typeof child === 'string') element.appendChild(document.createTextNode(child));" +
                "                else if (child) element.appendChild(child);" +
                "            });" +
                "            return element;" +
                "        }" +
                "        const stateManager = new StateManager({ chat: { messages: [] }, ui: { isProcessing: false } });" +
                "        let currentAssistantMessage = null;" +
                "        window.sendChatMessage = async function(message) {" +
                "            try {" +
                "                const messages = stateManager.get('chat.messages') || [];" +
                "                messages.push({ id: generateUUID(), role: 'user', content: message, timestamp: Date.now() });" +
                "                stateManager.updateState(stateManager.state, 'chat.messages', messages);" +
                "                stateManager.updateState(stateManager.state, 'ui.isProcessing', true);" +
                "                const request = { type: 'CCC_REQUEST', id: generateUUID(), timestamp: Date.now(), action: 'ai-complete', payload: { prompt: message } };" +
                "                const assistantMessage = { id: request.id, role: 'assistant', content: '', timestamp: Date.now() };" +
                "                messages.push(assistantMessage);" +
                "                stateManager.updateState(stateManager.state, 'chat.messages', [...messages]);" +
                "                currentAssistantMessage = assistantMessage;" +
                "                const response = await fetch('/api/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(request) });" +
                "                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);" +
                "                await handleSSEResponse(response, request.id);" +
                "            } catch (error) {" +
                "                const messages = stateManager.get('chat.messages') || [];" +
                "                messages.push({ id: generateUUID(), role: 'error', content: error.message, error: error.message, timestamp: Date.now() });" +
                "                stateManager.updateState(stateManager.state, 'chat.messages', [...messages]);" +
                "            } finally {" +
                "                stateManager.updateState(stateManager.state, 'ui.isProcessing', false);" +
                "            }" +
                "        };" +
                "        async function handleSSEResponse(response, requestId) {" +
                "            const reader = response.body.getReader();" +
                "            const decoder = new TextDecoder();" +
                "            while (true) {" +
                "                const { done, value } = await reader.read();" +
                "                if (done) break;" +
                "                const chunk = decoder.decode(value);" +
                "                const lines = chunk.split('\\\\n');" +
                "                for (const line of lines) {" +
                "                    if (line.startsWith('data: ')) {" +
                "                        const dataStr = line.substring(6);" +
                "                        if (dataStr === '[DONE]') return;" +
                "                        try {" +
                "                            const data = JSON.parse(dataStr);" +
                "                            if (data.type === 'BROWSER_PROGRESS' || data.type === 'BROWSER_RESPONSE') {" +
                "                                let content = '';" +
                "                                if (data.payload && data.payload.accumulated) content = data.payload.accumulated;" +
                "                                else if (data.payload && data.payload.content) content = data.payload.content;" +
                "                                if (content && currentAssistantMessage) {" +
                "                                    currentAssistantMessage.content = content;" +
                "                                    const messages = stateManager.get('chat.messages') || [];" +
                "                                    stateManager.updateState(stateManager.state, 'chat.messages', [...messages]);" +
                "                                }" +
                "                            }" +
                "                        } catch (parseError) {}" +
                "                    }" +
                "                }" +
                "            }" +
                "        }" +
                "        function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { const r = Math.random() * 16 | 0; const v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }" +
                "        function ChatMessage(state, basePath) {" +
                "            const message = el('div', {class: 'message'}, [el('div', {class: 'content'})]);" +
                "            const unsubscribes = [];" +
                "            unsubscribes.push(state.onUpdate([`${basePath}.role`, `${basePath}.content`], (role, content) => {" +
                "                message.className = `message ${role || 'user'}`;" +
                "                message.querySelector('.content').textContent = content || '';" +
                "            }));" +
                "            return { elements: message, destroy: () => unsubscribes.forEach(unsub => unsub()) };" +
                "        }" +
                "        function ChatInput(state, basePath) {" +
                "            const container = el('div', {class: 'chat-input'}, [" +
                "                el('input', { type: 'text', class: 'input-field', placeholder: 'Type your message...' })," +
                "                el('button', {class: 'send-btn'}, ['Send'])" +
                "            ]);" +
                "            const input = container.querySelector('.input-field');" +
                "            const button = container.querySelector('.send-btn');" +
                "            const unsubscribes = [];" +
                "            unsubscribes.push(state.onUpdate(`${basePath}.isProcessing`, (isProcessing) => {" +
                "                button.disabled = isProcessing;" +
                "                input.disabled = isProcessing;" +
                "                button.textContent = isProcessing ? 'Sending...' : 'Send';" +
                "            }));" +
                "            const sendMessage = () => {" +
                "                const message = input.value.trim();" +
                "                if (!message || state.get(`${basePath}.isProcessing`)) return;" +
                "                input.value = '';" +
                "                window.sendChatMessage(message);" +
                "            };" +
                "            button.addEventListener('click', sendMessage);" +
                "            input.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(); });" +
                "            return { elements: container, destroy: () => unsubscribes.forEach(unsub => unsub()) };" +
                "        }" +
                "        function ChatMessages(state, basePath) {" +
                "            const container = el('div', {class: 'chat-messages'});" +
                "            const messageComponents = [];" +
                "            const unsubscribes = [];" +
                "            unsubscribes.push(state.onUpdate(`${basePath}.messages`, (messages) => {" +
                "                messageComponents.forEach(comp => comp.destroy());" +
                "                messageComponents.length = 0;" +
                "                container.innerHTML = '';" +
                "                if (messages) {" +
                "                    messages.forEach((_, index) => {" +
                "                        const messageComp = ChatMessage(state, `${basePath}.messages[${index}]`);" +
                "                        messageComponents.push(messageComp);" +
                "                        container.appendChild(messageComp.elements);" +
                "                    });" +
                "                }" +
                "                container.scrollTop = container.scrollHeight;" +
                "            }));" +
                "            return { elements: container, destroy: () => { unsubscribes.forEach(unsub => unsub()); messageComponents.forEach(comp => comp.destroy()); } };" +
                "        }" +
                "        function ChatApp(state, basePath) {" +
                "            const container = el('div', {class: 'chat-container'}, [" +
                "                el('div', {class: 'chat-header'}, [" +
                "                    el('h1', {}, ['CCC Chat Interface'])," +
                "                    el('p', {}, ['Clipboard bridge to Claude API'])" +
                "                ])" +
                "            ]);" +
                "            const messagesComp = ChatMessages(state, `${basePath}.chat`);" +
                "            const inputComp = ChatInput(state, `${basePath}.ui`);" +
                "            container.appendChild(messagesComp.elements);" +
                "            container.appendChild(inputComp.elements);" +
                "            return { elements: container, destroy: () => { messagesComp.destroy(); inputComp.destroy(); } };" +
                "        }" +
                "        const app = ChatApp(stateManager, 'root');" +
                "        document.getElementById('app').appendChild(app.elements);" +
                "    </script>" +
                "</body>" +
                "</html>";
            
            byte[] bytes = html.getBytes("UTF-8");
            exchange.getResponseHeaders().set("Content-Type", "text/html; charset=UTF-8");
            exchange.sendResponseHeaders(200, bytes.length);
            
            OutputStream os = exchange.getResponseBody();
            os.write(bytes);
            os.close();
        }
        
        private void send404(HttpExchange exchange) throws IOException {
            String response = "404 Not Found";
            byte[] bytes = response.getBytes("UTF-8");
            exchange.sendResponseHeaders(404, bytes.length);
            
            OutputStream os = exchange.getResponseBody();
            os.write(bytes);
            os.close();
        }
    }
    
    static class ChatHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Received chat request: " + requestBody);
                
                // Parse request to get ID
                String requestId = extractJsonField(requestBody, "id");
                if (requestId == null) {
                    throw new Exception("No request ID found");
                }
                
                // Store pending request for response correlation
                pendingRequests.put(requestId, new PendingRequest(requestId, exchange));
                
                // Set up SSE response headers
                exchange.getResponseHeaders().set("Content-Type", "text/event-stream");
                exchange.getResponseHeaders().set("Cache-Control", "no-cache");
                exchange.getResponseHeaders().set("Connection", "keep-alive");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                exchange.sendResponseHeaders(200, 0);
                
                // Forward request via clipboard bridge
                String clipboardRequest = requestBody + "|||CCC_END|||";
                setClipboard(clipboardRequest);
                
                System.out.println("Request forwarded via clipboard bridge");
                
                // Start continuous clicking until response completes (if calibrated)
                if (calibrated && clickPosition != null) {
                    startContinuousClicking(requestId);
                }
                
            } catch (Exception e) {
                System.err.println("Chat request error: " + e.getMessage());
                
                // Send error response
                String errorResponse = "HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n" + e.getMessage();
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                OutputStream os = exchange.getResponseBody();
                os.write(bytes);
                os.close();
            }
        }
    }
    
    private static String getClipboardContent() throws Exception {
        Transferable contents = clipboard.getContents(null);
        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
            return (String) contents.getTransferData(DataFlavor.stringFlavor);
        }
        return null;
    }
    
    private static void setClipboard(String text) throws Exception {
        StringSelection selection = new StringSelection(text);
        clipboard.setContents(selection, null);
    }
    
    private static void startContinuousClicking(String requestId) {
        System.out.println("Starting continuous clicking for request: " + requestId);
        
        // Save current mouse position
        Point originalPosition = MouseInfo.getPointerInfo().getLocation();
        System.out.println("Saved original mouse position: " + originalPosition.x + ", " + originalPosition.y);
        
        Future<?> clickingTask = executor.submit(() -> {
            long startTime = System.currentTimeMillis();
            long timeoutMs = 5 * 60 * 1000; // 5 minutes
            int clickCount = 0;
            
            try {
                while (!Thread.currentThread().isInterrupted() && 
                       (System.currentTimeMillis() - startTime) < timeoutMs) {
                    
                    // Move to calibrated position
                    robot.mouseMove(clickPosition.x, clickPosition.y);
                    Thread.sleep(50);
                    
                    // Click
                    robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
                    robot.delay(50);
                    robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
                    clickCount++;
                    
                    System.out.println("Bridge click #" + clickCount + " sent for request: " + requestId);
                    
                    // Move back to original position
                    robot.mouseMove(originalPosition.x, originalPosition.y);
                    
                    // Wait 500ms before next click
                    Thread.sleep(500);
                }
                
                if (!Thread.currentThread().isInterrupted()) {
                    System.out.println("Clicking timeout reached for request: " + requestId + " (5 minutes)");
                }
                
            } catch (InterruptedException e) {
                System.out.println("Clicking stopped for request: " + requestId + " (total clicks: " + clickCount + ")");
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                System.err.println("Error in continuous clicking: " + e.getMessage());
            } finally {
                // Always restore original mouse position
                try {
                    robot.mouseMove(originalPosition.x, originalPosition.y);
                    System.out.println("Mouse position restored to: " + originalPosition.x + ", " + originalPosition.y);
                } catch (Exception e) {
                    System.err.println("Could not restore mouse position: " + e.getMessage());
                }
            }
        });
        
        clickingTasks.put(requestId, clickingTask);
    }
    
    private static void stopContinuousClicking(String requestId) {
        Future<?> clickingTask = clickingTasks.remove(requestId);
        if (clickingTask != null) {
            clickingTask.cancel(true);
            System.out.println("Stopped continuous clicking for request: " + requestId);
        }
    }
    
    private static String generateUUID() {
        return UUID.randomUUID().toString();
    }
}
-~{END}~-

-~{File: mock-env/server.js}~-
const http = require('http');
const url = require('url');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const PORT = process.env.MOCK_PORT || 5556;

// In-memory storage
const conversations = new Map();
const tokens = new Set(['mock-token-12345']);

// Helper to parse JSON body
async function parseBody(req) {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => {
      try {
        resolve(body ? JSON.parse(body) : {});
      } catch (e) {
        reject(e);
      }
    });
  });
}

// CORS headers for browser access
function setCorsHeaders(res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
}

// Validate auth token
function validateAuth(req) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Bearer ')) return false;
  return tokens.has(auth.substring(7));
}

// Generate message structure
function createMessage(content, role, parentId = null) {
  const id = crypto.randomUUID();
  const timestamp = Math.floor(Date.now() / 1000);
  
  return {
    id,
    role,
    content,
    parentId,
    childrenIds: [],
    timestamp
  };
}

// Handle requests
const server = http.createServer(async (req, res) => {
  setCorsHeaders(res);
  
  const parsedUrl = url.parse(req.url, true);
  const pathname = parsedUrl.pathname;
  
  // Handle preflight
  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }
  
  // Serve UI page
  if (pathname === '/' && req.method === 'GET') {
    const htmlPath = path.join(__dirname, 'ui.html');
    
    if (fs.existsSync(htmlPath)) {
      res.writeHead(200, { 'Content-Type': 'text/html' });
      res.end(fs.readFileSync(htmlPath));
    } else {
      res.writeHead(404);
      res.end('UI page not found');
    }
    return;
  }
  
  // Serve demo page
  if (pathname === '/demo' && req.method === 'GET') {
    const demoPath = path.join(__dirname, 'demo.html');
    
    if (fs.existsSync(demoPath)) {
      res.writeHead(200, { 'Content-Type': 'text/html' });
      res.end(fs.readFileSync(demoPath));
    } else {
      res.writeHead(404);
      res.end('Demo page not found');
    }
    return;
  }
  
  // Serve bridge scripts
  if ((pathname === '/bridge-calibrate.js' || pathname === '/bridge-api.js') && req.method === 'GET') {
    const scriptName = pathname.substring(1); // Remove leading /
    const scriptPath = path.join(__dirname, '..', 'src', 'browser-bridge', scriptName);
    
    if (fs.existsSync(scriptPath)) {
      res.writeHead(200, { 
        'Content-Type': 'application/javascript',
        'Access-Control-Allow-Origin': '*'
      });
      res.end(fs.readFileSync(scriptPath));
    } else {
      res.writeHead(404);
      res.end('Bridge script not found');
    }
    return;
  }
  
  // API endpoints
  if (!validateAuth(req) && pathname.startsWith('/api/')) {
    res.writeHead(401, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Unauthorized' }));
    return;
  }
  
  try {
    // Create new chat
    if (pathname === '/api/v1/chats/new' && req.method === 'POST') {
      const body = await parseBody(req);
      const chatId = 'mock-conv-' + Date.now();
      
      const userMessage = createMessage(
        body.message || 'Hello',
        'user',
        null
      );
      
      const conversation = {
        id: chatId,
        created_at: Math.floor(Date.now() / 1000),
        user_id: 'mock-user-123',
        messages: [userMessage],
        history: {
          messages: {
            [userMessage.id]: userMessage
          },
          currentId: userMessage.id
        },
        timestamp: Date.now()
      };
      
      conversations.set(chatId, conversation);
      
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        id: chatId,
        created_at: conversation.created_at,
        user_id: conversation.user_id
      }));
      return;
    }
    
    // Get conversation state
    if (pathname.match(/^\/api\/v1\/chats\/[^\/]+$/) && req.method === 'GET') {
      const chatId = pathname.split('/').pop();
      const conversation = conversations.get(chatId);
      
      if (!conversation) {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Conversation not found' }));
        return;
      }
      
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(conversation));
      return;
    }
    
    // Update conversation
    if (pathname.match(/^\/api\/v1\/chats\/[^\/]+$/) && req.method === 'POST') {
      const chatId = pathname.split('/').pop();
      const conversation = conversations.get(chatId);
      
      if (!conversation) {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Conversation not found' }));
        return;
      }
      
      const body = await parseBody(req);
      
      // Update conversation with new data
      if (body.messages) {
        conversation.messages = body.messages;
      }
      if (body.history) {
        conversation.history = body.history;
      }
      
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(conversation));
      return;
    }
    
    // Stream completions (SSE)
    if (pathname === '/api/chat/completions' && req.method === 'POST') {
      const body = await parseBody(req);
      
      res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive'
      });
      
      // Simulate streaming response
      const chunks = [
        'Hello! ',
        'This is ',
        'a mock ',
        'streaming ',
        'response ',
        'from the ',
        'CCC mock ',
        'server.'
      ];
      
      let chunkIndex = 0;
      const interval = setInterval(() => {
        if (chunkIndex < chunks.length) {
          const data = {
            id: String(chunkIndex + 1),
            choices: [{
              delta: { content: chunks[chunkIndex] }
            }]
          };
          res.write(`data: ${JSON.stringify(data)}\n\n`);
          chunkIndex++;
        } else {
          const finalData = {
            id: String(chunkIndex + 1),
            choices: [{
              finish_reason: 'stop'
            }]
          };
          res.write(`data: ${JSON.stringify(finalData)}\n\n`);
          res.end();
          clearInterval(interval);
        }
      }, 100); // 100ms between chunks
      
      return;
    }
    
    // 404 for unknown routes
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Not found' }));
    
  } catch (error) {
    console.error('Server error:', error);
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Internal server error' }));
  }
});

server.listen(PORT, () => {
  console.log(`Mock API server running at http://localhost:${PORT}`);
  console.log('Mock token: mock-token-12345');
});
-~{END}~-

-~{File: mock-env/ui.html}~-
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CCC Mock Internal UI</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: monospace;
      background: #1a1a1a;
      color: #fff;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    #status-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 10px;
      background: #2a2a2a;
      border-bottom: 2px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #main-container {
      text-align: center;
      padding: 40px;
      background: #2a2a2a;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      min-width: 500px;
    }
    
    .click-button {
      display: inline-block;
      margin: 20px;
      padding: 30px 50px;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      transition: all 0.3s;
    }
    
    #clipboard-read-btn {
      background: #28a745;
      color: white;
    }
    
    #clipboard-read-btn:hover {
      background: #218838;
    }
    
    #clipboard-write-btn {
      background: #17a2b8;
      color: white;
    }
    
    #clipboard-write-btn:hover {
      background: #138496;
    }
    
    #status {
      margin-top: 30px;
      padding: 20px;
      background: #1a1a1a;
      border-radius: 5px;
      height: 250px;
      overflow-y: auto;
      text-align: left;
      font-size: 12px;
      white-space: pre-wrap;
    }
    
    .log-entry {
      margin: 2px 0;
      padding: 2px;
    }
    
    .log-entry.info { color: #88ff88; }
    .log-entry.error { color: #ff8888; }
    .log-entry.success { color: #00ff00; }
    .log-entry.debug { color: #8888ff; }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      padding: 15px;
      background: rgba(0,0,0,0.8);
      border-radius: 5px;
      font-size: 14px;
      color: #aaa;
    }
    
    .stats {
      position: absolute;
      top: 60px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 5px;
      font-size: 14px;
    }
    
    .indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: 10px;
    }
    
    .indicator.ready { background: #28a745; }
    .indicator.processing { background: #ffc107; }
    .indicator.error { background: #dc3545; }
  </style>
</head>
<body>
  <div id="status-bar">
    <div>CCC Mock UI <span id="bridge-status" class="indicator ready"></span></div>
    <div>Token: <span id="token-status">mock-token-12345</span></div>
  </div>
  
  <div id="main-container">
    <h1>CCC Clipboard Bridge Test</h1>
    
    <div>
      <button id="clipboard-read-btn" class="click-button">
        READ CLIPBOARD
      </button>
      
      <button id="clipboard-write-btn" class="click-button">
        WRITE RESPONSE
      </button>
    </div>
    
    <div id="status"></div>
  </div>
  
  <div class="stats">
    <div>Click Count: <span id="click-count">0</span></div>
    <div>Success Count: <span id="success-count">0</span></div>
    <div>Fail Count: <span id="fail-count">0</span></div>
    <div>Last Click: <span id="last-click">Never</span></div>
    <div>isTrusted: <span id="trusted-status">N/A</span></div>
  </div>
  
  <div id="instructions">
    <strong>Instructions:</strong> The Java Robot will click these buttons automatically. 
    Watch for clipboard read/write operations. The READ button checks for CCC_REQUEST messages,
    and the WRITE button sends back responses.
  </div>
  
  <script>
    // Set mock token
    localStorage.setItem('token', 'mock-token-12345');
    
    // State
    let clickCount = 0;
    let successCount = 0;
    let failCount = 0;
    let lastRequest = null;
    let processingRequest = false;
    
    // Logging
    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const statusDiv = document.getElementById('status');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${timestamp}] ${message}`;
      statusDiv.appendChild(entry);
      statusDiv.scrollTop = statusDiv.scrollHeight;
      
      // Keep only last 50 entries
      while (statusDiv.children.length > 50) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
      
      console.log(`[${type.toUpperCase()}] ${message}`);
    }
    
    // Update stats
    function updateStats(isTrusted = null) {
      document.getElementById('click-count').textContent = clickCount;
      document.getElementById('success-count').textContent = successCount;
      document.getElementById('fail-count').textContent = failCount;
      document.getElementById('last-click').textContent = new Date().toLocaleTimeString();
      if (isTrusted !== null) {
        document.getElementById('trusted-status').textContent = isTrusted ? 'YES' : 'NO';
      }
    }
    
    // Read button - Check clipboard for CCC_REQUEST
    document.getElementById('clipboard-read-btn').addEventListener('click', async (e) => {
      clickCount++;
      updateStats(e.isTrusted);
      
      log(`Click #${clickCount} - READ button (isTrusted: ${e.isTrusted})`);
      
      // Check if this is a trusted event (real or Robot click)
      if (!e.isTrusted) {
        log('Warning: Click not trusted by browser', 'error');
      }
      
      try {
        // Try to read clipboard
        const clipboardText = await navigator.clipboard.readText();
        log(`Read ${clipboardText.length} chars from clipboard`, 'success');
        
        // Check if it's a CCC request
        if (clipboardText.includes('CCC_REQUEST')) {
          log('Found CCC_REQUEST!', 'success');
          successCount++;
          
          // Parse the request
          const requestEnd = clipboardText.indexOf('|||CCC_END|||');
          if (requestEnd > 0) {
            const requestJson = clipboardText.substring(0, requestEnd);
            try {
              lastRequest = JSON.parse(requestJson);
              log(`Parsed request ID: ${lastRequest.id}`, 'success');
              log(`Request action: ${lastRequest.action}`, 'info');
              
              // Set flag to write response on next write button click
              processingRequest = true;
              document.getElementById('clipboard-write-btn').style.background = '#ffc107';
              
            } catch (parseErr) {
              log(`Failed to parse request: ${parseErr.message}`, 'error');
              failCount++;
            }
          }
        } else {
          log('No CCC_REQUEST in clipboard', 'debug');
        }
        
      } catch (error) {
        failCount++;
        log(`Failed to read clipboard: ${error.message}`, 'error');
        
        // Try fallback method
        try {
          // For reading, there's no good fallback in modern browsers
          log('Note: No fallback for clipboard read in modern browsers', 'info');
        } catch (fallbackErr) {
          log(`Fallback also failed: ${fallbackErr.message}`, 'error');
        }
      }
      
      updateStats(e.isTrusted);
    });
    
    // Write button - Send response back
    document.getElementById('clipboard-write-btn').addEventListener('click', async (e) => {
      clickCount++;
      updateStats(e.isTrusted);
      
      log(`Click #${clickCount} - WRITE button (isTrusted: ${e.isTrusted})`);
      
      if (!processingRequest || !lastRequest) {
        log('No request to respond to', 'debug');
        return;
      }
      
      try {
        // Create response
        const response = {
          type: 'BROWSER_RESPONSE',
          id: lastRequest.id,
          timestamp: Date.now(),
          status: 'success',
          payload: {
            content: 'Mock response from fixed UI - clipboard access successful!',
            chat_id: 'mock-chat-' + Date.now(),
            trusted: e.isTrusted
          }
        };
        
        const responseText = JSON.stringify(response) + '|||BROWSER_END|||';
        
        // Try to write to clipboard
        await navigator.clipboard.writeText(responseText);
        successCount++;
        log(`Wrote response for request ${lastRequest.id}`, 'success');
        log(`Response length: ${responseText.length} chars`, 'info');
        
        // Reset state
        processingRequest = false;
        lastRequest = null;
        document.getElementById('clipboard-write-btn').style.background = '#17a2b8';
        
      } catch (error) {
        failCount++;
        log(`Failed to write clipboard: ${error.message}`, 'error');
        
        // Try fallback method (execCommand)
        try {
          const textarea = document.createElement('textarea');
          textarea.value = responseText;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          const success = document.execCommand('copy');
          document.body.removeChild(textarea);
          
          if (success) {
            successCount++;
            failCount--; // Correct the count
            log('SUCCESS with fallback method (execCommand)!', 'success');
            
            // Reset state
            processingRequest = false;
            lastRequest = null;
            document.getElementById('clipboard-write-btn').style.background = '#17a2b8';
          } else {
            log('Fallback method also failed', 'error');
          }
        } catch (fallbackErr) {
          log(`Fallback error: ${fallbackErr.message}`, 'error');
        }
      }
      
      updateStats(e.isTrusted);
    });
    
    // Monitor all clicks for debugging
    document.addEventListener('click', (e) => {
      console.log(`%cClick detected on ${e.target.tagName}#${e.target.id || '(no-id)'}`, 
                  'background: yellow; color: black');
      console.log(`  isTrusted: ${e.isTrusted}`);
      console.log(`  Target: ${e.target.id}`);
    }, true);
    
    // Initialize
    log('Fixed UI ready. Waiting for Java Robot clicks...', 'success');
    log('The READ button will check for CCC_REQUEST messages', 'info');
    log('The WRITE button will send BROWSER_RESPONSE messages', 'info');
    
    // Auto-load bridge enhancement
    setTimeout(() => {
      log('Loading bridge enhancement...', 'info');
      loadBridgeEnhancement();
    }, 1000);
    
    // Bridge Enhancement Script (from bridge-mock.js)
    function loadBridgeEnhancement() {
      'use strict';
      
      console.log('[CCC Bridge Mock] Initializing for button-based UI...');
      
      // State
      let bridgeActive = false;
      let bridgeLastRequest = null;
      let bridgeClickCount = 0;
      
      // Find the buttons
      const readBtn = document.getElementById('clipboard-read-btn');
      const writeBtn = document.getElementById('clipboard-write-btn');
      
      if (!readBtn || !writeBtn) {
        console.error('[CCC Bridge Mock] Buttons not found! Make sure you\'re on the mock UI page.');
        log('Bridge enhancement failed - buttons not found', 'error');
        return;
      }
      
      console.log('[CCC Bridge Mock] Found buttons, enhancing...');
      
      // Enhanced click handler for READ button
      const originalReadClick = readBtn.onclick;
      readBtn.onclick = async function(e) {
        console.log('[CCC Bridge Mock] READ button clicked by', e.isTrusted ? 'user/robot' : 'script');
        
        // Call original handler if exists
        if (originalReadClick) originalReadClick.call(this, e);
        
        // Our enhancement - check for CCC requests
        if (bridgeActive) {
          bridgeClickCount++;
          console.log('[CCC Bridge Mock] Checking clipboard for CCC_REQUEST...');
          
          try {
            const clipboardText = await navigator.clipboard.readText();
            console.log('[CCC Bridge Mock] Clipboard length:', clipboardText.length);
            
            if (clipboardText.includes('CCC_REQUEST')) {
              console.log('[CCC Bridge Mock] Found CCC_REQUEST!');
              const requestEnd = clipboardText.indexOf('|||CCC_END|||');
              if (requestEnd > 0) {
                const requestJson = clipboardText.substring(0, requestEnd).trim();
                console.log('[CCC Bridge Mock] Raw request JSON:', requestJson);
                console.log('[CCC Bridge Mock] First 50 chars:', requestJson.substring(0, 50));
                console.log('[CCC Bridge Mock] First char code:', requestJson.charCodeAt(0));
                
                try {
                  // Remove any BOM or zero-width characters
                  const cleanJson = requestJson.replace(/^\uFEFF/, '').replace(/^[\u200B-\u200D\uFEFF]/, '');
                  bridgeLastRequest = JSON.parse(cleanJson);
                  console.log('[CCC Bridge Mock] Parsed request:', bridgeLastRequest.id, bridgeLastRequest.action);
                  
                  // Visual feedback
                  readBtn.style.background = '#ffc107';
                  setTimeout(() => {
                    readBtn.style.background = '#28a745';
                  }, 500);
                } catch (parseErr) {
                  console.error('[CCC Bridge Mock] JSON parse error:', parseErr.message);
                  console.error('[CCC Bridge Mock] Invalid JSON:', requestJson);
                  // Log char codes for debugging
                  console.error('[CCC Bridge Mock] First 10 char codes:', 
                    [...requestJson.substring(0, 10)].map(c => c.charCodeAt(0)).join(', '));
                }
              } else {
                console.warn('[CCC Bridge Mock] Found CCC_REQUEST but no |||CCC_END||| marker');
              }
            } else {
              console.log('[CCC Bridge Mock] No CCC_REQUEST in clipboard');
            }
          } catch (err) {
            console.error('[CCC Bridge Mock] Error reading clipboard:', err);
          }
        }
      };
      
      // Enhanced click handler for WRITE button
      const originalWriteClick = writeBtn.onclick;
      writeBtn.onclick = async function(e) {
        console.log('[CCC Bridge Mock] WRITE button clicked by', e.isTrusted ? 'user/robot' : 'script');
        
        // Call original handler if exists
        if (originalWriteClick) originalWriteClick.call(this, e);
        
        // Our enhancement - write response if we have a request
        if (bridgeActive && bridgeLastRequest) {
          console.log('[CCC Bridge Mock] Writing response for request:', bridgeLastRequest.id);
          
          try {
            const response = {
              type: 'BROWSER_RESPONSE',
              id: bridgeLastRequest.id,
              timestamp: Date.now(),
              status: 'success',
              payload: {
                content: 'Mock response via bridge script - buttons working!',
                chat_id: 'mock-' + Date.now(),
                clickCount: bridgeClickCount,
                trusted: e.isTrusted
              }
            };
            
            const responseText = JSON.stringify(response) + '|||BROWSER_END|||';
            await navigator.clipboard.writeText(responseText);
            
            console.log('[CCC Bridge Mock] Response written to clipboard');
            
            // Visual feedback
            writeBtn.style.background = '#28a745';
            setTimeout(() => {
              writeBtn.style.background = '#17a2b8';
            }, 500);
            
            // Clear the request
            bridgeLastRequest = null;
            
          } catch (err) {
            console.error('[CCC Bridge Mock] Error writing clipboard:', err);
          }
        }
      };
      
      // Add visual indicator
      const indicator = document.createElement('div');
      indicator.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        padding: 10px 20px;
        background: #28a745;
        color: white;
        border-radius: 5px;
        font-family: monospace;
        font-weight: bold;
        z-index: 10000;
      `;
      indicator.textContent = 'CCC BRIDGE ACTIVE';
      document.body.appendChild(indicator);
      
      // Activate bridge
      bridgeActive = true;
      
      console.log('[CCC Bridge Mock] Bridge active! The existing buttons will now handle CCC requests.');
      console.log('[CCC Bridge Mock] Calibrate the button positions and start testing.');
      log('Bridge enhancement loaded successfully!', 'success');
      
      // Export for debugging
      window.CCCBridgeMock = {
        status: () => ({ active: bridgeActive, clickCount: bridgeClickCount, lastRequest: bridgeLastRequest }),
        deactivate: () => { bridgeActive = false; indicator.style.background = '#dc3545'; }
      };
    }
  </script>
</body>
</html>
-~{END}~-

-~{File: src/browser-bridge/bridge-api.js}~-
// CCC Browser Bridge Script - Real API Flow Version
// This follows the actual Claude API flow from SPEC.md
(function() {
  'use strict';
  
  console.log('[CCC Bridge API] Initializing with real API flow...');
  
  // Generate realistic session ID
  function generateSessionId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < 20; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  
  // Configuration
  const CONFIG = {
    apiBase: window.location.origin, // Use same origin as the page
    colors: {
      calibrating: '#1a1a2e',
      ready: '#16213e',
      processing: '#0f3460',
      streaming: '#2d5016',
      success: '#53bf9d',
      error: '#e94560'
    },
    sessionId: generateSessionId() // Generate realistic session ID
  };
  
  // State
  let bridgeState = 'calibrating';
  let lastRequest = null;
  let clickCount = 0;
  
  // Get auth token from localStorage (mock server sets this)
  const authToken = localStorage.getItem('token') || 'mock-token-12345';
  
  // Remove any existing bridge
  const existing = document.getElementById('ccc-bridge-overlay');
  if (existing) existing.remove();
  
  // Create full-page overlay
  const overlay = document.createElement('div');
  overlay.id = 'ccc-bridge-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: ${CONFIG.colors.calibrating};
    z-index: 999999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.3s;
    font-family: 'Courier New', monospace;
    color: white;
  `;
  
  // Create status display
  const statusDisplay = document.createElement('div');
  statusDisplay.style.cssText = `
    text-align: center;
    padding: 40px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    max-width: 600px;
  `;
  
  const title = document.createElement('h1');
  title.style.cssText = `margin: 0 0 20px 0; font-size: 36px;`;
  title.textContent = 'CCC Bridge API';
  
  const status = document.createElement('div');
  status.style.cssText = `font-size: 24px; margin-bottom: 10px;`;
  status.textContent = 'Click to calibrate';
  
  const info = document.createElement('div');
  info.style.cssText = `font-size: 16px; opacity: 0.8;`;
  info.textContent = 'Ready for calibration';
  
  const streamingContent = document.createElement('div');
  streamingContent.style.cssText = `
    margin-top: 20px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
    text-align: left;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
  `;
  
  statusDisplay.appendChild(title);
  statusDisplay.appendChild(status);
  statusDisplay.appendChild(info);
  statusDisplay.appendChild(streamingContent);
  overlay.appendChild(statusDisplay);
  
  // Helper functions
  function updateDisplay(state, message = '', showStreaming = false) {
    bridgeState = state;
    overlay.style.background = CONFIG.colors[state] || CONFIG.colors.ready;
    status.textContent = state.charAt(0).toUpperCase() + state.slice(1);
    info.textContent = message;
    streamingContent.style.display = showStreaming ? 'block' : 'none';
  }
  
  function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  // API Functions following the spec
  async function createNewChat(prompt) {
    console.log('[CCC Bridge API] === CREATING NEW CHAT ===');
    console.log('[CCC Bridge API] Prompt length:', prompt.length);
    console.log('[CCC Bridge API] Prompt preview:', prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''));
    
    const userMessageId = generateUUID();
    const timestamp = Date.now();
    console.log('[CCC Bridge API] Generated user message ID:', userMessageId);
    console.log('[CCC Bridge API] Timestamp:', timestamp);
    
    const body = {
      "chat": {
        "params": {},
        "tags": [],
        "timestamp": timestamp,
        "title": "Chat Pending",
        "models": ["Anthropic Claude 4 Sonnet"],
        "messages": [
          {
            "id": userMessageId,
            "role": "user",
            "content": prompt,
            "timestamp": timestamp,
            "parentId": null,
            "children": []
          }
        ],
        "id": "",
        "history": {
          "currentId": userMessageId,
          "messages": [
            {
              "id": userMessageId,
              "role": "user",
              "content": prompt,
              "timestamp": timestamp,
              "parentId": null,
              "children": []
            }
          ]
        }
      }
    };
    
    console.log('[CCC Bridge API] Making chat creation request to:', `${CONFIG.apiBase}/api/v1/chats/new`);
    console.log('[CCC Bridge API] Chat creation body:', JSON.stringify(body, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/new`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(body)
    });
    
    console.log('[CCC Bridge API] Chat creation response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Chat creation failed:', response.status, errorText);
      throw new Error(`Chat creation failed: ${response.status} - ${errorText}`);
    }
    
    const result = await response.json();
    console.log('[CCC Bridge API] Chat creation result:', JSON.stringify(result, null, 2));
    return result;
  }
  
  async function getConversationState(chatId) {
    console.log('[CCC Bridge API] === GETTING CONVERSATION STATE ===');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Request URL:', `${CONFIG.apiBase}/api/v1/chats/${chatId}`);
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    console.log('[CCC Bridge API] Get state response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Get state failed:', response.status, errorText);
      throw new Error(`Get state failed: ${response.status} - ${errorText}`);
    }
    
    const result = await response.json();
    console.log('[CCC Bridge API] Get state result structure:');
    console.log('[CCC Bridge API] - Has result?', !!result);
    console.log('[CCC Bridge API] - Has chat?', !!result?.chat);
    console.log('[CCC Bridge API] - Has messages?', !!result?.chat?.messages);
    console.log('[CCC Bridge API] - Messages count:', result?.chat?.messages?.length || 0);
    console.log('[CCC Bridge API] Full get state result:', JSON.stringify(result, null, 2));
    
    return result;
  }
  
  async function createAssistantMessage(chatId, conversation, parentMessageId) {
    console.log('[CCC Bridge API] === CREATING ASSISTANT MESSAGE VIA POST ===');
    
    const assistantId = generateUUID();
    const timestamp = Date.now();
    
    console.log('[CCC Bridge API] Generated assistant ID:', assistantId);
    console.log('[CCC Bridge API] Parent message ID:', parentMessageId);
    console.log('[CCC Bridge API] Timestamp:', timestamp);
    
    // Debug logging
    console.log('[CCC Bridge API] Input conversation structure:', JSON.stringify(conversation, null, 2));
    
    // Clone conversation data
    const updatedConv = JSON.parse(JSON.stringify(conversation));
    
    // Create assistant message
    const assistantMessage = {
      id: assistantId,
      role: 'assistant',
      content: '',
      timestamp: timestamp,
      parentId: parentMessageId,
      children: []
    };
    
    // Ensure structure exists
    if (!updatedConv.chat) {
      console.error('[CCC Bridge API] No chat object in conversation:', updatedConv);
      throw new Error('Invalid conversation structure');
    }
    
    if (!updatedConv.chat.messages) {
      updatedConv.chat.messages = [];
    }
    
    if (!updatedConv.chat.history) {
      updatedConv.chat.history = { currentId: null, messages: [] };
    }
    
    if (!updatedConv.chat.history.messages) {
      updatedConv.chat.history.messages = [];
    }
    
    // Add to messages array
    updatedConv.chat.messages.push(assistantMessage);
    
    // Add to history.messages
    updatedConv.chat.history.messages.push(assistantMessage);
    
    // Update parent's children array
    const parentMessage = updatedConv.chat.messages.find(m => m.id === parentMessageId);
    if (parentMessage) {
      parentMessage.children.push(assistantId);
    }
    
    // Update currentId in history
    updatedConv.chat.history.currentId = assistantId;
    
    // Update updated_at timestamp
    updatedConv.updated_at = timestamp;
    
    console.log('[CCC Bridge API] Making POST request to update conversation...');
    console.log('[CCC Bridge API] URL:', `${CONFIG.apiBase}/api/v1/chats/${chatId}`);
    console.log('[CCC Bridge API] Updated conversation payload:', JSON.stringify(updatedConv, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(updatedConv)
    });
    
    console.log('[CCC Bridge API] POST response status:', response.status);
    console.log('[CCC Bridge API] POST response headers:', Object.fromEntries(response.headers.entries()));
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] POST failed:', response.status, errorText);
      throw new Error(`Update failed: ${response.status} - ${errorText}`);
    }
    
    const responseData = await response.json();
    console.log('[CCC Bridge API] POST response data:', JSON.stringify(responseData, null, 2));
    console.log('[CCC Bridge API] ✓ Successfully created assistant message via POST');
    
    return assistantId;
  }
  
  async function streamCompletion(chatId, messageId, conversation, onChunk) {
    console.log('[CCC Bridge API] === STARTING STREAM COMPLETION ===');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Message ID:', messageId);
    console.log('[CCC Bridge API] Conversation structure validation:');
    console.log('[CCC Bridge API] - Has conversation?', !!conversation);
    console.log('[CCC Bridge API] - Has conversation.chat?', !!conversation?.chat);
    console.log('[CCC Bridge API] - Has messages array?', !!conversation?.chat?.messages);
    console.log('[CCC Bridge API] - Messages count:', conversation?.chat?.messages?.length || 0);
    
    if (!conversation?.chat?.messages) {
      throw new Error('Invalid conversation structure: missing messages array');
    }
    
    // Debug logging
    console.log('[CCC Bridge API] Full conversation for completions:', JSON.stringify(conversation, null, 2));
    console.log('[CCC Bridge API] Messages structure:', conversation.chat.messages.map(m => ({
      id: m.id,
      role: m.role,
      contentLength: m.content?.length || 0,
      hasParentId: !!m.parentId,
      childrenCount: m.children?.length || 0
    })));
    
    // Build messages array for completions - only user messages for the model
    const userMessages = conversation.chat.messages.filter(m => m.role === 'user');
    console.log('[CCC Bridge API] Found user messages:', userMessages.length);
    
    const messages = userMessages.map(m => ({
      role: m.role,
      content: m.content
    }));
    
    console.log('[CCC Bridge API] Filtered messages for completion:', messages);
    
    if (messages.length === 0) {
      throw new Error('No user messages found to send to completions API');
    }
    
    const body = {
      "background_tasks": {
        "title_generation": true,
        "tags_generation": true
      },
      "chat_id": chatId,
      "features": {
        "web_search": false
      },
      "id": messageId,
      "messages": messages,
      "model": "Anthropic Claude 4 Sonnet",
      "params": {},
      "session_id": CONFIG.sessionId,
      "stream": true
    };
    
    console.log('[CCC Bridge API] Making completions request to:', `${CONFIG.apiBase}/api/chat/completions`);
    console.log('[CCC Bridge API] Full request body:', JSON.stringify(body, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(body)
    });
    
    console.log('[CCC Bridge API] Completions response status:', response.status);
    console.log('[CCC Bridge API] Completions response headers:', Object.fromEntries(response.headers.entries()));
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Completions request failed:', response.status, errorText);
      throw new Error(`Stream failed: ${response.status} - ${errorText}`);
    }
    
    console.log('[CCC Bridge API] Starting to read SSE stream...');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let accumulated = '';
    let chunkCount = 0;
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        console.log('[CCC Bridge API] Stream ended, total chunks processed:', chunkCount);
        break;
      }
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');
      
      console.log('[CCC Bridge API] Received chunk with', lines.length, 'lines');
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const dataStr = line.substring(6);
            console.log('[CCC Bridge API] Processing SSE line:', dataStr.substring(0, 100) + (dataStr.length > 100 ? '...' : ''));
            
            if (dataStr === '[DONE]') {
              console.log('[CCC Bridge API] Received [DONE] marker, ending stream');
              return accumulated;
            }
            
            const data = JSON.parse(dataStr);
            chunkCount++;
            
            if (data.choices?.[0]?.delta?.content) {
              const newContent = data.choices[0].delta.content;
              accumulated += newContent;
              console.log('[CCC Bridge API] Added content chunk:', newContent.substring(0, 50) + (newContent.length > 50 ? '...' : ''));
              console.log('[CCC Bridge API] Total accumulated length:', accumulated.length);
              onChunk(accumulated, false);
            }
            if (data.choices?.[0]?.finish_reason === 'stop') {
              console.log('[CCC Bridge API] Received finish_reason=stop, ending stream');
              onChunk(accumulated, true);
              return accumulated;
            }
          } catch (e) {
            console.error('[CCC Bridge API] Parse error on line:', line.substring(0, 100));
            console.error('[CCC Bridge API] Parse error:', e);
          }
        } else if (line.trim()) {
          console.log('[CCC Bridge API] Non-data SSE line:', line.substring(0, 100));
        }
      }
    }
    
    return accumulated;
  }
  
  // Create assistant message manually (server doesn't auto-generate)
  async function createAssistantMessageSlot(chatId, parentMessageId) {
    console.log('[CCC Bridge API] ===== CREATING ASSISTANT MESSAGE SLOT =====');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Parent message ID:', parentMessageId);
    
    try {
      // Get current conversation state
      console.log('[CCC Bridge API] Step 1: Getting current conversation state...');
      const conversation = await getConversationState(chatId);
      console.log('[CCC Bridge API] Current conversation state before creating assistant message:');
      console.log('[CCC Bridge API] Messages count:', conversation.chat.messages.length);
      console.log('[CCC Bridge API] Messages:', conversation.chat.messages.map(m => ({id: m.id, role: m.role, contentLength: m.content?.length || 0})));
      
      // Create assistant message slot
      console.log('[CCC Bridge API] Step 2: Creating assistant message via POST...');
      const assistantId = await createAssistantMessage(chatId, conversation, parentMessageId);
      console.log('[CCC Bridge API] ✓ Successfully created assistant message slot:', assistantId);
      
      // Use the conversation we already have (optimization: skip verification GET)
      console.log('[CCC Bridge API] ===== ASSISTANT MESSAGE SLOT CREATION COMPLETE =====');
      return { assistantId, conversation };
      
    } catch (error) {
      console.error('[CCC Bridge API] ❌ ERROR in createAssistantMessageSlot:', error);
      console.error('[CCC Bridge API] Error stack:', error.stack);
      throw error;
    }
  }
  
  // Test function using api_template from browser global
  async function testWithApiTemplate() {
    console.log('[CCC Bridge API] ===== TESTING WITH API_TEMPLATE =====');
    
    try {
      // Get api_template from global variable
      const apiTemplateStr = window.api_template;
      if (!apiTemplateStr) {
        throw new Error('api_template global variable not found');
      }
      
      console.log('[CCC Bridge API] Found api_template, length:', apiTemplateStr.length);
      
      // Get auth token from localStorage
      const authToken = localStorage.getItem('token');
      if (!authToken) {
        throw new Error('Auth token not found in localStorage');
      }
      
      console.log('[CCC Bridge API] Found auth token, length:', authToken.length);
      
      // Replace ${auth} with actual token
      const templatedStr = apiTemplateStr.replace(/\${auth}/g, authToken);
      
      // Parse as JSON
      const apiTemplate = JSON.parse(templatedStr);
      console.log('[CCC Bridge API] Parsed api_template, found', apiTemplate.length, 'entries');
      
      let chatId = null;
      
      // Execute each request in sequence
      for (let i = 0; i < apiTemplate.length; i++) {
        const entry = apiTemplate[i];
        console.log('[CCC Bridge API] Processing entry', i + 1, ':', entry.url);
        
        // Handle first request (/api/v1/chats/new)
        if (entry.url === '/api/v1/chats/new') {
          console.log('[CCC Bridge API] Executing chat creation request...');
          
          const response = await fetch(`${CONFIG.apiBase}${entry.url}`, entry.options);
          console.log('[CCC Bridge API] Chat creation response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[CCC Bridge API] Chat creation failed:', response.status, errorText);
            throw new Error(`Chat creation failed: ${response.status}`);
          }
          
          const result = await response.json();
          chatId = result.id;
          console.log('[CCC Bridge API] ✓ Chat created with ID:', chatId);
          continue;
        }
        
        // Handle subsequent requests - replace ${chat_id}
        if (!chatId) {
          throw new Error('Chat ID not available for subsequent requests');
        }
        
        // Stringify, replace chat_id, parse back
        let entryStr = JSON.stringify(entry);
        entryStr = entryStr.replace(/\${chat_id}/g, chatId);
        const updatedEntry = JSON.parse(entryStr);
        
        console.log('[CCC Bridge API] Updated entry URL:', updatedEntry.url);
        
        // Handle /api/chat/completions specially (SSE streaming)
        if (updatedEntry.url === '/api/chat/completions') {
          console.log('[CCC Bridge API] ===== STARTING SSE STREAM =====');
          console.log('[CCC Bridge API] Request options:', JSON.stringify(updatedEntry.options, null, 2));
          
          const response = await fetch(`${CONFIG.apiBase}${updatedEntry.url}`, updatedEntry.options);
          console.log('[CCC Bridge API] SSE response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[CCC Bridge API] SSE request failed:', response.status, errorText);
            throw new Error(`SSE request failed: ${response.status}`);
          }
          
          // Stream the SSE events
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let eventCount = 0;
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              console.log('[CCC Bridge API] SSE stream ended, total events:', eventCount);
              break;
            }
            
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                eventCount++;
                const dataStr = line.substring(6);
                console.log('[CCC Bridge API] SSE Event', eventCount + ':', dataStr);
                
                if (dataStr === '[DONE]') {
                  console.log('[CCC Bridge API] ===== SSE STREAM COMPLETE =====');
                  return;
                }
              }
            }
          }
          
          // Stop processing after completions
          break;
        }
        
        // Handle other requests normally
        console.log('[CCC Bridge API] Executing request to:', updatedEntry.url);
        
        const response = await fetch(`${CONFIG.apiBase}${updatedEntry.url}`, updatedEntry.options);
        console.log('[CCC Bridge API] Response status:', response.status);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('[CCC Bridge API] Request failed:', response.status, errorText);
          throw new Error(`Request failed: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('[CCC Bridge API] Response:', JSON.stringify(result, null, 2));
      }
      
    } catch (error) {
      console.error('[CCC Bridge API] ❌ ERROR in testWithApiTemplate:', error);
      console.error('[CCC Bridge API] Error stack:', error.stack);
    }
  }

  // Process AI request using api_template flow
  async function processAIRequest(request) {
    try {
      updateDisplay('processing', 'Processing using API template...');
      console.log('[CCC Bridge API] ===== PROCESSING WITH API_TEMPLATE =====');
      
      // Get api_template from global variable
      const apiTemplateStr = window.api_template;
      if (!apiTemplateStr) {
        throw new Error('api_template global variable not found');
      }
      
      console.log('[CCC Bridge API] Found api_template, length:', apiTemplateStr.length);
      
      // Get auth token from localStorage
      const authToken = localStorage.getItem('token');
      if (!authToken) {
        throw new Error('Auth token not found in localStorage');
      }
      
      console.log('[CCC Bridge API] Found auth token, processing template...');
      
      // Replace ${auth} and ${message} with actual values
      let templatedStr = apiTemplateStr.replace(/\${auth}/g, authToken);
      templatedStr = templatedStr.replace(/\${message}/g, request.payload.prompt);
      
      // Parse as JSON
      const apiTemplate = JSON.parse(templatedStr);
      console.log('[CCC Bridge API] Parsed api_template, found', apiTemplate.length, 'entries');
      
      let chatId = null;
      let finalContent = '';
      
      updateDisplay('processing', 'Executing API sequence...', true);
      streamingContent.textContent = '';
      
      // Execute each request in sequence
      for (let i = 0; i < apiTemplate.length; i++) {
        const entry = apiTemplate[i];
        console.log('[CCC Bridge API] Processing entry', i + 1, ':', entry.url);
        
        // Handle first request (/api/v1/chats/new)
        if (entry.url === '/api/v1/chats/new') {
          console.log('[CCC Bridge API] Executing chat creation request...');
          
          const response = await fetch(`${CONFIG.apiBase}${entry.url}`, entry.options);
          console.log('[CCC Bridge API] Chat creation response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[CCC Bridge API] Chat creation failed:', response.status, errorText);
            throw new Error(`Chat creation failed: ${response.status}`);
          }
          
          const result = await response.json();
          chatId = result.id;
          console.log('[CCC Bridge API] ✓ Chat created with ID:', chatId);
          continue;
        }
        
        // Handle subsequent requests - replace ${chat_id}
        if (!chatId) {
          throw new Error('Chat ID not available for subsequent requests');
        }
        
        // Stringify, replace chat_id, parse back
        let entryStr = JSON.stringify(entry);
        entryStr = entryStr.replace(/\${chat_id}/g, chatId);
        const updatedEntry = JSON.parse(entryStr);
        
        console.log('[CCC Bridge API] Updated entry URL:', updatedEntry.url);
        
        // Handle /api/chat/completions specially (SSE streaming)
        if (updatedEntry.url === '/api/chat/completions') {
          console.log('[CCC Bridge API] ===== STARTING SSE STREAM =====');
          updateDisplay('streaming', 'Streaming response...', true);
          
          const response = await fetch(`${CONFIG.apiBase}${updatedEntry.url}`, updatedEntry.options);
          console.log('[CCC Bridge API] SSE response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[CCC Bridge API] SSE request failed:', response.status, errorText);
            throw new Error(`SSE request failed: ${response.status}`);
          }
          
          // Stream the SSE events and send via clipboard
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let eventCount = 0;
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              console.log('[CCC Bridge API] SSE stream ended, total events:', eventCount);
              break;
            }
            
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                eventCount++;
                const dataStr = line.substring(6);
                console.log('[CCC Bridge API] SSE Event', eventCount + ':', dataStr);
                
                if (dataStr === '[DONE]') {
                  console.log('[CCC Bridge API] ===== SSE STREAM COMPLETE =====');
                  
                  // Send final response via clipboard
                  const finalResponse = {
                    type: 'BROWSER_RESPONSE',
                    id: request.id,
                    timestamp: Date.now(),
                    status: 'success',
                    payload: {
                      content: finalContent,
                      chatId: chatId,
                      model: 'Anthropic Claude 4 Sonnet'
                    }
                  };
                  
                  const responseText = JSON.stringify(finalResponse) + '|||BROWSER_END|||';
                  await navigator.clipboard.writeText(responseText);
                  console.log('[CCC Bridge API] Final response written to clipboard');
                  
                  updateDisplay('success', 'Response sent!');
                  setTimeout(() => updateDisplay('ready', 'Waiting for AI requests...'), 3000);
                  
                  return finalResponse;
                }
                
                // Parse and accumulate content
                try {
                  const data = JSON.parse(dataStr);
                  if (data.choices?.[0]?.delta?.content) {
                    const newContent = data.choices[0].delta.content;
                    finalContent += newContent;
                    streamingContent.textContent = finalContent;
                    streamingContent.scrollTop = streamingContent.scrollHeight;
                    
                    // Send progress update via clipboard
                    const progressResponse = {
                      type: 'BROWSER_PROGRESS',
                      id: request.id,
                      status: 'streaming',
                      payload: {
                        accumulated: finalContent,
                        chatId: chatId
                      }
                    };
                    
                    // Write progress to clipboard for Java agent
                    const progressText = JSON.stringify(progressResponse) + '|||BROWSER_PROGRESS|||';
                    navigator.clipboard.writeText(progressText).catch(e => 
                      console.warn('[CCC Bridge API] Could not write progress to clipboard:', e.message)
                    );
                  }
                } catch (parseError) {
                  console.warn('[CCC Bridge API] Could not parse SSE data:', parseError.message);
                }
              }
            }
          }
          
          // Stop processing after completions
          break;
        }
        
        // Handle other requests normally
        console.log('[CCC Bridge API] Executing request to:', updatedEntry.url);
        
        const response = await fetch(`${CONFIG.apiBase}${updatedEntry.url}`, updatedEntry.options);
        console.log('[CCC Bridge API] Response status:', response.status);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('[CCC Bridge API] Request failed:', response.status, errorText);
          throw new Error(`Request failed: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('[CCC Bridge API] Response:', JSON.stringify(result, null, 2));
      }
      
    } catch (error) {
      console.error('[CCC Bridge API] Error:', error);
      return {
        type: 'BROWSER_RESPONSE',
        id: request.id,
        timestamp: Date.now(),
        status: 'error',
        payload: {
          error: error.message
        }
      };
    }
  }
  
  // Handle clicks
  overlay.addEventListener('click', async (e) => {
    clickCount++;
    console.log(`[CCC Bridge API] Click #${clickCount} at ${e.clientX}, ${e.clientY}`);
    
    if (bridgeState === 'calibrating') {
      try {
        const calibrationMsg = JSON.stringify({
          type: 'CCC_CALIBRATION',
          clicked: true,
          timestamp: Date.now()
        }) + '|||CCC_END|||';
        
        await navigator.clipboard.writeText(calibrationMsg);
        console.log('[CCC Bridge API] Calibration click written to clipboard');
        updateDisplay('ready', 'Waiting for AI requests...');
        
      } catch (err) {
        console.error('[CCC Bridge API] Calibration failed:', err);
        updateDisplay('error', 'Clipboard access failed');
      }
      return;
    }
    
    if (bridgeState === 'ready') {
      try {
        const clipboardText = await navigator.clipboard.readText();
        console.log('[CCC Bridge API] Clipboard content:', clipboardText.substring(0, 100) + '...');
        
        if (clipboardText.includes('CCC_REQUEST')) {
          const requestEnd = clipboardText.indexOf('|||CCC_END|||');
          if (requestEnd > 0) {
            const requestJson = clipboardText.substring(0, requestEnd);
            lastRequest = JSON.parse(requestJson);
            console.log('[CCC Bridge API] Found request:', lastRequest.id);
            
            // Process using real API
            const response = await processAIRequest(lastRequest);
            
            // Write response to clipboard
            const responseText = JSON.stringify(response) + '|||BROWSER_END|||';
            await navigator.clipboard.writeText(responseText);
            
            console.log('[CCC Bridge API] Response written to clipboard');
            updateDisplay('success', 'Response sent!');
            
            setTimeout(() => updateDisplay('ready', 'Waiting for AI requests...'), 3000);
          }
        } else {
          console.log('[CCC Bridge API] No CCC_REQUEST found in clipboard');
        }
      } catch (err) {
        console.error('[CCC Bridge API] Error:', err);
        updateDisplay('error', err.message);
      }
    }
  });
  
  // Add to page
  document.body.appendChild(overlay);
  
  // Set mock token if needed
  if (!localStorage.getItem('token')) {
    localStorage.setItem('token', 'mock-token-12345');
  }
  
  console.log('[CCC Bridge API] Ready with real API flow');
  
  // Signal initialization to Java agent via clipboard after user click
  setTimeout(() => {
    console.log('[CCC Bridge API] Ready to signal initialization...');
    console.log('[CCC Bridge API] Please click anywhere on the main page content (not in DevTools)');
    console.log('[CCC Bridge API] The page will then signal the Java agent');
    
    // Add one-time click listener to the document
    const handleInitClick = async (e) => {
      console.log('[CCC Bridge API] Click detected! Signaling Java agent...');
      document.removeEventListener('click', handleInitClick);
      
      try {
        await navigator.clipboard.writeText('CCC_BRIDGE_INITIALIZED');
        console.log('[CCC Bridge API] Initialization signal sent to Java agent');
      } catch (err) {
        console.log('[CCC Bridge API] Could not send initialization signal:', err.message);
        console.log('[CCC Bridge API] Make sure the main page has focus, not DevTools');
      }
    };
    
    document.addEventListener('click', handleInitClick);
  }, 1000);
  
  // Export for debugging
  window.CCCBridgeAPI = {
    getState: () => ({ state: bridgeState, clicks: clickCount, lastRequest }),
    recalibrate: () => updateDisplay('calibrating'),
    remove: () => overlay.remove(),
    testTemplate: testWithApiTemplate
  };
})();
-~{END}~-

-~{File: run-prod.bat}~-
@echo off
echo ================================
echo CCC Chat Server (Production)
echo ================================
echo.

REM Compile ChatServerAgent
echo Compiling ChatServerAgent...
javac src\java-agent\ChatServerAgent.java
if errorlevel 1 (
    echo ChatServerAgent compilation failed!
    pause
    exit /b 1
)

REM Create manifest file for JAR
echo Main-Class: ChatServerAgent > manifest.txt
echo. >> manifest.txt
jar cvfm src\java-agent\chat-server.jar manifest.txt -C src\java-agent ChatServerAgent*.class
if errorlevel 1 (
    echo JAR creation failed!
    pause
    exit /b 1
)
del manifest.txt

echo.
echo ================================
echo STARTING CCC CHAT SERVER
echo ================================
echo.
echo The chat server will:
echo 1. Start HTTP server on port 4444
echo 2. Auto-launch Chrome with chat interface
echo 3. Wait for you to paste bridge script in Claude UI
echo 4. Handle chat requests via clipboard bridge
echo.
echo Chat interface will be available at:
echo http://localhost:4444
echo.
echo Instructions for setup:
echo 1. When Chrome opens, keep it open
echo 2. Open your internal Claude UI in another tab/window
echo 3. Open Developer Console (F12) in Claude UI
echo 4. Copy and paste the bridge script (it will be in your clipboard)
echo 5. Click the calibration overlay to set click position
echo 6. Return to the chat interface and start chatting!
echo.
echo Starting chat server...
java -jar src\java-agent\chat-server.jar

pause
-~{END}~-

-~{File: run-dev.bat}~-
@echo off
echo ================================
echo CCC Development Runner
echo ================================
echo.

echo [DEBUG] Checking for node_modules directory...
if exist node_modules (
    echo [DEBUG] node_modules found, skipping npm install
    goto :startserver
)

echo [DEBUG] node_modules not found, installing...
echo Installing Node.js dependencies...
call npm install
echo [DEBUG] npm install completed with exit code: %errorlevel%
if errorlevel 1 (
    echo npm install failed!
    pause
    exit /b 1
)
echo [DEBUG] npm install successful, continuing...

:startserver
echo [DEBUG] Starting mock server section...

REM Kill any existing mock server on port 5556
echo [DEBUG] Killing any existing node processes on port 5556...
powershell -Command "Get-NetTCPConnection -LocalPort 5556 -ErrorAction SilentlyContinue | ForEach-Object { $proc = Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue; if($proc -and $proc.ProcessName -eq 'node') { Write-Host 'Killing node process' $proc.Id 'on port 5556'; Stop-Process -Id $proc.Id -Force } }" 2>nul
timeout /t 1 > nul

echo Starting mock server on http://localhost:5556/...
start /B node mock-env\server.js
echo [DEBUG] Mock server started in background

REM Wait for server to start
echo [DEBUG] Waiting 3 seconds for server startup...
timeout /t 3 > nul
echo [DEBUG] Wait complete

REM Don't open browser automatically
echo [DEBUG] Mock server ready at http://localhost:5556/
echo [DEBUG] You can open the browser manually if needed

REM Run production script (Java client with bridge copy)
echo [DEBUG] About to call run-prod.bat for clipboard copy and Java agent...
echo.
echo ================================
echo DEVELOPMENT ENVIRONMENT READY!
echo ================================
echo.
echo Instructions:
echo 1. Open http://localhost:5556/ in your browser
echo 2. Bridge script will be copied to clipboard
echo 3. Paste it in dev console or just use the built-in mock UI
echo 4. Java agent will start automatically
echo.
call run-prod.bat
echo [DEBUG] run-prod.bat completed
-~{END}~-
