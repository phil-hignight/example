// AI Agent - Built 2025-11-21T04:53:54.846Z
(function() {
  window.module = {};

  // Module: api-diagnostics.js
  // API Diagnostics - Probes for 500 errors and tests recovery strategies
  window.module['api-diagnostics.js'] = {
    results: [],
  
    // Main entry point - runs all diagnostic tests
    runAllTests: async function() {
      console.log('\n========== API DIAGNOSTICS: Error Detection + Auto-Recovery Test ==========\n');
  
      // Single test: 1792K message that we know triggers the error
      const api = window.module['api.js'];
      const size = 1792000;
      const content = "reply 'K'. Ignore: " + 'x'.repeat(size);
      const messages = [{ role: 'user', content }];
  
      console.log(`Sending ${Math.round(size/1000)}K message to trigger error...`);
  
      const result = await this.callWithAutoRecovery(messages);
  
      if (result.success) {
        console.log('Final result: SUCCESS');
        console.log('Retries needed:', result.retries);
        if (result.compacted) {
          console.log('Message was compacted from', result.originalSize, 'to', result.compactedSize, 'chars');
        }
      } else {
        console.log('Final result: FAILED after recovery attempts');
        console.log('Error:', result.error);
      }
    },
  
    // Call API with auto-recovery on server connection error
    callWithAutoRecovery: async function(messages, maxRetries = 2) {
      const api = window.module['api.js'];
      let retries = 0;
      let currentMessages = messages;
      let compacted = false;
      let originalSize = JSON.stringify(messages).length;
      let compactedSize = originalSize;
  
      while (retries <= maxRetries) {
        try {
          const response = await api.callAPI(currentMessages);
  
          if (response.valid) {
            return { success: true, response, retries, compacted, originalSize, compactedSize };
          }
  
          // Check if it's the server connection error
          if (this.isServerConnectionError(response.error)) {
            console.log(`Attempt ${retries + 1}: Server Connection Error detected`);
  
            if (retries < maxRetries) {
              // Compact messages and retry
              console.log('Compacting messages...');
              currentMessages = this.compactMessages(currentMessages);
              compacted = true;
              compactedSize = JSON.stringify(currentMessages).length;
              console.log(`Compacted: ${originalSize} -> ${compactedSize} chars (${Math.round((1 - compactedSize/originalSize) * 100)}% reduction)`);
              retries++;
              await this.delay(1000);
              continue;
            }
          }
  
          return { success: false, error: response.error, retries, compacted, originalSize, compactedSize };
  
        } catch (e) {
          if (this.isServerConnectionError(e)) {
            console.log(`Attempt ${retries + 1}: Server Connection Error (exception)`);
  
            if (retries < maxRetries) {
              console.log('Compacting messages...');
              currentMessages = this.compactMessages(currentMessages);
              compacted = true;
              compactedSize = JSON.stringify(currentMessages).length;
              console.log(`Compacted: ${originalSize} -> ${compactedSize} chars`);
              retries++;
              await this.delay(1000);
              continue;
            }
          }
  
          return { success: false, error: e.message || e, retries, compacted, originalSize, compactedSize };
        }
      }
  
      return { success: false, error: 'Max retries exceeded', retries, compacted, originalSize, compactedSize };
    },
  
    // Compact messages by truncating large content
    compactMessages: function(messages) {
      const maxContentSize = 500000; // 500K limit per message
  
      return messages.map(msg => {
        if (msg.content && msg.content.length > maxContentSize) {
          return {
            ...msg,
            content: msg.content.substring(0, maxContentSize) + '\n[TRUNCATED - content exceeded 500K limit]'
          };
        }
        return msg;
      });
    },
  
    // Log result helper
    logResult: function(testName, success, details, error = null) {
      const result = {
        test: testName,
        success,
        details,
        error: error ? error.message || error : null,
        timestamp: Date.now()
      };
      this.results.push(result);
  
      const status = success ? 'PASS' : 'FAIL';
      console.log(`[${status}] ${testName}: ${details}`);
      if (error) {
        console.log(`  Error: ${error.message || error}`);
      }
    },
  
    // Check if error is the 500 Server Connection Error
    is500Error: function(error) {
      if (!error) return false;
      const errStr = String(error.message || error);
      return errStr.includes('500') ||
             errStr.includes('Server Connection Error') ||
             errStr.includes('Open WebUI');
    },
  
    // Specific check for the server connection error we see with large payloads
    isServerConnectionError: function(error) {
      if (!error) return false;
      const errStr = String(error.message || error);
      // Match: "500: Open WebUI: Server Connection Error"
      return errStr.includes('Server Connection Error') ||
             (errStr.includes('500') && errStr.includes('Open WebUI'));
    },
  
    // Test 1: Message size limits - start at 512K, go up to 4MB
    testMessageSizeLimits: async function() {
      console.log('\n--- Test 1: Message Size Limits ---');
  
      const api = window.module['api.js'];
      // 12 rungs: 512K to 4MB
      const sizes = [512000, 640000, 768000, 896000, 1024000, 1280000, 1536000, 1792000, 2048000, 2560000, 3072000, 4096000];
      let lastSuccessSize = 0;
      let firstFailSize = null;
      let failError = null;
  
      for (const size of sizes) {
        const content = "reply 'K'. Ignore: " + 'x'.repeat(size);
        const messages = [{ role: 'user', content }];
  
        console.log(`  Testing ${Math.round(size/1000)}K chars...`);
  
        try {
          const response = await api.callAPI(messages);
  
          if (response.valid) {
            lastSuccessSize = size;
            console.log(`    ${Math.round(size/1000)}K: OK`);
          } else {
            firstFailSize = size;
            failError = response.error;
            console.log(`    ${Math.round(size/1000)}K: FAILED`);
            if (this.is500Error(response.error)) {
              await this.attemptRecovery('Message Size', messages, response.error);
            }
            break;
          }
        } catch (e) {
          firstFailSize = size;
          failError = e;
          break;
        }
  
        await this.delay(500);
      }
  
      this.logResult('Message Size Limits',
        firstFailSize === null,
        `Last success: ${Math.round(lastSuccessSize/1000)}K, First fail: ${firstFailSize ? Math.round(firstFailSize/1000)+'K' : 'none'}`,
        failError);
    },
  
    // Test 2: Conversation length - start at 80, go up to 1000 messages
    testConversationLengthLimits: async function() {
      console.log('\n--- Test 2: Conversation Length Limits ---');
  
      const api = window.module['api.js'];
      // 12 rungs: 80 to 1000 messages
      const counts = [80, 120, 160, 200, 250, 300, 400, 500, 600, 700, 850, 1000];
      let lastSuccessCount = 0;
      let firstFailCount = null;
      let failError = null;
  
      for (const count of counts) {
        const messages = [];
        for (let i = 0; i < count; i++) {
          messages.push({
            role: i % 2 === 0 ? 'user' : 'assistant',
            content: `Msg ${i}: Test content here.`
          });
        }
        messages.push({ role: 'user', content: "reply 'K'" });
  
        console.log(`  Testing ${count} messages...`);
  
        try {
          const response = await api.callAPI(messages);
  
          if (response.valid) {
            lastSuccessCount = count;
            console.log(`    ${count} msgs: OK`);
          } else {
            firstFailCount = count;
            failError = response.error;
            console.log(`    ${count} msgs: FAILED`);
            if (this.is500Error(response.error)) {
              await this.attemptRecovery('Conversation Length', messages, response.error);
            }
            break;
          }
        } catch (e) {
          firstFailCount = count;
          failError = e;
          break;
        }
  
        await this.delay(500);
      }
  
      this.logResult('Conversation Length',
        firstFailCount === null,
        `Last success: ${lastSuccessCount} msgs, First fail: ${firstFailCount || 'none'}`,
        failError);
    },
  
    // Test 3: Rapid requests - increase burst size
    testRapidRequests: async function() {
      console.log('\n--- Test 3: Rapid Requests ---');
  
      const api = window.module['api.js'];
      const messages = [{ role: 'user', content: "reply 'K'" }];
  
      // Burst: 10 rapid requests
      console.log('  Sending 10 rapid parallel requests...');
      const promises = [];
      for (let i = 0; i < 10; i++) {
        promises.push(api.callAPI(messages));
      }
  
      let successCount = 0;
      let failCount = 0;
      let firstError = null;
  
      try {
        const results = await Promise.all(promises);
        for (const r of results) {
          if (r.valid) successCount++;
          else {
            failCount++;
            if (!firstError) firstError = r.error;
          }
        }
      } catch (e) {
        failCount++;
        firstError = e;
      }
  
      this.logResult('Rapid Requests',
        failCount === 0,
        `${successCount}/10 succeeded, ${failCount} failed`,
        firstError);
    },
  
    // Test 4: Many tool results - start at 50, go up to 500
    testManyToolResults: async function() {
      console.log('\n--- Test 4: Many Tool Results ---');
  
      const api = window.module['api.js'];
      // 10 rungs: 50 to 500
      const counts = [50, 75, 100, 125, 150, 200, 250, 300, 400, 500];
      let lastSuccessCount = 0;
      let failError = null;
  
      for (const count of counts) {
        const messages = [];
        for (let i = 0; i < count; i++) {
          messages.push({
            role: 'user',
            content: `[Tool ${i}] list_directory: file1.js, file2.js, folder1/`
          });
          messages.push({
            role: 'assistant',
            content: `Listing ${i} done.`
          });
        }
        messages.push({ role: 'user', content: "reply 'K'" });
  
        console.log(`  Testing ${count} tool results...`);
  
        try {
          const response = await api.callAPI(messages);
          if (response.valid) {
            lastSuccessCount = count;
            console.log(`    ${count}: OK`);
          } else {
            failError = response.error;
            console.log(`    ${count}: FAILED`);
            break;
          }
        } catch (e) {
          failError = e;
          break;
        }
  
        await this.delay(500);
      }
  
      this.logResult('Many Tool Results',
        failError === null,
        `Last success: ${lastSuccessCount} tool results`,
        failError);
    },
  
    // Test 5: Message count (small content, many messages)
    testMessageCount: async function() {
      console.log('\n--- Test 5: Message Count ---');
  
      const api = window.module['api.js'];
      // Test message COUNT with small content per message
      const counts = [10, 20, 50, 100, 200, 500];
      let lastSuccessCount = 0;
      let failError = null;
  
      for (const count of counts) {
        const messages = [];
        for (let i = 0; i < count; i++) {
          messages.push({
            role: i % 2 === 0 ? 'user' : 'assistant',
            content: `Msg ${i}: short content`
          });
        }
        messages.push({ role: 'user', content: "reply 'K'" });
  
        console.log(`  Testing ${count} messages (small content)...`);
  
        try {
          const response = await api.callAPI(messages);
          if (response.valid) {
            lastSuccessCount = count;
            console.log(`    ${count} msgs: OK`);
          } else {
            failError = response.error;
            console.log(`    ${count} msgs: FAILED - ${response.error}`);
            break;
          }
        } catch (e) {
          failError = e;
          console.log(`    ${count} msgs: EXCEPTION - ${e.message}`);
          break;
        }
  
        await this.delay(500);
      }
  
      this.logResult('Message Count',
        failError === null,
        `Last success: ${lastSuccessCount} messages`,
        failError);
    },
  
    // Test 6: Long single lines - start at 50K, go up to 1MB
    testLongLines: async function() {
      console.log('\n--- Test 6: Long Lines (no newlines) ---');
  
      const api = window.module['api.js'];
      // 10 rungs: 50K to 1MB single line
      const lengths = [50000, 75000, 100000, 150000, 200000, 300000, 400000, 500000, 750000, 1000000];
      let lastSuccess = 0;
      let failError = null;
  
      for (const len of lengths) {
        const content = "reply 'K'. " + 'a'.repeat(len);
        const messages = [{ role: 'user', content }];
  
        console.log(`  Testing ${Math.round(len/1000)}K char single line...`);
        try {
          const response = await api.callAPI(messages);
          if (response.valid) {
            lastSuccess = len;
            console.log(`    ${Math.round(len/1000)}K: OK`);
          } else {
            failError = response.error;
            console.log(`    ${Math.round(len/1000)}K: FAILED`);
            break;
          }
        } catch (e) {
          failError = e;
          break;
        }
  
        await this.delay(300);
      }
  
      this.logResult('Long Lines',
        failError === null,
        `Last success: ${Math.round(lastSuccess/1000)}K chars`,
        failError);
    },
  
    // Test 7: Burst then sustained
    testBurstSustained: async function() {
      console.log('\n--- Test 7: Burst Then Sustained ---');
  
      const api = window.module['api.js'];
      const messages = [{ role: 'user', content: "reply 'K'" }];
  
      // Burst: 5 rapid requests
      console.log('  Burst: 5 rapid requests...');
      const burstPromises = [];
      for (let i = 0; i < 5; i++) burstPromises.push(api.callAPI(messages));
      const burstResults = await Promise.all(burstPromises);
      const burstSuccess = burstResults.filter(r => r.valid).length;
      console.log(`    Burst: ${burstSuccess}/5`);
  
      // Sustained: 10 requests @ 500ms intervals
      console.log('  Sustained: 10 requests @ 500ms...');
      let sustainedSuccess = 0;
      for (let i = 0; i < 10; i++) {
        await this.delay(500);
        try {
          const response = await api.callAPI(messages);
          if (response.valid) sustainedSuccess++;
        } catch (e) {}
      }
      console.log(`    Sustained: ${sustainedSuccess}/10`);
  
      this.logResult('Burst Then Sustained',
        burstSuccess >= 3 && sustainedSuccess >= 8,
        `Burst: ${burstSuccess}/5, Sustained: ${sustainedSuccess}/10`);
    },
  
    // Recovery attempts when 500 error is detected
    attemptRecovery: async function(context, originalMessages, originalError) {
      console.log('\n  --- Attempting Recovery ---');
  
      const api = window.module['api.js'];
  
      // Strategy 1: Retry 3x with increasing delays
      for (let i = 0; i < 3; i++) {
        await this.delay(1000 * (i + 1));
        try {
          const response = await api.callAPI(originalMessages);
          if (response.valid) {
            console.log(`    Retry ${i + 1}: SUCCESS`);
            return { strategy: 'retry', attempt: i + 1 };
          }
        } catch (e) {}
      }
  
      // Strategy 2: Minimal request
      const minimalMessages = [{ role: 'user', content: "reply 'K'" }];
      try {
        const response = await api.callAPI(minimalMessages);
        if (response.valid) {
          console.log(`    Minimal request: SUCCESS - original request too large`);
          return { strategy: 'minimal', success: true };
        } else {
          console.log(`    Minimal request: FAILED - API may be down`);
        }
      } catch (e) {}
  
      return { strategy: 'failed' };
    },
  
    // Print summary
    printSummary: function() {
      console.log('\n========== SUMMARY ==========\n');
  
      let passCount = 0;
      let failCount = 0;
  
      for (const result of this.results) {
        if (result.success) passCount++;
        else failCount++;
      }
  
      console.log(`Total: ${passCount} passed, ${failCount} failed\n`);
  
      if (failCount > 0) {
        console.log('Failed tests:');
        for (const f of this.results.filter(r => !r.success)) {
          console.log(`  - ${f.test}: ${f.details}`);
        }
      }
  
      console.log('\n========== END ==========\n');
    },
  
    delay: function(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  };
  

  // Module: api.js
  // API communication
  window.module['api.js'] = {
    // Render messages for API - simplified version
    renderMessagesForAPI: function(messages) {
      const tools = window.module['tools.js'];
      const state = window.module['state.js'];
      const diagnostics = window.module['diagnostics.js'];
  
      diagnostics.log('api', 'renderMessagesForAPI called', { totalMessages: messages.length });
  
      // Filter out UI-only messages
      const apiMessages = messages.filter(msg => !msg.uiOnly);
  
      diagnostics.log('api', 'After UI filtering', { apiMessagesCount: apiMessages.length });
  
      // Log total size estimate and find largest messages
      const totalChars = messages.reduce((sum, msg) => sum + (msg.content?.length || 0), 0);
      const estimatedTokens = Math.ceil(totalChars / 4);
      diagnostics.log('api', 'Message size calculation', { totalChars, estimatedTokens });
  
      // Find and log the 5 largest messages
      const messagesWithSize = messages.map((msg, idx) => ({
        index: idx,
        role: msg.role,
        toolName: msg.toolName,
        size: msg.content?.length || 0,
        preview: msg.content?.substring(0, 100) || ''
      })).sort((a, b) => b.size - a.size);
  
      diagnostics.log('api', 'Top 5 largest messages', { top5: messagesWithSize.slice(0, 5) });
  
      // If a summary exists, only include messages from last summary forward
      const lastSummaryIndex = state.getLastSummaryIndex();
      let messagesToProcess = apiMessages;
      let summaryContent = null;
  
      if (lastSummaryIndex !== -1) {
        // Find the summary message
        summaryContent = messages[lastSummaryIndex].content;
  
        // Filter to only messages after the summary (excluding the summary itself)
        messagesToProcess = apiMessages.filter((msg, index) => {
          const originalIndex = messages.findIndex(m => m === messages[index]);
          return originalIndex > lastSummaryIndex;
        });
  
        diagnostics.log('api', 'Summary compaction', {
          lastSummaryIndex,
          messagesAfterSummary: messagesToProcess.length
        });
      }
  
      // Convert messages for API: tool-use and tool-result become user messages
      // Combine consecutive user messages
      const processedMessages = [];
  
      for (let i = 0; i < messagesToProcess.length; i++) {
        const msg = messagesToProcess[i];
  
        // Convert tool-use and tool-result to user role
        if (msg.role === 'tool-use' || msg.role === 'tool-result') {
          const userContent = msg.content;
  
          // Check if previous message was also a user message
          if (processedMessages.length > 0 && processedMessages[processedMessages.length - 1].role === 'user') {
            // Combine with previous user message
            processedMessages[processedMessages.length - 1].content += '\n\n' + userContent;
          } else {
            // Create new user message
            processedMessages.push({
              role: 'user',
              content: userContent
            });
          }
        } else {
          // Regular user or assistant message
          const newMsg = {
            role: msg.role,
            content: msg.content
          };
  
          // Check if we need to combine consecutive user messages
          if (newMsg.role === 'user' && processedMessages.length > 0 && processedMessages[processedMessages.length - 1].role === 'user') {
            // Combine with previous user message
            processedMessages[processedMessages.length - 1].content += '\n\n' + newMsg.content;
          } else {
            processedMessages.push(newMsg);
          }
        }
      }
  
      diagnostics.log('api', 'Sending messages to API', { messageCount: processedMessages.length });
  
      return {
        messages: processedMessages,
        summary: summaryContent
      };
    },
  
    // Handle truncated responses by requesting continuations
    handleTruncatedResponse: async function(initialResponseText, headers, requestBody, startTime) {
      const diagnostics = window.module['diagnostics.js'];
      const TERMINATOR = '||||END||||';
      const MAX_CONTINUATIONS = 20;
      const TAIL_LENGTH = 20;
  
      let fullResponse = initialResponseText;
      let continuationCount = 0;
      let lastChunk = null;
      let incomplete = false;
      let incompleteReason = null;
  
      diagnostics.log('api', 'Response missing terminator - handling truncation');
  
      while (!fullResponse.includes(TERMINATOR) && continuationCount < MAX_CONTINUATIONS) {
        continuationCount++;
        diagnostics.log('api', 'Requesting continuation', { continuationCount, MAX_CONTINUATIONS });
  
        // Get last TAIL_LENGTH characters
        const tail = fullResponse.slice(-TAIL_LENGTH);
        diagnostics.log('api', 'Tail characters', { TAIL_LENGTH, tail });
  
        // Create continuation prompt
        const continuationMessages = [
          ...requestBody.messages,
          {
            role: 'assistant',
            content: fullResponse
          },
          {
            role: 'user',
            content: `Your response was truncated. The last ${TAIL_LENGTH} characters were: "${tail}". Continue from exactly the next character. When done, end with ||||END||||`
          }
        ];
  
        const continuationBody = {
          ...requestBody,
          messages: continuationMessages
        };
  
        try {
          // Make continuation request
          const response = await fetch('/api/chat/completions', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(continuationBody)
          });
  
          if (!response.ok) {
            const errorText = await response.text();
            diagnostics.handleError('API_ERROR', {
              error: new Error(`Continuation request failed (${response.status})`),
              response: { status: response.status, statusText: response.statusText },
              requestBody: continuationBody
            });
            incomplete = true;
            incompleteReason = `Continuation request failed (${response.status})`;
            break;
          }
  
          let data;
          try {
            data = await response.json();
          } catch (error) {
            const responseText = await response.text();
            diagnostics.handleError('JSON_PARSE_ERROR', {
              error,
              jsonString: responseText,
              position: error.message.match(/position (\d+)/)?.[1] || 0
            });
            incomplete = true;
            incompleteReason = `JSON parse error: ${error.message}`;
            break;
          }
          const chunk = data.choices[0].message.content;
          diagnostics.log('api', 'Chunk received', { chunkPreview: chunk.substring(0, 100) });
  
          // Handle blank response
          if (!chunk || chunk.trim() === '') {
            diagnostics.log('api', 'Received blank continuation - stopping');
            incomplete = true;
            incompleteReason = 'Received blank continuation response';
            break;
          }
  
          // Check for duplicate chunks (AI repeating itself)
          if (lastChunk && chunk === lastChunk) {
            diagnostics.log('api', 'AI is repeating the same chunk - aborting continuation');
            incomplete = true;
            incompleteReason = 'AI is repeating the same content';
            break;
          }
          lastChunk = chunk;
  
          // If AI just sends terminator, it means previous response was complete
          if (chunk.trim() === TERMINATOR) {
            diagnostics.log('api', 'AI confirmed completion with terminator');
            fullResponse += TERMINATOR;
            break;
          }
  
          // Check if the continuation starts with part of the tail (overlap detection)
          // The AI might repeat some characters to ensure continuity
          let chunkToAdd = chunk;
          let overlapFound = false;
          for (let overlapLen = TAIL_LENGTH; overlapLen > 0; overlapLen--) {
            const tailEnd = tail.slice(-overlapLen);
            const chunkStart = chunk.slice(0, overlapLen);
            if (tailEnd === chunkStart) {
              // Found overlap - remove it from the chunk
              chunkToAdd = chunk.slice(overlapLen);
              diagnostics.log('api', 'Detected overlap', { overlapLen, tailEnd });
              overlapFound = true;
              break;
            }
          }
  
          if (!overlapFound) {
            diagnostics.log('api', 'No overlap detected between tail and chunk start');
          }
  
          diagnostics.log('api', 'Received continuation chunk', { chunkLength: chunk.length, afterOverlapRemoval: chunkToAdd.length });
          fullResponse += chunkToAdd;
        } catch (error) {
          diagnostics.log('api', 'Error during continuation', { error: error.message });
          incomplete = true;
          incompleteReason = error.message;
          break;
        }
      }
  
      if (continuationCount >= MAX_CONTINUATIONS) {
        diagnostics.log('api', 'Exceeded maximum continuation attempts', { MAX_CONTINUATIONS });
        incomplete = true;
        incompleteReason = `Exceeded maximum continuation attempts (${MAX_CONTINUATIONS})`;
      }
  
      const endTime = Date.now();
      const durationSeconds = (endTime - startTime) / 1000;
  
      if (incomplete) {
        diagnostics.log('api', 'Returning incomplete response', { continuationCount, incompleteReason });
      } else {
        diagnostics.log('api', 'Complete response assembled', { continuationCount });
      }
  
      return {
        fullResponse: fullResponse,
        durationSeconds: durationSeconds,
        incomplete: incomplete,
        incompleteReason: incompleteReason
      };
    },
  
    // Simple API call without system prompt - for internal operations like summarization
    callAPISimple: async function(messages, maxRetries = 3) {
      const diagnostics = window.module['diagnostics.js'];
      const authToken = localStorage.getItem('token');
  
      const requestBody = {
        stream: false,
        model: 'Anthropic Claude 4 Sonnet',
        messages: messages,
        params: {},
        features: { web_search: false },
        session_id: 'session-' + Math.random().toString(36).substr(2, 9),
        id: 'msg-' + Date.now() + '-simple',
        background_tasks: { title_generation: false, tags_generation: false }
      };
  
      const requestBodySize = JSON.stringify(requestBody).length;
      diagnostics.log('api', 'callAPISimple', { messagesCount: messages.length, requestBodySize });
  
      const headers = { 'Content-Type': 'application/json' };
      if (authToken) headers['Authorization'] = `Bearer ${authToken}`;
  
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const response = await fetch('/api/chat/completions', {
            method: 'POST',
            headers,
            body: JSON.stringify(requestBody)
          });
  
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API request failed (${response.status}): ${errorText}`);
          }
  
          const data = await response.json();
          const responseText = data.choices[0].message.content;
          return { valid: true, text: responseText };
        } catch (error) {
          diagnostics.log('api', 'callAPISimple error', { attempt: attempt + 1, error: error.message });
          if (attempt >= maxRetries - 1) throw error;
        }
      }
    },
  
    callAPI: async function(messages, maxRetries = 3) {
      const diagnostics = window.module['diagnostics.js'];
      const authToken = localStorage.getItem('token');
      const tools = window.module['tools.js'];
      const TERMINATOR = '||||END||||';
  
      const result = this.renderMessagesForAPI(messages);
      const processedMessages = result.messages;
      const summary = result.summary;
  
      // Build system prompt
      let systemPrompt = tools.getSystemPrompt();
  
      // If summary exists, append it to system prompt
      if (summary) {
        systemPrompt += "\n\n=== Summary of Earlier Conversation ===\n\n" + summary;
        diagnostics.log('api', 'Appending summary to system prompt');
      }
  
      // Prepend system prompt to first user message (prod API doesn't support system field)
      const messagesWithSystem = [...processedMessages];
      if (messagesWithSystem.length > 0) {
        messagesWithSystem[0] = {
          ...messagesWithSystem[0],
          content: systemPrompt + "\n\n" + messagesWithSystem[0].content
        };
      }
  
      const requestBody = {
        stream: false,
        model: 'Anthropic Claude 4 Sonnet',
        messages: messagesWithSystem,
        // Note: Removed 'system' field - prod API doesn't support it
        // Note: Removed 'tools' field - prod API doesn't support native tools
        params: {},
        features: {
          web_search: false
        },
        session_id: 'session-' + Math.random().toString(36).substr(2, 9),
        id: 'msg-' + Date.now() + '-assistant',
        background_tasks: {
          title_generation: false,
          tags_generation: false
        }
      };
  
      // Log request body size
      const requestBodyString = JSON.stringify(requestBody);
      const requestBodySize = requestBodyString.length;
      const requestBodyTokens = Math.ceil(requestBodySize / 4);
  
      diagnostics.log('api', 'API REQUEST SUMMARY', {
        systemPromptLength: systemPrompt.length,
        messagesCount: messagesWithSystem.length,
        tools: 'list_directory, read_file, write_file',
        summaryIncluded: summary ? `YES (${summary.length} chars)` : 'NO',
        requestBodySize,
        requestBodyTokens
      });
      diagnostics.log('api', 'FULL REQUEST BODY', { requestBody });
  
      const headers = {
        'Content-Type': 'application/json'
      };
  
      if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
      }
  
      let lastError = null;
  
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const startTime = Date.now();
          const response = await fetch('/api/chat/completions', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
          });
  
          if (!response.ok) {
            const errorText = await response.text();
            diagnostics.handleError('API_ERROR', {
              error: new Error(`API request failed (${response.status}): ${errorText}`),
              response: { status: response.status, statusText: response.statusText },
              requestBody
            });
            throw new Error(`API request failed (${response.status}): ${errorText}`);
          }
  
          let data;
          try {
            data = await response.json();
          } catch (error) {
            const responseText = await response.text();
            diagnostics.handleError('JSON_PARSE_ERROR', {
              error,
              jsonString: responseText,
              position: error.message.match(/position (\d+)/)?.[1] || 0
            });
            throw new Error(`JSON parse error: ${error.message}`);
          }
          let responseText = data.choices[0].message.content;
          let durationSeconds = (Date.now() - startTime) / 1000;
  
          // Log response size details
          const responseDataString = JSON.stringify(data);
          const responseDataSize = responseDataString.length;
          const responseTokens = Math.ceil(responseText.length / 4);
  
          diagnostics.log('api', 'FULL API RESPONSE', { data });
          diagnostics.log('api', 'API RESPONSE SIZE', {
            responseTextLength: responseText.length,
            responseTokens,
            fullResponseDataSize: responseDataSize,
            durationSeconds: durationSeconds.toFixed(2)
          });
  
          // Check for terminator
          let wasIncomplete = false;
          let incompleteReason = null;
          if (!responseText.includes(TERMINATOR)) {
            // Handle truncation
            const result = await this.handleTruncatedResponse(responseText, headers, requestBody, startTime);
            responseText = result.fullResponse;
            durationSeconds = result.durationSeconds;
            wasIncomplete = result.incomplete;
            incompleteReason = result.incompleteReason;
          }
  
          // Remove terminator before parsing
          responseText = responseText.replace(TERMINATOR, '').trim();
  
          // Parse and validate response
          const parseResult = tools.parseResponse(responseText);
  
          if (!parseResult.valid) {
            lastError = parseResult.error;
            diagnostics.log('api', 'Invalid response', {
              attempt: attempt + 1,
              maxRetries,
              error: parseResult.error,
              responseTextPreview: responseText.substring(0, 500)
            });
  
            // If response was incomplete, include that info in the error
            let errorMessage = parseResult.error;
            if (wasIncomplete) {
              errorMessage += ` (Response was incomplete: ${incompleteReason})`;
            }
  
            // On validation errors, return immediately with error details
            // Don't retry - let the main loop provide feedback to AI
            return {
              text: responseText,
              parsed: null,
              valid: false,
              error: errorMessage,
              apiInput: processedMessages,
              apiInputFull: requestBody,
              apiOutput: data,
              durationSeconds: durationSeconds,
              incomplete: wasIncomplete,
              incompleteReason: incompleteReason
            };
          }
  
          // Return both raw text and parsed response
          return {
            text: responseText,
            parsed: parseResult.valid ? parseResult.parsed : null,
            valid: parseResult.valid,
            error: parseResult.valid ? null : parseResult.error,
            apiInput: processedMessages,  // Store input messages for debugging
            apiInputFull: requestBody,  // Store FULL request body that was actually sent
            apiOutput: data,  // Store full API response for debugging
            durationSeconds: durationSeconds
          };
        } catch (error) {
          lastError = error.message;
          diagnostics.log('api', 'API ERROR - EXCEPTION DURING API CALL', {
            attempt: `${attempt + 1}/${maxRetries}`,
            errorMessage: error.message,
            errorStack: error.stack
          });
  
          if (attempt < maxRetries - 1) {
            diagnostics.log('api', 'Retrying API call');
            continue;
          }
        }
      }
  
      // All retries failed
      throw new Error(`Failed after ${maxRetries} attempts. Last error: ${lastError}`);
    }
  };
  

  // Module: core.js
  // Core AI agent logic (UI-independent)
  // This module contains all the logic that can run without DOM/browser UI
  window.module['core.js'] = {
    // Process AI response loop (without UI calls)
    processAIResponse: async function(getMessages, addMessage, selectedDirectory, callbacks = {}) {
      const diagnostics = window.module['diagnostics.js'];
      const api = window.module['api.js'];
      const {
        onLoading = (text) => {},
        onHideLoading = () => {},
        onRenderMessages = () => {},
        onUpdateStats = () => {},
        onProcessingChange = () => {},
        onAfterTools = async () => {}  // Callback after tools execute (for compaction check)
      } = callbacks;
  
      let continueProcessing = true;
      let iteration = 0;
      let consecutiveErrors = 0;
      const MAX_RETRIES = 3;
  
      while (continueProcessing) {
        iteration++;
        diagnostics.log('context', '='.repeat(80));
        diagnostics.log('context', `[Core] ========== ITERATION ${iteration} START ==========`);
        diagnostics.log('context', '[Core] Total messages: ' + getMessages().length);
  
        // Send to API (loading indicator should already be showing)
        const response = await api.callAPI(getMessages());
  
        // Remove loading indicator
        onHideLoading();
  
        if (!response.valid) {
          // Invalid response - provide detailed feedback to AI
          diagnostics.log('context', '[Core] Invalid response: ' + response.error);
          consecutiveErrors++;
          diagnostics.log('context', `[Core] Consecutive errors: ${consecutiveErrors}/${MAX_RETRIES}`);
  
          // Only show error to user if we've exceeded retry limit
          if (consecutiveErrors >= MAX_RETRIES) {
            diagnostics.log('context', '[Core] Max retries exceeded, showing error to user');
            addMessage({
              role: 'assistant',
              content: `Error: Invalid response after ${MAX_RETRIES} attempts - ${response.error}`
            });
            onRenderMessages();
            onProcessingChange(false);
            return { success: false, error: response.error, iterations: iteration };
          }
  
          // Send error feedback to AI
          let errorFeedback = `ERROR: Your response was invalid. Error: "${response.error}"\n\n`;
          errorFeedback += `Your response was:\n${response.text.substring(0, 300)}${response.text.length > 300 ? '...' : ''}\n\n`;
          errorFeedback += `Please provide a valid JSON response.`;
  
          addMessage({
            role: 'user',
            content: errorFeedback,
            fromSystem: true
          });
  
          onLoading();
          continue;
        }
  
        // Reset error counter on successful response
        consecutiveErrors = 0;
  
        const parsedResponse = response.parsed;
  
        // If text was extracted from before/after the JSON, show it as an assistant message
        if (response.extractedText) {
          if (response.extractedText.prefix) {
            diagnostics.log('json', '[Core] Showing extracted prefix text as assistant message');
            addMessage({
              role: 'assistant',
              content: response.extractedText.prefix
            });
            onRenderMessages();
          }
        }
  
        if (parsedResponse.type === 'message') {
          // Final message response
          diagnostics.log('context', '[Core] ========== MESSAGE RESPONSE ==========');
  
          addMessage({
            role: 'assistant',
            content: parsedResponse.content,
            apiData: {
              input: response.apiInput,
              inputFull: response.apiInputFull,
              output: response.apiOutput,
              rawResponse: response.text
            },
            durationSeconds: response.durationSeconds
          });
          onRenderMessages();
          onUpdateStats();
  
          // If there's suffix text (text after JSON), show it as assistant message
          if (response.extractedText && response.extractedText.suffix) {
            diagnostics.log('json', '[Core] Showing extracted suffix text as assistant message');
            addMessage({
              role: 'assistant',
              content: response.extractedText.suffix
            });
            onRenderMessages();
          }
  
          continueProcessing = false;
        } else if (parsedResponse.type === 'execute') {
          diagnostics.log('tools', '[Core] ========== EXECUTE RESPONSE ==========');
          diagnostics.log('tools', '[Core] AI requested ' + parsedResponse.tool_uses.length + ' tool(s)');
  
          // Add assistant message with API data
          addMessage({
            role: 'assistant',
            content: response.text,
            apiData: {
              input: response.apiInput,
              inputFull: response.apiInputFull,
              output: response.apiOutput,
              rawResponse: response.text
            },
            durationSeconds: response.durationSeconds
          });
          onRenderMessages();
          onUpdateStats();
  
          // Show loading before executing tools
          onLoading('Running');
  
          // Execute all tools
          await this.executeTools(parsedResponse.tool_uses, selectedDirectory, addMessage, onRenderMessages);
  
          // If there's suffix text (text after JSON), show it as assistant message
          if (response.extractedText && response.extractedText.suffix) {
            diagnostics.log('json', '[Core] Showing extracted suffix text as assistant message');
            addMessage({
              role: 'assistant',
              content: response.extractedText.suffix
            });
            onRenderMessages();
          }
  
          // Check if compaction is needed after tools added results
          await onAfterTools();
  
          // Loading indicator will remain on for next API call
          continue;
        }
      }
  
      diagnostics.log('context', '[Core] Processing complete after ' + iteration + ' iterations');
      return { success: true, iterations: iteration };
    },
  
    // Truncate tool output if it exceeds size limit
    truncateToolOutput: function(content, toolName, maxTokens = 100) {
      const diagnostics = window.module['diagnostics.js'];
      const state = window.module['state.js'];
      const limit = state.getContextLimit();
      const maxChars = maxTokens * 4; // 4 chars per token estimate
  
      if (content.length <= maxChars) {
        return content;
      }
  
      const truncated = content.substring(0, maxChars);
      const remaining = content.length - maxChars;
      const remainingTokens = Math.ceil(remaining / 4);
  
      diagnostics.handleError('TOOL_OUTPUT_TOO_LARGE', {
        toolName,
        originalSize: content.length,
        truncatedSize: truncated.length,
        limit: maxChars
      });
  
      return truncated + `\n\n[Truncated: ${remainingTokens} more tokens omitted. Use more specific search parameters.]`;
    },
  
    // Execute tools (unified handler for all tools) - UI-independent
    executeTools: async function(toolUses, selectedDirectory, addMessage, onRenderMessages = () => {}) {
      for (const toolUse of toolUses) {
        if (toolUse.name === 'list_directory') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'list_directory',
            params: toolUse.input,
            content: `list_directory ${JSON.stringify(toolUse.input)}`
          });
  
          const startTime = performance.now();
          const result = await this.executeListDirectory(toolUse.input.path, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            // Count entries
            const lines = result.output.split('\n');
            const dirCount = lines.filter(l => l.includes('ðŸ“')).length;
            const fileCount = lines.filter(l => l.includes('ðŸ“„')).length;
            const total = dirCount + fileCount;
  
            addMessage({
              role: 'tool-result',
              toolName: 'list_directory',
              summary: `Listed ${total} items (${dirCount} folders, ${fileCount} files)`,
              fullResult: result.output,
              content: `Tool result for list_directory("${toolUse.input.path}"):\n\n${result.output}`,
              durationMs
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'list_directory',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Tool error for list_directory("${toolUse.input.path}"): ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'read_file') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'read_file',
            params: toolUse.input,
            content: `read_file ${JSON.stringify(toolUse.input)}`
          });
  
          const startTime = performance.now();
          const result = await this.executeReadFile(toolUse.input.path, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            const allLines = result.content.split('\n');
            const totalLines = allLines.length;
  
            // Apply offset/limit if provided
            const offset = toolUse.input.offset || 1;
            const limit = toolUse.input.limit || totalLines;
            const startLine = Math.max(1, offset) - 1; // Convert to 0-based
            const endLine = Math.min(startLine + limit, totalLines);
            const selectedLines = allLines.slice(startLine, endLine);
            const selectedContent = selectedLines.join('\n');
  
            // Add line numbers
            const numberedContent = selectedLines.map((line, i) => `${startLine + i + 1}: ${line}`).join('\n');
  
            const truncatedContent = this.truncateToolOutput(numberedContent, 'read_file');
            const wasTruncated = truncatedContent.length < numberedContent.length;
  
            // Calculate how many lines were actually shown
            const linesShown = truncatedContent.split('\n').length;
            const remainingLines = totalLines - (startLine + linesShown);
            const nextOffset = startLine + linesShown + 1;
  
            // Build truncation info
            let truncationNote = '';
            if (wasTruncated || remainingLines > 0) {
              truncationNote = `\n\n[Showing lines ${offset}-${startLine + linesShown} of ${totalLines}. ${remainingLines} more lines. Use offset:${nextOffset} to continue.]`;
            }
  
            addMessage({
              role: 'tool-result',
              toolName: 'read_file',
              summary: `Read lines ${offset}-${startLine + linesShown} of ${totalLines} from ${result.path}${wasTruncated ? ' (truncated)' : ''}`,
              fullResult: result.content,
              content: `File: ${result.path} (${totalLines} lines total)\n\n${truncatedContent}${truncationNote}`,
              truncated: wasTruncated,
              durationMs
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'read_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error reading file ${result.path}: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'write_file') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'write_file',
            params: toolUse.input,
            content: `write_file ${JSON.stringify({ path: toolUse.input.path, content: `(${toolUse.input.content.length} chars)` })}`
          });
  
          const startTime = performance.now();
          const result = await this.executeWriteFile(toolUse.input.path, toolUse.input.content, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            addMessage({
              role: 'tool-result',
              toolName: 'write_file',
              summary: `Wrote ${toolUse.input.content.length} characters to ${result.path}`,
              fullResult: `Successfully wrote to ${result.path}`,
              content: `Successfully wrote ${toolUse.input.content.length} characters to ${result.path}`,
              durationMs
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'write_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error writing file ${result.path}: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'search_by_filename') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'search_by_filename',
            params: toolUse.input,
            content: `search_by_filename ${JSON.stringify(toolUse.input)}`
          });
  
          const startTime = performance.now();
          const searchPath = toolUse.input.path || '.';
          const result = await this.executeSearchByFilename(toolUse.input.pattern, searchPath, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
  
            addMessage({
              role: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Found ${matchCount} file(s) matching "${toolUse.input.pattern}"${timeoutWarning}`,
              fullResult: result.output,
              content: `Search results for pattern "${toolUse.input.pattern}" in "${searchPath}":\n\n${result.output}`,
              durationMs
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching for files: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'search_by_content') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'search_by_content',
            params: toolUse.input,
            content: `search_by_content ${JSON.stringify(toolUse.input)}`
          });
  
          const startTime = performance.now();
          const searchPath = toolUse.input.path || '.';
          const filePattern = toolUse.input.filePattern || null;
          const result = await this.executeSearchByContent(toolUse.input.text, searchPath, filePattern, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
  
            addMessage({
              role: 'tool-result',
              toolName: 'search_by_content',
              summary: `Found ${matchCount} match(es) for "${toolUse.input.text}"${timeoutWarning}`,
              fullResult: result.output,
              content: `Search results for text "${toolUse.input.text}" in "${searchPath}":\n\n${result.output}`,
              durationMs
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'search_by_content',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching file contents: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'edit_file') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'edit_file',
            params: toolUse.input,
            content: `edit_file ${JSON.stringify({ path: toolUse.input.path, find: `(${toolUse.input.find.length} chars)`, replace: `(${toolUse.input.replace.length} chars)` })}`
          });
  
          const startTime = performance.now();
          const result = await this.executeEditFile(toolUse.input.path, toolUse.input.find, toolUse.input.replace, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            addMessage({
              role: 'tool-result',
              toolName: 'edit_file',
              summary: `Edited ${result.path}: replaced ${toolUse.input.find.length} chars with ${toolUse.input.replace.length} chars`,
              fullResult: `Successfully edited ${result.path}`,
              content: `Successfully edited ${result.path}`,
              durationMs
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'edit_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error editing file ${toolUse.input.path}: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'edit_file_batch') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'edit_file_batch',
            params: toolUse.input,
            content: `edit_file_batch ${JSON.stringify({ path: toolUse.input.path, edits: `(${toolUse.input.edits.length} edits)` })}`
          });
  
          const startTime = performance.now();
          const result = await this.executeEditFileBatch(toolUse.input.path, toolUse.input.edits, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            addMessage({
              role: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Batch edited ${result.path}: applied ${toolUse.input.edits.length} edit(s)`,
              fullResult: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`,
              content: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`,
              durationMs
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error batch editing file ${toolUse.input.path}: ${result.error}`,
              durationMs
            });
          }
        } else {
          // Unknown tool
          addMessage({
            role: 'user',
            content: `ERROR: Unknown tool "${toolUse.name}". Available tools are: list_directory, read_file, write_file, search_by_filename, search_by_content, edit_file, edit_file_batch.`,
            fromSystem: true
          });
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Core] Unknown tool: ${toolUse.name}`);
        }
      }
  
      onRenderMessages();
    },
  
    // Execute file operations using FileSystem API
    executeListDirectory: async function(path, dirHandle) {
      try {
        let targetHandle = dirHandle;
  
        // Navigate to the target path if not root
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // List directory contents
        const entries = [];
        for await (const entry of targetHandle.values()) {
          entries.push({
            name: entry.name,
            kind: entry.kind
          });
        }
  
        // Format output
        let output = `Contents of "${path || '.'}":\n\n`;
        const dirs = entries.filter(e => e.kind === 'directory').sort((a, b) => a.name.localeCompare(b.name));
        const files = entries.filter(e => e.kind === 'file').sort((a, b) => a.name.localeCompare(b.name));
  
        if (dirs.length > 0) {
          output += 'Directories:\n';
          dirs.forEach(d => {
            output += `  ðŸ“ ${d.name}/\n`;
          });
        }
  
        if (files.length > 0) {
          output += '\nFiles:\n';
          files.forEach(f => {
            output += `  ðŸ“„ ${f.name}\n`;
          });
        }
  
        if (entries.length === 0) {
          output += '(empty directory)\n';
        }
  
        return { success: true, output };
      } catch (error) {
        return { success: false, error: error.message };
      }
    },
  
    executeReadFile: async function(path, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory
        for (let i = 0; i < pathParts.length - 1; i++) {
          currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
        }
  
        // Get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName);
        const file = await fileHandle.getFile();
        const content = await file.text();
  
        return { success: true, content, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeWriteFile: async function(path, content, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory (create if doesn't exist)
        for (let i = 0; i < pathParts.length - 1; i++) {
          try {
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
          } catch {
            // Directory doesn't exist, create it
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i], { create: true });
          }
        }
  
        // Create or get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
  
        // Write content
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        return { success: true, path };
      } catch (error) {
        // Check if it's a user activation error
        if (error.message && error.message.includes('User activation is required')) {
          return {
            success: false,
            error: `Cannot create new directories due to browser security. Please manually create the parent directory first, then try again.`,
            path
          };
        }
        return { success: false, error: error.message, path };
      }
    },
  
    // Helper function to match wildcard pattern
    matchesPattern: function(filename, pattern) {
      // Convert wildcard pattern to regex
      // * matches any characters, ? matches single character
      const regexPattern = pattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&')  // Escape special regex chars
        .replace(/\*/g, '.*')  // * becomes .*
        .replace(/\?/g, '.');  // ? becomes .
  
      const regex = new RegExp(`^${regexPattern}$`, 'i');  // Case-insensitive
      return regex.test(filename);
    },
  
    // Recursively search for files by filename pattern
    executeSearchByFilename: async function(pattern, path, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if filename matches pattern
              if (window.module['core.js'].matchesPattern(entry.name, pattern)) {
                matches.push(entryPath);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Search] Error accessing ${currentPath}: ${error.message}`);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No files found matching the pattern.';
        } else {
          output = matches.map(m => `ðŸ“„ ${m}`).join('\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Recursively search for text within file contents
    executeSearchByContent: async function(searchText, path, filePattern, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if file matches filePattern (if provided)
              if (filePattern && !window.module['core.js'].matchesPattern(entry.name, filePattern)) {
                continue;
              }
  
              try {
                // Read file and search for text
                const file = await entry.getFile();
                const content = await file.text();
  
                if (content.toLowerCase().includes(searchText.toLowerCase())) {
                  // Find line numbers where text appears
                  const lines = content.split('\n');
                  const matchingLines = [];
  
                  for (let i = 0; i < lines.length; i++) {
                    if (lines[i].toLowerCase().includes(searchText.toLowerCase())) {
                      matchingLines.push({
                        lineNum: i + 1,
                        line: lines[i].trim()
                      });
                    }
                  }
  
                  matches.push({
                    path: entryPath,
                    lineMatches: matchingLines
                  });
                }
              } catch (error) {
                // Skip binary files or files that can't be read as text
                const diagnostics = window.module['diagnostics.js'];
                diagnostics.log('tools', `[Search] Could not read ${entryPath}: ${error.message}`);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Search] Error accessing ${currentPath}: ${error.message}`);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No matches found.';
        } else {
          output = matches.map(match => {
            const header = `ðŸ“„ ${match.path}`;
            const lineInfo = match.lineMatches.slice(0, 5).map(lm =>
              `  Line ${lm.lineNum}: ${lm.line.substring(0, 100)}${lm.line.length > 100 ? '...' : ''}`
            ).join('\n');
            const moreLines = match.lineMatches.length > 5 ? `  ... and ${match.lineMatches.length - 5} more matches` : '';
  
            return `${header}\n${lineInfo}${moreLines ? '\n' + moreLines : ''}`;
          }).join('\n\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or using a file pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    executeEditFile: async function(path, findStr, replaceStr, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.role === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].role === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        const content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file.`,
            path
          };
        }
  
        // 4. Check that find string appears exactly once
        const occurrences = content.split(findStr).length - 1;
        if (occurrences === 0) {
          return {
            success: false,
            error: `Find string not found in file. The file may have changed since you last read it.`,
            path
          };
        } else if (occurrences > 1) {
          return {
            success: false,
            error: `Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
            path
          };
        }
  
        // 5. Perform replacement
        const newContent = content.replace(findStr, replaceStr);
  
        // 6. Write back
        const writeResult = await this.executeWriteFile(path, newContent, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFileBatch: async function(path, edits, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.role === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].role === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        let content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file_batch.`,
            path
          };
        }
  
        // 4. Apply each edit in sequence
        for (let i = 0; i < edits.length; i++) {
          const { find, replace } = edits[i];
  
          // Check that find string appears exactly once in current content
          const occurrences = content.split(find).length - 1;
          if (occurrences === 0) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string not found in file. The file may have changed or earlier edits affected this replacement.`,
              path
            };
          } else if (occurrences > 1) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
              path
            };
          }
  
          // Perform replacement
          content = content.replace(find, replace);
        }
  
        // 5. Write back
        const writeResult = await this.executeWriteFile(path, content, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    }
  };
  

  // Module: diagnostics.js
  // Diagnostic and Error Handling System
  // Stores logs in memory and provides structured error reporting
  
  (function() {
    'use strict';
  
    // Log storage
    const logs = [];
    const MAX_LOGS = 1000;
  
    // Logging function (replaces console.log for internal use)
    function log(category, message, data = null) {
      const entry = {
        timestamp: Date.now(),
        category,
        message,
        data
      };
      logs.push(entry);
  
      // Keep only last MAX_LOGS entries
      if (logs.length > MAX_LOGS) {
        logs.shift();
      }
    }
  
    // Get recent logs
    function getLogs(category = null, count = 100) {
      let filtered = category ? logs.filter(l => l.category === category) : logs;
      return filtered.slice(-count);
    }
  
    // Clear logs
    function clearLogs() {
      logs.length = 0;
    }
  
    // Error analyzers - each analyzes a specific error type
    const errorAnalyzers = {
      'JSON_PARSE_ERROR': function(context) {
        const { error, jsonString, position } = context;
        const logs = getLogs('json', 50);
  
        // Extract key metrics
        const stringLength = jsonString ? jsonString.length : 0;
        const preview = jsonString ? jsonString.substring(Math.max(0, position - 50), position + 50) : '';
        const charAtPosition = jsonString ? jsonString[position] : '';
  
        // Check for common issues
        const hasTrailingComma = jsonString && /,\s*[}\]]/.test(jsonString);
        const hasUnescapedQuotes = jsonString && /[^\\]"[^,:}\]\s]/.test(jsonString);
        const hasMissingQuotes = jsonString && /{\s*\w+:/.test(jsonString);
        const hasTextBeforeJSON = jsonString && jsonString.trim()[0] !== '{';
        const hasTextAfterJSON = jsonString && jsonString.trim().slice(-1) !== '}';
        const firstBrace = jsonString ? jsonString.indexOf('{') : -1;
        const lastBrace = jsonString ? jsonString.lastIndexOf('}') : -1;
  
        // Theory-based analysis
        const theories = [];
        if (hasTextBeforeJSON || hasTextAfterJSON) {
          theories.push('AI added commentary text before/after JSON - extraction should handle this');
        }
        if (hasTrailingComma) {
          theories.push('Trailing comma in JSON object/array - invalid JSON syntax');
        }
        if (hasUnescapedQuotes) {
          theories.push('Unescaped quotes in string values - needs backslash escaping');
        }
        if (hasMissingQuotes) {
          theories.push('Missing quotes around object keys - invalid JSON syntax');
        }
        if (stringLength > 100000) {
          theories.push('Response over 100KB - may be truncated by API or network');
        }
        if (firstBrace === -1 || lastBrace === -1) {
          theories.push('No JSON braces found - response may be plain text error message');
        }
        if (firstBrace > 100) {
          theories.push(`JSON starts at position ${firstBrace} - likely has ${firstBrace} chars of text before it`);
        }
  
        return {
          code: 'JSON_PARSE_ERROR',
          position,
          stringLength,
          preview: `...${preview}...`,
          charAtPosition: charAtPosition ? `'${charAtPosition}' (code: ${charAtPosition.charCodeAt(0)})` : 'N/A',
          jsonBounds: `{ at ${firstBrace}, } at ${lastBrace}`,
          theories: theories.length > 0 ? theories : ['Unknown cause - check error message and preview'],
          errorMessage: error.message
        };
      },
  
      'API_ERROR': function(context) {
        const { error, response, requestBody } = context;
        const logs = getLogs('api', 50);
  
        const requestSize = requestBody ? JSON.stringify(requestBody).length : 0;
        const responseSize = response ? JSON.stringify(response).length : 0;
        const status = response?.status || 'unknown';
  
        // Check for size issues
        const requestTokens = Math.ceil(requestSize / 4);
        const isRequestTooLarge = requestTokens > 30000;
  
        // Count recent API calls
        const recentApiCalls = logs.filter(l =>
          l.message.includes('callAPI') || l.message.includes('API')
        ).length;
  
        // Theory-based analysis
        const theories = [];
        if (status === 401 || status === 403) {
          theories.push('Authentication failed - check API key is valid and not expired');
        }
        if (status === 429) {
          theories.push('Rate limit exceeded - too many requests to API');
          theories.push(`Recent API calls: ${recentApiCalls} in last 50 log entries`);
        }
        if (status === 500 || status === 502 || status === 503) {
          theories.push('Server error - API provider may be experiencing issues');
        }
        if (status === 400) {
          theories.push('Bad request - request format may be invalid');
          if (isRequestTooLarge) {
            theories.push(`Request is ${requestTokens} tokens - may exceed API limits`);
          }
        }
        if (isRequestTooLarge) {
          theories.push(`Request size (${requestTokens} tokens) exceeds typical limits - context compaction needed`);
        }
        if (status === 'unknown') {
          theories.push('Network error - check internet connection or API endpoint availability');
        }
        if (error.message.includes('fetch')) {
          theories.push('Fetch failed - possible CORS issue or network problem');
        }
  
        return {
          code: 'API_ERROR',
          status,
          requestSize,
          requestTokens,
          responseSize,
          recentApiCalls,
          theories: theories.length > 0 ? theories : ['Unknown API error - check error message'],
          errorMessage: error.message || 'Unknown API error',
          responsePreview: response ? JSON.stringify(response).substring(0, 200) : 'No response'
        };
      },
  
      'CONTEXT_LIMIT_EXCEEDED': function(context) {
        const { currentTokens, limit, messageCount } = context;
        const logs = getLogs('context', 50);
  
        const exceededBy = currentTokens - limit;
        const percentOver = Math.round((exceededBy / limit) * 100);
  
        // Check compaction history
        const compactionLogs = logs.filter(l => l.message.includes('compact'));
        const lastCompactionTime = compactionLogs.length > 0 ?
          Date.now() - compactionLogs[compactionLogs.length - 1].timestamp : null;
  
        // Check for truncations
        const truncationLogs = logs.filter(l => l.message.includes('truncat'));
  
        // Theory-based analysis
        const theories = [];
        if (percentOver < 10) {
          theories.push('Slightly over limit - normal, compaction should resolve');
        } else if (percentOver > 50) {
          theories.push('Significantly over limit - may indicate large tool outputs or insufficient compaction');
        }
  
        if (compactionLogs.length === 0) {
          theories.push('No compactions yet - this is the first time limit exceeded');
        } else if (compactionLogs.length > 5) {
          theories.push(`Frequent compactions (${compactionLogs.length}) - conversation may be too long or summaries ineffective`);
        }
  
        if (lastCompactionTime && lastCompactionTime < 10000) {
          theories.push('Compacted very recently - limit exceeded again quickly, may need more aggressive compaction');
        }
  
        if (truncationLogs.length > 0) {
          theories.push(`${truncationLogs.length} truncations detected - large tool outputs contributing to size`);
        }
  
        if (messageCount > 100) {
          theories.push(`High message count (${messageCount}) - long conversation needs compaction`);
        }
  
        const tokensPerMessage = Math.round(currentTokens / messageCount);
        if (tokensPerMessage > 500) {
          theories.push(`Large average message size (${tokensPerMessage} tokens/msg) - suggests large tool outputs or verbose responses`);
        }
  
        return {
          code: 'CONTEXT_LIMIT_EXCEEDED',
          currentTokens,
          limit,
          exceededBy,
          percentOver,
          messageCount,
          tokensPerMessage,
          lastCompactionAgo: lastCompactionTime ? `${Math.round(lastCompactionTime / 1000)}s ago` : 'never',
          compactionCount: compactionLogs.length,
          theories: theories.length > 0 ? theories : ['Context limit exceeded - compaction will run']
        };
      },
  
      'COMPACTION_FAILED': function(context) {
        const { error, tokensBefore, tokensAfter, messagesBefore, messagesAfter } = context;
        const logs = getLogs('compaction', 50);
  
        const tokensReduced = tokensBefore - tokensAfter;
        const messagesRemoved = messagesBefore - messagesAfter;
        const percentReduced = tokensBefore > 0 ? Math.round((tokensReduced / tokensBefore) * 100) : 0;
  
        // Check API logs for summarization issues
        const apiLogs = getLogs('api', 50);
        const recentApiErrors = apiLogs.filter(l =>
          l.message.includes('ERROR') || l.message.includes('error')
        ).length;
  
        // Theory-based analysis
        const theories = [];
  
        if (!error) {
          theories.push('No error object provided - compaction may not have actually failed');
        } else if (error.message.includes('API') || error.message.includes('fetch')) {
          theories.push('API call failed during summarization - check network or API status');
          if (recentApiErrors > 0) {
            theories.push(`${recentApiErrors} recent API errors detected - API may be unstable`);
          }
        } else if (error.message.includes('JSON')) {
          theories.push('JSON parse error - summary response may be malformed');
        }
  
        if (tokensReduced > 0 && percentReduced < 30) {
          theories.push(`Low reduction (${percentReduced}%) - summary may be too verbose or conversation already compact`);
        } else if (tokensReduced <= 0) {
          theories.push('No token reduction achieved - compaction failed to create effective summary');
        } else if (percentReduced > 30) {
          theories.push(`Good reduction (${percentReduced}%) achieved despite failure flag`);
        }
  
        if (messagesRemoved === 0) {
          theories.push('No messages removed - compaction logic may not have executed');
        }
  
        const compactionAttempts = logs.filter(l =>
          l.message.includes('compact') || l.message.includes('Compacting')
        ).length;
        if (compactionAttempts > 3) {
          theories.push(`Multiple compaction attempts (${compactionAttempts}) - may be stuck in retry loop`);
        }
  
        return {
          code: 'COMPACTION_FAILED',
          tokensBefore,
          tokensAfter,
          tokensReduced,
          percentReduced,
          messagesBefore,
          messagesAfter,
          messagesRemoved,
          compactionAttempts,
          theories: theories.length > 0 ? theories : ['Compaction failed - check error message'],
          errorMessage: error ? error.message : 'Unknown error'
        };
      },
  
      'TOOL_OUTPUT_TOO_LARGE': function(context) {
        const { toolName, originalSize, truncatedSize, limit } = context;
  
        const originalTokens = Math.ceil(originalSize / 4);
        const truncatedTokens = Math.ceil(truncatedSize / 4);
        const limitTokens = Math.ceil(limit / 4);
        const exceededBy = originalSize - limit;
        const percentReduced = Math.round(((originalSize - truncatedSize) / originalSize) * 100);
  
        // Get recent tool usage
        const logs = getLogs('tools', 50);
        const toolUsageCounts = {};
        logs.forEach(l => {
          if (l.message.includes('tool') || l.message.includes('Tool')) {
            const match = l.message.match(/\b(read_file|search_by_content|search_by_filename|list_directory)\b/);
            if (match) {
              toolUsageCounts[match[1]] = (toolUsageCounts[match[1]] || 0) + 1;
            }
          }
        });
  
        // Theory-based analysis
        const theories = [];
  
        if (toolName === 'read_file') {
          theories.push('File too large - AI should read specific sections or search for specific content instead');
          if (originalTokens > 5000) {
            theories.push(`Very large file (${originalTokens} tokens) - likely a log file, data file, or minified code`);
          }
          theories.push('Suggest: Use search_by_content to find specific sections, or ask user which part to focus on');
        } else if (toolName === 'search_by_content') {
          theories.push('Search returned too many results - need more specific search term or narrower file pattern');
          const resultCount = Math.floor(originalSize / 100); // Rough estimate
          theories.push(`Estimated ${resultCount}+ matches found - use more specific search or limit to specific directory`);
        } else if (toolName === 'search_by_filename') {
          theories.push('Filename search returned too many files - use more specific pattern or search in subdirectory');
        } else if (toolName === 'list_directory') {
          theories.push('Directory has too many files - should list specific subdirectories instead');
        }
  
        if (percentReduced > 80) {
          theories.push(`Severe truncation (${percentReduced}%) - most of output lost, AI needs different approach`);
        }
  
        const truncationCount = logs.filter(l => l.message.includes('truncat')).length;
        if (truncationCount > 3) {
          theories.push(`Frequent truncations (${truncationCount}) - AI strategy needs adjustment to use more targeted queries`);
        }
  
        return {
          code: 'TOOL_OUTPUT_TOO_LARGE',
          toolName,
          originalSize,
          originalTokens,
          truncatedSize,
          truncatedTokens,
          limit,
          limitTokens,
          exceededBy,
          percentReduced,
          recentToolUsage: toolUsageCounts,
          theories: theories.length > 0 ? theories : ['Output too large - truncated']
        };
      }
    };
  
    // Handle an error - calls appropriate analyzer and outputs to console
    function handleError(errorCode, context = {}) {
      const analyzer = errorAnalyzers[errorCode];
  
      if (!analyzer) {
        console.error(`ERROR: ${errorCode} (no analyzer found)`);
        return;
      }
  
      const analysis = analyzer(context);
  
      // Output ONLY the error code and key data points to console
      console.error(`\n========== ERROR: ${analysis.code} ==========`);
      delete analysis.code; // Already printed above
  
      for (const [key, value] of Object.entries(analysis)) {
        if (key === 'theories' && Array.isArray(value)) {
          console.error(`\n${key}:`);
          value.forEach((theory, idx) => {
            console.error(`  ${idx + 1}. ${theory}`);
          });
        } else if (typeof value === 'object' && !Array.isArray(value)) {
          console.error(`${key}:`);
          for (const [subKey, subValue] of Object.entries(value)) {
            console.error(`  ${subKey}: ${subValue}`);
          }
        } else {
          console.error(`${key}: ${value}`);
        }
      }
      console.error('==========================================\n');
    }
  
    // Export module
    window.module = window.module || {};
    window.module['diagnostics.js'] = {
      log,
      getLogs,
      clearLogs,
      handleError,
      // Expose for testing/debugging
      _errorAnalyzers: errorAnalyzers,
      _logs: logs
    };
  })();
  

  // Module: main.js
  // Main entry point for the app
  window.module['main.js'] = {
    version: '2.0.0',
  
    run: async function() {
      const diagnostics = window.module['diagnostics.js'];
      diagnostics.log('ui', '[AI Agent] Version: ' + this.version);
  
      // Get module references
      const state = window.module['state.js'];
      const styles = window.module['styles.js'];
      const ui = window.module['ui.js'];
      const api = window.module['api.js'];
  
      // Clear existing page content
      document.body.innerHTML = '';
  
      // Add styles
      styles.injectStyles();
  
      // Show directory selection screen
      ui.showDirectorySelection(() => this.selectDirectory());
    },
  
    selectDirectory: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      try {
        if (!window.showDirectoryPicker) {
          alert('Your browser does not support the File System Access API. Please use Chrome, Edge, or another compatible browser.');
          return;
        }
  
        const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
        state.setSelectedDirectory(dirHandle);
        this.showChatScreen();
      } catch (error) {
        const diagnostics = window.module['diagnostics.js'];
        if (error.name === 'AbortError') {
          // User cancelled the picker
          diagnostics.log('ui', 'Directory selection cancelled');
        } else {
          diagnostics.log('ui', 'Error selecting directory: ' + error);
          alert('Error selecting directory: ' + error.message);
        }
      }
    },
  
    showChatScreen: function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      const selectedDirectory = state.getState().selectedDirectory;
      ui.showChatScreen(selectedDirectory, () => this.sendMessage());
  
      // Render initial messages (including greeting)
      ui.renderMessages(state.getMessages());
  
      // Keepalive disabled for testing
      // this.startKeepalive();
    },
  
    startKeepalive: function() {
      const diagnostics = window.module['diagnostics.js'];
      const KEEPALIVE_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds
  
      // Clear any existing keepalive interval
      if (this.keepaliveInterval) {
        clearInterval(this.keepaliveInterval);
      }
  
      diagnostics.log('ui', '[Main] Starting keepalive interval (every 5 minutes)');
  
      this.keepaliveInterval = setInterval(async () => {
        const state = window.module['state.js'];
        const ui = window.module['ui.js'];
  
        // Only send keepalive if not currently processing
        if (state.isProcessing()) {
          diagnostics.log('ui', '[Main] Skipping keepalive - already processing');
          return;
        }
  
        diagnostics.log('ui', '[Main] Sending keepalive ping');
  
        // Call API directly with minimal payload - no system prompt, no context
        const api = window.module['api.js'];
        try {
          await api.callAPI([{ role: 'user', content: "reply 'K'" }]);
          diagnostics.log('ui', '[Main] Keepalive ping successful');
        } catch (error) {
          diagnostics.log('ui', '[Main] Keepalive error: ' + error.message);
        }
      }, KEEPALIVE_INTERVAL);
    },
  
    sendMessage: async function() {
      const diagnostics = window.module['diagnostics.js'];
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
      const api = window.module['api.js'];
      const tools = window.module['tools.js'];
  
      const message = ui.getInputValue();
  
      if (!message || state.isProcessing()) {
        return;
      }
  
      // Check if adding this message would exceed context limit
      if (state.wouldExceedLimit(message)) {
        diagnostics.log('compaction', '[Main] Message would exceed limit, compacting context first');
        await this.compactContext();
        ui.renderMessages(state.getMessages());
        ui.updateContextStats();
      }
  
      // Add user message
      state.addMessage({
        role: 'user',
        content: message
      });
  
      // Clear input and reset height
      ui.clearInput();
  
      // Render messages
      ui.renderMessages(state.getMessages());
  
      // Update context stats
      ui.updateContextStats();
  
      // Set processing state
      state.setProcessing(true);
      ui.setInputDisabled(true);
  
      // Show loading indicator
      ui.showLoading();
  
      try {
        await this.processAIResponse();
      } catch (error) {
        ui.hideLoading();
        state.addMessage({
          role: 'assistant',
          content: 'Error: ' + error.message
        });
        ui.renderMessages(state.getMessages());
        ui.updateContextStats();
      } finally {
        state.setProcessing(false);
        ui.setInputDisabled(false);
      }
    },
  
    processAIResponse: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
      const core = window.module['core.js'];
      const diagnostics = window.module['diagnostics.js'];
  
      const selectedDirectory = state.getState().selectedDirectory;
  
      // Check if context exceeds limit BEFORE calling API
      const currentTokens = state.calculateTokens();
      const limit = state.getContextLimit();
      if (currentTokens > limit) {
        diagnostics.log('context', `[Main] Context exceeds limit before API call (${currentTokens} > ${limit}), compacting...`);
        diagnostics.handleError('CONTEXT_LIMIT_EXCEEDED', {
          currentTokens: currentTokens,
          limit: limit,
          messageCount: state.getMessages().length
        });
        await this.compactContext();
        ui.renderMessages(state.getMessages());
        ui.updateContextStats();
      }
  
      // Use core.js for UI-independent processing
      await core.processAIResponse(
        () => state.getMessages(),
        (msg) => state.addMessage(msg),
        selectedDirectory,
        {
          onLoading: (text) => ui.showLoading(text),
          onHideLoading: () => ui.hideLoading(),
          onRenderMessages: () => ui.renderMessages(state.getMessages()),
          onUpdateStats: () => ui.updateContextStats(),
          onProcessingChange: (processing) => state.setProcessing(processing),
          onAfterTools: async () => {
            // Check if context exceeds limit after tool results
            const diagnostics = window.module['diagnostics.js'];
            const currentTokens = state.calculateTokens();
            const limit = state.getContextLimit();
            if (currentTokens > limit) {
              diagnostics.log('context', `[Main] Context exceeds limit after tools (${currentTokens} > ${limit}), compacting...`);
              diagnostics.handleError('CONTEXT_LIMIT_EXCEEDED', {
                currentTokens: currentTokens,
                limit: limit,
                messageCount: state.getMessages().length
              });
              await this.compactContext();
              ui.renderMessages(state.getMessages());
              ui.updateContextStats();
            }
          }
        }
      );
    },
  
    // Truncate tool output if it exceeds size limit (1/8 of context limit = 2500 tokens default)
    truncateToolOutput: function(content, toolName) {
      const diagnostics = window.module['diagnostics.js'];
      const state = window.module['state.js'];
      const limit = state.getContextLimit();
      const maxTokens = Math.floor(limit / 8); // 1/8 of limit
      const maxChars = maxTokens * 4; // 4 chars per token estimate
  
      if (content.length <= maxChars) {
        return { content, wasTruncated: false };
      }
  
      const truncated = content.substring(0, maxChars);
      const remaining = content.length - maxChars;
      const remainingTokens = Math.ceil(remaining / 4);
  
      diagnostics.handleError('TOOL_OUTPUT_TOO_LARGE', {
        toolName,
        originalSize: content.length,
        truncatedSize: truncated.length,
        limit: maxChars
      });
  
      return {
        content: truncated + `\n\n[... Output truncated. ${remainingTokens} more tokens (${remaining} chars) omitted. If you need the full output, run ${toolName} again with more specific parameters to reduce output size.]`,
        wasTruncated: true
      };
    },
  
    // Execute tools (unified handler for all tools)
    executeTools: async function(toolUses, selectedDirectory) {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      for (const toolUse of toolUses) {
        if (toolUse.name === 'list_directory') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'list_directory',
            params: toolUse.input,
            content: `list_directory ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeListDirectory(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            // Count entries
            const lines = result.output.split('\n');
            const dirCount = lines.filter(l => l.includes('ðŸ“')).length;
            const fileCount = lines.filter(l => l.includes('ðŸ“„')).length;
            const total = dirCount + fileCount;
  
            state.addMessage({
              role: 'tool-result',
              toolName: 'list_directory',
              summary: `Listed ${total} items (${dirCount} folders, ${fileCount} files)`,
              fullResult: result.output,
              content: `Tool result for list_directory("${toolUse.input.path}"):\n\n${result.output}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'list_directory',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Tool error for list_directory("${toolUse.input.path}"): ${result.error}`
            });
          }
        } else if (toolUse.name === 'read_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'read_file',
            params: toolUse.input,
            content: `read_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeReadFile(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            const lineCount = result.content.split('\n').length;
  
            state.addMessage({
              role: 'tool-result',
              toolName: 'read_file',
              summary: `Read ${lineCount} lines from ${result.path}`,
              fullResult: result.content,
              content: `File: ${result.path}\n\n${result.content}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'read_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error reading file ${result.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'write_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'write_file',
            params: toolUse.input,
            content: `write_file ${JSON.stringify({ path: toolUse.input.path, content: `(${toolUse.input.content.length} chars)` })}`
          });
  
          const result = await this.executeWriteFile(toolUse.input.path, toolUse.input.content, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'write_file',
              summary: `Wrote ${toolUse.input.content.length} characters to ${result.path}`,
              fullResult: `Successfully wrote to ${result.path}`,
              content: `Successfully wrote ${toolUse.input.content.length} characters to ${result.path}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'write_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error writing file ${result.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'search_by_filename') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'search_by_filename',
            params: toolUse.input,
            content: `search_by_filename ${JSON.stringify(toolUse.input)}`
          });
  
          const searchPath = toolUse.input.path || '.';
          const result = await this.executeSearchByFilename(toolUse.input.pattern, searchPath, selectedDirectory);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
            const truncated = this.truncateToolOutput(result.output, 'search_by_filename');
  
            state.addMessage({
              role: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Found ${matchCount} file(s) matching "${toolUse.input.pattern}"${timeoutWarning}${truncated.wasTruncated ? ' (truncated)' : ''}`,
              fullResult: result.output,
              content: `Search results for pattern "${toolUse.input.pattern}" in "${searchPath}":\n\n${truncated.content}`,
              truncated: truncated.wasTruncated
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching for files: ${result.error}`
            });
          }
        } else if (toolUse.name === 'search_by_content') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'search_by_content',
            params: toolUse.input,
            content: `search_by_content ${JSON.stringify(toolUse.input)}`
          });
  
          const searchPath = toolUse.input.path || '.';
          const filePattern = toolUse.input.filePattern || null;
          const result = await this.executeSearchByContent(toolUse.input.text, searchPath, filePattern, selectedDirectory);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
            const truncated = this.truncateToolOutput(result.output, 'search_by_content');
  
            state.addMessage({
              role: 'tool-result',
              toolName: 'search_by_content',
              summary: `Found ${matchCount} match(es) for "${toolUse.input.text}"${timeoutWarning}${truncated.wasTruncated ? ' (truncated)' : ''}`,
              fullResult: result.output,
              content: `Search results for text "${toolUse.input.text}" in "${searchPath}":\n\n${truncated.content}`,
              truncated: truncated.wasTruncated
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'search_by_content',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching file contents: ${result.error}`
            });
          }
        } else if (toolUse.name === 'edit_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'edit_file',
            params: toolUse.input,
            content: `edit_file ${JSON.stringify({ path: toolUse.input.path, find: `(${toolUse.input.find.length} chars)`, replace: `(${toolUse.input.replace.length} chars)` })}`
          });
  
          const result = await this.executeEditFile(toolUse.input.path, toolUse.input.find, toolUse.input.replace, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'edit_file',
              summary: `Edited ${result.path}: replaced ${toolUse.input.find.length} chars with ${toolUse.input.replace.length} chars`,
              fullResult: `Successfully edited ${result.path}`,
              content: `Successfully edited ${result.path}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'edit_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error editing file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'edit_file_batch') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'edit_file_batch',
            params: toolUse.input,
            content: `edit_file_batch ${JSON.stringify({ path: toolUse.input.path, edits: `(${toolUse.input.edits.length} edits)` })}`
          });
  
          const result = await this.executeEditFileBatch(toolUse.input.path, toolUse.input.edits, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Batch edited ${result.path}: applied ${toolUse.input.edits.length} edit(s)`,
              fullResult: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`,
              content: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error batch editing file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'delete_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'delete_file',
            params: toolUse.input,
            content: `delete_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeDeleteFile(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'delete_file',
              summary: `Deleted file: ${result.path}`,
              fullResult: `Successfully deleted ${result.path}`,
              content: `Successfully deleted file: ${result.path}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'delete_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error deleting file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'move_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'move_file',
            params: toolUse.input,
            content: `move_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeMoveFile(toolUse.input.source, toolUse.input.destination, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'move_file',
              summary: `Moved: ${result.source} â†’ ${result.destination}`,
              fullResult: `Successfully moved ${result.source} to ${result.destination}`,
              content: `Successfully moved file from ${result.source} to ${result.destination}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'move_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error moving file: ${result.error}`
            });
          }
        } else if (toolUse.name === 'copy_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'copy_file',
            params: toolUse.input,
            content: `copy_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeCopyFile(toolUse.input.source, toolUse.input.destination, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'copy_file',
              summary: `Copied: ${result.source} â†’ ${result.destination}`,
              fullResult: `Successfully copied ${result.source} to ${result.destination}`,
              content: `Successfully copied file from ${result.source} to ${result.destination}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'copy_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error copying file: ${result.error}`
            });
          }
        } else if (toolUse.name === 'create_directory') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'create_directory',
            params: toolUse.input,
            content: `create_directory ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeCreateDirectory(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'create_directory',
              summary: `Created directory: ${result.path}`,
              fullResult: `Successfully created directory ${result.path}`,
              content: `Successfully created directory: ${result.path}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'create_directory',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error creating directory ${toolUse.input.path}: ${result.error}`
            });
          }
        } else {
          // Unknown tool
          state.addMessage({
            role: 'user',
            content: `ERROR: Unknown tool "${toolUse.name}". Available tools are: list_directory, read_file, write_file, search_by_filename, search_by_content, edit_file, edit_file_batch, delete_file, move_file, copy_file, create_directory.`,
            fromSystem: true
          });
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Main] Unknown tool: ${toolUse.name}`);
        }
      }
  
      ui.renderMessages(state.getMessages());
    },
  
    // Execute file operations using FileSystem API
    executeListDirectory: async function(path, dirHandle) {
      try {
        let targetHandle = dirHandle;
  
        // Navigate to the target path if not root
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // List directory contents
        const entries = [];
        for await (const entry of targetHandle.values()) {
          entries.push({
            name: entry.name,
            kind: entry.kind
          });
        }
  
        // Format output
        let output = `Contents of "${path || '.'}":\n\n`;
        const dirs = entries.filter(e => e.kind === 'directory').sort((a, b) => a.name.localeCompare(b.name));
        const files = entries.filter(e => e.kind === 'file').sort((a, b) => a.name.localeCompare(b.name));
  
        if (dirs.length > 0) {
          output += 'Directories:\n';
          dirs.forEach(d => {
            output += `  ðŸ“ ${d.name}/\n`;
          });
        }
  
        if (files.length > 0) {
          output += '\nFiles:\n';
          files.forEach(f => {
            output += `  ðŸ“„ ${f.name}\n`;
          });
        }
  
        if (entries.length === 0) {
          output += '(empty directory)\n';
        }
  
        return { success: true, output };
      } catch (error) {
        return { success: false, error: error.message };
      }
    },
  
    executeReadFile: async function(path, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory
        for (let i = 0; i < pathParts.length - 1; i++) {
          currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
        }
  
        // Get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName);
        const file = await fileHandle.getFile();
        const content = await file.text();
  
        return { success: true, content, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeWriteFile: async function(path, content, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory (create if doesn't exist)
        for (let i = 0; i < pathParts.length - 1; i++) {
          try {
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
          } catch {
            // Directory doesn't exist, create it
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i], { create: true });
          }
        }
  
        // Create or get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
  
        // Write content
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        return { success: true, path };
      } catch (error) {
        // Check if it's a user activation error
        if (error.message && error.message.includes('User activation is required')) {
          return {
            success: false,
            error: `Cannot create new directories due to browser security. Please manually create the parent directory first, then try again.`,
            path
          };
        }
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFile: async function(path, findStr, replaceStr, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.role === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].role === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        const content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file.`,
            path
          };
        }
  
        // 4. Check that find string appears exactly once
        const occurrences = content.split(findStr).length - 1;
        if (occurrences === 0) {
          return {
            success: false,
            error: `Find string not found in file. The file may have changed since you last read it.`,
            path
          };
        } else if (occurrences > 1) {
          return {
            success: false,
            error: `Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
            path
          };
        }
  
        // 5. Perform replacement
        const newContent = content.replace(findStr, replaceStr);
  
        // 6. Write back
        const writeResult = await this.executeWriteFile(path, newContent, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFileBatch: async function(path, edits, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.role === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].role === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        let content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file_batch.`,
            path
          };
        }
  
        // 4. Apply each edit in sequence
        for (let i = 0; i < edits.length; i++) {
          const { find, replace } = edits[i];
  
          // Check that find string appears exactly once in current content
          const occurrences = content.split(find).length - 1;
          if (occurrences === 0) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string not found in file. The file may have changed or earlier edits affected this replacement.`,
              path
            };
          } else if (occurrences > 1) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
              path
            };
          }
  
          // Perform replacement
          content = content.replace(find, replace);
        }
  
        // 5. Write back
        const writeResult = await this.executeWriteFile(path, content, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    // Helper function to match wildcard pattern
    matchesPattern: function(filename, pattern) {
      // Convert wildcard pattern to regex
      // * matches any characters, ? matches single character
      const regexPattern = pattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&')  // Escape special regex chars
        .replace(/\*/g, '.*')  // * becomes .*
        .replace(/\?/g, '.');  // ? becomes .
  
      const regex = new RegExp(`^${regexPattern}$`, 'i');  // Case-insensitive
      return regex.test(filename);
    },
  
    // Recursively search for files by filename pattern
    executeSearchByFilename: async function(pattern, path, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if filename matches pattern
              if (window.module['main.js'].matchesPattern(entry.name, pattern)) {
                matches.push(entryPath);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Search] Error accessing ${currentPath}: ${error.message}`);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No files found matching the pattern.';
        } else {
          output = matches.map(m => `ðŸ“„ ${m}`).join('\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Recursively search for text within file contents
    executeSearchByContent: async function(searchText, path, filePattern, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if file matches filePattern (if provided)
              if (filePattern && !window.module['main.js'].matchesPattern(entry.name, filePattern)) {
                continue;
              }
  
              try {
                // Read file and search for text
                const file = await entry.getFile();
                const content = await file.text();
  
                if (content.toLowerCase().includes(searchText.toLowerCase())) {
                  // Find line numbers where text appears
                  const lines = content.split('\n');
                  const matchingLines = [];
  
                  for (let i = 0; i < lines.length; i++) {
                    if (lines[i].toLowerCase().includes(searchText.toLowerCase())) {
                      matchingLines.push({
                        lineNum: i + 1,
                        line: lines[i].trim()
                      });
                    }
                  }
  
                  matches.push({
                    path: entryPath,
                    lineMatches: matchingLines
                  });
                }
              } catch (error) {
                // Skip binary files or files that can't be read as text
                const diagnostics = window.module['diagnostics.js'];
                diagnostics.log('tools', `[Search] Could not read ${entryPath}: ${error.message}`);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Search] Error accessing ${currentPath}: ${error.message}`);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No matches found.';
        } else {
          output = matches.map(match => {
            const header = `ðŸ“„ ${match.path}`;
            const lineInfo = match.lineMatches.slice(0, 5).map(lm =>
              `  Line ${lm.lineNum}: ${lm.line.substring(0, 100)}${lm.line.length > 100 ? '...' : ''}`
            ).join('\n');
            const moreLines = match.lineMatches.length > 5 ? `  ... and ${match.lineMatches.length - 5} more matches` : '';
  
            return `${header}\n${lineInfo}${moreLines ? '\n' + moreLines : ''}`;
          }).join('\n\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or using a file pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Delete a file
    executeDeleteFile: async function(path, dirHandle) {
      try {
        // Navigate to the parent directory
        const pathParts = path.split('/').filter(p => p);
        const fileName = pathParts.pop();
  
        let targetHandle = dirHandle;
        for (const part of pathParts) {
          targetHandle = await targetHandle.getDirectoryHandle(part);
        }
  
        // Delete the file
        await targetHandle.removeEntry(fileName);
  
        return { success: true, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    // Move/rename a file
    executeMoveFile: async function(source, destination, dirHandle) {
      try {
        // Read source file
        const sourceContent = await this.executeReadFile(source, dirHandle);
        if (!sourceContent.success) {
          return { success: false, error: `Failed to read source file: ${sourceContent.error}`, source, destination };
        }
  
        // Write to destination
        const writeResult = await this.executeWriteFile(destination, sourceContent.content, dirHandle);
        if (!writeResult.success) {
          return { success: false, error: `Failed to write destination file: ${writeResult.error}`, source, destination };
        }
  
        // Delete source file
        const deleteResult = await this.executeDeleteFile(source, dirHandle);
        if (!deleteResult.success) {
          // Destination was written but source couldn't be deleted - warn but don't fail
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Main] Moved file but couldn't delete source: ${deleteResult.error}`);
        }
  
        return { success: true, source, destination };
      } catch (error) {
        return { success: false, error: error.message, source, destination };
      }
    },
  
    // Copy a file
    executeCopyFile: async function(source, destination, dirHandle) {
      try {
        // Read source file
        const sourceContent = await this.executeReadFile(source, dirHandle);
        if (!sourceContent.success) {
          return { success: false, error: `Failed to read source file: ${sourceContent.error}`, source, destination };
        }
  
        // Write to destination
        const writeResult = await this.executeWriteFile(destination, sourceContent.content, dirHandle);
        if (!writeResult.success) {
          return { success: false, error: `Failed to write destination file: ${writeResult.error}`, source, destination };
        }
  
        return { success: true, source, destination };
      } catch (error) {
        return { success: false, error: error.message, source, destination };
      }
    },
  
    // Create a directory
    executeCreateDirectory: async function(path, dirHandle) {
      try {
        // Navigate and create directories as needed
        const pathParts = path.split('/').filter(p => p);
  
        let targetHandle = dirHandle;
        for (const part of pathParts) {
          try {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          } catch (error) {
            // Directory doesn't exist, create it
            targetHandle = await targetHandle.getDirectoryHandle(part, { create: true });
          }
        }
  
        return { success: true, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    // Compact context by summarizing first half of messages
    compactContext: async function() {
      const diagnostics = window.module['diagnostics.js'];
      const state = window.module['state.js'];
      const api = window.module['api.js'];
      const ui = window.module['ui.js'];
  
      console.log('[Compaction] Starting context compaction...');
      diagnostics.log('compaction', '[Main] ========== COMPACTING CONTEXT ==========');
  
      // Update loading indicator
      ui.showLoading('Compacting');
  
      const messages = state.getMessages();
      const tokensBefore = state.calculateTokens();
      const messagesBefore = messages.length;
  
      // Find first message that's not uiOnly (skip initial greeting)
      let firstRealMessageIndex = -1;
      for (let i = 0; i < messages.length; i++) {
        if (!messages[i].uiOnly) {
          firstRealMessageIndex = i;
          break;
        }
      }
  
      if (firstRealMessageIndex === -1) {
        diagnostics.log('compaction', '[Main] No messages to compact');
        return;
      }
  
      // Get ALL real (non-uiOnly) messages to summarize
      const messagesToSummarize = messages.filter(m => !m.uiOnly);
  
      diagnostics.log('compaction', '[Main] Summarizing ALL ' + messagesToSummarize.length + ' messages');
      diagnostics.log('compaction', '[Main] Current tokens: ' + tokensBefore);
  
      // Create summarization request
      const summarizationMessages = [
        {
          role: 'user',
          content: 'You are summarizing a conversation between a user and a coding agent that has file system tools (read, write, search, edit files).\n\n' +
            'Provide a concise summary including:\n' +
            '1. User\'s most recent request\n' +
            '2. Recent actions (files read, edited, created)\n' +
            '3. Key decisions and context needed to continue\n' +
            '4. Any ongoing work or issues\n\n' +
            'Be concise. Focus on actionable context.\n\n' +
            'Conversation:\n\n' +
            messagesToSummarize.map(m => `[${m.role}]: ${m.content}`).join('\n\n')
        }
      ];
  
      try {
        // Call API for summarization (use simple call without system prompt)
        const requestSize = JSON.stringify(summarizationMessages).length;
        console.log(`[Compaction] Calling API for summarization (${requestSize} chars, ~${Math.round(requestSize/4)} tokens)`);
        const response = await api.callAPISimple(summarizationMessages);
  
        if (!response.valid) {
          diagnostics.log('compaction', '[Main] Failed to get summary from API');
          const tokensAfter = state.calculateTokens();
          const messagesAfter = messages.length;
          diagnostics.handleError('COMPACTION_FAILED', {
            error: new Error('Failed to get summary from API'),
            tokensBefore,
            tokensAfter,
            messagesBefore,
            messagesAfter
          });
          return;
        }
  
        const summaryContent = response.text;
        diagnostics.log('compaction', '[Main] Received summary: ' + summaryContent.substring(0, 100) + '...');
  
        // Mark ALL old messages as UI-only (keep them visible in UI, exclude from API)
        const oldMessages = messages.slice(firstRealMessageIndex).map(msg => ({
          ...msg,
          uiOnly: true
        }));
  
        // Keep all messages but mark ALL old ones as uiOnly and insert summary
        const newMessages = [
          ...messages.slice(0, firstRealMessageIndex),
          ...oldMessages,
          {
            role: 'summary',
            content: summaryContent,
            timestamp: Date.now(),
            uiOnly: true  // Summary is UI-only, actual content goes in system prompt
          }
        ];
  
        // Update state with new message array
        state.state.messages = newMessages;
  
        const tokensAfter = state.calculateTokens();
        const messagesAfter = newMessages.length;
        diagnostics.log('compaction', '[Main] Context compacted: ' + messages.length + ' -> ' + newMessages.length + ' messages');
  
      } catch (error) {
        diagnostics.log('compaction', '[Main] Error during compaction: ' + error);
        const tokensAfter = state.calculateTokens();
        const messagesAfter = messages.length;
        diagnostics.handleError('COMPACTION_FAILED', {
          error,
          tokensBefore,
          tokensAfter,
          messagesBefore,
          messagesAfter
        });
      }
    }
  };
  

  // Module: state.js
  // State management
  window.module['state.js'] = {
    state: {
      selectedDirectory: null,
      messages: [
        {
          role: 'assistant',
          content: 'Hello! I\'m your AI coding agent. I can help you with coding tasks, answer questions about your codebase, write code, debug issues, and more. What would you like to work on?',
          uiOnly: true  // This message won't be sent to the API
        }
      ],
      isProcessing: false,
      contextLimit: 20000  // Default 20K tokens (80K chars)
    },
  
    getState: function() {
      return this.state;
    },
  
    setSelectedDirectory: function(dirHandle) {
      this.state.selectedDirectory = dirHandle;
    },
  
    // Message management
    addMessage: function(message) {
      this.state.messages.push({
        ...message,
        timestamp: message.timestamp || Date.now()
      });
    },
  
    getMessages: function() {
      return this.state.messages;
    },
  
    // Processing state
    setProcessing: function(isProcessing) {
      this.state.isProcessing = isProcessing;
    },
  
    isProcessing: function() {
      return this.state.isProcessing;
    },
  
    // Clear all messages (keep initial greeting)
    clearMessages: function() {
      const initialGreeting = {
        role: 'assistant',
        content: 'Hello! I\'m your AI coding agent. I can help you with coding tasks, answer questions about your codebase, write code, debug issues, and more. What would you like to work on?',
        uiOnly: true
      };
  
      this.state.messages = [initialGreeting];
    },
  
    // Context limit management
    getContextLimit: function() {
      return this.state.contextLimit;
    },
  
    setContextLimit: function(limitInTokens) {
      this.state.contextLimit = limitInTokens;
    },
  
    // Calculate message size in tokens (estimate: 4 chars = 1 token)
    calculateTokens: function(messages) {
      if (!messages) {
        messages = this.state.messages;
      }
  
      let totalChars = 0;
      messages.forEach(msg => {
        if (msg.content) {
          totalChars += msg.content.length;
        }
      });
  
      return Math.ceil(totalChars / 4);  // 4 chars per token estimate
    },
  
    // Check if adding a message would exceed limit
    wouldExceedLimit: function(newMessageContent) {
      const currentTokens = this.calculateTokens();
      const newMessageTokens = Math.ceil(newMessageContent.length / 4);
      return (currentTokens + newMessageTokens) > this.state.contextLimit;
    },
  
    // Get the last summary index (if any)
    getLastSummaryIndex: function() {
      for (let i = this.state.messages.length - 1; i >= 0; i--) {
        if (this.state.messages[i].role === 'summary') {
          return i;
        }
      }
      return -1;
    }
  };
  

  // Module: styles.js
  // Styles and CSS injection
  window.module['styles.js'] = {
    injectStyles: function() {
      const style = document.createElement('style');
      style.textContent = `
        :root {
          --color-gold: #d4a017;
          --color-gold-light: #e5b028;
          --color-gold-glow: rgba(212, 160, 23, 0.3);
          --color-gold-subtle: rgba(212, 160, 23, 0.1);
          --color-bg-primary: #1a1a1a;
          --color-bg-secondary: #2d2d2d;
          --color-border: #404040;
          --color-text-primary: #e0e0e0;
          --color-text-secondary: #b0b0b0;
          --color-text-dim: #707070;
        }
  
        body {
          margin: 0;
          padding: 0;
          font-family: 'Consolas', 'Courier New', monospace;
          background-color: var(--color-bg-primary);
          color: var(--color-text-primary);
          overflow: hidden;
        }
  
        #app-container {
          width: 100%;
          height: 100vh;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        }
  
        /* Directory Selection Screen */
        #directory-screen {
          display: flex;
          align-items: center;
          justify-content: center;
          height: 100vh;
          flex-direction: column;
        }
  
        #directory-screen h1 {
          color: var(--color-gold);
          margin-bottom: 2rem;
          font-size: 48px;
          font-weight: 700;
          text-align: center;
          width: 100%;
        }
  
        #select-dir-btn {
          display: block;
          margin: 0 auto;
          background: var(--color-gold);
          color: var(--color-bg-primary);
          border: none;
          padding: 16px 32px;
          font-size: 16px;
          font-family: 'Consolas', 'Courier New', monospace;
          font-weight: 700;
          cursor: pointer;
          border-radius: 4px;
          transition: all 0.2s ease;
        }
  
        #select-dir-btn:hover {
          background: var(--color-gold-light);
          transform: translateY(-2px);
          box-shadow: 0 4px 12px var(--color-gold-glow);
        }
  
        #select-dir-btn:active {
          transform: translateY(0);
        }
  
        /* Chat Screen */
        #chat-screen {
          display: flex;
          flex-direction: column;
          height: 100vh;
        }
  
        #chat-container {
          flex: 1;
          overflow-y: auto;
          padding: 16px;
          scroll-behavior: smooth;
          width: 100%;
          max-width: 100%;
          box-sizing: border-box;
        }
  
        #chat-container::-webkit-scrollbar {
          width: 8px;
        }
  
        #chat-container::-webkit-scrollbar-track {
          background: var(--color-bg-secondary);
        }
  
        #chat-container::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 4px;
        }
  
        #chat-container::-webkit-scrollbar-thumb:hover {
          background: #777;
        }
  
        #input-container {
          padding: 16px;
          background-color: var(--color-bg-primary);
          width: 100%;
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 8px;
        }
  
        #input-wrapper {
          position: relative;
          width: 90%;
          max-width: 1200px;
          display: flex;
          align-items: flex-start;
          background-color: var(--color-bg-secondary);
          border: 1px solid var(--color-border);
          border-radius: 8px;
          max-height: 33.333vh;
          overflow: hidden;
        }
  
        #message-input {
          width: 100%;
          background: transparent;
          border: none;
          color: var(--color-text-primary);
          font-family: 'Consolas', 'Courier New', monospace;
          font-size: 14px;
          resize: none;
          outline: none;
          padding: 12px 16px;
          line-height: 1.6;
          overflow-y: auto;
          box-sizing: border-box;
        }
  
        #message-input::-webkit-scrollbar {
          display: none;
        }
  
        #message-input::placeholder {
          color: var(--color-text-dim);
        }
  
        #message-input:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
  
        #project-path {
          font-size: 12px;
          color: var(--color-text-secondary);
          text-align: left;
          width: 90%;
          max-width: 1200px;
        }
  
        #context-stats {
          display: flex;
          gap: 12px;
          justify-content: flex-end;
          width: 90%;
          max-width: 1200px;
          margin-top: 4px;
        }
  
        .context-stat-btn {
          background: none;
          border: none;
          color: var(--color-text-dim);
          font-size: 11px;
          font-family: 'Consolas', 'Courier New', monospace;
          cursor: pointer;
          padding: 2px 4px;
          transition: color 0.2s ease;
        }
  
        .context-stat-btn:hover {
          color: var(--color-gold);
        }
  
        /* Messages */
        .message {
          margin-bottom: 8px;
          position: relative;
        }
  
        .message:first-child {
          margin-top: 20px;
        }
  
        .user-message {
          display: flex;
          gap: 8px;
          color: var(--color-text-dim);
        }
  
        .user-message .message-prefix {
          flex-shrink: 0;
        }
  
        .user-message .message-content {
          flex: 1;
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        .assistant-message {
          color: var(--color-gold);
          padding-left: 2ch;
          background-image: linear-gradient(
            to right,
            transparent 0px,
            transparent calc(1ch - 5px),
            var(--color-gold) calc(1ch - 5px),
            var(--color-gold) calc(1ch - 4px),
            transparent calc(1ch - 4px)
          );
          background-repeat: no-repeat;
          background-size: 100% 100%;
          transition: all 0.2s ease;
          position: relative;
        }
  
        .assistant-message:hover {
          background-color: var(--color-gold-subtle);
          transform: translateX(2px);
        }
  
        .assistant-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
          max-width: 100%;
          overflow-wrap: break-word;
        }
  
        .message-timing {
          position: absolute;
          bottom: 2px;
          right: 8px;
          font-size: 10px;
          color: var(--color-text-dim);
          opacity: 0.5;
          pointer-events: none;
        }
  
        .tool-execution-timing {
          font-size: 10px;
          color: var(--color-text-dim);
          text-align: center;
          margin: 8px 0;
          opacity: 0.6;
          font-style: italic;
        }
  
        .loading {
          display: flex;
          gap: 6px;
          padding: 8px 12px;
          background: var(--color-gold-subtle);
          border-radius: 4px;
          color: var(--color-gold);
        }
  
        .loading::after {
          content: '';
          width: 6px;
          height: 6px;
          background: var(--color-gold);
          border-radius: 50%;
          animation: loading-bounce 1.4s infinite ease-in-out both;
        }
  
        @keyframes loading-bounce {
          0%, 80%, 100% {
            transform: scale(0);
            opacity: 0.5;
          }
          40% {
            transform: scale(1);
            opacity: 1;
          }
        }
  
        /* Tool Execution Messages - Inline Style */
        .tool-use-inline {
          padding: 4px 0 4px 2ch;
          font-size: 13px;
          line-height: 1.8;
        }
  
        .tool-use-inline .tool-name {
          color: #a0a0a0;
          font-weight: bold;
        }
  
        .tool-use-inline .tool-params {
          color: #888888;
          font-weight: normal;
        }
  
        .tool-result-inline {
          position: relative;
          padding: 4px 0 12px 3ch;
          font-size: 13px;
          color: #999999;
          cursor: pointer;
          transition: color 0.2s ease;
          line-height: 1.8;
        }
  
        .tool-result-inline:hover {
          color: var(--color-gold);
        }
  
        .tool-result-inline.error {
          color: #ff6b6b;
        }
  
        .tool-result-inline.error:hover {
          color: #ff5252;
        }
  
        /* Tool Execution Messages - Legacy */
        .tool-message {
          color: var(--color-text-secondary);
          padding: 8px 12px;
          background: var(--color-gold-subtle);
          border-left: 3px solid var(--color-gold);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 13px;
        }
  
        .tool-message:hover {
          background: rgba(212, 160, 23, 0.15);
          border-left-color: var(--color-gold-light);
          transform: translateX(2px);
        }
  
        .tool-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        /* Tool Group Container */
        .tool-group {
          margin-bottom: 8px;
        }
  
        /* Tool Use Messages (before execution) */
        .tool-use-message {
          position: relative;
          color: var(--color-text-secondary);
          padding: 0px 12px;
          background: rgba(212, 160, 23, 0.08);
          border-left: 3px solid rgba(212, 160, 23, 0.5);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 13px;
          line-height: 1.2;
        }
  
        /* When in a group, remove individual border radius and add top border */
        .tool-group .tool-use-message {
          border-radius: 0;
          margin-bottom: 0;
          border-top: 0.5px solid rgba(64, 64, 64, 0.3);
        }
  
        /* First child in group gets top rounded corners and no top border */
        .tool-group .tool-use-message:first-child {
          border-radius: 4px 4px 0 0;
          border-top: none;
        }
  
        /* Last child in group gets bottom rounded corners */
        .tool-group .tool-use-message:last-child {
          border-radius: 0 0 4px 4px;
        }
  
        /* Single child gets all corners rounded */
        .tool-group .tool-use-message:first-child:last-child {
          border-radius: 4px;
        }
  
        .tool-use-message:hover {
          background: rgba(212, 160, 23, 0.12);
          border-left-color: var(--color-gold);
          transform: translateX(2px);
        }
  
        .tool-use-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        /* Tool Result Messages (after execution) */
        .tool-result-message {
          position: relative;
          color: var(--color-text-secondary);
          padding: 0px 12px;
          background: rgba(76, 175, 80, 0.08);
          border-left: 3px solid rgba(76, 175, 80, 0.5);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 13px;
          line-height: 1.2;
        }
  
        /* When in a group, remove individual border radius and add top border */
        .tool-group .tool-result-message {
          border-radius: 0;
          margin-bottom: 0;
          border-top: 0.5px solid rgba(64, 64, 64, 0.3);
        }
  
        /* First child in group gets top rounded corners and no top border */
        .tool-group .tool-result-message:first-child {
          border-radius: 4px 4px 0 0;
          border-top: none;
        }
  
        /* Last child in group gets bottom rounded corners */
        .tool-group .tool-result-message:last-child {
          border-radius: 0 0 4px 4px;
        }
  
        /* Single child gets all corners rounded */
        .tool-group .tool-result-message:first-child:last-child {
          border-radius: 4px;
        }
  
        .tool-result-message:hover {
          background: rgba(76, 175, 80, 0.15);
          border-left-color: #4caf50;
          transform: translateX(2px);
        }
  
        .tool-result-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        /* Modal Overlay */
        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.85);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          animation: fadeIn 0.2s ease;
        }
  
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
  
        /* Modal Container */
        .modal-container {
          background: var(--color-bg-secondary);
          border: 2px solid var(--color-gold);
          border-radius: 8px;
          width: 90%;
          max-width: 900px;
          max-height: 80vh;
          display: flex;
          flex-direction: column;
          animation: slideUp 0.2s ease;
        }
  
        @keyframes slideUp {
          from {
            transform: translateY(20px);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }
  
        /* Modal Header */
        .modal-header {
          padding: 16px 20px;
          border-bottom: 1px solid var(--color-border);
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
  
        .modal-title {
          color: var(--color-gold);
          font-size: 18px;
          font-weight: bold;
        }
  
        .modal-close {
          background: none;
          border: none;
          color: var(--color-text-secondary);
          font-size: 24px;
          cursor: pointer;
          padding: 0;
          width: 32px;
          height: 32px;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: color 0.2s ease;
        }
  
        .modal-close:hover {
          color: var(--color-gold);
        }
  
        /* Modal Body */
        .modal-body {
          padding: 20px;
          overflow-y: auto;
          flex: 1;
        }
  
        .modal-body::-webkit-scrollbar {
          width: 8px;
        }
  
        .modal-body::-webkit-scrollbar-track {
          background: var(--color-bg-primary);
        }
  
        .modal-body::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 4px;
        }
  
        .modal-body::-webkit-scrollbar-thumb:hover {
          background: #777;
        }
  
        .modal-section {
          margin-bottom: 24px;
        }
  
        .modal-section:last-child {
          margin-bottom: 0;
        }
  
        .modal-section-title-row {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        }
  
        .modal-section-title {
          color: var(--color-gold);
          font-size: 14px;
          font-weight: bold;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
  
        .modal-section-copy-btn {
          background: var(--color-bg-primary);
          border: 1px solid var(--color-gold);
          color: var(--color-gold);
          padding: 4px 8px;
          font-size: 11px;
          font-family: 'Consolas', 'Courier New', monospace;
          cursor: pointer;
          border-radius: 3px;
          transition: all 0.2s ease;
        }
  
        .modal-section-copy-btn:hover {
          background: var(--color-gold);
          color: var(--color-bg-primary);
        }
  
        .modal-section-content {
          background: var(--color-bg-primary);
          padding: 12px;
          border-radius: 4px;
          border-left: 3px solid var(--color-gold-subtle);
          color: var(--color-text-primary);
          white-space: pre-wrap;
          word-wrap: break-word;
          font-family: 'Consolas', 'Courier New', monospace;
          font-size: 13px;
          line-height: 1.5;
          max-height: 400px;
          overflow-y: auto;
        }
  
        .modal-section-content::-webkit-scrollbar {
          width: 6px;
        }
  
        .modal-section-content::-webkit-scrollbar-track {
          background: var(--color-bg-secondary);
        }
  
        .modal-section-content::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 3px;
        }
  
        /* Summary Messages */
        .summary-message {
          background: rgba(100, 150, 200, 0.08);
          border-left: 3px solid rgba(100, 150, 200, 0.5);
          border-radius: 4px;
          padding: 12px 16px;
          margin-bottom: 20px;
          transition: all 0.2s ease;
        }
  
        .summary-message:hover {
          background: rgba(100, 150, 200, 0.12);
          border-left-color: #6496c8;
          transform: translateX(2px);
        }
  
        .summary-header {
          color: #6496c8;
          font-weight: bold;
          font-size: 13px;
          margin-bottom: 8px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
  
        .summary-message .message-content {
          color: var(--color-text-secondary);
          white-space: pre-wrap;
          word-wrap: break-word;
          font-size: 13px;
          line-height: 1.6;
        }
      `;
      document.head.appendChild(style);
    }
  };
  

  // Module: tools.js
  // Tool system - simplified architecture
  window.module['tools.js'] = {
  
    // Tool definitions
    tools: [
      {
        name: 'list_directory',
        description: 'List the contents of a directory (one level deep)',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The directory path to list (relative to project root, use "." for root)'
            }
          },
          required: ['path']
        }
      },
  
      {
        name: 'read_file',
        description: 'Read the contents of a file',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to read (relative to project root)'
            }
          },
          required: ['path']
        }
      },
  
      {
        name: 'write_file',
        description: 'Write content to a file (creates file and directories if they don\'t exist)',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to write (relative to project root)'
            },
            content: {
              type: 'string',
              description: 'The content to write to the file'
            }
          },
          required: ['path', 'content']
        }
      },
  
      {
        name: 'search_by_filename',
        description: 'Search for files by filename pattern (supports wildcards like *.js, test*, etc.)',
        input_schema: {
          type: 'object',
          properties: {
            pattern: {
              type: 'string',
              description: 'The filename pattern to search for (e.g., "*.js", "test*", "config.json")'
            },
            path: {
              type: 'string',
              description: 'The directory to search in (relative to project root, use "." for root). Optional, defaults to "."'
            }
          },
          required: ['pattern']
        }
      },
  
      {
        name: 'search_by_content',
        description: 'Search for text within file contents',
        input_schema: {
          type: 'object',
          properties: {
            text: {
              type: 'string',
              description: 'The text to search for within files'
            },
            path: {
              type: 'string',
              description: 'The directory to search in (relative to project root, use "." for root). Optional, defaults to "."'
            },
            filePattern: {
              type: 'string',
              description: 'Optional file pattern to limit search (e.g., "*.js", "*.txt"). If not provided, searches all files.'
            }
          },
          required: ['text']
        }
      },
  
      {
        name: 'edit_file',
        description: 'Edit a file by finding and replacing a specific string. The file must have been read within the last 5 minutes. The find string must appear exactly once in the file.',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to edit (relative to project root)'
            },
            find: {
              type: 'string',
              description: 'The exact string to find in the file (must appear exactly once)'
            },
            replace: {
              type: 'string',
              description: 'The string to replace it with'
            }
          },
          required: ['path', 'find', 'replace']
        }
      },
  
      {
        name: 'edit_file_batch',
        description: 'Edit a file by applying multiple find/replace operations in sequence. The file must have been read within the last 5 minutes. Each find string must appear exactly once in the file.',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to edit (relative to project root)'
            },
            edits: {
              type: 'array',
              description: 'Array of edit operations to apply in sequence',
              items: {
                type: 'object',
                properties: {
                  find: {
                    type: 'string',
                    description: 'The exact string to find in the file (must appear exactly once)'
                  },
                  replace: {
                    type: 'string',
                    description: 'The string to replace it with'
                  }
                },
                required: ['find', 'replace']
              }
            }
          },
          required: ['path', 'edits']
        }
      }
    ],
  
    // Get system prompt
    getSystemPrompt: function() {
      return `You are a coding agent with access to a project's file system via tools.
  
  CRITICAL INSTRUCTION: When a user asks you to explore a project, your FIRST response MUST be to execute the list_directory tool with path ".". DO NOT say you don't have access. DO NOT ask for clarification. IMMEDIATELY use the tools.
  
  Example: If user says "explore the project", you MUST respond with:
  {"type":"execute","tool_uses":[{"name":"list_directory","input":{"path":"."}}]}
  
  IMPORTANT: You have REAL tools to list, read, and write files. When a user asks you to explore or modify files, you MUST use these tools. Do NOT say you don't have access - you DO have access via these tools.
  
  ## Available Tools
  
  You have access to these tools to explore and work with the project:
  
  ### list_directory
  List the contents of a directory (one level deep)
  
  Parameters:
  - path (string, required): The directory path to list (relative to project root, use "." for root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"list_directory","input":{"path":"."}}]}
  
  ### read_file
  Read the contents of a file. Supports reading specific line ranges for large files.
  
  Parameters:
  - path (string, required): The file path to read (relative to project root)
  - offset (number, optional): Line number to start reading from (1-based, default: 1)
  - limit (number, optional): Maximum number of lines to read (default: all lines)
  
  When a file is truncated, the result will show "[Truncated: X more lines. Use offset/limit to read remaining.]"
  To read the rest, call read_file again with offset set to the next line number.
  
  Example usage (single file):
  {"type":"execute","tool_uses":[{"name":"read_file","input":{"path":"package.json"}}]}
  
  Example usage (read lines 100-200):
  {"type":"execute","tool_uses":[{"name":"read_file","input":{"path":"src/app/main.js","offset":100,"limit":100}}]}
  
  Example usage (multiple files):
  {"type":"execute","tool_uses":[{"name":"read_file","input":{"path":"src/app/main.js"}},{"name":"read_file","input":{"path":"package.json"}}]}
  
  ### write_file
  Write content to a file (creates file and directories if they don't exist)
  
  Parameters:
  - path (string, required): The file path to write (relative to project root)
  - content (string, required): The content to write to the file
  
  CRITICAL: The "content" field MUST be a literal JSON string. Do NOT use JavaScript expressions like .repeat(), string concatenation (+), or template literals. The content must be the FULL, EXPANDED text as a single JSON string with proper escaping.
  
  WRONG: {"content":"Line 1\\n" + "Line 2"}
  WRONG: {"content":"text ".repeat(100)}
  CORRECT: {"content":"Line 1\\nLine 2"}
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"write_file","input":{"path":"src/utils/helper.js","content":"// Helper functions\\nexport function add(a, b) {\\n  return a + b;\\n}"}}]}
  
  ### search_by_filename
  Search for files by filename pattern (supports wildcards)
  
  Parameters:
  - pattern (string, required): The filename pattern to search for (e.g., "*.js", "test*", "config.json")
  - path (string, optional): The directory to search in (relative to project root, defaults to ".")
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"search_by_filename","input":{"pattern":"*.js","path":"src"}}]}
  
  ### search_by_content
  Search for text within file contents
  
  Parameters:
  - text (string, required): The text to search for within files
  - path (string, optional): The directory to search in (relative to project root, defaults to ".")
  - filePattern (string, optional): File pattern to limit search (e.g., "*.js")
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"search_by_content","input":{"text":"executeTools","filePattern":"*.js"}}]}
  
  ### edit_file
  Edit a file by finding and replacing a specific string (for single edits)
  
  IMPORTANT REQUIREMENTS:
  1. You MUST read the file within the last 5 minutes before editing
  2. The find string MUST appear exactly once in the file (otherwise you'll get an error)
  3. If the file is blank/empty, use write_file instead
  
  Parameters:
  - path (string, required): The file path to edit (relative to project root)
  - find (string, required): The exact string to find (must appear exactly once)
  - replace (string, required): The string to replace it with
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"edit_file","input":{"path":"src/config.js","find":"debug: false","replace":"debug: true"}}]}
  
  ### edit_file_batch
  Edit a file by applying multiple find/replace operations in sequence (for multiple edits to the same file)
  
  IMPORTANT REQUIREMENTS:
  1. You MUST read the file within the last 5 minutes before editing
  2. Each find string MUST appear exactly once in the file at the time it's applied (otherwise you'll get an error)
  3. Edits are applied in sequence, so later edits see the results of earlier edits
  4. If the file is blank/empty, use write_file instead
  
  Parameters:
  - path (string, required): The file path to edit (relative to project root)
  - edits (array, required): Array of {find, replace} operations to apply in sequence
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"edit_file_batch","input":{"path":"src/config.js","edits":[{"find":"version: '1.0.0'","replace":"version: '2.0.0'"},{"find":"debug: false","replace":"debug: true"}]}}]}
  
  ### delete_file
  Delete a file
  
  Parameters:
  - path (string, required): The file path to delete (relative to project root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"delete_file","input":{"path":"temp/old-file.js"}}]}
  
  ### move_file
  Move or rename a file
  
  Parameters:
  - source (string, required): The source file path (relative to project root)
  - destination (string, required): The destination file path (relative to project root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"move_file","input":{"source":"src/old-name.js","destination":"src/new-name.js"}}]}
  
  ### copy_file
  Copy a file to a new location
  
  Parameters:
  - source (string, required): The source file path (relative to project root)
  - destination (string, required): The destination file path (relative to project root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"copy_file","input":{"source":"src/template.js","destination":"src/new-component.js"}}]}
  
  ### create_directory
  Create a new directory (and any parent directories as needed)
  
  Parameters:
  - path (string, required): The directory path to create (relative to project root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"create_directory","input":{"path":"src/components/new-feature"}}]}
  
  ## Workflow
  
  When asked to explore a project:
  1. Use list_directory to see what files/folders exist
  2. Use search_by_filename to find specific files by pattern
  3. Use search_by_content to find files containing specific text
  4. Use read_file to read relevant files (you can read multiple files at once)
  5. File contents will remain in the conversation for context
  6. Use write_file to create or update files
  7. Then provide your analysis or response
  
  ## Response Format
  
  You MUST respond with valid JSON followed by a terminator. Your response MUST be ONLY the JSON object, followed immediately by ||||END||||
  
  **To execute tools:**
  {"type":"execute","tool_uses":[{"name":"tool_name","input":{"param":"value"}}]}||||END||||
  
  **To send a message:**
  {"type":"message","content":"Your response text here"}||||END||||
  
  CRITICAL:
  - Do NOT use any other response type. Only "execute" or "message".
  - Do NOT wrap your JSON in markdown code blocks
  - Do NOT include any explanatory text before or after the JSON
  - Your ENTIRE response must be valid JSON starting with { and ending with }
  - JSON fields MUST contain literal values only - NO JavaScript expressions, concatenation (+), .repeat(), template literals, or any code
  - All string values must be fully expanded as literal JSON strings with proper escaping (\\n for newlines, \\" for quotes)
  - ALWAYS end your response with ||||END|||| immediately after the closing }
  - If your response is blank or empty, just send ||||END|||| to indicate completion`;
    },
  
    // Attempt to fix malformed JSON
    tryFixJSON: function(jsonText) {
      // If last character is "}", try removing it and parsing again
      if (jsonText.trim().endsWith('}')) {
        const withoutLastBrace = jsonText.trim().slice(0, -1);
        try {
          const parsed = JSON.parse(withoutLastBrace);
          console.log('[tryFixJSON] Successfully fixed JSON by removing trailing }');
          return { fixed: true, json: withoutLastBrace, parsed };
        } catch (e) {
          return { fixed: false };
        }
      }
      return { fixed: false };
    },
  
    // Attempt to fix unescaped newlines in JSON content
    tryFixNewlines: function(jsonText) {
      try {
        // Strategy: Find content field and escape newlines within it
        // This is a heuristic approach for common AI response patterns
        const contentMatch = jsonText.match(/"content"\s*:\s*"([\s\S]*?)(?:"(?:\s*[,}]))/);
        if (contentMatch) {
          const originalContent = contentMatch[1];
          const fixedContent = originalContent
            .replace(/\r/g, '\\r')
            .replace(/\n/g, '\\n')
            .replace(/\t/g, '\\t');
  
          const fixedJson = jsonText.replace(
            `"content":"${originalContent}"`,
            `"content":"${fixedContent}"`
          );
  
          const parsed = JSON.parse(fixedJson);
          console.log('[tryFixNewlines] Successfully fixed JSON by escaping newlines');
          return { fixed: true, json: fixedJson, parsed };
        }
      } catch (e) {
        console.log('[tryFixNewlines] Failed to fix:', e.message);
        return { fixed: false };
      }
      return { fixed: false };
    },
  
    // Attempt to extract valid JSON when AI adds text before/after the JSON
    tryExtractJSON: function(text) {
      const diagnostics = window.module['diagnostics.js'];
  
      try {
        // Strategy: Find the first '{' and count braces to find where JSON ends
        // Must properly handle braces inside strings
        const startIdx = text.indexOf('{');
        if (startIdx === -1) {
          return { fixed: false };
        }
  
        let braceCount = 0;
        let endIdx = -1;
        let inString = false;
        let escapeNext = false;
  
        for (let i = startIdx; i < text.length; i++) {
          const char = text[i];
  
          // Handle escape sequences
          if (escapeNext) {
            escapeNext = false;
            continue;
          }
  
          if (char === '\\') {
            escapeNext = true;
            continue;
          }
  
          // Handle string boundaries
          if (char === '"') {
            inString = !inString;
            continue;
          }
  
          // Only count braces outside of strings
          if (!inString) {
            if (char === '{') {
              braceCount++;
            } else if (char === '}') {
              braceCount--;
              if (braceCount === 0) {
                endIdx = i + 1;
                break;
              }
            }
          }
        }
  
        if (endIdx === -1) {
          return { fixed: false };
        }
  
        const extractedJson = text.substring(startIdx, endIdx);
        const parsed = JSON.parse(extractedJson);
  
        const prefixText = text.substring(0, startIdx).trim();
        const suffixText = text.substring(endIdx).trim();
  
        if (prefixText || suffixText) {
          diagnostics.log('json', '[tryExtractJSON] Extracted JSON, discarded surrounding text', {
            extractedLength: extractedJson.length,
            discardedPrefix: prefixText.substring(0, 100),
            discardedSuffix: suffixText.substring(0, 100)
          });
        }
  
        console.log('[tryExtractJSON] Successfully extracted JSON from response with surrounding text');
        return {
          fixed: true,
          json: extractedJson,
          parsed,
          prefixText: prefixText || null,
          suffixText: suffixText || null
        };
      } catch (e) {
        console.log('[tryExtractJSON] Failed to extract:', e.message);
        return { fixed: false };
      }
    },
  
    // Parse and validate AI response
    parseResponse: function(responseText) {
      let response;
      let extractedText = null;  // Store any text that was extracted
  
      // Try to parse JSON
      try {
        response = JSON.parse(responseText);
      } catch (parseError) {
        // Try to fix the JSON
        console.log('[parseResponse] Initial JSON parse failed:', parseError.message);
  
        // Try multiple fix strategies
        let fixResult = this.tryFixJSON(responseText);
  
        if (!fixResult.fixed) {
          // If that didn't work, try escaping newlines in content
          fixResult = this.tryFixNewlines(responseText);
        }
  
        if (!fixResult.fixed) {
          // If that didn't work, try extracting just the JSON portion (AI adding text after JSON)
          fixResult = this.tryExtractJSON(responseText);
        }
  
        if (fixResult.fixed) {
          console.log('[parseResponse] JSON was fixed, using repaired version');
          response = fixResult.parsed;
  
          // If extraction found prefix/suffix text, store it
          if (fixResult.prefixText || fixResult.suffixText) {
            extractedText = {
              prefix: fixResult.prefixText,
              suffix: fixResult.suffixText
            };
          }
        } else {
          return {
            valid: false,
            error: `Invalid JSON: ${parseError.message}`
          };
        }
      }
  
      // Validate response structure
      if (!response.type) {
        return {
          valid: false,
          error: 'Response missing required "type" field'
        };
      }
  
      if (response.type === 'message') {
        if (!response.content || typeof response.content !== 'string') {
          return {
            valid: false,
            error: 'Message response missing "content" field or content is not a string'
          };
        }
      } else if (response.type === 'execute') {
        if (!response.tool_uses || !Array.isArray(response.tool_uses)) {
          return {
            valid: false,
            error: 'Execute response missing "tool_uses" array'
          };
        }
  
        // Validate each tool use
        for (let i = 0; i < response.tool_uses.length; i++) {
          const toolUse = response.tool_uses[i];
          if (!toolUse.name || typeof toolUse.name !== 'string') {
            return {
              valid: false,
              error: `Tool use ${i} missing "name" field or name is not a string`
            };
          }
          if (!toolUse.input || typeof toolUse.input !== 'object') {
            return {
              valid: false,
              error: `Tool use ${i} missing "input" field or input is not an object`
            };
          }
        }
      } else {
        return {
          valid: false,
          error: `Unknown response type: "${response.type}". Must be "message" or "execute"`
        };
      }
  
      return {
        valid: true,
        parsed: response,
        extractedText: extractedText  // Include any prefix/suffix text that was extracted
      };
    }
  };
  

  // Module: ui.js
  // UI rendering and interaction
  window.module['ui.js'] = {
    showDirectorySelection: function(onSelect) {
      const container = document.createElement('div');
      container.id = 'app-container';
  
      const screen = document.createElement('div');
      screen.id = 'directory-screen';
  
      const title = document.createElement('h1');
      title.textContent = 'AI Coding Agent';
  
      const button = document.createElement('button');
      button.id = 'select-dir-btn';
      button.textContent = 'Select Project Directory';
      button.onclick = onSelect;
  
      screen.appendChild(title);
      screen.appendChild(button);
      container.appendChild(screen);
      document.body.appendChild(container);
    },
  
    showChatScreen: function(selectedDirectory, onSendMessage) {
      const container = document.getElementById('app-container');
      container.innerHTML = '';
  
      const screen = document.createElement('div');
      screen.id = 'chat-screen';
  
      // Chat container
      const chatContainer = document.createElement('div');
      chatContainer.id = 'chat-container';
  
      // Input container
      const inputContainer = document.createElement('div');
      inputContainer.id = 'input-container';
  
      // Input wrapper
      const inputWrapper = document.createElement('div');
      inputWrapper.id = 'input-wrapper';
  
      const textarea = document.createElement('textarea');
      textarea.id = 'message-input';
      textarea.placeholder = 'Type your message...';
      textarea.rows = 1;
  
      // Auto-resize textarea
      const resizeTextarea = () => {
        textarea.style.height = '0px';
        textarea.style.height = Math.min(textarea.scrollHeight, window.innerHeight * 0.33) + 'px';
      };
  
      textarea.addEventListener('input', resizeTextarea);
  
      textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          onSendMessage();
        }
      });
  
      inputWrapper.appendChild(textarea);
      inputContainer.appendChild(inputWrapper);
  
      // Project path display
      const projectPath = document.createElement('div');
      projectPath.id = 'project-path';
  
      // Get full path from directory handle
      if (selectedDirectory) {
        // Try to resolve the full path if available (Chrome 86+)
        selectedDirectory.resolve().then(path => {
          if (path && path.length > 0) {
            projectPath.textContent = path.join('/');
          } else {
            projectPath.textContent = selectedDirectory.name;
          }
        }).catch(() => {
          // Fallback to just the directory name
          projectPath.textContent = selectedDirectory.name;
        });
      }
  
      inputContainer.appendChild(projectPath);
  
      // Context stats display
      const contextStats = document.createElement('div');
      contextStats.id = 'context-stats';
  
      const messagesBtn = document.createElement('button');
      messagesBtn.className = 'context-stat-btn';
      messagesBtn.id = 'messages-stat-btn';
      messagesBtn.textContent = '0K';
      messagesBtn.onclick = () => this.showContextModal();
  
      const diagBtn = document.createElement('button');
      diagBtn.className = 'context-stat-btn';
      diagBtn.textContent = 'Run API Tests';
      diagBtn.onclick = () => {
        const apiDiag = window.module['api-diagnostics.js'];
        if (apiDiag) {
          apiDiag.runAllTests();
        } else {
          console.error('API diagnostics module not loaded');
        }
      };
  
      contextStats.appendChild(messagesBtn);
      contextStats.appendChild(diagBtn);
  
      inputContainer.appendChild(contextStats);
  
      screen.appendChild(chatContainer);
      screen.appendChild(inputContainer);
      container.appendChild(screen);
  
      // Focus the input
      textarea.focus();
  
      // Initial stats update
      this.updateContextStats();
    },
  
    renderMessages: function(messages) {
      const container = document.getElementById('chat-container');
  
      // Preserve loading indicator if it exists
      const loadingIndicator = document.getElementById('loading-indicator');
      const loadingHTML = loadingIndicator ? loadingIndicator.outerHTML : null;
  
      container.innerHTML = '';
  
      // Track which groupIds have been rendered
      const renderedGroupIds = new Set();
  
      messages.forEach((msg, index) => {
        // Skip messages from system (tool results, internal prompts)
        if (msg.fromSystem) {
          return;
        }
  
        // Skip marker messages
        if (msg.isMarker) {
          return;
        }
  
        // Skip API-only messages
        if (msg.apiOnly) {
          return;
        }
  
        // Skip assistant messages that contain raw JSON tool execution requests
        // These are for API conversation structure only, not for UI display
        // We detect them by checking if the content starts with JSON (contains "type": "execute")
        // However, we still want to show the timing for these AI calls
        if (msg.role === 'assistant' && msg.apiData && msg.content && msg.content.includes('"type"')) {
          // If there's timing info, display it
          if (msg.durationSeconds !== undefined) {
            const timingDiv = document.createElement('div');
            timingDiv.className = 'tool-execution-timing';
            timingDiv.textContent = `${msg.durationSeconds.toFixed(2)}s`;
            container.appendChild(timingDiv);
          }
          return;
        }
  
        // Check if this message belongs to a tool group
        const groupId = (msg.isToolUse && msg.toolUseData?.groupId) ||
                        (msg.isToolResult && msg.toolResultData?.groupId);
  
        // If this message has a groupId and we've already rendered this group, skip it
        if (groupId && renderedGroupIds.has(groupId)) {
          return;
        }
  
        // If this message is part of a tool group, collect all messages in that group
        if (groupId) {
          // Mark this group as rendered
          renderedGroupIds.add(groupId);
  
          // Collect all messages with this groupId (both tool-use and tool-result)
          const groupMessages = messages.filter(m => {
            const msgGroupId = (m.isToolUse && m.toolUseData?.groupId) ||
                               (m.isToolResult && m.toolResultData?.groupId);
            return msgGroupId === groupId;
          });
  
          // Create a grouped container
          const groupDiv = document.createElement('div');
          groupDiv.className = 'message tool-group';
  
          // Render each message in the group in order
          groupMessages.forEach(groupMsg => {
            if (groupMsg.isToolUse) {
              // Create tool-use div
              const toolUseDiv = document.createElement('div');
              toolUseDiv.className = 'tool-use-message';
              toolUseDiv.addEventListener('click', () => {
                this.showToolUseModal(groupMsg);
              });
  
              const toolUseContent = document.createElement('div');
              toolUseContent.className = 'message-content';
              toolUseContent.textContent = groupMsg.content;
              toolUseDiv.appendChild(toolUseContent);
  
              groupDiv.appendChild(toolUseDiv);
            } else if (groupMsg.isToolResult) {
              // Create tool-result div
              const toolResultDiv = document.createElement('div');
              toolResultDiv.className = 'tool-result-message';
              toolResultDiv.addEventListener('click', () => {
                this.showToolResultModal(groupMsg);
              });
  
              const toolResultContent = document.createElement('div');
              toolResultContent.className = 'message-content';
              toolResultContent.textContent = groupMsg.content;
              toolResultDiv.appendChild(toolResultContent);
  
              // Add timing if available
              if (groupMsg.durationMs !== undefined) {
                const timing = document.createElement('div');
                timing.className = 'message-timing';
                timing.textContent = `${groupMsg.durationMs}ms`;
                toolResultDiv.appendChild(timing);
              }
  
              groupDiv.appendChild(toolResultDiv);
            }
          });
  
          container.appendChild(groupDiv);
          return;
        }
  
        // Regular message rendering (for non-grouped messages)
        const messageDiv = document.createElement('div');
  
        // Handle new tool-use and tool-result roles
        if (msg.role === 'tool-use') {
          messageDiv.className = 'message tool-use-inline';
  
          const toolName = document.createElement('span');
          toolName.className = 'tool-name';
          toolName.textContent = msg.toolName;
  
          const toolParams = document.createElement('span');
          toolParams.className = 'tool-params';
          toolParams.textContent = ' ' + JSON.stringify(msg.params);
  
          messageDiv.appendChild(toolName);
          messageDiv.appendChild(toolParams);
  
          container.appendChild(messageDiv);
          return;
        } else if (msg.role === 'tool-result') {
          messageDiv.className = msg.error ? 'message tool-result-inline error' : 'message tool-result-inline';
          messageDiv.textContent = msg.summary;
          messageDiv.style.cursor = 'pointer';
          messageDiv.addEventListener('click', () => {
            this.showToolResultModal(msg);
          });
  
          // Add timing if available
          if (msg.durationMs !== undefined) {
            const timing = document.createElement('span');
            timing.className = 'message-timing';
            timing.textContent = `${msg.durationMs}ms`;
            messageDiv.appendChild(timing);
          }
  
          container.appendChild(messageDiv);
          return;
        }
  
        // Apply different styling for tool use and tool result messages
        if (msg.isToolUse) {
          messageDiv.className = 'message tool-use-message';
          messageDiv.addEventListener('click', () => {
            this.showToolUseModal(msg);
          });
        } else if (msg.isToolResult) {
          messageDiv.className = 'message tool-result-message';
          messageDiv.addEventListener('click', () => {
            this.showToolResultModal(msg);
          });
        } else if (msg.isToolExecution) {
          // Legacy support
          messageDiv.className = 'message tool-message';
          messageDiv.addEventListener('click', () => {
            this.showToolModal(msg);
          });
        } else {
          messageDiv.className = `message ${msg.role}-message`;
        }
  
        if (msg.role === 'user') {
          const prefix = document.createElement('span');
          prefix.className = 'message-prefix';
          prefix.textContent = '> ';
  
          const content = document.createElement('span');
          content.className = 'message-content';
          content.textContent = msg.content;
  
          messageDiv.appendChild(prefix);
          messageDiv.appendChild(content);
        } else if (msg.role === 'assistant') {
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
          messageDiv.appendChild(content);
  
          // Add timing info if available
          if (msg.durationSeconds !== undefined) {
            const timing = document.createElement('div');
            timing.className = 'message-timing';
            timing.textContent = `${msg.durationSeconds.toFixed(2)}s`;
            messageDiv.appendChild(timing);
          }
  
          // Make all assistant messages clickable to show details
          messageDiv.style.cursor = 'pointer';
          messageDiv.addEventListener('click', () => {
            this.showAssistantMessageModal(msg);
          });
        } else if (msg.role === 'summary') {
          // Summary message - special styling
          const header = document.createElement('div');
          header.className = 'summary-header';
          header.textContent = 'ðŸ“ Conversation Summary';
  
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
  
          messageDiv.appendChild(header);
          messageDiv.appendChild(content);
        } else {
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
          messageDiv.appendChild(content);
        }
  
        container.appendChild(messageDiv);
      });
  
      // Restore loading indicator if it was present
      if (loadingHTML) {
        container.insertAdjacentHTML('beforeend', loadingHTML);
      }
  
      // Scroll to bottom
      container.scrollTop = container.scrollHeight;
  
      // Update context stats
      this.updateContextStats();
    },
  
    showToolModal: function(toolMessage) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const title = document.createElement('div');
      title.className = 'modal-title';
      title.textContent = 'Tool Execution Details';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(title);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      // If there's toolData, show specific tool information
      if (toolMessage.toolData && toolMessage.toolData.results) {
        toolMessage.toolData.results.forEach((toolResult, index) => {
          const toolUse = toolMessage.toolData.toolUses[index];
  
          // Tool name section
          const nameSection = document.createElement('div');
          nameSection.className = 'modal-section';
  
          const nameTitle = document.createElement('div');
          nameTitle.className = 'modal-section-title';
          nameTitle.textContent = `Tool: ${toolUse.tool}`;
  
          const nameContent = document.createElement('div');
          nameContent.className = 'modal-section-content';
          nameContent.textContent = `Parameters: ${JSON.stringify(toolUse.params, null, 2)}`;
  
          nameSection.appendChild(nameTitle);
          nameSection.appendChild(nameContent);
          body.appendChild(nameSection);
  
          // Special handling for read_file
          if (toolUse.tool === 'read_file' && toolResult.result.success) {
            // File contents
            if (toolResult.result.fileContents) {
              const contentsSection = document.createElement('div');
              contentsSection.className = 'modal-section';
  
              const contentsTitle = document.createElement('div');
              contentsTitle.className = 'modal-section-title';
              contentsTitle.textContent = `File: ${toolResult.result.path}`;
  
              const contentsContent = document.createElement('div');
              contentsContent.className = 'modal-section-content';
              contentsContent.textContent = toolResult.result.fileContents;
  
              contentsSection.appendChild(contentsTitle);
              contentsSection.appendChild(contentsContent);
              body.appendChild(contentsSection);
            }
  
            // Previous mental model notes
            if (toolResult.result.currentNotes) {
              const notesSection = document.createElement('div');
              notesSection.className = 'modal-section';
  
              const notesTitle = document.createElement('div');
              notesTitle.className = 'modal-section-title';
              notesTitle.textContent = 'Mental Model (Before)';
  
              const notesContent = document.createElement('div');
              notesContent.className = 'modal-section-content';
              notesContent.textContent = toolResult.result.currentNotes;
  
              notesSection.appendChild(notesTitle);
              notesSection.appendChild(notesContent);
              body.appendChild(notesSection);
            }
          } else {
            // For other tools, show result
            const resultSection = document.createElement('div');
            resultSection.className = 'modal-section';
  
            const resultTitle = document.createElement('div');
            resultTitle.className = 'modal-section-title';
            resultTitle.textContent = 'Result';
  
            const resultContent = document.createElement('div');
            resultContent.className = 'modal-section-content';
            resultContent.textContent = JSON.stringify(toolResult.result, null, 2);
  
            resultSection.appendChild(resultTitle);
            resultSection.appendChild(resultContent);
            body.appendChild(resultSection);
          }
        });
      } else {
        // Fallback: show basic tool execution message
        const toolSection = document.createElement('div');
        toolSection.className = 'modal-section';
  
        const toolTitle = document.createElement('div');
        toolTitle.className = 'modal-section-title';
        toolTitle.textContent = 'Tool Execution';
  
        const toolContent = document.createElement('div');
        toolContent.className = 'modal-section-content';
        toolContent.textContent = toolMessage.content;
  
        toolSection.appendChild(toolTitle);
        toolSection.appendChild(toolContent);
        body.appendChild(toolSection);
      }
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    },
  
    showLoading: function(text = 'Thinking') {
      const container = document.getElementById('chat-container');
      let loading = document.getElementById('loading-indicator');
      if (loading) {
        loading.textContent = text;
      } else {
        loading = document.createElement('div');
        loading.id = 'loading-indicator';
        loading.className = 'message assistant-message loading';
        loading.textContent = text;
        container.appendChild(loading);
      }
      container.scrollTop = container.scrollHeight;
    },
  
    hideLoading: function() {
      const loading = document.getElementById('loading-indicator');
      if (loading) {
        loading.remove();
      }
    },
  
    getInputValue: function() {
      const input = document.getElementById('message-input');
      return input ? input.value.trim() : '';
    },
  
    clearInput: function() {
      const input = document.getElementById('message-input');
      if (input) {
        input.value = '';
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      }
    },
  
    setInputDisabled: function(disabled) {
      const input = document.getElementById('message-input');
      if (input) {
        input.disabled = disabled;
        if (!disabled) {
          input.focus();
        }
      }
    },
  
    showToolUseModal: function(toolUseMessage) {
      const data = toolUseMessage.toolUseData;
      const toolUse = data.toolUse;
  
      const overlay = this.createModalOverlay('Tool Use');
      const body = overlay.querySelector('.modal-body');
  
      // Tool and parameters
      const toolSection = this.createModalSection('Tool', `${toolUse.tool}`);
      body.appendChild(toolSection);
  
      const paramsSection = this.createModalSection('Parameters', JSON.stringify(toolUse.params, null, 2));
      body.appendChild(paramsSection);
  
      // For read_file, show additional context
      if (toolUse.tool === 'read_file') {
        const pathSection = this.createModalSection('File Path', toolUse.params.path);
        body.appendChild(pathSection);
      }
  
      // For update_mental_model, show the mental model updates
      if (toolUse.tool === 'update_mental_model' && toolUse.params.notes) {
        const notesSection = this.createModalSection(
          'Mental Model Updates',
          JSON.stringify(toolUse.params.notes, null, 2)
        );
        body.appendChild(notesSection);
  
        // Show individual file notes for easier reading
        const notes = toolUse.params.notes;
        if (Object.keys(notes).length > 0) {
          Object.entries(notes).forEach(([filePath, fileNotes]) => {
            const fileSection = this.createModalSection(
              `File: ${filePath}`,
              fileNotes
            );
            body.appendChild(fileSection);
          });
        }
      }
  
      // Full tool use object
      const fullSection = this.createModalSection('Full Tool Use Object', JSON.stringify(toolUse, null, 2));
      body.appendChild(fullSection);
  
      document.body.appendChild(overlay);
    },
  
    showToolResultModal: function(toolResultMessage) {
      const overlay = this.createModalOverlay('Tool Execution Details');
      const body = overlay.querySelector('.modal-body');
  
      const state = window.module['state.js'];
      const messages = state.getMessages();
      const currentIndex = messages.indexOf(toolResultMessage);
  
      // Find the previous assistant message (contains the tool execution request)
      let inputMessage = null;
      if (currentIndex !== -1) {
        for (let i = currentIndex - 1; i >= 0; i--) {
          if (messages[i].role === 'assistant') {
            inputMessage = messages[i];
            break;
          }
        }
      }
  
      // INPUT: Show the full API request body that generated this tool execution
      if (inputMessage && inputMessage.apiData && inputMessage.apiData.inputFull) {
        const inputSection = this.createModalSection(
          'Input',
          JSON.stringify(inputMessage.apiData.inputFull, null, 2)
        );
        body.appendChild(inputSection);
      } else {
        const noInputSection = this.createModalSection(
          'Input',
          'Could not find the associated API request'
        );
        body.appendChild(noInputSection);
      }
  
      // OUTPUT: Show the full API response that came back
      if (inputMessage && inputMessage.apiData && inputMessage.apiData.output) {
        const outputSection = this.createModalSection(
          'Output',
          JSON.stringify(inputMessage.apiData.output, null, 2)
        );
        body.appendChild(outputSection);
      } else {
        const noOutputSection = this.createModalSection(
          'Output',
          'Could not find the associated API response'
        );
        body.appendChild(noOutputSection);
      }
  
      document.body.appendChild(overlay);
    },
  
    createModalOverlay: function(title) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = title;
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      return overlay;
    },
  
    createModalSection: function(title, content) {
      const section = document.createElement('div');
      section.className = 'modal-section';
  
      const titleRow = document.createElement('div');
      titleRow.className = 'modal-section-title-row';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-section-title';
      titleEl.textContent = title;
  
      const copyBtn = document.createElement('button');
      copyBtn.className = 'modal-section-copy-btn';
      copyBtn.textContent = 'Copy';
      copyBtn.onclick = () => this.copySectionContent(content, copyBtn);
  
      titleRow.appendChild(titleEl);
      titleRow.appendChild(copyBtn);
  
      const contentEl = document.createElement('div');
      contentEl.className = 'modal-section-content';
      contentEl.textContent = content;
  
      section.appendChild(titleRow);
      section.appendChild(contentEl);
  
      return section;
    },
  
    copySectionContent: function(content, button) {
      navigator.clipboard.writeText(content).then(() => {
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.style.backgroundColor = 'var(--color-gold)';
        button.style.color = 'var(--color-bg-primary)';
  
        setTimeout(() => {
          button.textContent = originalText;
          button.style.backgroundColor = '';
          button.style.color = '';
        }, 2000);
      }).catch(err => {
        const diagnostics = window.module['diagnostics.js'];
        diagnostics.log('ui', 'Failed to copy: ' + err);
        button.textContent = 'Failed';
        setTimeout(() => {
          button.textContent = 'Copy';
        }, 2000);
      });
    },
  
    showAssistantMessageModal: function(message) {
      const apiData = message.apiData;
  
      const overlay = this.createModalOverlay('Assistant Message Details');
      const body = overlay.querySelector('.modal-body');
  
      if (!apiData) {
        // No API data available (e.g., initial greeting)
        const noDataSection = this.createModalSection(
          'No API Data',
          'No API interaction data available for this message'
        );
        body.appendChild(noDataSection);
      } else {
        // Input: Full API request body (stored at time of request)
        if (apiData.inputFull) {
          const inputSection = this.createModalSection(
            'Input',
            JSON.stringify(apiData.inputFull, null, 2)
          );
          body.appendChild(inputSection);
        }
  
        // Output: Full API response
        if (apiData.output) {
          const outputSection = this.createModalSection(
            'Output',
            JSON.stringify(apiData.output, null, 2)
          );
          body.appendChild(outputSection);
        }
      }
  
      document.body.appendChild(overlay);
    },
  
    // Calculate messages size in tokens
    calculateMessagesSize: function() {
      const state = window.module['state.js'];
      return state.calculateTokens();
    },
  
    // Format size in K (1K = 1000 tokens)
    formatSize: function(tokens) {
      const k = Math.ceil(tokens / 1000);
      return k + 'K';
    },
  
    // Update context stats display
    updateContextStats: function() {
      const messagesBtn = document.getElementById('messages-stat-btn');
  
      if (!messagesBtn) {
        return;
      }
  
      const tokens = this.calculateMessagesSize();
  
      messagesBtn.textContent = this.formatSize(tokens);
    },
  
    // Show clear confirmation modal
    showClearModal: function(contextType) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = 'Clear Messages';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      const message = document.createElement('div');
      message.style.marginBottom = '20px';
      message.style.color = 'var(--color-text-primary)';
      message.textContent = 'Are you sure you want to clear all messages? This will reset the conversation history (except the initial greeting).';
  
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.justifyContent = 'flex-end';
  
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.style.background = 'var(--color-bg-primary)';
      cancelBtn.style.border = '1px solid var(--color-border)';
      cancelBtn.style.color = 'var(--color-text-primary)';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      cancelBtn.onclick = () => overlay.remove();
  
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'Clear';
      confirmBtn.style.padding = '8px 16px';
      confirmBtn.style.background = 'var(--color-gold)';
      confirmBtn.style.border = 'none';
      confirmBtn.style.color = 'var(--color-bg-primary)';
      confirmBtn.style.cursor = 'pointer';
      confirmBtn.style.borderRadius = '4px';
      confirmBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      confirmBtn.style.fontWeight = 'bold';
      confirmBtn.onclick = () => {
        this.clearContext(contextType);
        overlay.remove();
      };
  
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(confirmBtn);
  
      body.appendChild(message);
      body.appendChild(buttonContainer);
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    },
  
    // Clear context
    clearContext: function(contextType) {
      const state = window.module['state.js'];
      state.clearMessages();
  
      // Update UI
      this.renderMessages(state.getMessages());
      this.updateContextStats();
    },
  
    // Show context management modal (new)
    showContextModal: function() {
      const state = window.module['state.js'];
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = 'Context Management';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      // Current stats
      const statsDiv = document.createElement('div');
      statsDiv.style.marginBottom = '20px';
      statsDiv.style.color = 'var(--color-text-primary)';
      const currentTokens = state.calculateTokens();
      const currentLimit = state.getContextLimit();
      statsDiv.innerHTML = `Current: <strong>${this.formatSize(currentTokens)}</strong> / ${this.formatSize(currentLimit)}`;
  
      // Context limit input
      const limitLabel = document.createElement('div');
      limitLabel.style.marginBottom = '8px';
      limitLabel.style.color = 'var(--color-text-primary)';
      limitLabel.textContent = 'Context limit (tokens):';
  
      const limitInput = document.createElement('input');
      limitInput.type = 'number';
      limitInput.value = currentLimit;
      limitInput.min = '1000';
      limitInput.step = '1000';
      limitInput.style.width = '100%';
      limitInput.style.padding = '8px';
      limitInput.style.marginBottom = '20px';
      limitInput.style.background = 'var(--color-bg-primary)';
      limitInput.style.border = '1px solid var(--color-border)';
      limitInput.style.color = 'var(--color-text-primary)';
      limitInput.style.borderRadius = '4px';
      limitInput.style.fontSize = '14px';
      limitInput.style.fontFamily = "'Consolas', 'Courier New', monospace";
  
      // Buttons
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.justifyContent = 'flex-end';
      buttonContainer.style.marginTop = '20px';
  
      const clearBtn = document.createElement('button');
      clearBtn.textContent = 'Clear All';
      clearBtn.style.padding = '8px 16px';
      clearBtn.style.background = 'var(--color-bg-primary)';
      clearBtn.style.border = '1px solid #ff6b6b';
      clearBtn.style.color = '#ff6b6b';
      clearBtn.style.cursor = 'pointer';
      clearBtn.style.borderRadius = '4px';
      clearBtn.style.fontSize = '14px';
      clearBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      clearBtn.style.marginRight = 'auto';
      clearBtn.onclick = () => {
        if (confirm('Are you sure you want to clear all messages?')) {
          state.clearMessages();
          this.renderMessages(state.getMessages());
          this.updateContextStats();
          overlay.remove();
        }
      };
  
      const compactBtn = document.createElement('button');
      compactBtn.textContent = 'Compact Now';
      compactBtn.style.padding = '8px 16px';
      compactBtn.style.background = 'var(--color-bg-primary)';
      compactBtn.style.border = '1px solid var(--color-gold)';
      compactBtn.style.color = 'var(--color-gold)';
      compactBtn.style.cursor = 'pointer';
      compactBtn.style.borderRadius = '4px';
      compactBtn.style.fontSize = '14px';
      compactBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      compactBtn.onclick = async () => {
        compactBtn.disabled = true;
        compactBtn.textContent = 'Compacting...';
        try {
          const main = window.module['main.js'];
          await main.compactContext();
          this.renderMessages(state.getMessages());
          this.updateContextStats();
          // Update stats display in modal
          statsDiv.innerHTML = `Current: <strong>${this.formatSize(state.calculateTokens())}</strong> / ${this.formatSize(state.getContextLimit())}`;
          compactBtn.textContent = 'Compacted!';
          setTimeout(() => {
            compactBtn.textContent = 'Compact Now';
            compactBtn.disabled = false;
          }, 2000);
        } catch (error) {
          compactBtn.textContent = 'Error';
          setTimeout(() => {
            compactBtn.textContent = 'Compact Now';
            compactBtn.disabled = false;
          }, 2000);
        }
      };
  
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.style.background = 'var(--color-bg-primary)';
      cancelBtn.style.border = '1px solid var(--color-border)';
      cancelBtn.style.color = 'var(--color-text-primary)';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      cancelBtn.onclick = () => overlay.remove();
  
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'Save Limit';
      saveBtn.style.padding = '8px 16px';
      saveBtn.style.background = 'var(--color-gold)';
      saveBtn.style.border = 'none';
      saveBtn.style.color = 'var(--color-bg-primary)';
      saveBtn.style.cursor = 'pointer';
      saveBtn.style.borderRadius = '4px';
      saveBtn.style.fontSize = '14px';
      saveBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      saveBtn.style.fontWeight = 'bold';
      saveBtn.onclick = async () => {
        const newLimit = parseInt(limitInput.value);
        if (newLimit && newLimit >= 1000) {
          state.setContextLimit(newLimit);
  
          // If new limit is lower than current usage, trigger compaction
          if (currentTokens > newLimit) {
            const main = window.module['main.js'];
            await main.compactContext();
            this.renderMessages(state.getMessages());
          }
  
          this.updateContextStats();
          overlay.remove();
        } else {
          alert('Please enter a valid limit (minimum 1000 tokens)');
        }
      };
  
      buttonContainer.appendChild(clearBtn);
      buttonContainer.appendChild(compactBtn);
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(saveBtn);
  
      body.appendChild(statsDiv);
      body.appendChild(limitLabel);
      body.appendChild(limitInput);
      body.appendChild(buttonContainer);
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
