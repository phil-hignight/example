// AI Agent - Built 2025-11-20T17:49:55.694Z
(function() {
  window.module = {};

  // Module: api.js
  // API communication
  window.module['api.js'] = {
    // Render messages for API - simplified version
    renderMessagesForAPI: function(messages) {
      const tools = window.module['tools.js'];
      const state = window.module['state.js'];
  
      console.log('[API INPUT] Total messages:', messages.length);
  
      // Filter out UI-only messages
      const apiMessages = messages.filter(msg => !msg.uiOnly);
  
      console.log('[API INPUT] After UI filtering:', apiMessages.length);
  
      // Log total size estimate and find largest messages
      const totalChars = messages.reduce((sum, msg) => sum + (msg.content?.length || 0), 0);
      const estimatedTokens = Math.ceil(totalChars / 4);
      console.log('[API INPUT SIZE] Total characters in all messages:', totalChars);
      console.log('[API INPUT SIZE] Estimated tokens (chars/4):', estimatedTokens);
  
      // Find and log the 5 largest messages
      const messagesWithSize = messages.map((msg, idx) => ({
        index: idx,
        role: msg.role,
        toolName: msg.toolName,
        size: msg.content?.length || 0,
        preview: msg.content?.substring(0, 100) || ''
      })).sort((a, b) => b.size - a.size);
  
      console.log('[API LARGEST MESSAGES] Top 5 largest messages:');
      for (let i = 0; i < Math.min(5, messagesWithSize.length); i++) {
        const m = messagesWithSize[i];
        console.log(`  ${i+1}. Index ${m.index}, Role: ${m.role}${m.toolName ? ' ('+m.toolName+')' : ''}, Size: ${m.size} chars, Preview: "${m.preview}..."`);
      }
  
      // If a summary exists, only include messages from last summary forward
      const lastSummaryIndex = state.getLastSummaryIndex();
      let messagesToProcess = apiMessages;
      let summaryContent = null;
  
      if (lastSummaryIndex !== -1) {
        // Find the summary message
        summaryContent = messages[lastSummaryIndex].content;
  
        // Filter to only messages after the summary (excluding the summary itself)
        messagesToProcess = apiMessages.filter((msg, index) => {
          const originalIndex = messages.findIndex(m => m === messages[index]);
          return originalIndex > lastSummaryIndex;
        });
  
        console.log('[API] Found summary at index', lastSummaryIndex);
        console.log('[API] Using', messagesToProcess.length, 'messages after summary');
      }
  
      // Convert messages for API: tool-use and tool-result become user messages
      // Combine consecutive user messages
      const processedMessages = [];
  
      for (let i = 0; i < messagesToProcess.length; i++) {
        const msg = messagesToProcess[i];
  
        // Convert tool-use and tool-result to user role
        if (msg.role === 'tool-use' || msg.role === 'tool-result') {
          const userContent = msg.content;
  
          // Check if previous message was also a user message
          if (processedMessages.length > 0 && processedMessages[processedMessages.length - 1].role === 'user') {
            // Combine with previous user message
            processedMessages[processedMessages.length - 1].content += '\n\n' + userContent;
          } else {
            // Create new user message
            processedMessages.push({
              role: 'user',
              content: userContent
            });
          }
        } else {
          // Regular user or assistant message
          const newMsg = {
            role: msg.role,
            content: msg.content
          };
  
          // Check if we need to combine consecutive user messages
          if (newMsg.role === 'user' && processedMessages.length > 0 && processedMessages[processedMessages.length - 1].role === 'user') {
            // Combine with previous user message
            processedMessages[processedMessages.length - 1].content += '\n\n' + newMsg.content;
          } else {
            processedMessages.push(newMsg);
          }
        }
      }
  
      console.log('[API] Sending', processedMessages.length, 'messages to API');
  
      return {
        messages: processedMessages,
        summary: summaryContent
      };
    },
  
    // Handle truncated responses by requesting continuations
    handleTruncatedResponse: async function(initialResponseText, headers, requestBody, startTime) {
      const TERMINATOR = '||||END||||';
      const MAX_CONTINUATIONS = 20;
      const TAIL_LENGTH = 20;
  
      let fullResponse = initialResponseText;
      let continuationCount = 0;
      let lastChunk = null;
      let incomplete = false;
      let incompleteReason = null;
  
      console.log('[API] Response missing terminator - handling truncation');
  
      while (!fullResponse.includes(TERMINATOR) && continuationCount < MAX_CONTINUATIONS) {
        continuationCount++;
        console.log(`[API] Requesting continuation ${continuationCount}/${MAX_CONTINUATIONS}`);
  
        // Get last TAIL_LENGTH characters
        const tail = fullResponse.slice(-TAIL_LENGTH);
        console.log(`[API] Tail (last ${TAIL_LENGTH} chars): "${tail}"`);
  
        // Create continuation prompt
        const continuationMessages = [
          ...requestBody.messages,
          {
            role: 'assistant',
            content: fullResponse
          },
          {
            role: 'user',
            content: `Your response was truncated. The last ${TAIL_LENGTH} characters were: "${tail}". Continue from exactly the next character. When done, end with ||||END||||`
          }
        ];
  
        const continuationBody = {
          ...requestBody,
          messages: continuationMessages
        };
  
        try {
          // Make continuation request
          const response = await fetch('/api/chat/completions', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(continuationBody)
          });
  
          if (!response.ok) {
            const errorText = await response.text();
            console.warn(`[API] Continuation request failed (${response.status}): ${errorText}`);
            incomplete = true;
            incompleteReason = `Continuation request failed (${response.status})`;
            break;
          }
  
          const data = await response.json();
          const chunk = data.choices[0].message.content;
          console.log(`[API] Chunk received (first 100 chars): "${chunk.substring(0, 100)}"`);
  
          // Handle blank response
          if (!chunk || chunk.trim() === '') {
            console.log('[API] Received blank continuation - stopping');
            incomplete = true;
            incompleteReason = 'Received blank continuation response';
            break;
          }
  
          // Check for duplicate chunks (AI repeating itself)
          if (lastChunk && chunk === lastChunk) {
            console.warn('[API] AI is repeating the same chunk - aborting continuation');
            incomplete = true;
            incompleteReason = 'AI is repeating the same content';
            break;
          }
          lastChunk = chunk;
  
          // If AI just sends terminator, it means previous response was complete
          if (chunk.trim() === TERMINATOR) {
            console.log('[API] AI confirmed completion with terminator');
            fullResponse += TERMINATOR;
            break;
          }
  
          // Check if the continuation starts with part of the tail (overlap detection)
          // The AI might repeat some characters to ensure continuity
          let chunkToAdd = chunk;
          let overlapFound = false;
          for (let overlapLen = TAIL_LENGTH; overlapLen > 0; overlapLen--) {
            const tailEnd = tail.slice(-overlapLen);
            const chunkStart = chunk.slice(0, overlapLen);
            if (tailEnd === chunkStart) {
              // Found overlap - remove it from the chunk
              chunkToAdd = chunk.slice(overlapLen);
              console.log(`[API] Detected ${overlapLen} char overlap: "${tailEnd}"`);
              overlapFound = true;
              break;
            }
          }
  
          if (!overlapFound) {
            console.log(`[API] No overlap detected between tail and chunk start`);
          }
  
          console.log(`[API] Received continuation chunk: ${chunk.length} chars (${chunkToAdd.length} after overlap removal)`);
          fullResponse += chunkToAdd;
        } catch (error) {
          console.warn(`[API] Error during continuation: ${error.message}`);
          incomplete = true;
          incompleteReason = error.message;
          break;
        }
      }
  
      if (continuationCount >= MAX_CONTINUATIONS) {
        console.warn(`[API] Exceeded maximum continuation attempts (${MAX_CONTINUATIONS})`);
        incomplete = true;
        incompleteReason = `Exceeded maximum continuation attempts (${MAX_CONTINUATIONS})`;
      }
  
      const endTime = Date.now();
      const durationSeconds = (endTime - startTime) / 1000;
  
      if (incomplete) {
        console.log(`[API] Returning incomplete response after ${continuationCount} continuations. Reason: ${incompleteReason}`);
      } else {
        console.log(`[API] Complete response assembled after ${continuationCount} continuations`);
      }
  
      return {
        fullResponse: fullResponse,
        durationSeconds: durationSeconds,
        incomplete: incomplete,
        incompleteReason: incompleteReason
      };
    },
  
    callAPI: async function(messages, maxRetries = 3) {
      const authToken = localStorage.getItem('token');
      const tools = window.module['tools.js'];
      const TERMINATOR = '||||END||||';
  
      const result = this.renderMessagesForAPI(messages);
      const processedMessages = result.messages;
      const summary = result.summary;
  
      // Build system prompt
      let systemPrompt = tools.getSystemPrompt();
  
      // If summary exists, append it to system prompt
      if (summary) {
        systemPrompt += "\n\n=== Summary of Earlier Conversation ===\n\n" + summary;
        console.log('[API] Appending summary to system prompt');
      }
  
      // Prepend system prompt to first user message (prod API doesn't support system field)
      const messagesWithSystem = [...processedMessages];
      if (messagesWithSystem.length > 0) {
        messagesWithSystem[0] = {
          ...messagesWithSystem[0],
          content: systemPrompt + "\n\n" + messagesWithSystem[0].content
        };
      }
  
      const requestBody = {
        stream: false,
        model: 'Anthropic Claude 4 Sonnet',
        messages: messagesWithSystem,
        // Note: Removed 'system' field - prod API doesn't support it
        // Note: Removed 'tools' field - prod API doesn't support native tools
        params: {},
        features: {
          web_search: false
        },
        session_id: 'session-' + Math.random().toString(36).substr(2, 9),
        id: 'msg-' + Date.now() + '-assistant',
        background_tasks: {
          title_generation: false,
          tags_generation: false
        }
      };
  
      // Log request body size
      const requestBodyString = JSON.stringify(requestBody);
      const requestBodySize = requestBodyString.length;
      const requestBodyTokens = Math.ceil(requestBodySize / 4);
  
      console.log('[API] ========================================');
      console.log('[API REQUEST] REQUEST SUMMARY:');
      console.log('[API] ========================================');
      console.log('  - System prompt length:', systemPrompt.length);
      console.log('  - Messages count:', messagesWithSystem.length);
      console.log('  - Tools: list_directory, read_file, write_file');
      if (summary) {
        console.log('  - Summary included: YES (' + summary.length + ' chars)');
      }
      console.log('[API REQUEST SIZE] Request body size:', requestBodySize, 'chars');
      console.log('[API REQUEST SIZE] Request body estimated tokens:', requestBodyTokens);
      console.log('[API]');
      console.log('[API] FULL REQUEST BODY:');
      console.log('[API] ========================================');
      console.log(JSON.stringify(requestBody, null, 2));
      console.log('[API] ========================================');
  
      const headers = {
        'Content-Type': 'application/json'
      };
  
      if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
      }
  
      let lastError = null;
  
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const startTime = Date.now();
          const response = await fetch('/api/chat/completions', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
          });
  
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[API ERROR] ========================================');
            console.error('[API ERROR] API REQUEST FAILED');
            console.error('[API ERROR] ========================================');
            console.error('[API ERROR] Status code:', response.status);
            console.error('[API ERROR] Status text:', response.statusText);
            console.error('[API ERROR] Error response length:', errorText.length, 'chars');
            console.error('[API ERROR] Error response:', errorText);
            console.error('[API ERROR] ========================================');
            throw new Error(`API request failed (${response.status}): ${errorText}`);
          }
  
          const data = await response.json();
          let responseText = data.choices[0].message.content;
          let durationSeconds = (Date.now() - startTime) / 1000;
  
          // Log response size details
          const responseDataString = JSON.stringify(data);
          const responseDataSize = responseDataString.length;
          const responseTokens = Math.ceil(responseText.length / 4);
  
          console.log('[API]');
          console.log('[API] ========================================');
          console.log('[API RESPONSE] FULL API RESPONSE:');
          console.log('[API] ========================================');
          console.log(JSON.stringify(data, null, 2));
          console.log('[API] ========================================');
          console.log('[API RESPONSE SIZE] Response text length:', responseText.length, 'chars');
          console.log('[API RESPONSE SIZE] Response estimated tokens:', responseTokens);
          console.log('[API RESPONSE SIZE] Full response data size:', responseDataSize, 'chars');
          console.log('[API RESPONSE SIZE] Request duration:', durationSeconds.toFixed(2), 'seconds');
          console.log('[API] ========================================');
  
          // Check for terminator
          let wasIncomplete = false;
          let incompleteReason = null;
          if (!responseText.includes(TERMINATOR)) {
            // Handle truncation
            const result = await this.handleTruncatedResponse(responseText, headers, requestBody, startTime);
            responseText = result.fullResponse;
            durationSeconds = result.durationSeconds;
            wasIncomplete = result.incomplete;
            incompleteReason = result.incompleteReason;
          }
  
          // Remove terminator before parsing
          responseText = responseText.replace(TERMINATOR, '').trim();
  
          // Parse and validate response
          const parseResult = tools.parseResponse(responseText);
  
          if (!parseResult.valid) {
            lastError = parseResult.error;
            console.warn(`Attempt ${attempt + 1}/${maxRetries} - Invalid response: ${parseResult.error}`);
            console.warn(`Raw response text:`, responseText.substring(0, 500));
  
            // If response was incomplete, include that info in the error
            let errorMessage = parseResult.error;
            if (wasIncomplete) {
              errorMessage += ` (Response was incomplete: ${incompleteReason})`;
            }
  
            // On validation errors, return immediately with error details
            // Don't retry - let the main loop provide feedback to AI
            return {
              text: responseText,
              parsed: null,
              valid: false,
              error: errorMessage,
              apiInput: processedMessages,
              apiInputFull: requestBody,
              apiOutput: data,
              durationSeconds: durationSeconds,
              incomplete: wasIncomplete,
              incompleteReason: incompleteReason
            };
          }
  
          // Return both raw text and parsed response
          return {
            text: responseText,
            parsed: parseResult.valid ? parseResult.parsed : null,
            valid: parseResult.valid,
            error: parseResult.valid ? null : parseResult.error,
            apiInput: processedMessages,  // Store input messages for debugging
            apiInputFull: requestBody,  // Store FULL request body that was actually sent
            apiOutput: data,  // Store full API response for debugging
            durationSeconds: durationSeconds
          };
        } catch (error) {
          lastError = error.message;
          console.error('[API ERROR] ========================================');
          console.error('[API ERROR] EXCEPTION DURING API CALL');
          console.error('[API ERROR] ========================================');
          console.error('[API ERROR] Attempt:', `${attempt + 1}/${maxRetries}`);
          console.error('[API ERROR] Error message:', error.message);
          console.error('[API ERROR] Error stack:', error.stack);
          console.error('[API ERROR] ========================================');
  
          if (attempt < maxRetries - 1) {
            console.log('[API ERROR] Retrying...');
            continue;
          }
        }
      }
  
      // All retries failed
      throw new Error(`Failed after ${maxRetries} attempts. Last error: ${lastError}`);
    }
  };
  

  // Module: core.js
  // Core AI agent logic (UI-independent)
  // This module contains all the logic that can run without DOM/browser UI
  window.module['core.js'] = {
    // Process AI response loop (without UI calls)
    processAIResponse: async function(getMessages, addMessage, selectedDirectory, callbacks = {}) {
      const api = window.module['api.js'];
      const {
        onLoading = () => {},
        onHideLoading = () => {},
        onRenderMessages = () => {},
        onUpdateStats = () => {},
        onProcessingChange = () => {},
        onAfterTools = async () => {}  // Callback after tools execute (for compaction check)
      } = callbacks;
  
      let continueProcessing = true;
      let iteration = 0;
      let consecutiveErrors = 0;
      const MAX_RETRIES = 3;
  
      while (continueProcessing) {
        iteration++;
        console.log('='.repeat(80));
        console.log(`[Core] ========== ITERATION ${iteration} START ==========`);
        console.log('[Core] Total messages:', getMessages().length);
  
        // Send to API
        const response = await api.callAPI(getMessages());
  
        // Remove loading indicator
        onHideLoading();
  
        if (!response.valid) {
          // Invalid response - provide detailed feedback to AI
          console.error('[Core] Invalid response:', response.error);
          consecutiveErrors++;
          console.log(`[Core] Consecutive errors: ${consecutiveErrors}/${MAX_RETRIES}`);
  
          // Only show error to user if we've exceeded retry limit
          if (consecutiveErrors >= MAX_RETRIES) {
            console.error('[Core] Max retries exceeded, showing error to user');
            addMessage({
              role: 'assistant',
              content: `Error: Invalid response after ${MAX_RETRIES} attempts - ${response.error}`
            });
            onRenderMessages();
            onProcessingChange(false);
            return { success: false, error: response.error, iterations: iteration };
          }
  
          // Send error feedback to AI
          let errorFeedback = `ERROR: Your response was invalid. Error: "${response.error}"\n\n`;
          errorFeedback += `Your response was:\n${response.text.substring(0, 300)}${response.text.length > 300 ? '...' : ''}\n\n`;
          errorFeedback += `Please provide a valid JSON response.`;
  
          addMessage({
            role: 'user',
            content: errorFeedback,
            fromSystem: true
          });
  
          onLoading();
          continue;
        }
  
        // Reset error counter on successful response
        consecutiveErrors = 0;
  
        const parsedResponse = response.parsed;
  
        if (parsedResponse.type === 'message') {
          // Final message response
          console.log('[Core] ========== MESSAGE RESPONSE ==========');
  
          addMessage({
            role: 'assistant',
            content: parsedResponse.content,
            apiData: {
              input: response.apiInput,
              inputFull: response.apiInputFull,
              output: response.apiOutput,
              rawResponse: response.text
            },
            durationSeconds: response.durationSeconds
          });
          onRenderMessages();
          onUpdateStats();
          continueProcessing = false;
        } else if (parsedResponse.type === 'execute') {
          console.log('[Core] ========== EXECUTE RESPONSE ==========');
          console.log('[Core] AI requested', parsedResponse.tool_uses.length, 'tool(s)');
  
          // Add assistant message with API data
          addMessage({
            role: 'assistant',
            content: response.text,
            apiData: {
              input: response.apiInput,
              inputFull: response.apiInputFull,
              output: response.apiOutput,
              rawResponse: response.text
            },
            durationSeconds: response.durationSeconds
          });
  
          // Execute all tools
          await this.executeTools(parsedResponse.tool_uses, selectedDirectory, addMessage, onRenderMessages);
  
          // Check if compaction is needed after tools added results
          await onAfterTools();
  
          onUpdateStats();
          onLoading();
          continue;
        }
      }
  
      console.log('[Core] Processing complete after', iteration, 'iterations');
      return { success: true, iterations: iteration };
    },
  
    // Truncate tool output if it exceeds size limit
    truncateToolOutput: function(content, toolName, maxTokens = 2500) {
      const state = window.module['state.js'];
      const limit = state.getContextLimit();
      const maxChars = maxTokens * 4; // 4 chars per token estimate
  
      if (content.length <= maxChars) {
        return content;
      }
  
      const truncated = content.substring(0, maxChars);
      const remaining = content.length - maxChars;
      const remainingTokens = Math.ceil(remaining / 4);
  
      return truncated + `\n\n[... Output truncated. ${remainingTokens} more tokens (${remaining} chars) omitted. If you need the full output, run ${toolName} again with more specific parameters to reduce output size.]`;
    },
  
    // Execute tools (unified handler for all tools) - UI-independent
    executeTools: async function(toolUses, selectedDirectory, addMessage, onRenderMessages = () => {}) {
      for (const toolUse of toolUses) {
        if (toolUse.name === 'list_directory') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'list_directory',
            params: toolUse.input,
            content: `list_directory ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeListDirectory(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            // Count entries
            const lines = result.output.split('\n');
            const dirCount = lines.filter(l => l.includes('ðŸ“')).length;
            const fileCount = lines.filter(l => l.includes('ðŸ“„')).length;
            const total = dirCount + fileCount;
  
            addMessage({
              role: 'tool-result',
              toolName: 'list_directory',
              summary: `Listed ${total} items (${dirCount} folders, ${fileCount} files)`,
              fullResult: result.output,
              content: `Tool result for list_directory("${toolUse.input.path}"):\n\n${result.output}`
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'list_directory',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Tool error for list_directory("${toolUse.input.path}"): ${result.error}`
            });
          }
        } else if (toolUse.name === 'read_file') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'read_file',
            params: toolUse.input,
            content: `read_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeReadFile(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            const lineCount = result.content.split('\n').length;
            const truncatedContent = this.truncateToolOutput(result.content, 'read_file');
            const wasTruncated = truncatedContent.length < result.content.length;
  
            addMessage({
              role: 'tool-result',
              toolName: 'read_file',
              summary: `Read ${lineCount} lines from ${result.path}${wasTruncated ? ' (truncated)' : ''}`,
              fullResult: result.content,
              content: `File: ${result.path}\n\n${truncatedContent}`,
              truncated: wasTruncated
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'read_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error reading file ${result.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'write_file') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'write_file',
            params: toolUse.input,
            content: `write_file ${JSON.stringify({ path: toolUse.input.path, content: `(${toolUse.input.content.length} chars)` })}`
          });
  
          const result = await this.executeWriteFile(toolUse.input.path, toolUse.input.content, selectedDirectory);
  
          if (result.success) {
            addMessage({
              role: 'tool-result',
              toolName: 'write_file',
              summary: `Wrote ${toolUse.input.content.length} characters to ${result.path}`,
              fullResult: `Successfully wrote to ${result.path}`,
              content: `Successfully wrote ${toolUse.input.content.length} characters to ${result.path}`
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'write_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error writing file ${result.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'search_by_filename') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'search_by_filename',
            params: toolUse.input,
            content: `search_by_filename ${JSON.stringify(toolUse.input)}`
          });
  
          const searchPath = toolUse.input.path || '.';
          const result = await this.executeSearchByFilename(toolUse.input.pattern, searchPath, selectedDirectory);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
  
            addMessage({
              role: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Found ${matchCount} file(s) matching "${toolUse.input.pattern}"${timeoutWarning}`,
              fullResult: result.output,
              content: `Search results for pattern "${toolUse.input.pattern}" in "${searchPath}":\n\n${result.output}`
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching for files: ${result.error}`
            });
          }
        } else if (toolUse.name === 'search_by_content') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'search_by_content',
            params: toolUse.input,
            content: `search_by_content ${JSON.stringify(toolUse.input)}`
          });
  
          const searchPath = toolUse.input.path || '.';
          const filePattern = toolUse.input.filePattern || null;
          const result = await this.executeSearchByContent(toolUse.input.text, searchPath, filePattern, selectedDirectory);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
  
            addMessage({
              role: 'tool-result',
              toolName: 'search_by_content',
              summary: `Found ${matchCount} match(es) for "${toolUse.input.text}"${timeoutWarning}`,
              fullResult: result.output,
              content: `Search results for text "${toolUse.input.text}" in "${searchPath}":\n\n${result.output}`
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'search_by_content',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching file contents: ${result.error}`
            });
          }
        } else if (toolUse.name === 'edit_file') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'edit_file',
            params: toolUse.input,
            content: `edit_file ${JSON.stringify({ path: toolUse.input.path, find: `(${toolUse.input.find.length} chars)`, replace: `(${toolUse.input.replace.length} chars)` })}`
          });
  
          const result = await this.executeEditFile(toolUse.input.path, toolUse.input.find, toolUse.input.replace, selectedDirectory);
  
          if (result.success) {
            addMessage({
              role: 'tool-result',
              toolName: 'edit_file',
              summary: `Edited ${result.path}: replaced ${toolUse.input.find.length} chars with ${toolUse.input.replace.length} chars`,
              fullResult: `Successfully edited ${result.path}`,
              content: `Successfully edited ${result.path}`
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'edit_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error editing file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'edit_file_batch') {
          // Add tool use message
          addMessage({
            role: 'tool-use',
            toolName: 'edit_file_batch',
            params: toolUse.input,
            content: `edit_file_batch ${JSON.stringify({ path: toolUse.input.path, edits: `(${toolUse.input.edits.length} edits)` })}`
          });
  
          const result = await this.executeEditFileBatch(toolUse.input.path, toolUse.input.edits, selectedDirectory);
  
          if (result.success) {
            addMessage({
              role: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Batch edited ${result.path}: applied ${toolUse.input.edits.length} edit(s)`,
              fullResult: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`,
              content: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`
            });
          } else {
            addMessage({
              role: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error batch editing file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else {
          // Unknown tool
          addMessage({
            role: 'user',
            content: `ERROR: Unknown tool "${toolUse.name}". Available tools are: list_directory, read_file, write_file, search_by_filename, search_by_content, edit_file, edit_file_batch.`,
            fromSystem: true
          });
          console.warn(`[Core] Unknown tool: ${toolUse.name}`);
        }
      }
  
      onRenderMessages();
    },
  
    // Execute file operations using FileSystem API
    executeListDirectory: async function(path, dirHandle) {
      try {
        let targetHandle = dirHandle;
  
        // Navigate to the target path if not root
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // List directory contents
        const entries = [];
        for await (const entry of targetHandle.values()) {
          entries.push({
            name: entry.name,
            kind: entry.kind
          });
        }
  
        // Format output
        let output = `Contents of "${path || '.'}":\n\n`;
        const dirs = entries.filter(e => e.kind === 'directory').sort((a, b) => a.name.localeCompare(b.name));
        const files = entries.filter(e => e.kind === 'file').sort((a, b) => a.name.localeCompare(b.name));
  
        if (dirs.length > 0) {
          output += 'Directories:\n';
          dirs.forEach(d => {
            output += `  ðŸ“ ${d.name}/\n`;
          });
        }
  
        if (files.length > 0) {
          output += '\nFiles:\n';
          files.forEach(f => {
            output += `  ðŸ“„ ${f.name}\n`;
          });
        }
  
        if (entries.length === 0) {
          output += '(empty directory)\n';
        }
  
        return { success: true, output };
      } catch (error) {
        return { success: false, error: error.message };
      }
    },
  
    executeReadFile: async function(path, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory
        for (let i = 0; i < pathParts.length - 1; i++) {
          currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
        }
  
        // Get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName);
        const file = await fileHandle.getFile();
        const content = await file.text();
  
        return { success: true, content, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeWriteFile: async function(path, content, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory (create if doesn't exist)
        for (let i = 0; i < pathParts.length - 1; i++) {
          try {
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
          } catch {
            // Directory doesn't exist, create it
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i], { create: true });
          }
        }
  
        // Create or get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
  
        // Write content
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        return { success: true, path };
      } catch (error) {
        // Check if it's a user activation error
        if (error.message && error.message.includes('User activation is required')) {
          return {
            success: false,
            error: `Cannot create new directories due to browser security. Please manually create the parent directory first, then try again.`,
            path
          };
        }
        return { success: false, error: error.message, path };
      }
    },
  
    // Helper function to match wildcard pattern
    matchesPattern: function(filename, pattern) {
      // Convert wildcard pattern to regex
      // * matches any characters, ? matches single character
      const regexPattern = pattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&')  // Escape special regex chars
        .replace(/\*/g, '.*')  // * becomes .*
        .replace(/\?/g, '.');  // ? becomes .
  
      const regex = new RegExp(`^${regexPattern}$`, 'i');  // Case-insensitive
      return regex.test(filename);
    },
  
    // Recursively search for files by filename pattern
    executeSearchByFilename: async function(pattern, path, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if filename matches pattern
              if (window.module['core.js'].matchesPattern(entry.name, pattern)) {
                matches.push(entryPath);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          console.warn(`[Search] Error accessing ${currentPath}:`, error.message);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No files found matching the pattern.';
        } else {
          output = matches.map(m => `ðŸ“„ ${m}`).join('\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Recursively search for text within file contents
    executeSearchByContent: async function(searchText, path, filePattern, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if file matches filePattern (if provided)
              if (filePattern && !window.module['core.js'].matchesPattern(entry.name, filePattern)) {
                continue;
              }
  
              try {
                // Read file and search for text
                const file = await entry.getFile();
                const content = await file.text();
  
                if (content.toLowerCase().includes(searchText.toLowerCase())) {
                  // Find line numbers where text appears
                  const lines = content.split('\n');
                  const matchingLines = [];
  
                  for (let i = 0; i < lines.length; i++) {
                    if (lines[i].toLowerCase().includes(searchText.toLowerCase())) {
                      matchingLines.push({
                        lineNum: i + 1,
                        line: lines[i].trim()
                      });
                    }
                  }
  
                  matches.push({
                    path: entryPath,
                    lineMatches: matchingLines
                  });
                }
              } catch (error) {
                // Skip binary files or files that can't be read as text
                console.warn(`[Search] Could not read ${entryPath}:`, error.message);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          console.warn(`[Search] Error accessing ${currentPath}:`, error.message);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No matches found.';
        } else {
          output = matches.map(match => {
            const header = `ðŸ“„ ${match.path}`;
            const lineInfo = match.lineMatches.slice(0, 5).map(lm =>
              `  Line ${lm.lineNum}: ${lm.line.substring(0, 100)}${lm.line.length > 100 ? '...' : ''}`
            ).join('\n');
            const moreLines = match.lineMatches.length > 5 ? `  ... and ${match.lineMatches.length - 5} more matches` : '';
  
            return `${header}\n${lineInfo}${moreLines ? '\n' + moreLines : ''}`;
          }).join('\n\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or using a file pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    executeEditFile: async function(path, findStr, replaceStr, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.role === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].role === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        const content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file.`,
            path
          };
        }
  
        // 4. Check that find string appears exactly once
        const occurrences = content.split(findStr).length - 1;
        if (occurrences === 0) {
          return {
            success: false,
            error: `Find string not found in file. The file may have changed since you last read it.`,
            path
          };
        } else if (occurrences > 1) {
          return {
            success: false,
            error: `Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
            path
          };
        }
  
        // 5. Perform replacement
        const newContent = content.replace(findStr, replaceStr);
  
        // 6. Write back
        const writeResult = await this.executeWriteFile(path, newContent, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFileBatch: async function(path, edits, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.role === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].role === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        let content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file_batch.`,
            path
          };
        }
  
        // 4. Apply each edit in sequence
        for (let i = 0; i < edits.length; i++) {
          const { find, replace } = edits[i];
  
          // Check that find string appears exactly once in current content
          const occurrences = content.split(find).length - 1;
          if (occurrences === 0) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string not found in file. The file may have changed or earlier edits affected this replacement.`,
              path
            };
          } else if (occurrences > 1) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
              path
            };
          }
  
          // Perform replacement
          content = content.replace(find, replace);
        }
  
        // 5. Write back
        const writeResult = await this.executeWriteFile(path, content, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    }
  };
  

  // Module: main.js
  // Main entry point for the app
  window.module['main.js'] = {
    version: '2.0.0',
  
    run: async function() {
      console.log('[AI Agent] Version:', this.version);
  
      // Get module references
      const state = window.module['state.js'];
      const styles = window.module['styles.js'];
      const ui = window.module['ui.js'];
      const api = window.module['api.js'];
  
      // Clear existing page content
      document.body.innerHTML = '';
  
      // Add styles
      styles.injectStyles();
  
      // Show directory selection screen
      ui.showDirectorySelection(() => this.selectDirectory());
    },
  
    selectDirectory: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      try {
        if (!window.showDirectoryPicker) {
          alert('Your browser does not support the File System Access API. Please use Chrome, Edge, or another compatible browser.');
          return;
        }
  
        const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
        state.setSelectedDirectory(dirHandle);
        this.showChatScreen();
      } catch (error) {
        if (error.name === 'AbortError') {
          // User cancelled the picker
          console.log('Directory selection cancelled');
        } else {
          console.error('Error selecting directory:', error);
          alert('Error selecting directory: ' + error.message);
        }
      }
    },
  
    showChatScreen: function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      const selectedDirectory = state.getState().selectedDirectory;
      ui.showChatScreen(selectedDirectory, () => this.sendMessage());
  
      // Render initial messages (including greeting)
      ui.renderMessages(state.getMessages());
    },
  
    sendMessage: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
      const api = window.module['api.js'];
      const tools = window.module['tools.js'];
  
      const message = ui.getInputValue();
  
      if (!message || state.isProcessing()) {
        return;
      }
  
      // Check if adding this message would exceed context limit
      if (state.wouldExceedLimit(message)) {
        console.log('[Main] Message would exceed limit, compacting context first');
        await this.compactContext();
        ui.renderMessages(state.getMessages());
        ui.updateContextStats();
      }
  
      // Add user message
      state.addMessage({
        role: 'user',
        content: message
      });
  
      // Clear input and reset height
      ui.clearInput();
  
      // Render messages
      ui.renderMessages(state.getMessages());
  
      // Update context stats
      ui.updateContextStats();
  
      // Set processing state
      state.setProcessing(true);
      ui.setInputDisabled(true);
  
      // Show loading indicator
      ui.showLoading();
  
      try {
        await this.processAIResponse();
      } catch (error) {
        ui.hideLoading();
        state.addMessage({
          role: 'assistant',
          content: 'Error: ' + error.message
        });
        ui.renderMessages(state.getMessages());
        ui.updateContextStats();
      } finally {
        state.setProcessing(false);
        ui.setInputDisabled(false);
      }
    },
  
    processAIResponse: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
      const core = window.module['core.js'];
  
      const selectedDirectory = state.getState().selectedDirectory;
  
      // Use core.js for UI-independent processing
      await core.processAIResponse(
        () => state.getMessages(),
        (msg) => state.addMessage(msg),
        selectedDirectory,
        {
          onLoading: () => ui.showLoading(),
          onHideLoading: () => ui.hideLoading(),
          onRenderMessages: () => ui.renderMessages(state.getMessages()),
          onUpdateStats: () => ui.updateContextStats(),
          onProcessingChange: (processing) => state.setProcessing(processing),
          onAfterTools: async () => {
            // Check if context exceeds limit after tool results
            const currentTokens = state.calculateTokens();
            const limit = state.getContextLimit();
            if (currentTokens > limit) {
              console.log(`[Main] Context exceeds limit after tools (${currentTokens} > ${limit}), compacting...`);
              await this.compactContext();
              ui.renderMessages(state.getMessages());
              ui.updateContextStats();
            }
          }
        }
      );
    },
  
    // Truncate tool output if it exceeds size limit (1/8 of context limit = 2500 tokens default)
    truncateToolOutput: function(content, toolName) {
      const state = window.module['state.js'];
      const limit = state.getContextLimit();
      const maxTokens = Math.floor(limit / 8); // 1/8 of limit
      const maxChars = maxTokens * 4; // 4 chars per token estimate
  
      if (content.length <= maxChars) {
        return { content, wasTruncated: false };
      }
  
      const truncated = content.substring(0, maxChars);
      const remaining = content.length - maxChars;
      const remainingTokens = Math.ceil(remaining / 4);
  
      return {
        content: truncated + `\n\n[... Output truncated. ${remainingTokens} more tokens (${remaining} chars) omitted. If you need the full output, run ${toolName} again with more specific parameters to reduce output size.]`,
        wasTruncated: true
      };
    },
  
    // Execute tools (unified handler for all tools)
    executeTools: async function(toolUses, selectedDirectory) {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      for (const toolUse of toolUses) {
        if (toolUse.name === 'list_directory') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'list_directory',
            params: toolUse.input,
            content: `list_directory ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeListDirectory(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            // Count entries
            const lines = result.output.split('\n');
            const dirCount = lines.filter(l => l.includes('ðŸ“')).length;
            const fileCount = lines.filter(l => l.includes('ðŸ“„')).length;
            const total = dirCount + fileCount;
  
            state.addMessage({
              role: 'tool-result',
              toolName: 'list_directory',
              summary: `Listed ${total} items (${dirCount} folders, ${fileCount} files)`,
              fullResult: result.output,
              content: `Tool result for list_directory("${toolUse.input.path}"):\n\n${result.output}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'list_directory',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Tool error for list_directory("${toolUse.input.path}"): ${result.error}`
            });
          }
        } else if (toolUse.name === 'read_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'read_file',
            params: toolUse.input,
            content: `read_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeReadFile(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            const lineCount = result.content.split('\n').length;
  
            state.addMessage({
              role: 'tool-result',
              toolName: 'read_file',
              summary: `Read ${lineCount} lines from ${result.path}`,
              fullResult: result.content,
              content: `File: ${result.path}\n\n${result.content}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'read_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error reading file ${result.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'write_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'write_file',
            params: toolUse.input,
            content: `write_file ${JSON.stringify({ path: toolUse.input.path, content: `(${toolUse.input.content.length} chars)` })}`
          });
  
          const result = await this.executeWriteFile(toolUse.input.path, toolUse.input.content, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'write_file',
              summary: `Wrote ${toolUse.input.content.length} characters to ${result.path}`,
              fullResult: `Successfully wrote to ${result.path}`,
              content: `Successfully wrote ${toolUse.input.content.length} characters to ${result.path}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'write_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error writing file ${result.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'search_by_filename') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'search_by_filename',
            params: toolUse.input,
            content: `search_by_filename ${JSON.stringify(toolUse.input)}`
          });
  
          const searchPath = toolUse.input.path || '.';
          const result = await this.executeSearchByFilename(toolUse.input.pattern, searchPath, selectedDirectory);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
            const truncated = this.truncateToolOutput(result.output, 'search_by_filename');
  
            state.addMessage({
              role: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Found ${matchCount} file(s) matching "${toolUse.input.pattern}"${timeoutWarning}${truncated.wasTruncated ? ' (truncated)' : ''}`,
              fullResult: result.output,
              content: `Search results for pattern "${toolUse.input.pattern}" in "${searchPath}":\n\n${truncated.content}`,
              truncated: truncated.wasTruncated
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching for files: ${result.error}`
            });
          }
        } else if (toolUse.name === 'search_by_content') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'search_by_content',
            params: toolUse.input,
            content: `search_by_content ${JSON.stringify(toolUse.input)}`
          });
  
          const searchPath = toolUse.input.path || '.';
          const filePattern = toolUse.input.filePattern || null;
          const result = await this.executeSearchByContent(toolUse.input.text, searchPath, filePattern, selectedDirectory);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
            const truncated = this.truncateToolOutput(result.output, 'search_by_content');
  
            state.addMessage({
              role: 'tool-result',
              toolName: 'search_by_content',
              summary: `Found ${matchCount} match(es) for "${toolUse.input.text}"${timeoutWarning}${truncated.wasTruncated ? ' (truncated)' : ''}`,
              fullResult: result.output,
              content: `Search results for text "${toolUse.input.text}" in "${searchPath}":\n\n${truncated.content}`,
              truncated: truncated.wasTruncated
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'search_by_content',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching file contents: ${result.error}`
            });
          }
        } else if (toolUse.name === 'edit_file') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'edit_file',
            params: toolUse.input,
            content: `edit_file ${JSON.stringify({ path: toolUse.input.path, find: `(${toolUse.input.find.length} chars)`, replace: `(${toolUse.input.replace.length} chars)` })}`
          });
  
          const result = await this.executeEditFile(toolUse.input.path, toolUse.input.find, toolUse.input.replace, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'edit_file',
              summary: `Edited ${result.path}: replaced ${toolUse.input.find.length} chars with ${toolUse.input.replace.length} chars`,
              fullResult: `Successfully edited ${result.path}`,
              content: `Successfully edited ${result.path}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'edit_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error editing file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'edit_file_batch') {
          // Add tool use message
          state.addMessage({
            role: 'tool-use',
            toolName: 'edit_file_batch',
            params: toolUse.input,
            content: `edit_file_batch ${JSON.stringify({ path: toolUse.input.path, edits: `(${toolUse.input.edits.length} edits)` })}`
          });
  
          const result = await this.executeEditFileBatch(toolUse.input.path, toolUse.input.edits, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              role: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Batch edited ${result.path}: applied ${toolUse.input.edits.length} edit(s)`,
              fullResult: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`,
              content: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`
            });
          } else {
            state.addMessage({
              role: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error batch editing file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else {
          // Unknown tool
          state.addMessage({
            role: 'user',
            content: `ERROR: Unknown tool "${toolUse.name}". Available tools are: list_directory, read_file, write_file, search_by_filename, search_by_content, edit_file, edit_file_batch.`,
            fromSystem: true
          });
          console.warn(`[Main] Unknown tool: ${toolUse.name}`);
        }
      }
  
      ui.renderMessages(state.getMessages());
    },
  
    // Execute file operations using FileSystem API
    executeListDirectory: async function(path, dirHandle) {
      try {
        let targetHandle = dirHandle;
  
        // Navigate to the target path if not root
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // List directory contents
        const entries = [];
        for await (const entry of targetHandle.values()) {
          entries.push({
            name: entry.name,
            kind: entry.kind
          });
        }
  
        // Format output
        let output = `Contents of "${path || '.'}":\n\n`;
        const dirs = entries.filter(e => e.kind === 'directory').sort((a, b) => a.name.localeCompare(b.name));
        const files = entries.filter(e => e.kind === 'file').sort((a, b) => a.name.localeCompare(b.name));
  
        if (dirs.length > 0) {
          output += 'Directories:\n';
          dirs.forEach(d => {
            output += `  ðŸ“ ${d.name}/\n`;
          });
        }
  
        if (files.length > 0) {
          output += '\nFiles:\n';
          files.forEach(f => {
            output += `  ðŸ“„ ${f.name}\n`;
          });
        }
  
        if (entries.length === 0) {
          output += '(empty directory)\n';
        }
  
        return { success: true, output };
      } catch (error) {
        return { success: false, error: error.message };
      }
    },
  
    executeReadFile: async function(path, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory
        for (let i = 0; i < pathParts.length - 1; i++) {
          currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
        }
  
        // Get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName);
        const file = await fileHandle.getFile();
        const content = await file.text();
  
        return { success: true, content, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeWriteFile: async function(path, content, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory (create if doesn't exist)
        for (let i = 0; i < pathParts.length - 1; i++) {
          try {
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
          } catch {
            // Directory doesn't exist, create it
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i], { create: true });
          }
        }
  
        // Create or get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
  
        // Write content
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        return { success: true, path };
      } catch (error) {
        // Check if it's a user activation error
        if (error.message && error.message.includes('User activation is required')) {
          return {
            success: false,
            error: `Cannot create new directories due to browser security. Please manually create the parent directory first, then try again.`,
            path
          };
        }
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFile: async function(path, findStr, replaceStr, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.role === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].role === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        const content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file.`,
            path
          };
        }
  
        // 4. Check that find string appears exactly once
        const occurrences = content.split(findStr).length - 1;
        if (occurrences === 0) {
          return {
            success: false,
            error: `Find string not found in file. The file may have changed since you last read it.`,
            path
          };
        } else if (occurrences > 1) {
          return {
            success: false,
            error: `Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
            path
          };
        }
  
        // 5. Perform replacement
        const newContent = content.replace(findStr, replaceStr);
  
        // 6. Write back
        const writeResult = await this.executeWriteFile(path, newContent, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFileBatch: async function(path, edits, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.role === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].role === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        let content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file_batch.`,
            path
          };
        }
  
        // 4. Apply each edit in sequence
        for (let i = 0; i < edits.length; i++) {
          const { find, replace } = edits[i];
  
          // Check that find string appears exactly once in current content
          const occurrences = content.split(find).length - 1;
          if (occurrences === 0) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string not found in file. The file may have changed or earlier edits affected this replacement.`,
              path
            };
          } else if (occurrences > 1) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
              path
            };
          }
  
          // Perform replacement
          content = content.replace(find, replace);
        }
  
        // 5. Write back
        const writeResult = await this.executeWriteFile(path, content, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    // Helper function to match wildcard pattern
    matchesPattern: function(filename, pattern) {
      // Convert wildcard pattern to regex
      // * matches any characters, ? matches single character
      const regexPattern = pattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&')  // Escape special regex chars
        .replace(/\*/g, '.*')  // * becomes .*
        .replace(/\?/g, '.');  // ? becomes .
  
      const regex = new RegExp(`^${regexPattern}$`, 'i');  // Case-insensitive
      return regex.test(filename);
    },
  
    // Recursively search for files by filename pattern
    executeSearchByFilename: async function(pattern, path, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if filename matches pattern
              if (window.module['main.js'].matchesPattern(entry.name, pattern)) {
                matches.push(entryPath);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          console.warn(`[Search] Error accessing ${currentPath}:`, error.message);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No files found matching the pattern.';
        } else {
          output = matches.map(m => `ðŸ“„ ${m}`).join('\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Recursively search for text within file contents
    executeSearchByContent: async function(searchText, path, filePattern, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if file matches filePattern (if provided)
              if (filePattern && !window.module['main.js'].matchesPattern(entry.name, filePattern)) {
                continue;
              }
  
              try {
                // Read file and search for text
                const file = await entry.getFile();
                const content = await file.text();
  
                if (content.toLowerCase().includes(searchText.toLowerCase())) {
                  // Find line numbers where text appears
                  const lines = content.split('\n');
                  const matchingLines = [];
  
                  for (let i = 0; i < lines.length; i++) {
                    if (lines[i].toLowerCase().includes(searchText.toLowerCase())) {
                      matchingLines.push({
                        lineNum: i + 1,
                        line: lines[i].trim()
                      });
                    }
                  }
  
                  matches.push({
                    path: entryPath,
                    lineMatches: matchingLines
                  });
                }
              } catch (error) {
                // Skip binary files or files that can't be read as text
                console.warn(`[Search] Could not read ${entryPath}:`, error.message);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          console.warn(`[Search] Error accessing ${currentPath}:`, error.message);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No matches found.';
        } else {
          output = matches.map(match => {
            const header = `ðŸ“„ ${match.path}`;
            const lineInfo = match.lineMatches.slice(0, 5).map(lm =>
              `  Line ${lm.lineNum}: ${lm.line.substring(0, 100)}${lm.line.length > 100 ? '...' : ''}`
            ).join('\n');
            const moreLines = match.lineMatches.length > 5 ? `  ... and ${match.lineMatches.length - 5} more matches` : '';
  
            return `${header}\n${lineInfo}${moreLines ? '\n' + moreLines : ''}`;
          }).join('\n\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or using a file pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Compact context by summarizing first half of messages
    compactContext: async function() {
      const state = window.module['state.js'];
      const api = window.module['api.js'];
      const ui = window.module['ui.js'];
  
      console.log('[Main] ========== COMPACTING CONTEXT ==========');
  
      const messages = state.getMessages();
  
      // Find first message that's not uiOnly (skip initial greeting)
      let firstRealMessageIndex = -1;
      for (let i = 0; i < messages.length; i++) {
        if (!messages[i].uiOnly) {
          firstRealMessageIndex = i;
          break;
        }
      }
  
      if (firstRealMessageIndex === -1) {
        console.log('[Main] No messages to compact');
        return;
      }
  
      // Calculate target: remove messages until we're at 50% of limit or less
      const limit = state.getContextLimit();
      const targetTokens = Math.floor(limit * 0.5);
      const currentTokens = state.calculateTokens();
  
      console.log('[Main] Current tokens:', currentTokens, '/ Limit:', limit);
      console.log('[Main] Target after compaction:', targetTokens, 'tokens (50% of limit)');
  
      // Remove messages from the front until we reach target
      let splitIndex = firstRealMessageIndex;
      let tokensAfterSplit = currentTokens;
  
      for (let i = firstRealMessageIndex; i < messages.length; i++) {
        if (messages[i].uiOnly) continue;
  
        // Calculate tokens if we remove up to this message
        const remainingMessages = messages.slice(i + 1);
        tokensAfterSplit = state.calculateTokens(remainingMessages);
  
        splitIndex = i;
  
        // Stop if we've reached our target
        if (tokensAfterSplit <= targetTokens) {
          break;
        }
      }
  
      const messagesToRemove = splitIndex - firstRealMessageIndex + 1;
      console.log('[Main] Removing', messagesToRemove, 'messages (up to index', splitIndex, ')');
      console.log('[Main] Tokens after removal:', tokensAfterSplit);
  
      // Get messages to summarize (from first real message to split point)
      const messagesToSummarize = messages.slice(firstRealMessageIndex, splitIndex + 1);
  
      console.log('[Main] Summarizing', messagesToSummarize.length, 'messages');
  
      // Create summarization request
      const summarizationMessages = [
        {
          role: 'user',
          content: 'Please provide a concise summary of the following conversation. Focus on key decisions, code changes, and important context that would be needed to continue the conversation.\n\nConversation to summarize:\n\n' +
            messagesToSummarize.map(m => `[${m.role}]: ${m.content}`).join('\n\n')
        }
      ];
  
      try {
        // Call API for summarization
        const response = await api.callAPI(summarizationMessages);
  
        if (!response.valid || response.parsed.type !== 'message') {
          console.error('[Main] Failed to get summary from API');
          return;
        }
  
        const summaryContent = response.parsed.content;
        console.log('[Main] Received summary:', summaryContent.substring(0, 100) + '...');
  
        // Remove the first half of messages and replace with summary
        const newMessages = [
          ...messages.slice(0, firstRealMessageIndex),
          {
            role: 'summary',
            content: summaryContent,
            timestamp: Date.now()
          },
          ...messages.slice(splitIndex + 1)
        ];
  
        // Update state with new message array
        state.state.messages = newMessages;
  
        console.log('[Main] Context compacted:', messages.length, '->', newMessages.length, 'messages');
  
      } catch (error) {
        console.error('[Main] Error during compaction:', error);
      }
    }
  };
  

  // Module: state.js
  // State management
  window.module['state.js'] = {
    state: {
      selectedDirectory: null,
      messages: [
        {
          role: 'assistant',
          content: 'Hello! I\'m your AI coding agent. I can help you with coding tasks, answer questions about your codebase, write code, debug issues, and more. What would you like to work on?',
          uiOnly: true  // This message won't be sent to the API
        }
      ],
      isProcessing: false,
      contextLimit: 20000  // Default 20K tokens (80K chars)
    },
  
    getState: function() {
      return this.state;
    },
  
    setSelectedDirectory: function(dirHandle) {
      this.state.selectedDirectory = dirHandle;
    },
  
    // Message management
    addMessage: function(message) {
      this.state.messages.push({
        ...message,
        timestamp: message.timestamp || Date.now()
      });
    },
  
    getMessages: function() {
      return this.state.messages;
    },
  
    // Processing state
    setProcessing: function(isProcessing) {
      this.state.isProcessing = isProcessing;
    },
  
    isProcessing: function() {
      return this.state.isProcessing;
    },
  
    // Clear all messages (keep initial greeting)
    clearMessages: function() {
      const initialGreeting = {
        role: 'assistant',
        content: 'Hello! I\'m your AI coding agent. I can help you with coding tasks, answer questions about your codebase, write code, debug issues, and more. What would you like to work on?',
        uiOnly: true
      };
  
      this.state.messages = [initialGreeting];
    },
  
    // Context limit management
    getContextLimit: function() {
      return this.state.contextLimit;
    },
  
    setContextLimit: function(limitInTokens) {
      this.state.contextLimit = limitInTokens;
    },
  
    // Calculate message size in tokens (estimate: 4 chars = 1 token)
    calculateTokens: function(messages) {
      if (!messages) {
        messages = this.state.messages;
      }
  
      let totalChars = 0;
      messages.forEach(msg => {
        if (msg.content) {
          totalChars += msg.content.length;
        }
      });
  
      return Math.ceil(totalChars / 4);  // 4 chars per token estimate
    },
  
    // Check if adding a message would exceed limit
    wouldExceedLimit: function(newMessageContent) {
      const currentTokens = this.calculateTokens();
      const newMessageTokens = Math.ceil(newMessageContent.length / 4);
      return (currentTokens + newMessageTokens) > this.state.contextLimit;
    },
  
    // Get the last summary index (if any)
    getLastSummaryIndex: function() {
      for (let i = this.state.messages.length - 1; i >= 0; i--) {
        if (this.state.messages[i].role === 'summary') {
          return i;
        }
      }
      return -1;
    }
  };
  

  // Module: styles.js
  // Styles and CSS injection
  window.module['styles.js'] = {
    injectStyles: function() {
      const style = document.createElement('style');
      style.textContent = `
        :root {
          --color-gold: #d4a017;
          --color-gold-light: #e5b028;
          --color-gold-glow: rgba(212, 160, 23, 0.3);
          --color-gold-subtle: rgba(212, 160, 23, 0.1);
          --color-bg-primary: #1a1a1a;
          --color-bg-secondary: #2d2d2d;
          --color-border: #404040;
          --color-text-primary: #e0e0e0;
          --color-text-secondary: #b0b0b0;
          --color-text-dim: #707070;
        }
  
        body {
          margin: 0;
          padding: 0;
          font-family: 'Consolas', 'Courier New', monospace;
          background-color: var(--color-bg-primary);
          color: var(--color-text-primary);
          overflow: hidden;
        }
  
        #app-container {
          width: 100%;
          height: 100vh;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        }
  
        /* Directory Selection Screen */
        #directory-screen {
          display: flex;
          align-items: center;
          justify-content: center;
          height: 100vh;
          flex-direction: column;
        }
  
        #directory-screen h1 {
          color: var(--color-gold);
          margin-bottom: 2rem;
          font-size: 48px;
          font-weight: 700;
          text-align: center;
          width: 100%;
        }
  
        #select-dir-btn {
          display: block;
          margin: 0 auto;
          background: var(--color-gold);
          color: var(--color-bg-primary);
          border: none;
          padding: 16px 32px;
          font-size: 16px;
          font-family: 'Consolas', 'Courier New', monospace;
          font-weight: 700;
          cursor: pointer;
          border-radius: 4px;
          transition: all 0.2s ease;
        }
  
        #select-dir-btn:hover {
          background: var(--color-gold-light);
          transform: translateY(-2px);
          box-shadow: 0 4px 12px var(--color-gold-glow);
        }
  
        #select-dir-btn:active {
          transform: translateY(0);
        }
  
        /* Chat Screen */
        #chat-screen {
          display: flex;
          flex-direction: column;
          height: 100vh;
        }
  
        #chat-container {
          flex: 1;
          overflow-y: auto;
          padding: 16px;
          scroll-behavior: smooth;
          width: 100%;
          max-width: 100%;
          box-sizing: border-box;
        }
  
        #chat-container::-webkit-scrollbar {
          width: 8px;
        }
  
        #chat-container::-webkit-scrollbar-track {
          background: var(--color-bg-secondary);
        }
  
        #chat-container::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 4px;
        }
  
        #chat-container::-webkit-scrollbar-thumb:hover {
          background: #777;
        }
  
        #input-container {
          padding: 16px;
          background-color: var(--color-bg-primary);
          width: 100%;
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 8px;
        }
  
        #input-wrapper {
          position: relative;
          width: 90%;
          max-width: 1200px;
          display: flex;
          align-items: flex-start;
          background-color: var(--color-bg-secondary);
          border: 1px solid var(--color-border);
          border-radius: 8px;
          max-height: 33.333vh;
          overflow: hidden;
        }
  
        #message-input {
          width: 100%;
          background: transparent;
          border: none;
          color: var(--color-text-primary);
          font-family: 'Consolas', 'Courier New', monospace;
          font-size: 14px;
          resize: none;
          outline: none;
          padding: 12px 16px;
          line-height: 1.6;
          overflow-y: auto;
          box-sizing: border-box;
        }
  
        #message-input::-webkit-scrollbar {
          display: none;
        }
  
        #message-input::placeholder {
          color: var(--color-text-dim);
        }
  
        #message-input:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
  
        #project-path {
          font-size: 12px;
          color: var(--color-text-secondary);
          text-align: left;
          width: 90%;
          max-width: 1200px;
        }
  
        #context-stats {
          display: flex;
          gap: 12px;
          justify-content: flex-end;
          width: 90%;
          max-width: 1200px;
          margin-top: 4px;
        }
  
        .context-stat-btn {
          background: none;
          border: none;
          color: var(--color-text-dim);
          font-size: 11px;
          font-family: 'Consolas', 'Courier New', monospace;
          cursor: pointer;
          padding: 2px 4px;
          transition: color 0.2s ease;
        }
  
        .context-stat-btn:hover {
          color: var(--color-gold);
        }
  
        /* Messages */
        .message {
          margin-bottom: 20px;
        }
  
        .message:first-child {
          margin-top: 20px;
        }
  
        .user-message {
          display: flex;
          gap: 8px;
          color: var(--color-text-dim);
        }
  
        .user-message .message-prefix {
          flex-shrink: 0;
        }
  
        .user-message .message-content {
          flex: 1;
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        .assistant-message {
          color: var(--color-gold);
          padding-left: 2ch;
          background-image: linear-gradient(
            to right,
            transparent 0px,
            transparent calc(1ch - 5px),
            var(--color-gold) calc(1ch - 5px),
            var(--color-gold) calc(1ch - 4px),
            transparent calc(1ch - 4px)
          );
          background-repeat: no-repeat;
          background-size: 100% 100%;
          transition: all 0.2s ease;
          position: relative;
        }
  
        .assistant-message:hover {
          background-color: var(--color-gold-subtle);
          transform: translateX(2px);
        }
  
        .assistant-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
          max-width: 100%;
          overflow-wrap: break-word;
        }
  
        .message-timing {
          font-size: 10px;
          color: var(--color-text-dim);
          margin-top: 4px;
          opacity: 0.7;
        }
  
        .tool-execution-timing {
          font-size: 10px;
          color: var(--color-text-dim);
          text-align: center;
          margin: 8px 0;
          opacity: 0.6;
          font-style: italic;
        }
  
        .loading {
          display: flex;
          gap: 6px;
          padding: 8px 12px;
          background: var(--color-gold-subtle);
          border-radius: 4px;
          color: var(--color-gold);
        }
  
        .loading::after {
          content: '';
          width: 6px;
          height: 6px;
          background: var(--color-gold);
          border-radius: 50%;
          animation: loading-bounce 1.4s infinite ease-in-out both;
        }
  
        @keyframes loading-bounce {
          0%, 80%, 100% {
            transform: scale(0);
            opacity: 0.5;
          }
          40% {
            transform: scale(1);
            opacity: 1;
          }
        }
  
        /* Tool Execution Messages - Inline Style */
        .tool-use-inline {
          padding: 4px 0 4px 2ch;
          font-size: 13px;
          line-height: 1.8;
        }
  
        .tool-use-inline .tool-name {
          color: #a0a0a0;
          font-weight: bold;
        }
  
        .tool-use-inline .tool-params {
          color: #888888;
          font-weight: normal;
        }
  
        .tool-result-inline {
          padding: 4px 0 12px 3ch;
          font-size: 13px;
          color: #999999;
          cursor: pointer;
          transition: color 0.2s ease;
          line-height: 1.8;
        }
  
        .tool-result-inline:hover {
          color: var(--color-gold);
        }
  
        .tool-result-inline.error {
          color: #ff6b6b;
        }
  
        .tool-result-inline.error:hover {
          color: #ff5252;
        }
  
        /* Tool Execution Messages - Legacy */
        .tool-message {
          color: var(--color-text-secondary);
          padding: 8px 12px;
          background: var(--color-gold-subtle);
          border-left: 3px solid var(--color-gold);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 13px;
        }
  
        .tool-message:hover {
          background: rgba(212, 160, 23, 0.15);
          border-left-color: var(--color-gold-light);
          transform: translateX(2px);
        }
  
        .tool-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        /* Tool Group Container */
        .tool-group {
          margin-bottom: 20px;
        }
  
        /* Tool Use Messages (before execution) */
        .tool-use-message {
          color: var(--color-text-secondary);
          padding: 8px 12px;
          background: rgba(212, 160, 23, 0.08);
          border-left: 3px solid rgba(212, 160, 23, 0.5);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 13px;
        }
  
        /* When in a group, remove individual border radius and add top border */
        .tool-group .tool-use-message {
          border-radius: 0;
          margin-bottom: 0;
          border-top: 1px solid var(--color-border);
        }
  
        /* First child in group gets top rounded corners and no top border */
        .tool-group .tool-use-message:first-child {
          border-radius: 4px 4px 0 0;
          border-top: none;
        }
  
        /* Last child in group gets bottom rounded corners */
        .tool-group .tool-use-message:last-child {
          border-radius: 0 0 4px 4px;
        }
  
        /* Single child gets all corners rounded */
        .tool-group .tool-use-message:first-child:last-child {
          border-radius: 4px;
        }
  
        .tool-use-message:hover {
          background: rgba(212, 160, 23, 0.12);
          border-left-color: var(--color-gold);
          transform: translateX(2px);
        }
  
        .tool-use-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        /* Tool Result Messages (after execution) */
        .tool-result-message {
          color: var(--color-text-secondary);
          padding: 8px 12px;
          background: rgba(76, 175, 80, 0.08);
          border-left: 3px solid rgba(76, 175, 80, 0.5);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 13px;
        }
  
        /* When in a group, remove individual border radius and add top border */
        .tool-group .tool-result-message {
          border-radius: 0;
          margin-bottom: 0;
          border-top: 1px solid var(--color-border);
        }
  
        /* First child in group gets top rounded corners and no top border */
        .tool-group .tool-result-message:first-child {
          border-radius: 4px 4px 0 0;
          border-top: none;
        }
  
        /* Last child in group gets bottom rounded corners */
        .tool-group .tool-result-message:last-child {
          border-radius: 0 0 4px 4px;
        }
  
        /* Single child gets all corners rounded */
        .tool-group .tool-result-message:first-child:last-child {
          border-radius: 4px;
        }
  
        .tool-result-message:hover {
          background: rgba(76, 175, 80, 0.15);
          border-left-color: #4caf50;
          transform: translateX(2px);
        }
  
        .tool-result-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        /* Modal Overlay */
        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.85);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          animation: fadeIn 0.2s ease;
        }
  
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
  
        /* Modal Container */
        .modal-container {
          background: var(--color-bg-secondary);
          border: 2px solid var(--color-gold);
          border-radius: 8px;
          width: 90%;
          max-width: 900px;
          max-height: 80vh;
          display: flex;
          flex-direction: column;
          animation: slideUp 0.2s ease;
        }
  
        @keyframes slideUp {
          from {
            transform: translateY(20px);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }
  
        /* Modal Header */
        .modal-header {
          padding: 16px 20px;
          border-bottom: 1px solid var(--color-border);
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
  
        .modal-title {
          color: var(--color-gold);
          font-size: 18px;
          font-weight: bold;
        }
  
        .modal-close {
          background: none;
          border: none;
          color: var(--color-text-secondary);
          font-size: 24px;
          cursor: pointer;
          padding: 0;
          width: 32px;
          height: 32px;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: color 0.2s ease;
        }
  
        .modal-close:hover {
          color: var(--color-gold);
        }
  
        /* Modal Body */
        .modal-body {
          padding: 20px;
          overflow-y: auto;
          flex: 1;
        }
  
        .modal-body::-webkit-scrollbar {
          width: 8px;
        }
  
        .modal-body::-webkit-scrollbar-track {
          background: var(--color-bg-primary);
        }
  
        .modal-body::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 4px;
        }
  
        .modal-body::-webkit-scrollbar-thumb:hover {
          background: #777;
        }
  
        .modal-section {
          margin-bottom: 24px;
        }
  
        .modal-section:last-child {
          margin-bottom: 0;
        }
  
        .modal-section-title-row {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        }
  
        .modal-section-title {
          color: var(--color-gold);
          font-size: 14px;
          font-weight: bold;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
  
        .modal-section-copy-btn {
          background: var(--color-bg-primary);
          border: 1px solid var(--color-gold);
          color: var(--color-gold);
          padding: 4px 8px;
          font-size: 11px;
          font-family: 'Consolas', 'Courier New', monospace;
          cursor: pointer;
          border-radius: 3px;
          transition: all 0.2s ease;
        }
  
        .modal-section-copy-btn:hover {
          background: var(--color-gold);
          color: var(--color-bg-primary);
        }
  
        .modal-section-content {
          background: var(--color-bg-primary);
          padding: 12px;
          border-radius: 4px;
          border-left: 3px solid var(--color-gold-subtle);
          color: var(--color-text-primary);
          white-space: pre-wrap;
          word-wrap: break-word;
          font-family: 'Consolas', 'Courier New', monospace;
          font-size: 13px;
          line-height: 1.5;
          max-height: 400px;
          overflow-y: auto;
        }
  
        .modal-section-content::-webkit-scrollbar {
          width: 6px;
        }
  
        .modal-section-content::-webkit-scrollbar-track {
          background: var(--color-bg-secondary);
        }
  
        .modal-section-content::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 3px;
        }
  
        /* Summary Messages */
        .summary-message {
          background: rgba(100, 150, 200, 0.08);
          border-left: 3px solid rgba(100, 150, 200, 0.5);
          border-radius: 4px;
          padding: 12px 16px;
          margin-bottom: 20px;
          transition: all 0.2s ease;
        }
  
        .summary-message:hover {
          background: rgba(100, 150, 200, 0.12);
          border-left-color: #6496c8;
          transform: translateX(2px);
        }
  
        .summary-header {
          color: #6496c8;
          font-weight: bold;
          font-size: 13px;
          margin-bottom: 8px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
  
        .summary-message .message-content {
          color: var(--color-text-secondary);
          white-space: pre-wrap;
          word-wrap: break-word;
          font-size: 13px;
          line-height: 1.6;
        }
      `;
      document.head.appendChild(style);
    }
  };
  

  // Module: tools.js
  // Tool system - simplified architecture
  window.module['tools.js'] = {
  
    // Tool definitions
    tools: [
      {
        name: 'list_directory',
        description: 'List the contents of a directory (one level deep)',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The directory path to list (relative to project root, use "." for root)'
            }
          },
          required: ['path']
        }
      },
  
      {
        name: 'read_file',
        description: 'Read the contents of a file',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to read (relative to project root)'
            }
          },
          required: ['path']
        }
      },
  
      {
        name: 'write_file',
        description: 'Write content to a file (creates file and directories if they don\'t exist)',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to write (relative to project root)'
            },
            content: {
              type: 'string',
              description: 'The content to write to the file'
            }
          },
          required: ['path', 'content']
        }
      },
  
      {
        name: 'search_by_filename',
        description: 'Search for files by filename pattern (supports wildcards like *.js, test*, etc.)',
        input_schema: {
          type: 'object',
          properties: {
            pattern: {
              type: 'string',
              description: 'The filename pattern to search for (e.g., "*.js", "test*", "config.json")'
            },
            path: {
              type: 'string',
              description: 'The directory to search in (relative to project root, use "." for root). Optional, defaults to "."'
            }
          },
          required: ['pattern']
        }
      },
  
      {
        name: 'search_by_content',
        description: 'Search for text within file contents',
        input_schema: {
          type: 'object',
          properties: {
            text: {
              type: 'string',
              description: 'The text to search for within files'
            },
            path: {
              type: 'string',
              description: 'The directory to search in (relative to project root, use "." for root). Optional, defaults to "."'
            },
            filePattern: {
              type: 'string',
              description: 'Optional file pattern to limit search (e.g., "*.js", "*.txt"). If not provided, searches all files.'
            }
          },
          required: ['text']
        }
      },
  
      {
        name: 'edit_file',
        description: 'Edit a file by finding and replacing a specific string. The file must have been read within the last 5 minutes. The find string must appear exactly once in the file.',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to edit (relative to project root)'
            },
            find: {
              type: 'string',
              description: 'The exact string to find in the file (must appear exactly once)'
            },
            replace: {
              type: 'string',
              description: 'The string to replace it with'
            }
          },
          required: ['path', 'find', 'replace']
        }
      },
  
      {
        name: 'edit_file_batch',
        description: 'Edit a file by applying multiple find/replace operations in sequence. The file must have been read within the last 5 minutes. Each find string must appear exactly once in the file.',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to edit (relative to project root)'
            },
            edits: {
              type: 'array',
              description: 'Array of edit operations to apply in sequence',
              items: {
                type: 'object',
                properties: {
                  find: {
                    type: 'string',
                    description: 'The exact string to find in the file (must appear exactly once)'
                  },
                  replace: {
                    type: 'string',
                    description: 'The string to replace it with'
                  }
                },
                required: ['find', 'replace']
              }
            }
          },
          required: ['path', 'edits']
        }
      }
    ],
  
    // Get system prompt
    getSystemPrompt: function() {
      return `You are a coding agent with access to a project's file system via tools.
  
  CRITICAL INSTRUCTION: When a user asks you to explore a project, your FIRST response MUST be to execute the list_directory tool with path ".". DO NOT say you don't have access. DO NOT ask for clarification. IMMEDIATELY use the tools.
  
  Example: If user says "explore the project", you MUST respond with:
  {"type":"execute","tool_uses":[{"name":"list_directory","input":{"path":"."}}]}
  
  IMPORTANT: You have REAL tools to list, read, and write files. When a user asks you to explore or modify files, you MUST use these tools. Do NOT say you don't have access - you DO have access via these tools.
  
  ## Available Tools
  
  You have access to these tools to explore and work with the project:
  
  ### list_directory
  List the contents of a directory (one level deep)
  
  Parameters:
  - path (string, required): The directory path to list (relative to project root, use "." for root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"list_directory","input":{"path":"."}}]}
  
  ### read_file
  Read the contents of a file
  
  Parameters:
  - path (string, required): The file path to read (relative to project root)
  
  Example usage (single file):
  {"type":"execute","tool_uses":[{"name":"read_file","input":{"path":"package.json"}}]}
  
  Example usage (multiple files):
  {"type":"execute","tool_uses":[{"name":"read_file","input":{"path":"src/app/main.js"}},{"name":"read_file","input":{"path":"package.json"}}]}
  
  ### write_file
  Write content to a file (creates file and directories if they don't exist)
  
  Parameters:
  - path (string, required): The file path to write (relative to project root)
  - content (string, required): The content to write to the file
  
  CRITICAL: The "content" field MUST be a literal JSON string. Do NOT use JavaScript expressions like .repeat(), string concatenation (+), or template literals. The content must be the FULL, EXPANDED text as a single JSON string with proper escaping.
  
  WRONG: {"content":"Line 1\\n" + "Line 2"}
  WRONG: {"content":"text ".repeat(100)}
  CORRECT: {"content":"Line 1\\nLine 2"}
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"write_file","input":{"path":"src/utils/helper.js","content":"// Helper functions\\nexport function add(a, b) {\\n  return a + b;\\n}"}}]}
  
  ### search_by_filename
  Search for files by filename pattern (supports wildcards)
  
  Parameters:
  - pattern (string, required): The filename pattern to search for (e.g., "*.js", "test*", "config.json")
  - path (string, optional): The directory to search in (relative to project root, defaults to ".")
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"search_by_filename","input":{"pattern":"*.js","path":"src"}}]}
  
  ### search_by_content
  Search for text within file contents
  
  Parameters:
  - text (string, required): The text to search for within files
  - path (string, optional): The directory to search in (relative to project root, defaults to ".")
  - filePattern (string, optional): File pattern to limit search (e.g., "*.js")
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"search_by_content","input":{"text":"executeTools","filePattern":"*.js"}}]}
  
  ### edit_file
  Edit a file by finding and replacing a specific string (for single edits)
  
  IMPORTANT REQUIREMENTS:
  1. You MUST read the file within the last 5 minutes before editing
  2. The find string MUST appear exactly once in the file (otherwise you'll get an error)
  3. If the file is blank/empty, use write_file instead
  
  Parameters:
  - path (string, required): The file path to edit (relative to project root)
  - find (string, required): The exact string to find (must appear exactly once)
  - replace (string, required): The string to replace it with
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"edit_file","input":{"path":"src/config.js","find":"debug: false","replace":"debug: true"}}]}
  
  ### edit_file_batch
  Edit a file by applying multiple find/replace operations in sequence (for multiple edits to the same file)
  
  IMPORTANT REQUIREMENTS:
  1. You MUST read the file within the last 5 minutes before editing
  2. Each find string MUST appear exactly once in the file at the time it's applied (otherwise you'll get an error)
  3. Edits are applied in sequence, so later edits see the results of earlier edits
  4. If the file is blank/empty, use write_file instead
  
  Parameters:
  - path (string, required): The file path to edit (relative to project root)
  - edits (array, required): Array of {find, replace} operations to apply in sequence
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"edit_file_batch","input":{"path":"src/config.js","edits":[{"find":"version: '1.0.0'","replace":"version: '2.0.0'"},{"find":"debug: false","replace":"debug: true"}]}}]}
  
  ## Workflow
  
  When asked to explore a project:
  1. Use list_directory to see what files/folders exist
  2. Use search_by_filename to find specific files by pattern
  3. Use search_by_content to find files containing specific text
  4. Use read_file to read relevant files (you can read multiple files at once)
  5. File contents will remain in the conversation for context
  6. Use write_file to create or update files
  7. Then provide your analysis or response
  
  ## Response Format
  
  You MUST respond with valid JSON followed by a terminator. Your response MUST be ONLY the JSON object, followed immediately by ||||END||||
  
  **To execute tools:**
  {"type":"execute","tool_uses":[{"name":"tool_name","input":{"param":"value"}}]}||||END||||
  
  **To send a message:**
  {"type":"message","content":"Your response text here"}||||END||||
  
  CRITICAL:
  - Do NOT use any other response type. Only "execute" or "message".
  - Do NOT wrap your JSON in markdown code blocks
  - Do NOT include any explanatory text before or after the JSON
  - Your ENTIRE response must be valid JSON starting with { and ending with }
  - JSON fields MUST contain literal values only - NO JavaScript expressions, concatenation (+), .repeat(), template literals, or any code
  - All string values must be fully expanded as literal JSON strings with proper escaping (\\n for newlines, \\" for quotes)
  - ALWAYS end your response with ||||END|||| immediately after the closing }
  - If your response is blank or empty, just send ||||END|||| to indicate completion`;
    },
  
    // Attempt to fix malformed JSON
    tryFixJSON: function(jsonText) {
      // If last character is "}", try removing it and parsing again
      if (jsonText.trim().endsWith('}')) {
        const withoutLastBrace = jsonText.trim().slice(0, -1);
        try {
          const parsed = JSON.parse(withoutLastBrace);
          console.log('[tryFixJSON] Successfully fixed JSON by removing trailing }');
          return { fixed: true, json: withoutLastBrace, parsed };
        } catch (e) {
          return { fixed: false };
        }
      }
      return { fixed: false };
    },
  
    // Attempt to fix unescaped newlines in JSON content
    tryFixNewlines: function(jsonText) {
      try {
        // Strategy: Find content field and escape newlines within it
        // This is a heuristic approach for common AI response patterns
        const contentMatch = jsonText.match(/"content"\s*:\s*"([\s\S]*?)(?:"(?:\s*[,}]))/);
        if (contentMatch) {
          const originalContent = contentMatch[1];
          const fixedContent = originalContent
            .replace(/\r/g, '\\r')
            .replace(/\n/g, '\\n')
            .replace(/\t/g, '\\t');
  
          const fixedJson = jsonText.replace(
            `"content":"${originalContent}"`,
            `"content":"${fixedContent}"`
          );
  
          const parsed = JSON.parse(fixedJson);
          console.log('[tryFixNewlines] Successfully fixed JSON by escaping newlines');
          return { fixed: true, json: fixedJson, parsed };
        }
      } catch (e) {
        console.log('[tryFixNewlines] Failed to fix:', e.message);
        return { fixed: false };
      }
      return { fixed: false };
    },
  
    // Parse and validate AI response
    parseResponse: function(responseText) {
      let response;
  
      // Try to parse JSON
      try {
        response = JSON.parse(responseText);
      } catch (parseError) {
        // Try to fix the JSON
        console.log('[parseResponse] Initial JSON parse failed:', parseError.message);
  
        // Try multiple fix strategies
        let fixResult = this.tryFixJSON(responseText);
  
        if (!fixResult.fixed) {
          // If that didn't work, try escaping newlines in content
          fixResult = this.tryFixNewlines(responseText);
        }
  
        if (fixResult.fixed) {
          console.log('[parseResponse] JSON was fixed, using repaired version');
          response = fixResult.parsed;
        } else {
          return {
            valid: false,
            error: `Invalid JSON: ${parseError.message}`
          };
        }
      }
  
      // Validate response structure
      if (!response.type) {
        return {
          valid: false,
          error: 'Response missing required "type" field'
        };
      }
  
      if (response.type === 'message') {
        if (!response.content || typeof response.content !== 'string') {
          return {
            valid: false,
            error: 'Message response missing "content" field or content is not a string'
          };
        }
      } else if (response.type === 'execute') {
        if (!response.tool_uses || !Array.isArray(response.tool_uses)) {
          return {
            valid: false,
            error: 'Execute response missing "tool_uses" array'
          };
        }
  
        // Validate each tool use
        for (let i = 0; i < response.tool_uses.length; i++) {
          const toolUse = response.tool_uses[i];
          if (!toolUse.name || typeof toolUse.name !== 'string') {
            return {
              valid: false,
              error: `Tool use ${i} missing "name" field or name is not a string`
            };
          }
          if (!toolUse.input || typeof toolUse.input !== 'object') {
            return {
              valid: false,
              error: `Tool use ${i} missing "input" field or input is not an object`
            };
          }
        }
      } else {
        return {
          valid: false,
          error: `Unknown response type: "${response.type}". Must be "message" or "execute"`
        };
      }
  
      return {
        valid: true,
        parsed: response
      };
    }
  };
  

  // Module: ui.js
  // UI rendering and interaction
  window.module['ui.js'] = {
    showDirectorySelection: function(onSelect) {
      const container = document.createElement('div');
      container.id = 'app-container';
  
      const screen = document.createElement('div');
      screen.id = 'directory-screen';
  
      const title = document.createElement('h1');
      title.textContent = 'AI Coding Agent';
  
      const button = document.createElement('button');
      button.id = 'select-dir-btn';
      button.textContent = 'Select Project Directory';
      button.onclick = onSelect;
  
      screen.appendChild(title);
      screen.appendChild(button);
      container.appendChild(screen);
      document.body.appendChild(container);
    },
  
    showChatScreen: function(selectedDirectory, onSendMessage) {
      const container = document.getElementById('app-container');
      container.innerHTML = '';
  
      const screen = document.createElement('div');
      screen.id = 'chat-screen';
  
      // Chat container
      const chatContainer = document.createElement('div');
      chatContainer.id = 'chat-container';
  
      // Input container
      const inputContainer = document.createElement('div');
      inputContainer.id = 'input-container';
  
      // Input wrapper
      const inputWrapper = document.createElement('div');
      inputWrapper.id = 'input-wrapper';
  
      const textarea = document.createElement('textarea');
      textarea.id = 'message-input';
      textarea.placeholder = 'Type your message...';
      textarea.rows = 1;
  
      // Auto-resize textarea
      const resizeTextarea = () => {
        textarea.style.height = '0px';
        textarea.style.height = Math.min(textarea.scrollHeight, window.innerHeight * 0.33) + 'px';
      };
  
      textarea.addEventListener('input', resizeTextarea);
  
      textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          onSendMessage();
        }
      });
  
      inputWrapper.appendChild(textarea);
      inputContainer.appendChild(inputWrapper);
  
      // Project path display
      const projectPath = document.createElement('div');
      projectPath.id = 'project-path';
  
      // Get full path from directory handle
      if (selectedDirectory) {
        // Try to resolve the full path if available (Chrome 86+)
        selectedDirectory.resolve().then(path => {
          if (path && path.length > 0) {
            projectPath.textContent = path.join('/');
          } else {
            projectPath.textContent = selectedDirectory.name;
          }
        }).catch(() => {
          // Fallback to just the directory name
          projectPath.textContent = selectedDirectory.name;
        });
      }
  
      inputContainer.appendChild(projectPath);
  
      // Context stats display
      const contextStats = document.createElement('div');
      contextStats.id = 'context-stats';
  
      const messagesBtn = document.createElement('button');
      messagesBtn.className = 'context-stat-btn';
      messagesBtn.id = 'messages-stat-btn';
      messagesBtn.textContent = '0K';
      messagesBtn.onclick = () => this.showContextModal();
  
      contextStats.appendChild(messagesBtn);
  
      inputContainer.appendChild(contextStats);
  
      screen.appendChild(chatContainer);
      screen.appendChild(inputContainer);
      container.appendChild(screen);
  
      // Focus the input
      textarea.focus();
  
      // Initial stats update
      this.updateContextStats();
    },
  
    renderMessages: function(messages) {
      const container = document.getElementById('chat-container');
      container.innerHTML = '';
  
      // Track which groupIds have been rendered
      const renderedGroupIds = new Set();
  
      messages.forEach((msg, index) => {
        // Skip messages from system (tool results, internal prompts)
        if (msg.fromSystem) {
          return;
        }
  
        // Skip marker messages
        if (msg.isMarker) {
          return;
        }
  
        // Skip API-only messages
        if (msg.apiOnly) {
          return;
        }
  
        // Skip assistant messages that contain raw JSON tool execution requests
        // These are for API conversation structure only, not for UI display
        // We detect them by checking if the content starts with JSON (contains "type": "execute")
        // However, we still want to show the timing for these AI calls
        if (msg.role === 'assistant' && msg.apiData && msg.content && msg.content.includes('"type"')) {
          // If there's timing info, display it
          if (msg.durationSeconds !== undefined) {
            const timingDiv = document.createElement('div');
            timingDiv.className = 'tool-execution-timing';
            timingDiv.textContent = `${msg.durationSeconds.toFixed(2)}s`;
            container.appendChild(timingDiv);
          }
          return;
        }
  
        // Check if this message belongs to a tool group
        const groupId = (msg.isToolUse && msg.toolUseData?.groupId) ||
                        (msg.isToolResult && msg.toolResultData?.groupId);
  
        // If this message has a groupId and we've already rendered this group, skip it
        if (groupId && renderedGroupIds.has(groupId)) {
          return;
        }
  
        // If this message is part of a tool group, collect all messages in that group
        if (groupId) {
          // Mark this group as rendered
          renderedGroupIds.add(groupId);
  
          // Collect all messages with this groupId (both tool-use and tool-result)
          const groupMessages = messages.filter(m => {
            const msgGroupId = (m.isToolUse && m.toolUseData?.groupId) ||
                               (m.isToolResult && m.toolResultData?.groupId);
            return msgGroupId === groupId;
          });
  
          // Create a grouped container
          const groupDiv = document.createElement('div');
          groupDiv.className = 'message tool-group';
  
          // Render each message in the group in order
          groupMessages.forEach(groupMsg => {
            if (groupMsg.isToolUse) {
              // Create tool-use div
              const toolUseDiv = document.createElement('div');
              toolUseDiv.className = 'tool-use-message';
              toolUseDiv.addEventListener('click', () => {
                this.showToolUseModal(groupMsg);
              });
  
              const toolUseContent = document.createElement('div');
              toolUseContent.className = 'message-content';
              toolUseContent.textContent = groupMsg.content;
              toolUseDiv.appendChild(toolUseContent);
  
              groupDiv.appendChild(toolUseDiv);
            } else if (groupMsg.isToolResult) {
              // Create tool-result div
              const toolResultDiv = document.createElement('div');
              toolResultDiv.className = 'tool-result-message';
              toolResultDiv.addEventListener('click', () => {
                this.showToolResultModal(groupMsg);
              });
  
              const toolResultContent = document.createElement('div');
              toolResultContent.className = 'message-content';
              toolResultContent.textContent = groupMsg.content;
              toolResultDiv.appendChild(toolResultContent);
  
              groupDiv.appendChild(toolResultDiv);
            }
          });
  
          container.appendChild(groupDiv);
          return;
        }
  
        // Regular message rendering (for non-grouped messages)
        const messageDiv = document.createElement('div');
  
        // Handle new tool-use and tool-result roles
        if (msg.role === 'tool-use') {
          messageDiv.className = 'message tool-use-inline';
  
          const toolName = document.createElement('span');
          toolName.className = 'tool-name';
          toolName.textContent = msg.toolName;
  
          const toolParams = document.createElement('span');
          toolParams.className = 'tool-params';
          toolParams.textContent = ' ' + JSON.stringify(msg.params);
  
          messageDiv.appendChild(toolName);
          messageDiv.appendChild(toolParams);
  
          container.appendChild(messageDiv);
          return;
        } else if (msg.role === 'tool-result') {
          messageDiv.className = msg.error ? 'message tool-result-inline error' : 'message tool-result-inline';
          messageDiv.textContent = msg.summary;
          messageDiv.style.cursor = 'pointer';
          messageDiv.addEventListener('click', () => {
            this.showToolResultModal(msg);
          });
  
          container.appendChild(messageDiv);
          return;
        }
  
        // Apply different styling for tool use and tool result messages
        if (msg.isToolUse) {
          messageDiv.className = 'message tool-use-message';
          messageDiv.addEventListener('click', () => {
            this.showToolUseModal(msg);
          });
        } else if (msg.isToolResult) {
          messageDiv.className = 'message tool-result-message';
          messageDiv.addEventListener('click', () => {
            this.showToolResultModal(msg);
          });
        } else if (msg.isToolExecution) {
          // Legacy support
          messageDiv.className = 'message tool-message';
          messageDiv.addEventListener('click', () => {
            this.showToolModal(msg);
          });
        } else {
          messageDiv.className = `message ${msg.role}-message`;
        }
  
        if (msg.role === 'user') {
          const prefix = document.createElement('span');
          prefix.className = 'message-prefix';
          prefix.textContent = '> ';
  
          const content = document.createElement('span');
          content.className = 'message-content';
          content.textContent = msg.content;
  
          messageDiv.appendChild(prefix);
          messageDiv.appendChild(content);
        } else if (msg.role === 'assistant') {
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
          messageDiv.appendChild(content);
  
          // Add timing info if available
          if (msg.durationSeconds !== undefined) {
            const timing = document.createElement('div');
            timing.className = 'message-timing';
            timing.textContent = `${msg.durationSeconds.toFixed(2)}s`;
            messageDiv.appendChild(timing);
          }
  
          // Make all assistant messages clickable to show details
          messageDiv.style.cursor = 'pointer';
          messageDiv.addEventListener('click', () => {
            this.showAssistantMessageModal(msg);
          });
        } else if (msg.role === 'summary') {
          // Summary message - special styling
          const header = document.createElement('div');
          header.className = 'summary-header';
          header.textContent = 'ðŸ“ Conversation Summary';
  
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
  
          messageDiv.appendChild(header);
          messageDiv.appendChild(content);
        } else {
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
          messageDiv.appendChild(content);
        }
  
        container.appendChild(messageDiv);
      });
  
      // Scroll to bottom
      container.scrollTop = container.scrollHeight;
  
      // Update context stats
      this.updateContextStats();
    },
  
    showToolModal: function(toolMessage) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const title = document.createElement('div');
      title.className = 'modal-title';
      title.textContent = 'Tool Execution Details';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(title);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      // If there's toolData, show specific tool information
      if (toolMessage.toolData && toolMessage.toolData.results) {
        toolMessage.toolData.results.forEach((toolResult, index) => {
          const toolUse = toolMessage.toolData.toolUses[index];
  
          // Tool name section
          const nameSection = document.createElement('div');
          nameSection.className = 'modal-section';
  
          const nameTitle = document.createElement('div');
          nameTitle.className = 'modal-section-title';
          nameTitle.textContent = `Tool: ${toolUse.tool}`;
  
          const nameContent = document.createElement('div');
          nameContent.className = 'modal-section-content';
          nameContent.textContent = `Parameters: ${JSON.stringify(toolUse.params, null, 2)}`;
  
          nameSection.appendChild(nameTitle);
          nameSection.appendChild(nameContent);
          body.appendChild(nameSection);
  
          // Special handling for read_file
          if (toolUse.tool === 'read_file' && toolResult.result.success) {
            // File contents
            if (toolResult.result.fileContents) {
              const contentsSection = document.createElement('div');
              contentsSection.className = 'modal-section';
  
              const contentsTitle = document.createElement('div');
              contentsTitle.className = 'modal-section-title';
              contentsTitle.textContent = `File: ${toolResult.result.path}`;
  
              const contentsContent = document.createElement('div');
              contentsContent.className = 'modal-section-content';
              contentsContent.textContent = toolResult.result.fileContents;
  
              contentsSection.appendChild(contentsTitle);
              contentsSection.appendChild(contentsContent);
              body.appendChild(contentsSection);
            }
  
            // Previous mental model notes
            if (toolResult.result.currentNotes) {
              const notesSection = document.createElement('div');
              notesSection.className = 'modal-section';
  
              const notesTitle = document.createElement('div');
              notesTitle.className = 'modal-section-title';
              notesTitle.textContent = 'Mental Model (Before)';
  
              const notesContent = document.createElement('div');
              notesContent.className = 'modal-section-content';
              notesContent.textContent = toolResult.result.currentNotes;
  
              notesSection.appendChild(notesTitle);
              notesSection.appendChild(notesContent);
              body.appendChild(notesSection);
            }
          } else {
            // For other tools, show result
            const resultSection = document.createElement('div');
            resultSection.className = 'modal-section';
  
            const resultTitle = document.createElement('div');
            resultTitle.className = 'modal-section-title';
            resultTitle.textContent = 'Result';
  
            const resultContent = document.createElement('div');
            resultContent.className = 'modal-section-content';
            resultContent.textContent = JSON.stringify(toolResult.result, null, 2);
  
            resultSection.appendChild(resultTitle);
            resultSection.appendChild(resultContent);
            body.appendChild(resultSection);
          }
        });
      } else {
        // Fallback: show basic tool execution message
        const toolSection = document.createElement('div');
        toolSection.className = 'modal-section';
  
        const toolTitle = document.createElement('div');
        toolTitle.className = 'modal-section-title';
        toolTitle.textContent = 'Tool Execution';
  
        const toolContent = document.createElement('div');
        toolContent.className = 'modal-section-content';
        toolContent.textContent = toolMessage.content;
  
        toolSection.appendChild(toolTitle);
        toolSection.appendChild(toolContent);
        body.appendChild(toolSection);
      }
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    },
  
    showLoading: function() {
      const container = document.getElementById('chat-container');
      const loading = document.createElement('div');
      loading.id = 'loading-indicator';
      loading.className = 'message assistant-message loading';
      loading.textContent = 'Thinking';
      container.appendChild(loading);
      container.scrollTop = container.scrollHeight;
    },
  
    hideLoading: function() {
      const loading = document.getElementById('loading-indicator');
      if (loading) {
        loading.remove();
      }
    },
  
    getInputValue: function() {
      const input = document.getElementById('message-input');
      return input ? input.value.trim() : '';
    },
  
    clearInput: function() {
      const input = document.getElementById('message-input');
      if (input) {
        input.value = '';
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      }
    },
  
    setInputDisabled: function(disabled) {
      const input = document.getElementById('message-input');
      if (input) {
        input.disabled = disabled;
        if (!disabled) {
          input.focus();
        }
      }
    },
  
    showToolUseModal: function(toolUseMessage) {
      const data = toolUseMessage.toolUseData;
      const toolUse = data.toolUse;
  
      const overlay = this.createModalOverlay('Tool Use');
      const body = overlay.querySelector('.modal-body');
  
      // Tool and parameters
      const toolSection = this.createModalSection('Tool', `${toolUse.tool}`);
      body.appendChild(toolSection);
  
      const paramsSection = this.createModalSection('Parameters', JSON.stringify(toolUse.params, null, 2));
      body.appendChild(paramsSection);
  
      // For read_file, show additional context
      if (toolUse.tool === 'read_file') {
        const pathSection = this.createModalSection('File Path', toolUse.params.path);
        body.appendChild(pathSection);
      }
  
      // For update_mental_model, show the mental model updates
      if (toolUse.tool === 'update_mental_model' && toolUse.params.notes) {
        const notesSection = this.createModalSection(
          'Mental Model Updates',
          JSON.stringify(toolUse.params.notes, null, 2)
        );
        body.appendChild(notesSection);
  
        // Show individual file notes for easier reading
        const notes = toolUse.params.notes;
        if (Object.keys(notes).length > 0) {
          Object.entries(notes).forEach(([filePath, fileNotes]) => {
            const fileSection = this.createModalSection(
              `File: ${filePath}`,
              fileNotes
            );
            body.appendChild(fileSection);
          });
        }
      }
  
      // Full tool use object
      const fullSection = this.createModalSection('Full Tool Use Object', JSON.stringify(toolUse, null, 2));
      body.appendChild(fullSection);
  
      document.body.appendChild(overlay);
    },
  
    showToolResultModal: function(toolResultMessage) {
      const overlay = this.createModalOverlay('Tool Execution Details');
      const body = overlay.querySelector('.modal-body');
  
      const state = window.module['state.js'];
      const messages = state.getMessages();
      const currentIndex = messages.indexOf(toolResultMessage);
  
      // Find the previous assistant message (contains the tool execution request)
      let inputMessage = null;
      if (currentIndex !== -1) {
        for (let i = currentIndex - 1; i >= 0; i--) {
          if (messages[i].role === 'assistant') {
            inputMessage = messages[i];
            break;
          }
        }
      }
  
      // INPUT: Show the full API request body that generated this tool execution
      if (inputMessage && inputMessage.apiData && inputMessage.apiData.inputFull) {
        const inputSection = this.createModalSection(
          'Input',
          JSON.stringify(inputMessage.apiData.inputFull, null, 2)
        );
        body.appendChild(inputSection);
      } else {
        const noInputSection = this.createModalSection(
          'Input',
          'Could not find the associated API request'
        );
        body.appendChild(noInputSection);
      }
  
      // OUTPUT: Show the full API response that came back
      if (inputMessage && inputMessage.apiData && inputMessage.apiData.output) {
        const outputSection = this.createModalSection(
          'Output',
          JSON.stringify(inputMessage.apiData.output, null, 2)
        );
        body.appendChild(outputSection);
      } else {
        const noOutputSection = this.createModalSection(
          'Output',
          'Could not find the associated API response'
        );
        body.appendChild(noOutputSection);
      }
  
      document.body.appendChild(overlay);
    },
  
    createModalOverlay: function(title) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = title;
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      return overlay;
    },
  
    createModalSection: function(title, content) {
      const section = document.createElement('div');
      section.className = 'modal-section';
  
      const titleRow = document.createElement('div');
      titleRow.className = 'modal-section-title-row';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-section-title';
      titleEl.textContent = title;
  
      const copyBtn = document.createElement('button');
      copyBtn.className = 'modal-section-copy-btn';
      copyBtn.textContent = 'Copy';
      copyBtn.onclick = () => this.copySectionContent(content, copyBtn);
  
      titleRow.appendChild(titleEl);
      titleRow.appendChild(copyBtn);
  
      const contentEl = document.createElement('div');
      contentEl.className = 'modal-section-content';
      contentEl.textContent = content;
  
      section.appendChild(titleRow);
      section.appendChild(contentEl);
  
      return section;
    },
  
    copySectionContent: function(content, button) {
      navigator.clipboard.writeText(content).then(() => {
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.style.backgroundColor = 'var(--color-gold)';
        button.style.color = 'var(--color-bg-primary)';
  
        setTimeout(() => {
          button.textContent = originalText;
          button.style.backgroundColor = '';
          button.style.color = '';
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy:', err);
        button.textContent = 'Failed';
        setTimeout(() => {
          button.textContent = 'Copy';
        }, 2000);
      });
    },
  
    showAssistantMessageModal: function(message) {
      const apiData = message.apiData;
  
      const overlay = this.createModalOverlay('Assistant Message Details');
      const body = overlay.querySelector('.modal-body');
  
      if (!apiData) {
        // No API data available (e.g., initial greeting)
        const noDataSection = this.createModalSection(
          'No API Data',
          'No API interaction data available for this message'
        );
        body.appendChild(noDataSection);
      } else {
        // Input: Full API request body (stored at time of request)
        if (apiData.inputFull) {
          const inputSection = this.createModalSection(
            'Input',
            JSON.stringify(apiData.inputFull, null, 2)
          );
          body.appendChild(inputSection);
        }
  
        // Output: Full API response
        if (apiData.output) {
          const outputSection = this.createModalSection(
            'Output',
            JSON.stringify(apiData.output, null, 2)
          );
          body.appendChild(outputSection);
        }
      }
  
      document.body.appendChild(overlay);
    },
  
    // Calculate messages size in tokens
    calculateMessagesSize: function() {
      const state = window.module['state.js'];
      return state.calculateTokens();
    },
  
    // Format size in K (1K = 1000 tokens)
    formatSize: function(tokens) {
      const k = Math.ceil(tokens / 1000);
      return k + 'K';
    },
  
    // Update context stats display
    updateContextStats: function() {
      const messagesBtn = document.getElementById('messages-stat-btn');
  
      if (!messagesBtn) {
        return;
      }
  
      const tokens = this.calculateMessagesSize();
  
      messagesBtn.textContent = this.formatSize(tokens);
    },
  
    // Show clear confirmation modal
    showClearModal: function(contextType) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = 'Clear Messages';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      const message = document.createElement('div');
      message.style.marginBottom = '20px';
      message.style.color = 'var(--color-text-primary)';
      message.textContent = 'Are you sure you want to clear all messages? This will reset the conversation history (except the initial greeting).';
  
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.justifyContent = 'flex-end';
  
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.style.background = 'var(--color-bg-primary)';
      cancelBtn.style.border = '1px solid var(--color-border)';
      cancelBtn.style.color = 'var(--color-text-primary)';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      cancelBtn.onclick = () => overlay.remove();
  
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'Clear';
      confirmBtn.style.padding = '8px 16px';
      confirmBtn.style.background = 'var(--color-gold)';
      confirmBtn.style.border = 'none';
      confirmBtn.style.color = 'var(--color-bg-primary)';
      confirmBtn.style.cursor = 'pointer';
      confirmBtn.style.borderRadius = '4px';
      confirmBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      confirmBtn.style.fontWeight = 'bold';
      confirmBtn.onclick = () => {
        this.clearContext(contextType);
        overlay.remove();
      };
  
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(confirmBtn);
  
      body.appendChild(message);
      body.appendChild(buttonContainer);
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    },
  
    // Clear context
    clearContext: function(contextType) {
      const state = window.module['state.js'];
      state.clearMessages();
  
      // Update UI
      this.renderMessages(state.getMessages());
      this.updateContextStats();
    },
  
    // Show context management modal (new)
    showContextModal: function() {
      const state = window.module['state.js'];
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = 'Context Management';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      // Current stats
      const statsDiv = document.createElement('div');
      statsDiv.style.marginBottom = '20px';
      statsDiv.style.color = 'var(--color-text-primary)';
      const currentTokens = state.calculateTokens();
      const currentLimit = state.getContextLimit();
      statsDiv.innerHTML = `Current: <strong>${this.formatSize(currentTokens)}</strong> / ${this.formatSize(currentLimit)}`;
  
      // Context limit input
      const limitLabel = document.createElement('div');
      limitLabel.style.marginBottom = '8px';
      limitLabel.style.color = 'var(--color-text-primary)';
      limitLabel.textContent = 'Context limit (tokens):';
  
      const limitInput = document.createElement('input');
      limitInput.type = 'number';
      limitInput.value = currentLimit;
      limitInput.min = '1000';
      limitInput.step = '1000';
      limitInput.style.width = '100%';
      limitInput.style.padding = '8px';
      limitInput.style.marginBottom = '20px';
      limitInput.style.background = 'var(--color-bg-primary)';
      limitInput.style.border = '1px solid var(--color-border)';
      limitInput.style.color = 'var(--color-text-primary)';
      limitInput.style.borderRadius = '4px';
      limitInput.style.fontSize = '14px';
      limitInput.style.fontFamily = "'Consolas', 'Courier New', monospace";
  
      // Buttons
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.justifyContent = 'flex-end';
      buttonContainer.style.marginTop = '20px';
  
      const clearBtn = document.createElement('button');
      clearBtn.textContent = 'Clear All';
      clearBtn.style.padding = '8px 16px';
      clearBtn.style.background = 'var(--color-bg-primary)';
      clearBtn.style.border = '1px solid #ff6b6b';
      clearBtn.style.color = '#ff6b6b';
      clearBtn.style.cursor = 'pointer';
      clearBtn.style.borderRadius = '4px';
      clearBtn.style.fontSize = '14px';
      clearBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      clearBtn.style.marginRight = 'auto';
      clearBtn.onclick = () => {
        if (confirm('Are you sure you want to clear all messages?')) {
          state.clearMessages();
          this.renderMessages(state.getMessages());
          this.updateContextStats();
          overlay.remove();
        }
      };
  
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.style.background = 'var(--color-bg-primary)';
      cancelBtn.style.border = '1px solid var(--color-border)';
      cancelBtn.style.color = 'var(--color-text-primary)';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      cancelBtn.onclick = () => overlay.remove();
  
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'Save Limit';
      saveBtn.style.padding = '8px 16px';
      saveBtn.style.background = 'var(--color-gold)';
      saveBtn.style.border = 'none';
      saveBtn.style.color = 'var(--color-bg-primary)';
      saveBtn.style.cursor = 'pointer';
      saveBtn.style.borderRadius = '4px';
      saveBtn.style.fontSize = '14px';
      saveBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      saveBtn.style.fontWeight = 'bold';
      saveBtn.onclick = async () => {
        const newLimit = parseInt(limitInput.value);
        if (newLimit && newLimit >= 1000) {
          state.setContextLimit(newLimit);
  
          // If new limit is lower than current usage, trigger compaction
          if (currentTokens > newLimit) {
            const main = window.module['main.js'];
            await main.compactContext();
            this.renderMessages(state.getMessages());
          }
  
          this.updateContextStats();
          overlay.remove();
        } else {
          alert('Please enter a valid limit (minimum 1000 tokens)');
        }
      };
  
      buttonContainer.appendChild(clearBtn);
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(saveBtn);
  
      body.appendChild(statsDiv);
      body.appendChild(limitLabel);
      body.appendChild(limitInput);
      body.appendChild(buttonContainer);
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
