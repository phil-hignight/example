// AI Agent - Built 2025-11-23T19:17:00.074Z
(function() {
  window.module = {};

  // Module: api-diagnostics.js
  // API Diagnostics - Tests complexity vs size to find timeout issues
  window.module['api-diagnostics.js'] = {
    results: [],
  
    // Main entry point - tests EXACT compaction format at various sizes
    runAllTests: async function() {
      console.log('\n========== API DIAGNOSTICS: EXACT Compaction Format Test ==========\n');
      console.log('Testing with EXACT prompt and format used in main.js compactContext...\n');
  
      const api = window.module['api.js'];
      this.results = [];
  
      // EXACT prompt from main.js compactContext (line 1188-1196)
      const compactionPrompt = 'You are summarizing a conversation between a user and a coding agent that has file system tools (read, write, search, edit files).\n\n' +
        'Provide a concise summary including:\n' +
        '1. User\'s most recent request\n' +
        '2. Recent actions (files read, edited, created)\n' +
        '3. Key decisions and context needed to continue\n' +
        '4. Any ongoing work or issues\n\n' +
        'Be concise. Focus on actionable context.\n\n' +
        'Conversation:\n\n';
  
      // Test sizes (in chars) - 100 to 30K tokens = 400 to 120000 chars
      const sizes = [400, 2000, 4000, 8000, 16000, 24000, 32000, 48000, 64000, 80000, 100000, 120000];
  
      for (const size of sizes) {
        // Use EXACT format: [role]: content
        const conversation = this.generateCompactionFormatConversation(size);
        const content = compactionPrompt + conversation;
        const tokens = Math.round(content.length / 4);
  
        console.log(`\n[exact-compaction-${tokens}tok] Testing...`);
  
        const messages = [{ role: 'user', content }];
        const startTime = Date.now();
  
        try {
          const response = await api.callAPISimple(messages);
          const duration = ((Date.now() - startTime) / 1000).toFixed(1);
          const timings = response.attemptTimings || [];
          const timingStr = timings.map(t => `${t.success ? 'âœ“' : 'âœ—'}${t.duration}s`).join(', ');
  
          if (response.valid) {
            console.log(`  âœ“ OK (total ${duration}s) [${timingStr}] - Summary: "${response.text.substring(0, 80)}..."`);
            this.results.push({ name: `exact-compaction-${tokens}tok`, tokens, success: true, duration, timings, error: null });
          } else {
            console.log(`  âœ— FAILED (total ${duration}s) [${timingStr}] - ${response.error.substring(0, 100)}`);
            this.results.push({ name: `exact-compaction-${tokens}tok`, tokens, success: false, duration, timings, error: response.error });
          }
        } catch (e) {
          const duration = ((Date.now() - startTime) / 1000).toFixed(1);
          console.log(`  âœ— EXCEPTION (total ${duration}s) - ${e.message.substring(0, 100)}`);
          this.results.push({ name: `exact-compaction-${tokens}tok`, tokens, success: false, duration, timings: [], error: e.message });
        }
  
        await this.delay(500);
      }
  
      this.printCompactionSummary();
    },
  
    // Generate realistic coding conversation (clean text)
    generateCodingConversation: function(targetLength) {
      const exchanges = [
        { user: "Can you help me fix a bug in my authentication code?", assistant: "I'd be happy to help. Could you share the relevant code and describe what's happening?" },
        { user: "Here's the login function:\nfunction login(user, pass) {\n  const hash = md5(pass);\n  return db.query('SELECT * FROM users WHERE name=' + user);\n}", assistant: "I see a SQL injection vulnerability. Let me fix that by using parameterized queries:\n```javascript\nfunction login(user, pass) {\n  const hash = md5(pass);\n  return db.query('SELECT * FROM users WHERE name = ?', [user]);\n}\n```" },
        { user: "Thanks! Now I'm getting a timeout error on large queries.", assistant: "Let's add pagination and indexing. First, ensure you have an index on the name column, then modify the query to use LIMIT and OFFSET." },
        { user: "I also need to add rate limiting to prevent brute force attacks.", assistant: "Good idea. Here's a simple rate limiter using a token bucket algorithm:\n```javascript\nconst rateLimiter = {\n  tokens: 10,\n  lastRefill: Date.now(),\n  refillRate: 1000,\n  check() {\n    const now = Date.now();\n    this.tokens = Math.min(10, this.tokens + (now - this.lastRefill) / this.refillRate);\n    this.lastRefill = now;\n    return this.tokens-- > 0;\n  }\n};\n```" },
        { user: "The tests are failing now. Here's the error:\nAssertionError: expected 401 to equal 200", assistant: "The rate limiter is blocking test requests. Add a test mode bypass or mock the rate limiter in tests." },
      ];
  
      let conversation = '';
      let i = 0;
      while (conversation.length < targetLength) {
        const ex = exchanges[i % exchanges.length];
        conversation += `User: ${ex.user}\n\nAssistant: ${ex.assistant}\n\n`;
        i++;
      }
      return conversation.substring(0, targetLength);
    },
  
    // Generate conversation in EXACT compaction format with tool messages
    generateCompactionFormatConversation: function(targetLength) {
      // This mimics the exact format used in main.js compactContext:
      // messagesToSummarize.map(m => `[${m.role}]: ${m.content}`).join('\n\n')
      const messages = [
        { role: 'user', content: 'Can you help me fix a bug in my authentication code?' },
        { role: 'assistant', content: 'I\'d be happy to help. Let me read the file first.' },
        { role: 'tool-use', content: 'read_file {"path":"src/auth.js"}' },
        { role: 'tool-result', content: 'File: src/auth.js (150 lines)\n\n1: // Authentication module\n2: function login(user, pass) {\n3:   const hash = md5(pass);\n4:   return db.query(\'SELECT * FROM users WHERE name=\' + user);\n5: }\n6: \n7: function logout() {\n8:   session.destroy();\n9: }\n10: // ... more code ...' },
        { role: 'assistant', content: 'I found a SQL injection vulnerability. Let me fix it.' },
        { role: 'tool-use', content: 'edit_file {"path":"src/auth.js","find":"(50 chars)","replace":"(60 chars)"}' },
        { role: 'tool-result', content: 'Successfully edited src/auth.js' },
        { role: 'user', content: 'Now I need to add rate limiting.' },
        { role: 'assistant', content: 'I\'ll search for where to add the rate limiter.' },
        { role: 'tool-use', content: 'search_by_content {"text":"login","path":"."}' },
        { role: 'tool-result', content: 'Found 5 matches:\nsrc/auth.js:4: function login(user, pass)\nsrc/routes/api.js:15: router.post(\'/login\', auth.login)\nsrc/tests/auth.test.js:10: describe(\'login\')' },
      ];
  
      let conversation = '';
      let i = 0;
      while (conversation.length < targetLength) {
        const m = messages[i % messages.length];
        conversation += `[${m.role}]: ${m.content}\n\n`;
        i++;
      }
      return conversation.substring(0, targetLength);
    },
  
    printCompactionSummary: function() {
      console.log('\n========== COMPACTION TEST SUMMARY ==========\n');
  
      const passed = this.results.filter(r => r.success);
      const failed = this.results.filter(r => !r.success);
  
      console.log(`Passed: ${passed.length}, Failed: ${failed.length}`);
  
      if (passed.length > 0) {
        const maxSuccess = Math.max(...passed.map(r => r.tokens));
        console.log(`\nMax successful size: ${maxSuccess} tokens`);
      }
  
      if (failed.length > 0) {
        const minFail = Math.min(...failed.map(r => r.tokens));
        console.log(`First failure at: ${minFail} tokens`);
        console.log('\nFailures:');
        for (const f of failed) {
          console.log(`  - ${f.name}: ${f.error?.substring(0, 60)}`);
        }
      }
  
      console.log('\n========== END ==========\n');
    },
  
    runTest: async function(test, api) {
      const { name, complexity, size, prompt } = test;
  
      // Build content to match target size
      let content = prompt;
      if (size > prompt.length) {
        const padding = this.generatePadding(complexity, size - prompt.length);
        content = prompt + padding;
      }
  
      const messages = [{ role: 'user', content }];
      const actualSize = JSON.stringify(messages).length;
      const tokens = Math.round(actualSize / 4);
  
      console.log(`[${name}] ${complexity} @ ${tokens} tokens...`);
  
      const startTime = Date.now();
      try {
        const response = await api.callAPISimple(messages);
        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
  
        if (response.valid) {
          console.log(`  âœ“ OK (${duration}s) - Response: "${response.text.substring(0, 50)}..."`);
          this.results.push({ name, complexity, tokens, success: true, duration, error: null });
        } else {
          console.log(`  âœ— FAILED (${duration}s) - ${response.error.substring(0, 100)}`);
          this.results.push({ name, complexity, tokens, success: false, duration, error: response.error });
        }
      } catch (e) {
        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
        console.log(`  âœ— EXCEPTION (${duration}s) - ${e.message.substring(0, 100)}`);
        this.results.push({ name, complexity, tokens, success: false, duration, error: e.message });
      }
    },
  
    generatePadding: function(complexity, length) {
      if (complexity === 'simple') {
        // Just filler text
        return 'x'.repeat(length);
      } else if (complexity === 'medium') {
        // Repeating pattern
        return 'x'.repeat(length);
      } else if (complexity === 'complex') {
        // Fake conversation to summarize
        const messages = [];
        let total = 0;
        let i = 0;
        while (total < length) {
          const role = i % 2 === 0 ? 'User' : 'Assistant';
          const msg = `${role}: This is message number ${i}. It contains some content that needs to be summarized.\n`;
          messages.push(msg);
          total += msg.length;
          i++;
        }
        return messages.join('').substring(0, length);
      } else {
        // Code-like content for analysis
        const lines = [];
        let total = 0;
        let i = 0;
        while (total < length) {
          const line = `function func${i}(x) { return x * ${i}; }\n`;
          lines.push(line);
          total += line.length;
          i++;
        }
        return lines.join('').substring(0, length);
      }
    },
  
    printSummary: function() {
      console.log('\n========== SUMMARY ==========\n');
  
      // Group by complexity
      const byComplexity = {};
      for (const r of this.results) {
        if (!byComplexity[r.complexity]) byComplexity[r.complexity] = [];
        byComplexity[r.complexity].push(r);
      }
  
      for (const [complexity, results] of Object.entries(byComplexity)) {
        const passed = results.filter(r => r.success).length;
        const failed = results.filter(r => !r.success).length;
        console.log(`${complexity.toUpperCase()}: ${passed} passed, ${failed} failed`);
  
        if (failed > 0) {
          const failures = results.filter(r => !r.success);
          for (const f of failures) {
            console.log(`  - ${f.name} (${f.tokens} tokens): ${f.error?.substring(0, 80)}`);
          }
        }
      }
  
      // Look for pattern
      const simpleMax = Math.max(...this.results.filter(r => r.complexity === 'simple' && r.success).map(r => r.tokens), 0);
      const complexMax = Math.max(...this.results.filter(r => r.complexity === 'complex' && r.success).map(r => r.tokens), 0);
  
      console.log('\n--- Analysis ---');
      console.log(`Simple requests succeeded up to: ${simpleMax} tokens`);
      console.log(`Complex requests succeeded up to: ${complexMax} tokens`);
  
      if (complexMax < simpleMax && complexMax > 0) {
        console.log('\nâš ï¸  TIMEOUT THEORY CONFIRMED: Complex requests fail at smaller sizes!');
        console.log('   This suggests the API has a timeout that complex requests exceed.');
      }
  
      console.log('\n========== END ==========\n');
    },
  
    delay: function(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  };
  

  // Module: api.js
  // API communication
  window.module['api.js'] = {
    // Render messages for API - simplified version
    renderMessagesForAPI: function(messages) {
      const tools = window.module['tools.js'];
      const state = window.module['state.js'];
      const diagnostics = window.module['diagnostics.js'];
  
      diagnostics.log('api', 'renderMessagesForAPI called', { totalMessages: messages.length });
  
      // Find most recent summary
      let mostRecentSummaryIndex = -1;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].type === 'summary') {
          mostRecentSummaryIndex = i;
          break;
        }
      }
  
      // Filter: start from most recent summary (or all messages if no summary)
      let messagesToProcess = messages;
      if (mostRecentSummaryIndex !== -1) {
        // Include everything from the summary forward
        messagesToProcess = messages.slice(mostRecentSummaryIndex);
        diagnostics.log('api', 'Starting from summary', {
          summaryIndex: mostRecentSummaryIndex,
          messagesIncluded: messagesToProcess.length
        });
      }
  
      // Filter out UI-only messages
      const apiMessages = messagesToProcess.filter(msg => !msg.uiOnly);
  
      diagnostics.log('api', 'After UI filtering', { apiMessagesCount: apiMessages.length });
  
      // Log total size estimate and find largest messages
      const totalChars = apiMessages.reduce((sum, msg) => sum + (msg.content?.length || 0), 0);
      const estimatedTokens = Math.ceil(totalChars / 4);
      diagnostics.log('api', 'Message size calculation', { totalChars, estimatedTokens });
  
      // Find and log the 5 largest messages
      const messagesWithSize = apiMessages.map((msg, idx) => ({
        index: idx,
        type: msg.type,
        toolName: msg.toolName,
        size: msg.content?.length || 0,
        preview: msg.content?.substring(0, 100) || ''
      })).sort((a, b) => b.size - a.size);
  
      diagnostics.log('api', 'Top 5 largest messages', { top5: messagesWithSize.slice(0, 5) });
  
      // Convert messages for API: translate type to role
      // Combine consecutive user messages
      const processedMessages = [];
  
      for (let i = 0; i < apiMessages.length; i++) {
        const msg = apiMessages[i];
  
        // Translate type to role for API
        let apiRole;
        if (msg.type === 'user_msg' || msg.type === 'tool-use' || msg.type === 'tool-result' || msg.type === 'summary') {
          apiRole = 'user';
        } else if (msg.type === 'assistant_msg') {
          apiRole = 'assistant';
        } else {
          // Fallback for unknown types
          apiRole = 'user';
        }
  
        const newMsg = {
          role: apiRole,
          content: msg.content
        };
  
        // Check if we need to combine consecutive user messages
        if (newMsg.role === 'user' && processedMessages.length > 0 && processedMessages[processedMessages.length - 1].role === 'user') {
          // Combine with previous user message
          processedMessages[processedMessages.length - 1].content += '\n\n' + newMsg.content;
        } else {
          processedMessages.push(newMsg);
        }
      }
  
      diagnostics.log('api', 'Sending messages to API', { messageCount: processedMessages.length });
  
      return {
        messages: processedMessages,
        summary: null  // No longer needed since summary is included in messages
      };
    },
  
    // Handle truncated responses by requesting continuations
    handleTruncatedResponse: async function(initialResponseText, headers, requestBody, startTime) {
      const diagnostics = window.module['diagnostics.js'];
      const TERMINATOR = '||||END||||';
      const MAX_CONTINUATIONS = 20;
      const TAIL_LENGTH = 20;
  
      let fullResponse = initialResponseText;
      let continuationCount = 0;
      let lastChunk = null;
      let incomplete = false;
      let incompleteReason = null;
  
      diagnostics.log('api', 'Response missing terminator - handling truncation');
  
      while (!fullResponse.includes(TERMINATOR) && continuationCount < MAX_CONTINUATIONS) {
        continuationCount++;
        diagnostics.log('api', 'Requesting continuation', { continuationCount, MAX_CONTINUATIONS });
  
        // Get last TAIL_LENGTH characters
        const tail = fullResponse.slice(-TAIL_LENGTH);
        diagnostics.log('api', 'Tail characters', { TAIL_LENGTH, tail });
  
        // Create continuation prompt
        const continuationMessages = [
          ...requestBody.messages,
          {
            role: 'assistant',
            content: fullResponse
          },
          {
            role: 'user',
            content: `Your response was truncated. The last ${TAIL_LENGTH} characters were: "${tail}". Continue from exactly the next character. When done, end with ||||END||||`
          }
        ];
  
        const continuationBody = {
          ...requestBody,
          messages: continuationMessages
        };
  
        try {
          // Make continuation request
          const response = await fetch('/api/chat/completions', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(continuationBody)
          });
  
          if (!response.ok) {
            const errorText = await response.text();
            diagnostics.handleError('API_ERROR', {
              error: new Error(`Continuation request failed (${response.status})`),
              response: { status: response.status, statusText: response.statusText },
              requestBody: continuationBody
            });
            incomplete = true;
            incompleteReason = `Continuation request failed (${response.status})`;
            break;
          }
  
          let data;
          try {
            data = await response.json();
          } catch (error) {
            const responseText = await response.text();
            diagnostics.handleError('JSON_PARSE_ERROR', {
              error,
              jsonString: responseText,
              position: error.message.match(/position (\d+)/)?.[1] || 0
            });
            incomplete = true;
            incompleteReason = `JSON parse error: ${error.message}`;
            break;
          }
          const chunk = data.choices[0].message.content;
          diagnostics.log('api', 'Chunk received', { chunkPreview: chunk.substring(0, 100) });
  
          // Handle blank response
          if (!chunk || chunk.trim() === '') {
            diagnostics.log('api', 'Received blank continuation - stopping');
            incomplete = true;
            incompleteReason = 'Received blank continuation response';
            break;
          }
  
          // Check for duplicate chunks (AI repeating itself)
          if (lastChunk && chunk === lastChunk) {
            diagnostics.log('api', 'AI is repeating the same chunk - aborting continuation');
            incomplete = true;
            incompleteReason = 'AI is repeating the same content';
            break;
          }
          lastChunk = chunk;
  
          // If AI just sends terminator, it means previous response was complete
          if (chunk.trim() === TERMINATOR) {
            diagnostics.log('api', 'AI confirmed completion with terminator');
            fullResponse += TERMINATOR;
            break;
          }
  
          // Check if the continuation starts with part of the tail (overlap detection)
          // The AI might repeat some characters to ensure continuity
          let chunkToAdd = chunk;
          let overlapFound = false;
          for (let overlapLen = TAIL_LENGTH; overlapLen > 0; overlapLen--) {
            const tailEnd = tail.slice(-overlapLen);
            const chunkStart = chunk.slice(0, overlapLen);
            if (tailEnd === chunkStart) {
              // Found overlap - remove it from the chunk
              chunkToAdd = chunk.slice(overlapLen);
              diagnostics.log('api', 'Detected overlap', { overlapLen, tailEnd });
              overlapFound = true;
              break;
            }
          }
  
          if (!overlapFound) {
            diagnostics.log('api', 'No overlap detected between tail and chunk start');
          }
  
          diagnostics.log('api', 'Received continuation chunk', { chunkLength: chunk.length, afterOverlapRemoval: chunkToAdd.length });
          fullResponse += chunkToAdd;
        } catch (error) {
          diagnostics.log('api', 'Error during continuation', { error: error.message });
          incomplete = true;
          incompleteReason = error.message;
          break;
        }
      }
  
      if (continuationCount >= MAX_CONTINUATIONS) {
        diagnostics.log('api', 'Exceeded maximum continuation attempts', { MAX_CONTINUATIONS });
        incomplete = true;
        incompleteReason = `Exceeded maximum continuation attempts (${MAX_CONTINUATIONS})`;
      }
  
      const endTime = Date.now();
      const durationSeconds = (endTime - startTime) / 1000;
  
      if (incomplete) {
        diagnostics.log('api', 'Returning incomplete response', { continuationCount, incompleteReason });
      } else {
        diagnostics.log('api', 'Complete response assembled', { continuationCount });
      }
  
      return {
        fullResponse: fullResponse,
        durationSeconds: durationSeconds,
        incomplete: incomplete,
        incompleteReason: incompleteReason
      };
    },
  
    // Simple API call without system prompt - for internal operations like summarization
    callAPISimple: async function(messages) {
      const authToken = localStorage.getItem('token');
  
      // Transform messages to API format (with role and content)
      const result = this.renderMessagesForAPI(messages);
      const processedMessages = result.messages;
  
      const requestBody = {
        stream: false,
        model: 'Anthropic Claude 4 Sonnet',
        messages: processedMessages,
        params: {},
        features: { web_search: false },
        session_id: 'session-' + Math.random().toString(36).substr(2, 9),
        id: 'msg-' + Date.now() + '-simple',
        background_tasks: { title_generation: false, tags_generation: false }
      };
  
      const headers = { 'Content-Type': 'application/json' };
      if (authToken) headers['Authorization'] = `Bearer ${authToken}`;
  
      try {
        const response = await fetch('/api/chat/completions', {
          method: 'POST',
          headers,
          body: JSON.stringify(requestBody)
        });
  
        if (!response.ok) {
          const errorText = await response.text();
          return { valid: false, error: `API request failed (${response.status}): ${errorText}` };
        }
  
        const data = await response.json();
        const responseText = data.choices[0].message.content;
        return { valid: true, text: responseText };
      } catch (error) {
        return { valid: false, error: error.message };
      }
    },
  
    callAPI: async function(messages) {
      const diagnostics = window.module['diagnostics.js'];
      const authToken = localStorage.getItem('token');
      const tools = window.module['tools.js'];
      const TERMINATOR = '||||END||||';
  
      const result = this.renderMessagesForAPI(messages);
      const processedMessages = result.messages;
      const summary = result.summary;
  
      // Build system prompt
      let systemPrompt = tools.getSystemPrompt();
  
      // If summary exists, append it to system prompt
      if (summary) {
        systemPrompt += "\n\n=== Summary of Earlier Conversation ===\n\n" + summary;
        diagnostics.log('api', 'Appending summary to system prompt');
      }
  
      // Prepend system prompt to first user message (prod API doesn't support system field)
      const messagesWithSystem = [...processedMessages];
      if (messagesWithSystem.length > 0) {
        messagesWithSystem[0] = {
          ...messagesWithSystem[0],
          content: systemPrompt + "\n\n" + messagesWithSystem[0].content
        };
      }
  
      const requestBody = {
        stream: false,
        model: 'Anthropic Claude 4 Sonnet',
        messages: messagesWithSystem,
        // Note: Removed 'system' field - prod API doesn't support it
        // Note: Removed 'tools' field - prod API doesn't support native tools
        params: {},
        features: {
          web_search: false
        },
        session_id: 'session-' + Math.random().toString(36).substr(2, 9),
        id: 'msg-' + Date.now() + '-assistant',
        background_tasks: {
          title_generation: false,
          tags_generation: false
        }
      };
  
      // Log request body size
      const requestBodyString = JSON.stringify(requestBody);
      const requestBodySize = requestBodyString.length;
      const requestBodyTokens = Math.ceil(requestBodySize / 4);
  
      diagnostics.log('api', 'API REQUEST SUMMARY', {
        systemPromptLength: systemPrompt.length,
        messagesCount: messagesWithSystem.length,
        tools: 'list_directory, read_file, write_file',
        summaryIncluded: summary ? `YES (${summary.length} chars)` : 'NO',
        requestBodySize,
        requestBodyTokens
      });
      diagnostics.log('api', 'FULL REQUEST BODY', { requestBody });
  
      const headers = {
        'Content-Type': 'application/json'
      };
  
      if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
      }
  
      // Single attempt - no retries
      try {
        const startTime = Date.now();
        const response = await fetch('/api/chat/completions', {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(requestBody)
        });
  
        if (!response.ok) {
          const errorText = await response.text();
          diagnostics.handleError('API_ERROR', {
            error: new Error(`API request failed (${response.status}): ${errorText}`),
            response: { status: response.status, statusText: response.statusText },
            requestBody
          });
          return {
            valid: false,
            error: `API request failed (${response.status}): ${errorText}`
          };
        }
  
        let data;
        try {
          data = await response.json();
        } catch (error) {
          const responseText = await response.text();
          diagnostics.handleError('JSON_PARSE_ERROR', {
            error,
            jsonString: responseText,
            position: error.message.match(/position (\d+)/)?.[1] || 0
          });
          return {
            valid: false,
            error: `JSON parse error: ${error.message}`
          };
        }
        let responseText = data.choices[0].message.content;
        let durationSeconds = (Date.now() - startTime) / 1000;
  
        // Log response size details
        const responseDataString = JSON.stringify(data);
        const responseDataSize = responseDataString.length;
        const responseTokens = Math.ceil(responseText.length / 4);
  
        diagnostics.log('api', 'FULL API RESPONSE', { data });
        diagnostics.log('api', 'API RESPONSE SIZE', {
          responseTextLength: responseText.length,
          responseTokens,
          fullResponseDataSize: responseDataSize,
          durationSeconds: durationSeconds.toFixed(2)
        });
  
        // Check for terminator
        let wasIncomplete = false;
        let incompleteReason = null;
        if (!responseText.includes(TERMINATOR)) {
          // Handle truncation
          const result = await this.handleTruncatedResponse(responseText, headers, requestBody, startTime);
          responseText = result.fullResponse;
          durationSeconds = result.durationSeconds;
          wasIncomplete = result.incomplete;
          incompleteReason = result.incompleteReason;
        }
  
        // Remove terminator before parsing
        responseText = responseText.replace(TERMINATOR, '').trim();
  
        // Parse and validate response
        const parseResult = tools.parseResponse(responseText);
  
        if (!parseResult.valid) {
          diagnostics.log('api', 'Invalid response', {
            error: parseResult.error,
            responseTextPreview: responseText.substring(0, 500)
          });
  
          // If response was incomplete, include that info in the error
          let errorMessage = parseResult.error;
          if (wasIncomplete) {
            errorMessage += ` (Response was incomplete: ${incompleteReason})`;
          }
  
          return {
            text: responseText,
            parsed: null,
            valid: false,
            error: errorMessage,
            apiInput: processedMessages,
            apiInputFull: requestBody,
            apiOutput: data,
            durationSeconds: durationSeconds,
            incomplete: wasIncomplete,
            incompleteReason: incompleteReason
          };
        }
  
        // Return both raw text and parsed response
        return {
          text: responseText,
          parsed: parseResult.valid ? parseResult.parsed : null,
          valid: parseResult.valid,
          error: parseResult.valid ? null : parseResult.error,
          apiInput: processedMessages,  // Store input messages for debugging
          apiInputFull: requestBody,  // Store FULL request body that was actually sent
          apiOutput: data,  // Store full API response for debugging
          durationSeconds: durationSeconds
        };
      } catch (error) {
        diagnostics.log('api', 'API ERROR - EXCEPTION DURING API CALL', {
          errorMessage: error.message,
          errorStack: error.stack
        });
  
        return {
          valid: false,
          error: error.message
        };
      }
    }
  };
  

  // Module: core.js
  // Core AI agent logic (UI-independent)
  // This module contains all the logic that can run without DOM/browser UI
  window.module['core.js'] = {
    // Process AI response loop (without UI calls)
    processAIResponse: async function(getMessages, addMessage, selectedDirectory, callbacks = {}) {
      const diagnostics = window.module['diagnostics.js'];
      const api = window.module['api.js'];
      const {
        onLoading = (text) => {},
        onHideLoading = () => {},
        onRenderMessages = () => {},
        onUpdateStats = () => {},
        onProcessingChange = () => {},
        onAfterTools = async () => {}  // Callback after tools execute (for compaction check)
      } = callbacks;
  
      let continueProcessing = true;
      let iteration = 0;
  
      while (continueProcessing) {
        iteration++;
        diagnostics.log('context', '='.repeat(80));
        diagnostics.log('context', `[Core] ========== ITERATION ${iteration} START ==========`);
        diagnostics.log('context', '[Core] Total messages: ' + getMessages().length);
  
        // Send to API (loading indicator should already be showing)
        const response = await api.callAPI(getMessages());
  
        // Remove loading indicator
        onHideLoading();
  
        if (!response.valid) {
          // Invalid response - show error to user without adding to conversation
          diagnostics.log('context', '[Core] Invalid response: ' + response.error);
          onProcessingChange(false);
  
          // Show error in alert instead of adding to conversation
          alert(`API Error: ${response.error}\n\nPlease try again.`);
  
          return { success: false, error: response.error, iterations: iteration };
        }
  
        const parsedResponse = response.parsed;
  
        // If text was extracted from before/after the JSON, show it as an assistant message
        if (response.extractedText) {
          if (response.extractedText.prefix) {
            diagnostics.log('json', '[Core] Showing extracted prefix text as assistant message');
            addMessage({
              type: 'assistant_msg',
              content: response.extractedText.prefix
            });
            onRenderMessages();
          }
        }
  
        if (parsedResponse.type === 'message') {
          // Final message response
          diagnostics.log('context', '[Core] ========== MESSAGE RESPONSE ==========');
  
          addMessage({
            type: 'assistant_msg',
            content: parsedResponse.content,
            apiData: {
              input: response.apiInput,
              inputFull: response.apiInputFull,
              output: response.apiOutput,
              rawResponse: response.text
            },
            durationSeconds: response.durationSeconds
          });
          onRenderMessages();
          onUpdateStats();
  
          // If there's suffix text (text after JSON), show it as assistant message
          if (response.extractedText && response.extractedText.suffix) {
            diagnostics.log('json', '[Core] Showing extracted suffix text as assistant message');
            addMessage({
              type: 'assistant_msg',
              content: response.extractedText.suffix
            });
            onRenderMessages();
          }
  
          continueProcessing = false;
        } else if (parsedResponse.type === 'execute') {
          diagnostics.log('tools', '[Core] ========== EXECUTE RESPONSE ==========');
          diagnostics.log('tools', '[Core] AI requested ' + parsedResponse.tool_uses.length + ' tool(s)');
  
          // Add assistant message with API data
          addMessage({
            type: 'assistant_msg',
            content: response.text,
            apiData: {
              input: response.apiInput,
              inputFull: response.apiInputFull,
              output: response.apiOutput,
              rawResponse: response.text
            },
            durationSeconds: response.durationSeconds
          });
          onRenderMessages();
          onUpdateStats();
  
          // Show loading before executing tools
          onLoading('Running');
  
          // Execute all tools
          await this.executeTools(parsedResponse.tool_uses, selectedDirectory, addMessage, onRenderMessages);
  
          // Hide loading after tools complete
          onHideLoading();
  
          // If there's suffix text (text after JSON), show it as assistant message
          if (response.extractedText && response.extractedText.suffix) {
            diagnostics.log('json', '[Core] Showing extracted suffix text as assistant message');
            addMessage({
              type: 'assistant_msg',
              content: response.extractedText.suffix
            });
            onRenderMessages();
          }
  
          // Check if compaction is needed after tools added results
          await onAfterTools();
  
          // NEW: Stop here - user will manually submit to continue
          continueProcessing = false;
        }
      }
  
      diagnostics.log('context', '[Core] Processing complete after ' + iteration + ' iterations');
      return { success: true, iterations: iteration };
    },
  
    // Truncate tool output if it exceeds size limit (DISABLED - show full content)
    truncateToolOutput: function(content, toolName) {
      // No truncation - show full content
      return content;
    },
  
    // Execute tools (unified handler for all tools) - UI-independent
    executeTools: async function(toolUses, selectedDirectory, addMessage, onRenderMessages = () => {}) {
      for (const toolUse of toolUses) {
        if (toolUse.name === 'list_directory') {
          // Add tool use message
          addMessage({
            type: 'tool-use',
            toolName: 'list_directory',
            params: toolUse.input,
            content: `list_directory ${JSON.stringify(toolUse.input)}`
          });
  
          const startTime = performance.now();
          const result = await this.executeListDirectory(toolUse.input.path, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            // Count entries
            const lines = result.output.split('\n');
            const dirCount = lines.filter(l => l.includes('ðŸ“')).length;
            const fileCount = lines.filter(l => l.includes('ðŸ“„')).length;
            const total = dirCount + fileCount;
  
            addMessage({
              type: 'tool-result',
              toolName: 'list_directory',
              summary: `Listed ${total} items (${dirCount} folders, ${fileCount} files)`,
              fullResult: result.output,
              content: `Tool result for list_directory("${toolUse.input.path}"):\n\n${result.output}`,
              durationMs
            });
          } else {
            addMessage({
              type: 'tool-result',
              toolName: 'list_directory',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Tool error for list_directory("${toolUse.input.path}"): ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'read_file') {
          // Add tool use message
          addMessage({
            type: 'tool-use',
            toolName: 'read_file',
            params: toolUse.input,
            content: `read_file ${JSON.stringify(toolUse.input)}`
          });
  
          const startTime = performance.now();
          const result = await this.executeReadFile(toolUse.input.path, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            const allLines = result.content.split('\n');
            const totalLines = allLines.length;
  
            // Apply offset/limit if provided
            const offset = toolUse.input.offset || 1;
            const limit = toolUse.input.limit || totalLines;
            const startLine = Math.max(1, offset) - 1; // Convert to 0-based
            const endLine = Math.min(startLine + limit, totalLines);
            const selectedLines = allLines.slice(startLine, endLine);
            const selectedContent = selectedLines.join('\n');
  
            // Add line numbers
            const numberedContent = selectedLines.map((line, i) => `${startLine + i + 1}: ${line}`).join('\n');
  
            const truncatedContent = this.truncateToolOutput(numberedContent, 'read_file');
            const wasTruncated = truncatedContent.length < numberedContent.length;
  
            // Calculate how many lines were actually shown
            let endLineNumber;
            if (wasTruncated) {
              // Count lines in truncated output (it has line numbers, so count newlines)
              const linesInTruncated = truncatedContent.split('\n').length;
              endLineNumber = offset + linesInTruncated - 1;
            } else {
              // No truncation - use actual selected lines
              const actualLinesSelected = selectedLines.length;
              endLineNumber = Math.min(offset + actualLinesSelected - 1, totalLines);
            }
  
            const remainingLines = totalLines - endLineNumber;
            const nextOffset = endLineNumber + 1;
  
            // Build truncation info
            let truncationNote = '';
            if (wasTruncated || remainingLines > 0) {
              truncationNote = `\n\n[Showing lines ${offset}-${endLineNumber} of ${totalLines}. ${remainingLines} more lines. Use offset:${nextOffset} to continue.]`;
            }
  
            // Build summary message - format: "Read File â€¢ path/to/file.js\n123 lines" or "lines 1-50 of 243"
            let lineInfo;
            if (offset === 1 && endLineNumber === totalLines && !wasTruncated) {
              // Read the whole file without truncation
              lineInfo = `${totalLines} lines`;
            } else {
              // Partial read or truncated
              lineInfo = `lines ${offset}-${endLineNumber} of ${totalLines}${wasTruncated ? ' (truncated)' : ''}`;
            }
            const summary = `Read File â€¢ ${result.path}\n${lineInfo}`;
  
            addMessage({
              type: 'tool-result',
              toolName: 'read_file',
              summary: summary,
              fullResult: result.content,
              content: `File: ${result.path} (${totalLines} lines total)\n\n${truncatedContent}${truncationNote}`,
              truncated: wasTruncated,
              durationMs
            });
          } else {
            addMessage({
              type: 'tool-result',
              toolName: 'read_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error reading file ${result.path}: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'write_file') {
          // Add tool use message
          addMessage({
            type: 'tool-use',
            toolName: 'write_file',
            params: toolUse.input,
            content: `write_file ${JSON.stringify({ path: toolUse.input.path, content: `(${toolUse.input.content.length} chars)` })}`
          });
  
          const startTime = performance.now();
          const result = await this.executeWriteFile(toolUse.input.path, toolUse.input.content, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            addMessage({
              type: 'tool-result',
              toolName: 'write_file',
              summary: `Wrote ${toolUse.input.content.length} characters to ${result.path}`,
              fullResult: `Successfully wrote to ${result.path}`,
              content: `Successfully wrote ${toolUse.input.content.length} characters to ${result.path}`,
              durationMs
            });
          } else {
            addMessage({
              type: 'tool-result',
              toolName: 'write_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error writing file ${result.path}: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'search_by_filename') {
          // Add tool use message
          addMessage({
            type: 'tool-use',
            toolName: 'search_by_filename',
            params: toolUse.input,
            content: `search_by_filename ${JSON.stringify(toolUse.input)}`
          });
  
          const startTime = performance.now();
          const searchPath = toolUse.input.path || '.';
          const result = await this.executeSearchByFilename(toolUse.input.pattern, searchPath, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
  
            addMessage({
              type: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Found ${matchCount} file(s) matching "${toolUse.input.pattern}"${timeoutWarning}`,
              fullResult: result.output,
              content: `Search results for pattern "${toolUse.input.pattern}" in "${searchPath}":\n\n${result.output}`,
              durationMs
            });
          } else {
            addMessage({
              type: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching for files: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'search_by_content') {
          // Add tool use message
          addMessage({
            type: 'tool-use',
            toolName: 'search_by_content',
            params: toolUse.input,
            content: `search_by_content ${JSON.stringify(toolUse.input)}`
          });
  
          const startTime = performance.now();
          const searchPath = toolUse.input.path || '.';
          const filePattern = toolUse.input.filePattern || null;
          const result = await this.executeSearchByContent(toolUse.input.text, searchPath, filePattern, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
  
            addMessage({
              type: 'tool-result',
              toolName: 'search_by_content',
              summary: `Found ${matchCount} match(es) for "${toolUse.input.text}"${timeoutWarning}`,
              fullResult: result.output,
              content: `Search results for text "${toolUse.input.text}" in "${searchPath}":\n\n${result.output}`,
              durationMs
            });
          } else {
            addMessage({
              type: 'tool-result',
              toolName: 'search_by_content',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching file contents: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'edit_file') {
          // Add tool use message
          addMessage({
            type: 'tool-use',
            toolName: 'edit_file',
            params: toolUse.input,
            content: `edit_file ${JSON.stringify({ path: toolUse.input.path, find: `(${toolUse.input.find.length} chars)`, replace: `(${toolUse.input.replace.length} chars)` })}`
          });
  
          const startTime = performance.now();
          const result = await this.executeEditFile(toolUse.input.path, toolUse.input.find, toolUse.input.replace, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            addMessage({
              type: 'tool-result',
              toolName: 'edit_file',
              summary: `Edited ${result.path}: replaced ${toolUse.input.find.length} chars with ${toolUse.input.replace.length} chars`,
              fullResult: `Successfully edited ${result.path}`,
              content: `Successfully edited ${result.path}`,
              durationMs
            });
          } else {
            addMessage({
              type: 'tool-result',
              toolName: 'edit_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error editing file ${toolUse.input.path}: ${result.error}`,
              durationMs
            });
          }
        } else if (toolUse.name === 'edit_file_batch') {
          // Add tool use message
          addMessage({
            type: 'tool-use',
            toolName: 'edit_file_batch',
            params: toolUse.input,
            content: `edit_file_batch ${JSON.stringify({ path: toolUse.input.path, edits: `(${toolUse.input.edits.length} edits)` })}`
          });
  
          const startTime = performance.now();
          const result = await this.executeEditFileBatch(toolUse.input.path, toolUse.input.edits, selectedDirectory);
          const durationMs = Math.round(performance.now() - startTime);
  
          if (result.success) {
            addMessage({
              type: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Batch edited ${result.path}: applied ${toolUse.input.edits.length} edit(s)`,
              fullResult: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`,
              content: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`,
              durationMs
            });
          } else {
            addMessage({
              type: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error batch editing file ${toolUse.input.path}: ${result.error}`,
              durationMs
            });
          }
        } else {
          // Unknown tool
          addMessage({
            type: 'user_msg',
            content: `ERROR: Unknown tool "${toolUse.name}". Available tools are: list_directory, read_file, write_file, search_by_filename, search_by_content, edit_file, edit_file_batch.`,
            fromSystem: true
          });
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Core] Unknown tool: ${toolUse.name}`);
        }
      }
  
      onRenderMessages();
    },
  
    // Execute file operations using FileSystem API
    executeListDirectory: async function(path, dirHandle) {
      try {
        let targetHandle = dirHandle;
  
        // Navigate to the target path if not root
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // List directory contents
        const entries = [];
        for await (const entry of targetHandle.values()) {
          entries.push({
            name: entry.name,
            kind: entry.kind
          });
        }
  
        // Format output
        let output = `Contents of "${path || '.'}":\n\n`;
        const dirs = entries.filter(e => e.kind === 'directory').sort((a, b) => a.name.localeCompare(b.name));
        const files = entries.filter(e => e.kind === 'file').sort((a, b) => a.name.localeCompare(b.name));
  
        if (dirs.length > 0) {
          output += 'Directories:\n';
          dirs.forEach(d => {
            output += `  ðŸ“ ${d.name}/\n`;
          });
        }
  
        if (files.length > 0) {
          output += '\nFiles:\n';
          files.forEach(f => {
            output += `  ðŸ“„ ${f.name}\n`;
          });
        }
  
        if (entries.length === 0) {
          output += '(empty directory)\n';
        }
  
        return { success: true, output };
      } catch (error) {
        return { success: false, error: error.message };
      }
    },
  
    executeReadFile: async function(path, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory
        for (let i = 0; i < pathParts.length - 1; i++) {
          currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
        }
  
        // Get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName);
        const file = await fileHandle.getFile();
        const content = await file.text();
  
        return { success: true, content, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeWriteFile: async function(path, content, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory (create if doesn't exist)
        for (let i = 0; i < pathParts.length - 1; i++) {
          try {
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
          } catch {
            // Directory doesn't exist, create it
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i], { create: true });
          }
        }
  
        // Create or get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
  
        // Write content
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        return { success: true, path };
      } catch (error) {
        // Check if it's a user activation error
        if (error.message && error.message.includes('User activation is required')) {
          return {
            success: false,
            error: `Cannot create new directories due to browser security. Please manually create the parent directory first, then try again.`,
            path
          };
        }
        return { success: false, error: error.message, path };
      }
    },
  
    // Helper function to match wildcard pattern
    matchesPattern: function(filename, pattern) {
      // Convert wildcard pattern to regex
      // * matches any characters, ? matches single character
      const regexPattern = pattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&')  // Escape special regex chars
        .replace(/\*/g, '.*')  // * becomes .*
        .replace(/\?/g, '.');  // ? becomes .
  
      const regex = new RegExp(`^${regexPattern}$`, 'i');  // Case-insensitive
      return regex.test(filename);
    },
  
    // Recursively search for files by filename pattern
    executeSearchByFilename: async function(pattern, path, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if filename matches pattern
              if (window.module['core.js'].matchesPattern(entry.name, pattern)) {
                matches.push(entryPath);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Search] Error accessing ${currentPath}: ${error.message}`);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No files found matching the pattern.';
        } else {
          output = matches.map(m => `ðŸ“„ ${m}`).join('\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Recursively search for text within file contents
    executeSearchByContent: async function(searchText, path, filePattern, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if file matches filePattern (if provided)
              if (filePattern && !window.module['core.js'].matchesPattern(entry.name, filePattern)) {
                continue;
              }
  
              try {
                // Read file and search for text
                const file = await entry.getFile();
                const content = await file.text();
  
                if (content.toLowerCase().includes(searchText.toLowerCase())) {
                  // Find line numbers where text appears
                  const lines = content.split('\n');
                  const matchingLines = [];
  
                  for (let i = 0; i < lines.length; i++) {
                    if (lines[i].toLowerCase().includes(searchText.toLowerCase())) {
                      matchingLines.push({
                        lineNum: i + 1,
                        line: lines[i].trim()
                      });
                    }
                  }
  
                  matches.push({
                    path: entryPath,
                    lineMatches: matchingLines
                  });
                }
              } catch (error) {
                // Skip binary files or files that can't be read as text
                const diagnostics = window.module['diagnostics.js'];
                diagnostics.log('tools', `[Search] Could not read ${entryPath}: ${error.message}`);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Search] Error accessing ${currentPath}: ${error.message}`);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No matches found.';
        } else {
          output = matches.map(match => {
            const header = `ðŸ“„ ${match.path}`;
            const lineInfo = match.lineMatches.slice(0, 5).map(lm =>
              `  Line ${lm.lineNum}: ${lm.line.substring(0, 100)}${lm.line.length > 100 ? '...' : ''}`
            ).join('\n');
            const moreLines = match.lineMatches.length > 5 ? `  ... and ${match.lineMatches.length - 5} more matches` : '';
  
            return `${header}\n${lineInfo}${moreLines ? '\n' + moreLines : ''}`;
          }).join('\n\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or using a file pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    executeEditFile: async function(path, findStr, replaceStr, dirHandle) {
      try {
        // 1. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        const content = readResult.content;
  
        // 2. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file.`,
            path
          };
        }
  
        // 3. Check that find string appears exactly once
        const occurrences = content.split(findStr).length - 1;
        if (occurrences === 0) {
          return {
            success: false,
            error: `Find string not found in file. The file may have changed since you last read it.`,
            path
          };
        } else if (occurrences > 1) {
          return {
            success: false,
            error: `Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
            path
          };
        }
  
        // 4. Perform replacement
        const newContent = content.replace(findStr, replaceStr);
  
        // 5. Write back
        const writeResult = await this.executeWriteFile(path, newContent, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFileBatch: async function(path, edits, dirHandle) {
      try {
        // 1. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        let content = readResult.content;
  
        // 2. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file_batch.`,
            path
          };
        }
  
        // 3. Apply each edit in sequence
        for (let i = 0; i < edits.length; i++) {
          const { find, replace } = edits[i];
  
          // Check that find string appears exactly once in current content
          const occurrences = content.split(find).length - 1;
          if (occurrences === 0) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string not found in file. The file may have changed or earlier edits affected this replacement.`,
              path
            };
          } else if (occurrences > 1) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
              path
            };
          }
  
          // Perform replacement
          content = content.replace(find, replace);
        }
  
        // 4. Write back
        const writeResult = await this.executeWriteFile(path, content, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    }
  };
  

  // Module: diagnostics.js
  // Diagnostic and Error Handling System
  // Stores logs in memory and provides structured error reporting
  
  (function() {
    'use strict';
  
    // Log storage
    const logs = [];
    const MAX_LOGS = 1000;
  
    // Logging function (replaces console.log for internal use)
    function log(category, message, data = null) {
      const entry = {
        timestamp: Date.now(),
        category,
        message,
        data
      };
      logs.push(entry);
  
      // Keep only last MAX_LOGS entries
      if (logs.length > MAX_LOGS) {
        logs.shift();
      }
    }
  
    // Get recent logs
    function getLogs(category = null, count = 100) {
      let filtered = category ? logs.filter(l => l.category === category) : logs;
      return filtered.slice(-count);
    }
  
    // Clear logs
    function clearLogs() {
      logs.length = 0;
    }
  
    // Error analyzers - each analyzes a specific error type
    const errorAnalyzers = {
      'JSON_PARSE_ERROR': function(context) {
        const { error, jsonString, position } = context;
        const logs = getLogs('json', 50);
  
        // Extract key metrics
        const stringLength = jsonString ? jsonString.length : 0;
        const preview = jsonString ? jsonString.substring(Math.max(0, position - 50), position + 50) : '';
        const charAtPosition = jsonString ? jsonString[position] : '';
  
        // Check for common issues
        const hasTrailingComma = jsonString && /,\s*[}\]]/.test(jsonString);
        const hasUnescapedQuotes = jsonString && /[^\\]"[^,:}\]\s]/.test(jsonString);
        const hasMissingQuotes = jsonString && /{\s*\w+:/.test(jsonString);
        const hasTextBeforeJSON = jsonString && jsonString.trim()[0] !== '{';
        const hasTextAfterJSON = jsonString && jsonString.trim().slice(-1) !== '}';
        const firstBrace = jsonString ? jsonString.indexOf('{') : -1;
        const lastBrace = jsonString ? jsonString.lastIndexOf('}') : -1;
  
        // Theory-based analysis
        const theories = [];
        if (hasTextBeforeJSON || hasTextAfterJSON) {
          theories.push('AI added commentary text before/after JSON - extraction should handle this');
        }
        if (hasTrailingComma) {
          theories.push('Trailing comma in JSON object/array - invalid JSON syntax');
        }
        if (hasUnescapedQuotes) {
          theories.push('Unescaped quotes in string values - needs backslash escaping');
        }
        if (hasMissingQuotes) {
          theories.push('Missing quotes around object keys - invalid JSON syntax');
        }
        if (stringLength > 100000) {
          theories.push('Response over 100KB - may be truncated by API or network');
        }
        if (firstBrace === -1 || lastBrace === -1) {
          theories.push('No JSON braces found - response may be plain text error message');
        }
        if (firstBrace > 100) {
          theories.push(`JSON starts at position ${firstBrace} - likely has ${firstBrace} chars of text before it`);
        }
  
        return {
          code: 'JSON_PARSE_ERROR',
          position,
          stringLength,
          preview: `...${preview}...`,
          charAtPosition: charAtPosition ? `'${charAtPosition}' (code: ${charAtPosition.charCodeAt(0)})` : 'N/A',
          jsonBounds: `{ at ${firstBrace}, } at ${lastBrace}`,
          theories: theories.length > 0 ? theories : ['Unknown cause - check error message and preview'],
          errorMessage: error.message
        };
      },
  
      'API_ERROR': function(context) {
        const { error, response, requestBody } = context;
        const logs = getLogs('api', 50);
  
        const requestSize = requestBody ? JSON.stringify(requestBody).length : 0;
        const responseSize = response ? JSON.stringify(response).length : 0;
        const status = response?.status || 'unknown';
  
        // Check for size issues
        const requestTokens = Math.ceil(requestSize / 4);
        const isRequestTooLarge = requestTokens > 30000;
  
        // Count recent API calls
        const recentApiCalls = logs.filter(l =>
          l.message.includes('callAPI') || l.message.includes('API')
        ).length;
  
        // Theory-based analysis
        const theories = [];
        if (status === 401 || status === 403) {
          theories.push('Authentication failed - check API key is valid and not expired');
        }
        if (status === 429) {
          theories.push('Rate limit exceeded - too many requests to API');
          theories.push(`Recent API calls: ${recentApiCalls} in last 50 log entries`);
        }
        if (status === 500 || status === 502 || status === 503) {
          theories.push('Server error - API provider may be experiencing issues');
        }
        if (status === 400) {
          theories.push('Bad request - request format may be invalid');
          if (isRequestTooLarge) {
            theories.push(`Request is ${requestTokens} tokens - may exceed API limits`);
          }
        }
        if (isRequestTooLarge) {
          theories.push(`Request size (${requestTokens} tokens) exceeds typical limits - context compaction needed`);
        }
        if (status === 'unknown') {
          theories.push('Network error - check internet connection or API endpoint availability');
        }
        if (error.message.includes('fetch')) {
          theories.push('Fetch failed - possible CORS issue or network problem');
        }
  
        return {
          code: 'API_ERROR',
          status,
          requestSize,
          requestTokens,
          responseSize,
          recentApiCalls,
          theories: theories.length > 0 ? theories : ['Unknown API error - check error message'],
          errorMessage: error.message || 'Unknown API error',
          responsePreview: response ? JSON.stringify(response).substring(0, 200) : 'No response'
        };
      },
  
      'CONTEXT_LIMIT_EXCEEDED': function(context) {
        const { currentTokens, limit, messageCount } = context;
        const logs = getLogs('context', 50);
  
        const exceededBy = currentTokens - limit;
        const percentOver = Math.round((exceededBy / limit) * 100);
  
        // Check compaction history
        const compactionLogs = logs.filter(l => l.message.includes('compact'));
        const lastCompactionTime = compactionLogs.length > 0 ?
          Date.now() - compactionLogs[compactionLogs.length - 1].timestamp : null;
  
        // Check for truncations
        const truncationLogs = logs.filter(l => l.message.includes('truncat'));
  
        // Theory-based analysis
        const theories = [];
        if (percentOver < 10) {
          theories.push('Slightly over limit - normal, compaction should resolve');
        } else if (percentOver > 50) {
          theories.push('Significantly over limit - may indicate large tool outputs or insufficient compaction');
        }
  
        if (compactionLogs.length === 0) {
          theories.push('No compactions yet - this is the first time limit exceeded');
        } else if (compactionLogs.length > 5) {
          theories.push(`Frequent compactions (${compactionLogs.length}) - conversation may be too long or summaries ineffective`);
        }
  
        if (lastCompactionTime && lastCompactionTime < 10000) {
          theories.push('Compacted very recently - limit exceeded again quickly, may need more aggressive compaction');
        }
  
        if (truncationLogs.length > 0) {
          theories.push(`${truncationLogs.length} truncations detected - large tool outputs contributing to size`);
        }
  
        if (messageCount > 100) {
          theories.push(`High message count (${messageCount}) - long conversation needs compaction`);
        }
  
        const tokensPerMessage = Math.round(currentTokens / messageCount);
        if (tokensPerMessage > 500) {
          theories.push(`Large average message size (${tokensPerMessage} tokens/msg) - suggests large tool outputs or verbose responses`);
        }
  
        return {
          code: 'CONTEXT_LIMIT_EXCEEDED',
          currentTokens,
          limit,
          exceededBy,
          percentOver,
          messageCount,
          tokensPerMessage,
          lastCompactionAgo: lastCompactionTime ? `${Math.round(lastCompactionTime / 1000)}s ago` : 'never',
          compactionCount: compactionLogs.length,
          theories: theories.length > 0 ? theories : ['Context limit exceeded - compaction will run']
        };
      },
  
      'COMPACTION_FAILED': function(context) {
        const { error, tokensBefore, tokensAfter, messagesBefore, messagesAfter } = context;
        const logs = getLogs('compaction', 50);
  
        const tokensReduced = tokensBefore - tokensAfter;
        const messagesRemoved = messagesBefore - messagesAfter;
        const percentReduced = tokensBefore > 0 ? Math.round((tokensReduced / tokensBefore) * 100) : 0;
  
        // Check API logs for summarization issues
        const apiLogs = getLogs('api', 50);
        const recentApiErrors = apiLogs.filter(l =>
          l.message.includes('ERROR') || l.message.includes('error')
        ).length;
  
        // Theory-based analysis
        const theories = [];
  
        if (!error) {
          theories.push('No error object provided - compaction may not have actually failed');
        } else if (error.message.includes('API') || error.message.includes('fetch')) {
          theories.push('API call failed during summarization - check network or API status');
          if (recentApiErrors > 0) {
            theories.push(`${recentApiErrors} recent API errors detected - API may be unstable`);
          }
        } else if (error.message.includes('JSON')) {
          theories.push('JSON parse error - summary response may be malformed');
        }
  
        if (tokensReduced > 0 && percentReduced < 30) {
          theories.push(`Low reduction (${percentReduced}%) - summary may be too verbose or conversation already compact`);
        } else if (tokensReduced <= 0) {
          theories.push('No token reduction achieved - compaction failed to create effective summary');
        } else if (percentReduced > 30) {
          theories.push(`Good reduction (${percentReduced}%) achieved despite failure flag`);
        }
  
        if (messagesRemoved === 0) {
          theories.push('No messages removed - compaction logic may not have executed');
        }
  
        const compactionAttempts = logs.filter(l =>
          l.message.includes('compact') || l.message.includes('Compacting')
        ).length;
        if (compactionAttempts > 3) {
          theories.push(`Multiple compaction attempts (${compactionAttempts}) - may be stuck in retry loop`);
        }
  
        return {
          code: 'COMPACTION_FAILED',
          tokensBefore,
          tokensAfter,
          tokensReduced,
          percentReduced,
          messagesBefore,
          messagesAfter,
          messagesRemoved,
          compactionAttempts,
          theories: theories.length > 0 ? theories : ['Compaction failed - check error message'],
          errorMessage: error ? error.message : 'Unknown error'
        };
      },
  
      'TOOL_OUTPUT_TOO_LARGE': function(context) {
        const { toolName, originalSize, truncatedSize, limit } = context;
  
        const originalTokens = Math.ceil(originalSize / 4);
        const truncatedTokens = Math.ceil(truncatedSize / 4);
        const limitTokens = Math.ceil(limit / 4);
        const exceededBy = originalSize - limit;
        const percentReduced = Math.round(((originalSize - truncatedSize) / originalSize) * 100);
  
        // Get recent tool usage
        const logs = getLogs('tools', 50);
        const toolUsageCounts = {};
        logs.forEach(l => {
          if (l.message.includes('tool') || l.message.includes('Tool')) {
            const match = l.message.match(/\b(read_file|search_by_content|search_by_filename|list_directory)\b/);
            if (match) {
              toolUsageCounts[match[1]] = (toolUsageCounts[match[1]] || 0) + 1;
            }
          }
        });
  
        // Theory-based analysis
        const theories = [];
  
        if (toolName === 'read_file') {
          theories.push('File too large - AI should read specific sections or search for specific content instead');
          if (originalTokens > 5000) {
            theories.push(`Very large file (${originalTokens} tokens) - likely a log file, data file, or minified code`);
          }
          theories.push('Suggest: Use search_by_content to find specific sections, or ask user which part to focus on');
        } else if (toolName === 'search_by_content') {
          theories.push('Search returned too many results - need more specific search term or narrower file pattern');
          const resultCount = Math.floor(originalSize / 100); // Rough estimate
          theories.push(`Estimated ${resultCount}+ matches found - use more specific search or limit to specific directory`);
        } else if (toolName === 'search_by_filename') {
          theories.push('Filename search returned too many files - use more specific pattern or search in subdirectory');
        } else if (toolName === 'list_directory') {
          theories.push('Directory has too many files - should list specific subdirectories instead');
        }
  
        if (percentReduced > 80) {
          theories.push(`Severe truncation (${percentReduced}%) - most of output lost, AI needs different approach`);
        }
  
        const truncationCount = logs.filter(l => l.message.includes('truncat')).length;
        if (truncationCount > 3) {
          theories.push(`Frequent truncations (${truncationCount}) - AI strategy needs adjustment to use more targeted queries`);
        }
  
        return {
          code: 'TOOL_OUTPUT_TOO_LARGE',
          toolName,
          originalSize,
          originalTokens,
          truncatedSize,
          truncatedTokens,
          limit,
          limitTokens,
          exceededBy,
          percentReduced,
          recentToolUsage: toolUsageCounts,
          theories: theories.length > 0 ? theories : ['Output too large - truncated']
        };
      }
    };
  
    // Handle an error - calls appropriate analyzer and outputs to console
    function handleError(errorCode, context = {}) {
      const analyzer = errorAnalyzers[errorCode];
  
      if (!analyzer) {
        console.error(`ERROR: ${errorCode} (no analyzer found)`);
        return;
      }
  
      const analysis = analyzer(context);
  
      // Output ONLY the error code and key data points to console
      console.error(`\n========== ERROR: ${analysis.code} ==========`);
      delete analysis.code; // Already printed above
  
      for (const [key, value] of Object.entries(analysis)) {
        if (key === 'theories' && Array.isArray(value)) {
          console.error(`\n${key}:`);
          value.forEach((theory, idx) => {
            console.error(`  ${idx + 1}. ${theory}`);
          });
        } else if (typeof value === 'object' && !Array.isArray(value)) {
          console.error(`${key}:`);
          for (const [subKey, subValue] of Object.entries(value)) {
            console.error(`  ${subKey}: ${subValue}`);
          }
        } else {
          console.error(`${key}: ${value}`);
        }
      }
      console.error('==========================================\n');
    }
  
    // Export module
    window.module = window.module || {};
    window.module['diagnostics.js'] = {
      log,
      getLogs,
      clearLogs,
      handleError,
      // Expose for testing/debugging
      _errorAnalyzers: errorAnalyzers,
      _logs: logs
    };
  })();
  

  // Module: main.js
  // Main entry point for the app
  window.module['main.js'] = {
    version: '2.0.0',
  
    run: async function() {
      const diagnostics = window.module['diagnostics.js'];
      diagnostics.log('ui', '[AI Agent] Version: ' + this.version);
  
      // Get module references
      const state = window.module['state.js'];
      const styles = window.module['styles.js'];
      const ui = window.module['ui.js'];
      const api = window.module['api.js'];
  
      // Clear existing page content
      document.body.innerHTML = '';
  
      // Add styles
      styles.injectStyles();
  
      // Show directory selection screen
      ui.showDirectorySelection(() => this.selectDirectory());
    },
  
    selectDirectory: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      try {
        if (!window.showDirectoryPicker) {
          alert('Your browser does not support the File System Access API. Please use Chrome, Edge, or another compatible browser.');
          return;
        }
  
        const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
        state.setSelectedDirectory(dirHandle);
        this.showChatScreen();
      } catch (error) {
        const diagnostics = window.module['diagnostics.js'];
        if (error.name === 'AbortError') {
          // User cancelled the picker
          diagnostics.log('ui', 'Directory selection cancelled');
        } else {
          diagnostics.log('ui', 'Error selecting directory: ' + error);
          alert('Error selecting directory: ' + error.message);
        }
      }
    },
  
    showChatScreen: function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      const selectedDirectory = state.getState().selectedDirectory;
      ui.showChatScreen(
        selectedDirectory,
        () => this.addMessage(),  // Enter key adds message
        () => this.submitToAI()   // Button submits to AI
      );
  
      // Render initial messages (no greeting - starts empty)
      ui.renderMessages(state.getMessages());
  
      // Note: Compaction now runs inline after tools execute (not in background)
  
      // Keepalive disabled for testing
      // this.startKeepalive();
    },
  
    startKeepalive: function() {
      const diagnostics = window.module['diagnostics.js'];
      const KEEPALIVE_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds
  
      // Clear any existing keepalive interval
      if (this.keepaliveInterval) {
        clearInterval(this.keepaliveInterval);
      }
  
      diagnostics.log('ui', '[Main] Starting keepalive interval (every 5 minutes)');
  
      this.keepaliveInterval = setInterval(async () => {
        const state = window.module['state.js'];
        const ui = window.module['ui.js'];
  
        // Only send keepalive if not currently processing
        if (state.isProcessing()) {
          diagnostics.log('ui', '[Main] Skipping keepalive - already processing');
          return;
        }
  
        diagnostics.log('ui', '[Main] Sending keepalive ping');
  
        // Call API directly with minimal payload - no system prompt, no context
        const api = window.module['api.js'];
        try {
          await api.callAPI([{ role: 'user', content: "reply 'K'" }]);
          diagnostics.log('ui', '[Main] Keepalive ping successful');
        } catch (error) {
          diagnostics.log('ui', '[Main] Keepalive error: ' + error.message);
        }
      }, KEEPALIVE_INTERVAL);
    },
  
    // Add message to chat (Enter key) - does NOT submit to AI
    addMessage: function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      const message = ui.getInputValue();
  
      if (!message || state.isProcessing()) {
        return;
      }
  
      const userMessage = {
        type: 'user_msg',
        content: message
      };
  
      // Add user message
      state.addMessage(userMessage);
  
      // Clear input and reset height
      ui.clearInput();
  
      // Render messages
      ui.renderMessages(state.getMessages());
  
      // Update context stats
      ui.updateContextStats();
    },
  
    // Submit entire conversation to AI (button click)
    submitToAI: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      // Don't submit if already processing or no messages
      if (state.isProcessing() || state.getMessages().length === 0) {
        return;
      }
  
      // Set processing state
      state.setProcessing(true);
      ui.setInputDisabled(true);
  
      // Show loading indicator
      ui.showLoading();
  
      try {
        await this.processAIResponse();
      } catch (error) {
        ui.hideLoading();
        state.addMessage({
          type: 'assistant_msg',
          content: 'Error: ' + error.message
        });
        ui.renderMessages(state.getMessages());
        ui.updateContextStats();
      } finally {
        state.setProcessing(false);
        ui.setInputDisabled(false);
        ui.updateSubmitButtonVisibility();
      }
    },
  
    processAIResponse: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
      const core = window.module['core.js'];
  
      const selectedDirectory = state.getState().selectedDirectory;
  
      // Use core.js for UI-independent processing
      await core.processAIResponse(
        () => state.getMessages(),
        (msg) => state.addMessage(msg),
        selectedDirectory,
        {
          onLoading: (text) => ui.showLoading(text),
          onHideLoading: () => ui.hideLoading(),
          onRenderMessages: () => ui.renderMessages(state.getMessages()),
          onUpdateStats: () => ui.updateContextStats(),
          onProcessingChange: (processing) => state.setProcessing(processing),
          onAfterTools: async () => {}
        }
      );
    },
  
    // Truncate tool output if it exceeds size limit (1/8 of context limit = 2500 tokens default)
    truncateToolOutput: function(content, toolName) {
      const diagnostics = window.module['diagnostics.js'];
      const state = window.module['state.js'];
      const limit = state.getContextLimit();
      const maxTokens = Math.floor(limit / 8); // 1/8 of limit
      const maxChars = maxTokens * 4; // 4 chars per token estimate
  
      if (content.length <= maxChars) {
        return { content, wasTruncated: false };
      }
  
      const truncated = content.substring(0, maxChars);
      const remaining = content.length - maxChars;
      const remainingTokens = Math.ceil(remaining / 4);
  
      diagnostics.handleError('TOOL_OUTPUT_TOO_LARGE', {
        toolName,
        originalSize: content.length,
        truncatedSize: truncated.length,
        limit: maxChars
      });
  
      return {
        content: truncated + `\n\n[... Output truncated. ${remainingTokens} more tokens (${remaining} chars) omitted. If you need the full output, run ${toolName} again with more specific parameters to reduce output size.]`,
        wasTruncated: true
      };
    },
  
    // Execute tools (unified handler for all tools)
    executeTools: async function(toolUses, selectedDirectory) {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
  
      for (const toolUse of toolUses) {
        if (toolUse.name === 'list_directory') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'list_directory',
            params: toolUse.input,
            content: `list_directory ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeListDirectory(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            // Count entries
            const lines = result.output.split('\n');
            const dirCount = lines.filter(l => l.includes('ðŸ“')).length;
            const fileCount = lines.filter(l => l.includes('ðŸ“„')).length;
            const total = dirCount + fileCount;
  
            state.addMessage({
              type: 'tool-result',
              toolName: 'list_directory',
              summary: `Listed ${total} items (${dirCount} folders, ${fileCount} files)`,
              fullResult: result.output,
              content: `Tool result for list_directory("${toolUse.input.path}"):\n\n${result.output}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'list_directory',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Tool error for list_directory("${toolUse.input.path}"): ${result.error}`
            });
          }
        } else if (toolUse.name === 'read_file') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'read_file',
            params: toolUse.input,
            content: `read_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeReadFile(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            const lineCount = result.content.split('\n').length;
  
            state.addMessage({
              type: 'tool-result',
              toolName: 'read_file',
              summary: `Read ${lineCount} lines from ${result.path}`,
              fullResult: result.content,
              content: `File: ${result.path}\n\n${result.content}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'read_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error reading file ${result.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'write_file') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'write_file',
            params: toolUse.input,
            content: `write_file ${JSON.stringify({ path: toolUse.input.path, content: `(${toolUse.input.content.length} chars)` })}`
          });
  
          const result = await this.executeWriteFile(toolUse.input.path, toolUse.input.content, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              type: 'tool-result',
              toolName: 'write_file',
              summary: `Wrote ${toolUse.input.content.length} characters to ${result.path}`,
              fullResult: `Successfully wrote to ${result.path}`,
              content: `Successfully wrote ${toolUse.input.content.length} characters to ${result.path}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'write_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error writing file ${result.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'search_by_filename') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'search_by_filename',
            params: toolUse.input,
            content: `search_by_filename ${JSON.stringify(toolUse.input)}`
          });
  
          const searchPath = toolUse.input.path || '.';
          const result = await this.executeSearchByFilename(toolUse.input.pattern, searchPath, selectedDirectory);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
            const truncated = this.truncateToolOutput(result.output, 'search_by_filename');
  
            state.addMessage({
              type: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Found ${matchCount} file(s) matching "${toolUse.input.pattern}"${timeoutWarning}${truncated.wasTruncated ? ' (truncated)' : ''}`,
              fullResult: result.output,
              content: `Search results for pattern "${toolUse.input.pattern}" in "${searchPath}":\n\n${truncated.content}`,
              truncated: truncated.wasTruncated
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'search_by_filename',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching for files: ${result.error}`
            });
          }
        } else if (toolUse.name === 'search_by_content') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'search_by_content',
            params: toolUse.input,
            content: `search_by_content ${JSON.stringify(toolUse.input)}`
          });
  
          const searchPath = toolUse.input.path || '.';
          const filePattern = toolUse.input.filePattern || null;
          const result = await this.executeSearchByContent(toolUse.input.text, searchPath, filePattern, selectedDirectory);
  
          if (result.success) {
            const matchCount = result.matches.length;
            const timeoutWarning = result.timeout ? ' (search timed out - partial results)' : '';
            const truncated = this.truncateToolOutput(result.output, 'search_by_content');
  
            state.addMessage({
              type: 'tool-result',
              toolName: 'search_by_content',
              summary: `Found ${matchCount} match(es) for "${toolUse.input.text}"${timeoutWarning}${truncated.wasTruncated ? ' (truncated)' : ''}`,
              fullResult: result.output,
              content: `Search results for text "${toolUse.input.text}" in "${searchPath}":\n\n${truncated.content}`,
              truncated: truncated.wasTruncated
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'search_by_content',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error searching file contents: ${result.error}`
            });
          }
        } else if (toolUse.name === 'edit_file') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'edit_file',
            params: toolUse.input,
            content: `edit_file ${JSON.stringify({ path: toolUse.input.path, find: `(${toolUse.input.find.length} chars)`, replace: `(${toolUse.input.replace.length} chars)` })}`
          });
  
          const result = await this.executeEditFile(toolUse.input.path, toolUse.input.find, toolUse.input.replace, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              type: 'tool-result',
              toolName: 'edit_file',
              summary: `Edited ${result.path}: replaced ${toolUse.input.find.length} chars with ${toolUse.input.replace.length} chars`,
              fullResult: `Successfully edited ${result.path}`,
              content: `Successfully edited ${result.path}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'edit_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error editing file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'edit_file_batch') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'edit_file_batch',
            params: toolUse.input,
            content: `edit_file_batch ${JSON.stringify({ path: toolUse.input.path, edits: `(${toolUse.input.edits.length} edits)` })}`
          });
  
          const result = await this.executeEditFileBatch(toolUse.input.path, toolUse.input.edits, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              type: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Batch edited ${result.path}: applied ${toolUse.input.edits.length} edit(s)`,
              fullResult: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`,
              content: `Successfully applied ${toolUse.input.edits.length} edits to ${result.path}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'edit_file_batch',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error batch editing file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'delete_file') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'delete_file',
            params: toolUse.input,
            content: `delete_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeDeleteFile(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              type: 'tool-result',
              toolName: 'delete_file',
              summary: `Deleted file: ${result.path}`,
              fullResult: `Successfully deleted ${result.path}`,
              content: `Successfully deleted file: ${result.path}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'delete_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error deleting file ${toolUse.input.path}: ${result.error}`
            });
          }
        } else if (toolUse.name === 'move_file') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'move_file',
            params: toolUse.input,
            content: `move_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeMoveFile(toolUse.input.source, toolUse.input.destination, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              type: 'tool-result',
              toolName: 'move_file',
              summary: `Moved: ${result.source} â†’ ${result.destination}`,
              fullResult: `Successfully moved ${result.source} to ${result.destination}`,
              content: `Successfully moved file from ${result.source} to ${result.destination}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'move_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error moving file: ${result.error}`
            });
          }
        } else if (toolUse.name === 'copy_file') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'copy_file',
            params: toolUse.input,
            content: `copy_file ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeCopyFile(toolUse.input.source, toolUse.input.destination, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              type: 'tool-result',
              toolName: 'copy_file',
              summary: `Copied: ${result.source} â†’ ${result.destination}`,
              fullResult: `Successfully copied ${result.source} to ${result.destination}`,
              content: `Successfully copied file from ${result.source} to ${result.destination}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'copy_file',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error copying file: ${result.error}`
            });
          }
        } else if (toolUse.name === 'create_directory') {
          // Add tool use message
          state.addMessage({
            type: 'tool-use',
            toolName: 'create_directory',
            params: toolUse.input,
            content: `create_directory ${JSON.stringify(toolUse.input)}`
          });
  
          const result = await this.executeCreateDirectory(toolUse.input.path, selectedDirectory);
  
          if (result.success) {
            state.addMessage({
              type: 'tool-result',
              toolName: 'create_directory',
              summary: `Created directory: ${result.path}`,
              fullResult: `Successfully created directory ${result.path}`,
              content: `Successfully created directory: ${result.path}`
            });
          } else {
            state.addMessage({
              type: 'tool-result',
              toolName: 'create_directory',
              summary: `Error: ${result.error}`,
              error: true,
              content: `Error creating directory ${toolUse.input.path}: ${result.error}`
            });
          }
        } else {
          // Unknown tool
          state.addMessage({
            type: 'user_msg',
            content: `ERROR: Unknown tool "${toolUse.name}". Available tools are: list_directory, read_file, write_file, search_by_filename, search_by_content, edit_file, edit_file_batch, delete_file, move_file, copy_file, create_directory.`,
            fromSystem: true
          });
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Main] Unknown tool: ${toolUse.name}`);
        }
      }
  
      ui.renderMessages(state.getMessages());
    },
  
    // Execute file operations using FileSystem API
    executeListDirectory: async function(path, dirHandle) {
      try {
        let targetHandle = dirHandle;
  
        // Navigate to the target path if not root
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // List directory contents
        const entries = [];
        for await (const entry of targetHandle.values()) {
          entries.push({
            name: entry.name,
            kind: entry.kind
          });
        }
  
        // Format output
        let output = `Contents of "${path || '.'}":\n\n`;
        const dirs = entries.filter(e => e.kind === 'directory').sort((a, b) => a.name.localeCompare(b.name));
        const files = entries.filter(e => e.kind === 'file').sort((a, b) => a.name.localeCompare(b.name));
  
        if (dirs.length > 0) {
          output += 'Directories:\n';
          dirs.forEach(d => {
            output += `  ðŸ“ ${d.name}/\n`;
          });
        }
  
        if (files.length > 0) {
          output += '\nFiles:\n';
          files.forEach(f => {
            output += `  ðŸ“„ ${f.name}\n`;
          });
        }
  
        if (entries.length === 0) {
          output += '(empty directory)\n';
        }
  
        return { success: true, output };
      } catch (error) {
        return { success: false, error: error.message };
      }
    },
  
    executeReadFile: async function(path, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory
        for (let i = 0; i < pathParts.length - 1; i++) {
          currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
        }
  
        // Get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName);
        const file = await fileHandle.getFile();
        const content = await file.text();
  
        return { success: true, content, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeWriteFile: async function(path, content, dirHandle) {
      try {
        const pathParts = path.split('/').filter(p => p);
        let currentHandle = dirHandle;
  
        // Navigate to parent directory (create if doesn't exist)
        for (let i = 0; i < pathParts.length - 1; i++) {
          try {
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
          } catch {
            // Directory doesn't exist, create it
            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i], { create: true });
          }
        }
  
        // Create or get file
        const fileName = pathParts[pathParts.length - 1];
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
  
        // Write content
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        return { success: true, path };
      } catch (error) {
        // Check if it's a user activation error
        if (error.message && error.message.includes('User activation is required')) {
          return {
            success: false,
            error: `Cannot create new directories due to browser security. Please manually create the parent directory first, then try again.`,
            path
          };
        }
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFile: async function(path, findStr, replaceStr, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.type === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].type === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        const content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file.`,
            path
          };
        }
  
        // 4. Check that find string appears exactly once
        const occurrences = content.split(findStr).length - 1;
        if (occurrences === 0) {
          return {
            success: false,
            error: `Find string not found in file. The file may have changed since you last read it.`,
            path
          };
        } else if (occurrences > 1) {
          return {
            success: false,
            error: `Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
            path
          };
        }
  
        // 5. Perform replacement
        const newContent = content.replace(findStr, replaceStr);
  
        // 6. Write back
        const writeResult = await this.executeWriteFile(path, newContent, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    executeEditFileBatch: async function(path, edits, dirHandle) {
      const state = window.module['state.js'];
  
      try {
        // 1. Check if file was read within last 5 minutes
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        const messages = state.getMessages();
        const recentRead = messages
          .filter(m => m.type === 'tool-result' && m.toolName === 'read_file' && m.timestamp > fiveMinutesAgo)
          .find(m => {
            // Check if this read was for our file
            const toolUseIndex = messages.indexOf(m) - 1;
            if (toolUseIndex >= 0 && messages[toolUseIndex].type === 'tool-use') {
              return messages[toolUseIndex].params.path === path;
            }
            return false;
          });
  
        if (!recentRead) {
          return {
            success: false,
            error: `File has not been read in the last 5 minutes. Please read the file first to ensure you have the latest content before editing.`,
            path
          };
        }
  
        // 2. Read current file content
        const readResult = await this.executeReadFile(path, dirHandle);
        if (!readResult.success) {
          return { success: false, error: readResult.error, path };
        }
  
        let content = readResult.content;
  
        // 3. Check if file is blank - suggest using write_file instead
        if (content.trim() === '') {
          return {
            success: false,
            error: `File is empty. Please use write_file to populate empty files instead of edit_file_batch.`,
            path
          };
        }
  
        // 4. Apply each edit in sequence
        for (let i = 0; i < edits.length; i++) {
          const { find, replace } = edits[i];
  
          // Check that find string appears exactly once in current content
          const occurrences = content.split(find).length - 1;
          if (occurrences === 0) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string not found in file. The file may have changed or earlier edits affected this replacement.`,
              path
            };
          } else if (occurrences > 1) {
            return {
              success: false,
              error: `Edit ${i + 1}: Find string appears ${occurrences} times in the file. It must appear exactly once. Please use a more specific find string.`,
              path
            };
          }
  
          // Perform replacement
          content = content.replace(find, replace);
        }
  
        // 5. Write back
        const writeResult = await this.executeWriteFile(path, content, dirHandle);
        return writeResult;
  
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    // Helper function to match wildcard pattern
    matchesPattern: function(filename, pattern) {
      // Convert wildcard pattern to regex
      // * matches any characters, ? matches single character
      const regexPattern = pattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&')  // Escape special regex chars
        .replace(/\*/g, '.*')  // * becomes .*
        .replace(/\?/g, '.');  // ? becomes .
  
      const regex = new RegExp(`^${regexPattern}$`, 'i');  // Case-insensitive
      return regex.test(filename);
    },
  
    // Recursively search for files by filename pattern
    executeSearchByFilename: async function(pattern, path, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if filename matches pattern
              if (window.module['main.js'].matchesPattern(entry.name, pattern)) {
                matches.push(entryPath);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Search] Error accessing ${currentPath}: ${error.message}`);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No files found matching the pattern.';
        } else {
          output = matches.map(m => `ðŸ“„ ${m}`).join('\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Recursively search for text within file contents
    executeSearchByContent: async function(searchText, path, filePattern, dirHandle) {
      const TIMEOUT_MS = 10000;  // 10 seconds
      const startTime = Date.now();
      let timedOut = false;
  
      const matches = [];
  
      async function searchRecursive(handle, currentPath) {
        // Check timeout
        if (Date.now() - startTime > TIMEOUT_MS) {
          timedOut = true;
          return;
        }
  
        try {
          for await (const entry of handle.values()) {
            // Check timeout inside loop
            if (Date.now() - startTime > TIMEOUT_MS) {
              timedOut = true;
              return;
            }
  
            const entryPath = currentPath ? `${currentPath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              // Check if file matches filePattern (if provided)
              if (filePattern && !window.module['main.js'].matchesPattern(entry.name, filePattern)) {
                continue;
              }
  
              try {
                // Read file and search for text
                const file = await entry.getFile();
                const content = await file.text();
  
                if (content.toLowerCase().includes(searchText.toLowerCase())) {
                  // Find line numbers where text appears
                  const lines = content.split('\n');
                  const matchingLines = [];
  
                  for (let i = 0; i < lines.length; i++) {
                    if (lines[i].toLowerCase().includes(searchText.toLowerCase())) {
                      matchingLines.push({
                        lineNum: i + 1,
                        line: lines[i].trim()
                      });
                    }
                  }
  
                  matches.push({
                    path: entryPath,
                    lineMatches: matchingLines
                  });
                }
              } catch (error) {
                // Skip binary files or files that can't be read as text
                const diagnostics = window.module['diagnostics.js'];
                diagnostics.log('tools', `[Search] Could not read ${entryPath}: ${error.message}`);
              }
            } else if (entry.kind === 'directory') {
              // Recurse into subdirectory
              await searchRecursive(entry, entryPath);
            }
          }
        } catch (error) {
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Search] Error accessing ${currentPath}: ${error.message}`);
        }
      }
  
      try {
        // Navigate to starting path
        let targetHandle = dirHandle;
        if (path && path !== '.' && path !== './') {
          const pathParts = path.split('/').filter(p => p && p !== '.');
          for (const part of pathParts) {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          }
        }
  
        // Start recursive search
        await searchRecursive(targetHandle, path === '.' || !path ? '' : path);
  
        // Format output
        let output = '';
        if (matches.length === 0) {
          output = 'No matches found.';
        } else {
          output = matches.map(match => {
            const header = `ðŸ“„ ${match.path}`;
            const lineInfo = match.lineMatches.slice(0, 5).map(lm =>
              `  Line ${lm.lineNum}: ${lm.line.substring(0, 100)}${lm.line.length > 100 ? '...' : ''}`
            ).join('\n');
            const moreLines = match.lineMatches.length > 5 ? `  ... and ${match.lineMatches.length - 5} more matches` : '';
  
            return `${header}\n${lineInfo}${moreLines ? '\n' + moreLines : ''}`;
          }).join('\n\n');
        }
  
        if (timedOut) {
          output += '\n\nâš ï¸ Search timed out after 10 seconds - showing partial results. Try narrowing your search path or using a file pattern.';
        }
  
        return {
          success: true,
          matches: matches,
          output: output,
          timeout: timedOut
        };
      } catch (error) {
        return { success: false, error: error.message, matches: [] };
      }
    },
  
    // Delete a file
    executeDeleteFile: async function(path, dirHandle) {
      try {
        // Navigate to the parent directory
        const pathParts = path.split('/').filter(p => p);
        const fileName = pathParts.pop();
  
        let targetHandle = dirHandle;
        for (const part of pathParts) {
          targetHandle = await targetHandle.getDirectoryHandle(part);
        }
  
        // Delete the file
        await targetHandle.removeEntry(fileName);
  
        return { success: true, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    // Move/rename a file
    executeMoveFile: async function(source, destination, dirHandle) {
      try {
        // Read source file
        const sourceContent = await this.executeReadFile(source, dirHandle);
        if (!sourceContent.success) {
          return { success: false, error: `Failed to read source file: ${sourceContent.error}`, source, destination };
        }
  
        // Write to destination
        const writeResult = await this.executeWriteFile(destination, sourceContent.content, dirHandle);
        if (!writeResult.success) {
          return { success: false, error: `Failed to write destination file: ${writeResult.error}`, source, destination };
        }
  
        // Delete source file
        const deleteResult = await this.executeDeleteFile(source, dirHandle);
        if (!deleteResult.success) {
          // Destination was written but source couldn't be deleted - warn but don't fail
          const diagnostics = window.module['diagnostics.js'];
          diagnostics.log('tools', `[Main] Moved file but couldn't delete source: ${deleteResult.error}`);
        }
  
        return { success: true, source, destination };
      } catch (error) {
        return { success: false, error: error.message, source, destination };
      }
    },
  
    // Copy a file
    executeCopyFile: async function(source, destination, dirHandle) {
      try {
        // Read source file
        const sourceContent = await this.executeReadFile(source, dirHandle);
        if (!sourceContent.success) {
          return { success: false, error: `Failed to read source file: ${sourceContent.error}`, source, destination };
        }
  
        // Write to destination
        const writeResult = await this.executeWriteFile(destination, sourceContent.content, dirHandle);
        if (!writeResult.success) {
          return { success: false, error: `Failed to write destination file: ${writeResult.error}`, source, destination };
        }
  
        return { success: true, source, destination };
      } catch (error) {
        return { success: false, error: error.message, source, destination };
      }
    },
  
    // Create a directory
    executeCreateDirectory: async function(path, dirHandle) {
      try {
        // Navigate and create directories as needed
        const pathParts = path.split('/').filter(p => p);
  
        let targetHandle = dirHandle;
        for (const part of pathParts) {
          try {
            targetHandle = await targetHandle.getDirectoryHandle(part);
          } catch (error) {
            // Directory doesn't exist, create it
            targetHandle = await targetHandle.getDirectoryHandle(part, { create: true });
          }
        }
  
        return { success: true, path };
      } catch (error) {
        return { success: false, error: error.message, path };
      }
    },
  
    // Compact selected messages using AI summarization
    compactSelection: async function() {
      const state = window.module['state.js'];
      const ui = window.module['ui.js'];
      const api = window.module['api.js'];
      const diagnostics = window.module['diagnostics.js'];
  
      if (!state.hasSelection()) {
        diagnostics.log('context', '[Main] No messages selected for compaction');
        return;
      }
  
      // Get selected messages
      const selectedMessages = state.getSelectedMessages();
      const allMessages = state.getMessages();
  
      // Find indices of first and last selected messages in full conversation
      const firstSelectedId = selectedMessages[0].id;
      const lastSelectedId = selectedMessages[selectedMessages.length - 1].id;
  
      const firstSelectedIndex = allMessages.findIndex(m => m.id === firstSelectedId);
      const lastSelectedIndex = allMessages.findIndex(m => m.id === lastSelectedId);
  
      // Determine what message types should come before and after
      const messageBefore = firstSelectedIndex > 0 ? allMessages[firstSelectedIndex - 1] : null;
      const messageAfter = lastSelectedIndex < allMessages.length - 1 ? allMessages[lastSelectedIndex + 1] : null;
  
      // Determine required start and end types for AI response
      let startType = null;
      let endType = null;
  
      if (messageBefore) {
        // If previous message was from user, AI should start with assistant
        // If previous message was from assistant, AI should start with user
        if (messageBefore.type === 'user_msg' || messageBefore.type === 'tool-result') {
          startType = 'assistant';
        } else if (messageBefore.type === 'assistant_msg' || messageBefore.type === 'tool-use') {
          startType = 'user';
        }
      }
  
      if (messageAfter) {
        // If next message is from user, AI should end with assistant
        // If next message is from assistant, AI should end with user
        if (messageAfter.type === 'user_msg' || messageAfter.type === 'tool-result') {
          endType = 'assistant';
        } else if (messageAfter.type === 'assistant_msg' || messageAfter.type === 'tool-use') {
          endType = 'user';
        }
      }
  
      // Build summarization prompt
      let prompt = 'You are summarizing a portion of a conversation between a user and an AI coding assistant.\n\n';
      prompt += 'Here are the messages to summarize:\n\n';
  
      // Format selected messages for summarization
      selectedMessages.forEach(msg => {
        let role = 'unknown';
        if (msg.type === 'user_msg') role = 'user';
        else if (msg.type === 'assistant_msg') role = 'assistant';
        else if (msg.type === 'tool-use') role = 'tool-use';
        else if (msg.type === 'tool-result') role = 'tool-result';
  
        prompt += `[${role}]: ${msg.content}\n\n`;
      });
  
      prompt += '\nProvide a concise summary that captures:\n';
      prompt += '1. Key user requests and intent\n';
      prompt += '2. Important actions taken (files read, edited, created)\n';
      prompt += '3. Key decisions and context needed to continue the conversation\n';
      prompt += '4. Any ongoing issues or work in progress\n\n';
  
      // Tell AI about required message structure
      if (startType && endType) {
        prompt += `IMPORTANT: Your response must be formatted as a conversation that starts with a ${startType} message and ends with a ${endType} message. `;
        prompt += `You can include as many messages as you need in between (could be just 1-2 messages, or more if needed), but must start with ${startType} and end with ${endType}.\n\n`;
      } else if (startType) {
        prompt += `IMPORTANT: Your response must start with a ${startType} message. You can include as many messages as needed.\n\n`;
      } else if (endType) {
        prompt += `IMPORTANT: Your response must end with a ${endType} message. You can include as many messages as needed.\n\n`;
      } else {
        prompt += 'Format your response as a conversation with user and assistant messages as needed.\n\n';
      }
  
      prompt += 'Format each message as: [role]: message content\n';
      prompt += 'Roles should be: user, assistant, tool-use, or tool-result\n';
  
      diagnostics.log('context', '[Main] Compacting ' + selectedMessages.length + ' messages');
      diagnostics.log('context', '[Main] Start type: ' + (startType || 'any') + ', End type: ' + (endType || 'any'));
  
      // Show loading
      state.setProcessing(true);
      ui.setInputDisabled(true);
      ui.showLoading('Compacting...');
  
      try {
        // Call API with summarization request
        const apiMessages = [{ role: 'user', content: prompt }];
        const response = await api.callAPISimple(apiMessages);
  
        if (!response.valid) {
          throw new Error(response.error || 'Failed to get summary from AI');
        }
  
        // Parse AI response into messages
        const summaryText = response.text;
  
        if (!summaryText) {
          diagnostics.log('context', '[Main] API response missing text field: ' + JSON.stringify(response));
          throw new Error('API response missing text content');
        }
  
        diagnostics.log('context', '[Main] AI response: ' + summaryText.substring(0, 200) + '...');
        const newMessages = this.parseCompactionResponse(summaryText);
  
        diagnostics.log('context', '[Main] AI generated ' + newMessages.length + ' summary messages');
  
        // Replace selected messages with new summary messages
        const beforeMessages = allMessages.slice(0, firstSelectedIndex);
        const afterMessages = allMessages.slice(lastSelectedIndex + 1);
  
        // Clear current messages and rebuild
        state.clearMessages();
  
        // Add messages back in order: before, summary, after
        beforeMessages.forEach(msg => state.addMessage(msg));
        newMessages.forEach(msg => state.addMessage(msg));
        afterMessages.forEach(msg => state.addMessage(msg));
  
        // Clear selection
        state.clearSelection();
  
        // Re-render and update UI
        ui.renderMessages(state.getMessages());
        ui.updateContextStats();
        ui.updateCompactButtonVisibility();
  
        diagnostics.log('context', '[Main] Compaction complete');
      } catch (error) {
        diagnostics.log('context', '[Main] Compaction error: ' + error.message);
        alert('Error compacting messages: ' + error.message);
      } finally {
        state.setProcessing(false);
        ui.setInputDisabled(false);
        ui.hideLoading();
        ui.updateSubmitButtonVisibility();
      }
    },
  
    // Parse AI's compaction response into message objects
    parseCompactionResponse: function(text) {
      const messages = [];
  
      if (!text || typeof text !== 'string') {
        const diagnostics = window.module['diagnostics.js'];
        diagnostics.log('context', '[Main] parseCompactionResponse received invalid text: ' + typeof text);
        return messages;
      }
  
      const lines = text.split('\n');
  
      let currentMessage = null;
  
      for (const line of lines) {
        // Check if line starts with [role]:
        const roleMatch = line.match(/^\[(user|assistant|tool-use|tool-result)\]:\s*(.*)$/);
  
        if (roleMatch) {
          // Save previous message if exists
          if (currentMessage) {
            messages.push(currentMessage);
          }
  
          // Start new message
          const role = roleMatch[1];
          const content = roleMatch[2];
  
          let type = 'user_msg';
          if (role === 'assistant') type = 'assistant_msg';
          else if (role === 'tool-use') type = 'tool-use';
          else if (role === 'tool-result') type = 'tool-result';
  
          currentMessage = {
            type: type,
            content: content
          };
        } else if (currentMessage && line.trim()) {
          // Continue current message (multi-line)
          currentMessage.content += '\n' + line;
        }
      }
  
      // Don't forget last message
      if (currentMessage) {
        messages.push(currentMessage);
      }
  
      return messages;
    },
  
    // Compact context by summarizing messages (with scope control via targetPercentage)
    // Returns true if successful, false if failed
  };
  

  // Module: state.js
  // State management
  window.module['state.js'] = {
    state: {
      selectedDirectory: null,
      messages: [],  // Start with empty chat (no greeting)
      isProcessing: false,
      contextLimit: 80000,  // Default 80K chars (reference only, no auto-enforcement)
      selectedMessageIds: []  // Message selection for compaction
    },
  
    getState: function() {
      return this.state;
    },
  
    setSelectedDirectory: function(dirHandle) {
      this.state.selectedDirectory = dirHandle;
    },
  
    // Message management
    addMessage: function(message) {
      const id = message.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      this.state.messages.push({
        ...message,
        id,
        timestamp: message.timestamp || Date.now()
      });
    },
  
    editMessage: function(id, newContent) {
      const message = this.state.messages.find(m => m.id === id);
      if (message) {
        message.content = newContent;
      }
    },
  
    deleteMessage: function(id) {
      this.state.messages = this.state.messages.filter(m => m.id !== id);
    },
  
    getMessages: function() {
      return this.state.messages;
    },
  
    // Processing state
    setProcessing: function(isProcessing) {
      this.state.isProcessing = isProcessing;
    },
  
    isProcessing: function() {
      return this.state.isProcessing;
    },
  
    // Clear all messages
    clearMessages: function() {
      this.state.messages = [];
    },
  
    // Context limit management
    getContextLimit: function() {
      return this.state.contextLimit;
    },
  
    setContextLimit: function(limitInChars) {
      this.state.contextLimit = limitInChars;
    },
  
    // Calculate message size in characters
    // Only counts non-uiOnly messages since those are what get sent to API
    calculateChars: function(messages) {
      if (!messages) {
        messages = this.state.messages;
      }
  
      let totalChars = 0;
      messages.forEach(msg => {
        // Skip uiOnly and fromSystem messages - they don't get sent to API or are internal
        if (!msg.uiOnly && !msg.fromSystem && msg.content) {
          totalChars += msg.content.length;
        }
      });
  
      return totalChars;
    },
  
    // Check if adding a message would exceed limit
    wouldExceedLimit: function(newMessageContent) {
      const currentChars = this.calculateChars();
      const newMessageChars = newMessageContent.length;
      return (currentChars + newMessageChars) > this.state.contextLimit;
    },
  
    // Message selection management
    toggleMessageSelection: function(id) {
      const index = this.state.selectedMessageIds.indexOf(id);
      if (index > -1) {
        // Deselect
        this.state.selectedMessageIds.splice(index, 1);
      } else {
        // Select
        this.state.selectedMessageIds.push(id);
      }
    },
  
    selectMessageRange: function(fromId, toId) {
      // Find indices of from and to messages
      const messages = this.state.messages;
      const fromIndex = messages.findIndex(m => m.id === fromId);
      const toIndex = messages.findIndex(m => m.id === toId);
  
      if (fromIndex === -1 || toIndex === -1) return;
  
      // Determine range direction
      const start = Math.min(fromIndex, toIndex);
      const end = Math.max(fromIndex, toIndex);
  
      // Select all messages in range
      for (let i = start; i <= end; i++) {
        const id = messages[i].id;
        if (!this.state.selectedMessageIds.includes(id)) {
          this.state.selectedMessageIds.push(id);
        }
      }
    },
  
    isMessageSelected: function(id) {
      return this.state.selectedMessageIds.includes(id);
    },
  
    getSelectedMessages: function() {
      return this.state.messages.filter(m => this.state.selectedMessageIds.includes(m.id));
    },
  
    clearSelection: function() {
      this.state.selectedMessageIds = [];
    },
  
    hasSelection: function() {
      return this.state.selectedMessageIds.length > 0;
    },
  
  };
  

  // Module: styles.js
  // Styles and CSS injection
  window.module['styles.js'] = {
    injectStyles: function() {
      const style = document.createElement('style');
      style.textContent = `
        :root {
          --color-gold: #d4a017;
          --color-gold-light: #e5b028;
          --color-gold-glow: rgba(212, 160, 23, 0.3);
          --color-gold-subtle: rgba(212, 160, 23, 0.1);
          --color-bg-primary: #1a1a1a;
          --color-bg-secondary: #2d2d2d;
          --color-border: #404040;
          --color-text-primary: #e0e0e0;
          --color-text-secondary: #b0b0b0;
          --color-text-dim: #707070;
        }
  
        body {
          margin: 0;
          padding: 0;
          font-family: 'Consolas', 'Courier New', monospace;
          background-color: var(--color-bg-primary);
          color: var(--color-text-primary);
          overflow: hidden;
        }
  
        #app-container {
          width: 100%;
          height: 100vh;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        }
  
        /* Directory Selection Screen */
        #directory-screen {
          display: flex;
          align-items: center;
          justify-content: center;
          height: 100vh;
          flex-direction: column;
        }
  
        #directory-screen h1 {
          color: var(--color-gold);
          margin-bottom: 2rem;
          font-size: 48px;
          font-weight: 700;
          text-align: center;
          width: 100%;
        }
  
        #select-dir-btn {
          display: block;
          margin: 0 auto;
          background: var(--color-gold);
          color: var(--color-bg-primary);
          border: none;
          padding: 16px 32px;
          font-size: 16px;
          font-family: 'Consolas', 'Courier New', monospace;
          font-weight: 700;
          cursor: pointer;
          border-radius: 4px;
          transition: all 0.2s ease;
        }
  
        #select-dir-btn:hover {
          background: var(--color-gold-light);
          transform: translateY(-2px);
          box-shadow: 0 4px 12px var(--color-gold-glow);
        }
  
        #select-dir-btn:active {
          transform: translateY(0);
        }
  
        /* Chat Screen */
        #chat-screen {
          display: flex;
          flex-direction: column;
          height: 100vh;
        }
  
        #chat-container {
          flex: 1;
          overflow-y: auto;
          padding: 16px;
          scroll-behavior: smooth;
          width: 100%;
          max-width: 100%;
          box-sizing: border-box;
        }
  
        #chat-container::-webkit-scrollbar {
          width: 8px;
        }
  
        #chat-container::-webkit-scrollbar-track {
          background: var(--color-bg-secondary);
        }
  
        #chat-container::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 4px;
        }
  
        #chat-container::-webkit-scrollbar-thumb:hover {
          background: #777;
        }
  
        #input-container {
          padding: 16px;
          background-color: var(--color-bg-primary);
          width: 100%;
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 8px;
        }
  
        #input-wrapper {
          position: relative;
          width: 90%;
          max-width: 1200px;
          display: flex;
          align-items: flex-end;
          gap: 12px;
          background-color: var(--color-bg-secondary);
          border: 1px solid var(--color-border);
          border-radius: 8px;
          max-height: 33.333vh;
          overflow: hidden;
          padding: 12px;
        }
  
        #message-input {
          flex: 1;
          background: transparent;
          border: none;
          color: var(--color-text-primary);
          font-family: 'Consolas', 'Courier New', monospace;
          font-size: 14px;
          resize: none;
          outline: none;
          padding: 0;
          line-height: 1.6;
          overflow-y: auto;
          box-sizing: border-box;
          max-height: calc(33.333vh - 24px);
        }
  
        .submit-ai-btn {
          background: var(--color-gold);
          color: var(--color-bg-primary);
          border: none;
          border-radius: 6px;
          padding: 8px 16px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          white-space: nowrap;
          transition: opacity 0.2s, transform 0.1s;
          align-self: flex-end;
          margin-bottom: 0;
        }
  
        .submit-ai-btn:hover:not(:disabled) {
          opacity: 0.9;
          transform: translateY(-1px);
        }
  
        .submit-ai-btn:active:not(:disabled) {
          transform: translateY(0);
        }
  
        .submit-ai-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
  
        /* Compact button - floating in upper right */
        .compact-button {
          position: fixed;
          top: 20px;
          right: 20px;
          background: var(--color-gold);
          color: var(--color-bg-primary);
          border: none;
          border-radius: 6px;
          padding: 10px 20px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
          z-index: 1000;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
  
        .compact-button:hover {
          background: var(--color-gold-light);
          transform: translateY(-2px);
          box-shadow: 0 4px 12px var(--color-gold-glow);
        }
  
        .compact-button:active {
          transform: translateY(0);
        }
  
        #message-input::-webkit-scrollbar {
          display: none;
        }
  
        #message-input::placeholder {
          color: var(--color-text-dim);
        }
  
        #message-input:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
  
        #project-path {
          font-size: 12px;
          color: var(--color-text-secondary);
          text-align: left;
          width: 90%;
          max-width: 1200px;
        }
  
        #context-stats {
          display: flex;
          gap: 12px;
          justify-content: flex-end;
          width: 90%;
          max-width: 1200px;
          margin-top: 4px;
        }
  
        .context-stat-btn {
          background: none;
          border: none;
          color: var(--color-text-dim);
          font-size: 11px;
          font-family: 'Consolas', 'Courier New', monospace;
          cursor: pointer;
          padding: 2px 4px;
          transition: color 0.2s ease;
        }
  
        .context-stat-btn:hover {
          color: var(--color-gold);
        }
  
        /* Messages */
        .message {
          margin-bottom: 8px;
          position: relative;
          cursor: pointer;
          transition: all 0.2s;
        }
  
        .message.selected {
          background: rgba(212, 160, 23, 0.15);
          border-left: 3px solid var(--color-gold);
          padding-left: 8px;
          margin-left: -8px;
        }
  
        .message:first-child {
          margin-top: 20px;
        }
  
        /* Edit/Delete buttons */
        .message-actions {
          position: absolute;
          top: 4px;
          right: 8px;
          opacity: 0;
          transition: opacity 0.2s;
          display: flex;
          gap: 8px;
          z-index: 10;
        }
  
        .message:hover .message-actions {
          opacity: 1;
        }
  
        .message-action-btn {
          background: rgba(0, 0, 0, 0.3);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 3px;
          padding: 2px 6px;
          cursor: pointer;
          font-size: 12px;
          color: var(--color-text-secondary);
          transition: all 0.2s;
        }
  
        .message-action-btn:hover {
          background: rgba(0, 0, 0, 0.5);
          border-color: var(--color-gold);
          color: var(--color-gold);
        }
  
        /* Editing state */
        .message-content.editing {
          border: 1px solid var(--color-gold);
          outline: none;
          background: rgba(212, 160, 23, 0.1);
          cursor: text;
          padding: 8px;
          border-radius: 4px;
        }
  
        .edit-actions {
          display: flex;
          gap: 8px;
          margin-top: 8px;
          justify-content: flex-end;
        }
  
        .edit-action-btn {
          padding: 4px 12px;
          border-radius: 4px;
          border: 1px solid var(--color-border);
          cursor: pointer;
          font-size: 12px;
          transition: all 0.2s;
        }
  
        .edit-save-btn {
          background: var(--color-gold);
          color: var(--color-bg-primary);
          border-color: var(--color-gold);
        }
  
        .edit-save-btn:hover {
          opacity: 0.9;
        }
  
        .edit-cancel-btn {
          background: transparent;
          color: var(--color-text-secondary);
        }
  
        .edit-cancel-btn:hover {
          background: rgba(255, 255, 255, 0.1);
        }
  
        .user-message {
          display: flex;
          gap: 8px;
          color: var(--color-text-dim);
        }
  
        .user-message .message-prefix {
          flex-shrink: 0;
        }
  
        .user-message .message-content {
          flex: 1;
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        .assistant-message {
          color: var(--color-gold);
          padding-left: 2ch;
          background-image: linear-gradient(
            to right,
            transparent 0px,
            transparent calc(1ch - 5px),
            var(--color-gold) calc(1ch - 5px),
            var(--color-gold) calc(1ch - 4px),
            transparent calc(1ch - 4px)
          );
          background-repeat: no-repeat;
          background-size: 100% 100%;
          transition: all 0.2s ease;
          position: relative;
        }
  
        .assistant-message:hover {
          background-color: var(--color-gold-subtle);
          transform: translateX(2px);
        }
  
        .assistant-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
          max-width: 100%;
          overflow-wrap: break-word;
        }
  
        .message-timing {
          position: absolute;
          bottom: 2px;
          right: 8px;
          font-size: 10px;
          color: var(--color-text-dim);
          opacity: 0.5;
          pointer-events: none;
        }
  
        .tool-execution-timing {
          font-size: 10px;
          color: var(--color-text-dim);
          text-align: center;
          margin: 8px 0;
          opacity: 0.6;
          font-style: italic;
        }
  
        .loading {
          display: flex;
          gap: 6px;
          padding: 8px 12px;
          background: var(--color-gold-subtle);
          border-radius: 4px;
          color: var(--color-gold);
          align-items: center;
          justify-content: space-between;
        }
  
        .loading-text {
          display: flex;
          align-items: center;
          gap: 6px;
        }
  
        .loading-text::after {
          content: '';
          width: 6px;
          height: 6px;
          background: var(--color-gold);
          border-radius: 50%;
          animation: loading-bounce 1.4s infinite ease-in-out both;
        }
  
        .loading-cancel-btn {
          background: rgba(255, 255, 255, 0.1);
          border: 1px solid var(--color-gold);
          color: var(--color-gold);
          padding: 4px 12px;
          font-size: 11px;
          font-family: 'Consolas', 'Courier New', monospace;
          cursor: pointer;
          border-radius: 3px;
          transition: all 0.2s;
        }
  
        .loading-cancel-btn:hover {
          background: var(--color-gold);
          color: var(--color-bg);
        }
  
        @keyframes loading-bounce {
          0%, 80%, 100% {
            transform: scale(0);
            opacity: 0.5;
          }
          40% {
            transform: scale(1);
            opacity: 1;
          }
        }
  
        /* Tool Execution Messages - Inline Style */
        .tool-use-inline {
          padding: 4px 0 4px 2ch;
          font-size: 13px;
          line-height: 1.8;
        }
  
        .tool-use-inline .tool-name {
          color: #a0a0a0;
          font-weight: bold;
        }
  
        .tool-use-inline .tool-params {
          color: #888888;
          font-weight: normal;
        }
  
        .tool-result-inline {
          position: relative;
          padding: 4px 0 12px 3ch;
          font-size: 13px;
          color: #999999;
          cursor: pointer;
          transition: color 0.2s ease;
          line-height: 1.8;
        }
  
        .tool-result-inline:hover {
          color: var(--color-gold);
        }
  
        .tool-result-inline.error {
          color: #ff6b6b;
        }
  
        .tool-result-inline.error:hover {
          color: #ff5252;
        }
  
        /* Tool Execution Messages - Legacy */
        .tool-message {
          color: var(--color-text-secondary);
          padding: 8px 12px;
          background: var(--color-gold-subtle);
          border-left: 3px solid var(--color-gold);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 13px;
        }
  
        .tool-message:hover {
          background: rgba(212, 160, 23, 0.15);
          border-left-color: var(--color-gold-light);
          transform: translateX(2px);
        }
  
        .tool-message .message-content {
          white-space: pre-wrap;
          word-wrap: break-word;
        }
  
        /* Tool Pair Container (inline tool-use + tool-result) */
        .tool-pair {
          margin-bottom: 8px;
          position: relative;
        }
  
        /* System messages - visually distinct */
        .from-system {
          border-left: 3px solid #ff9800 !important;
          background: rgba(255, 152, 0, 0.05) !important;
          opacity: 0.85;
        }
  
        .from-system::before {
          content: "âš™ SYSTEM";
          display: block;
          font-size: 10px;
          font-weight: bold;
          color: #ff9800;
          margin-bottom: 4px;
          letter-spacing: 0.5px;
        }
  
        /* Message character count badge */
        .message-char-count {
          position: absolute;
          bottom: 4px;
          right: 8px;
          font-size: 10px;
          color: #666;
          font-weight: normal;
          opacity: 0.6;
          pointer-events: none;
          font-family: 'Consolas', 'Courier New', monospace;
        }
  
        /* Modal Overlay */
        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.85);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          animation: fadeIn 0.2s ease;
        }
  
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
  
        /* Modal Container */
        .modal-container {
          background: var(--color-bg-secondary);
          border: 2px solid var(--color-gold);
          border-radius: 8px;
          width: 90%;
          max-width: 900px;
          max-height: 80vh;
          display: flex;
          flex-direction: column;
          animation: slideUp 0.2s ease;
        }
  
        @keyframes slideUp {
          from {
            transform: translateY(20px);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }
  
        /* Modal Header */
        .modal-header {
          padding: 16px 20px;
          border-bottom: 1px solid var(--color-border);
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
  
        .modal-title {
          color: var(--color-gold);
          font-size: 18px;
          font-weight: bold;
        }
  
        .modal-close {
          background: none;
          border: none;
          color: var(--color-text-secondary);
          font-size: 24px;
          cursor: pointer;
          padding: 0;
          width: 32px;
          height: 32px;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: color 0.2s ease;
        }
  
        .modal-close:hover {
          color: var(--color-gold);
        }
  
        /* Modal Body */
        .modal-body {
          padding: 20px;
          overflow-y: auto;
          flex: 1;
        }
  
        .modal-body::-webkit-scrollbar {
          width: 8px;
        }
  
        .modal-body::-webkit-scrollbar-track {
          background: var(--color-bg-primary);
        }
  
        .modal-body::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 4px;
        }
  
        .modal-body::-webkit-scrollbar-thumb:hover {
          background: #777;
        }
  
        .modal-section {
          margin-bottom: 24px;
        }
  
        .modal-section:last-child {
          margin-bottom: 0;
        }
  
        .modal-section-title-row {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        }
  
        .modal-section-title {
          color: var(--color-gold);
          font-size: 14px;
          font-weight: bold;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
  
        .modal-section-copy-btn {
          background: var(--color-bg-primary);
          border: 1px solid var(--color-gold);
          color: var(--color-gold);
          padding: 4px 8px;
          font-size: 11px;
          font-family: 'Consolas', 'Courier New', monospace;
          cursor: pointer;
          border-radius: 3px;
          transition: all 0.2s ease;
        }
  
        .modal-section-copy-btn:hover {
          background: var(--color-gold);
          color: var(--color-bg-primary);
        }
  
        .modal-section-content {
          background: var(--color-bg-primary);
          padding: 12px;
          border-radius: 4px;
          border-left: 3px solid var(--color-gold-subtle);
          color: var(--color-text-primary);
          white-space: pre-wrap;
          word-wrap: break-word;
          font-family: 'Consolas', 'Courier New', monospace;
          font-size: 13px;
          line-height: 1.5;
          max-height: 400px;
          overflow-y: auto;
        }
  
        .modal-section-content::-webkit-scrollbar {
          width: 6px;
        }
  
        .modal-section-content::-webkit-scrollbar-track {
          background: var(--color-bg-secondary);
        }
  
        .modal-section-content::-webkit-scrollbar-thumb {
          background: #555;
          border-radius: 3px;
        }
  
        /* Summary Messages */
        .summary-message {
          background: rgba(100, 150, 200, 0.08);
          border-left: 3px solid rgba(100, 150, 200, 0.5);
          border-radius: 4px;
          padding: 12px 16px;
          margin-bottom: 20px;
          transition: all 0.2s ease;
        }
  
        .summary-message:hover {
          background: rgba(100, 150, 200, 0.12);
          border-left-color: #6496c8;
          transform: translateX(2px);
        }
  
        .summary-header {
          color: #6496c8;
          font-weight: bold;
          font-size: 13px;
          margin-bottom: 8px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
  
        .summary-message .message-content {
          color: var(--color-text-secondary);
          white-space: pre-wrap;
          word-wrap: break-word;
          font-size: 13px;
          line-height: 1.6;
        }
      `;
      document.head.appendChild(style);
    }
  };
  

  // Module: tools.js
  // Tool system - simplified architecture
  window.module['tools.js'] = {
  
    // Tool definitions
    tools: [
      {
        name: 'list_directory',
        description: 'List the contents of a directory (one level deep)',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The directory path to list (relative to project root, use "." for root)'
            }
          },
          required: ['path']
        }
      },
  
      {
        name: 'read_file',
        description: 'Read the contents of a file',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to read (relative to project root)'
            }
          },
          required: ['path']
        }
      },
  
      {
        name: 'write_file',
        description: 'Write content to a file (creates file and directories if they don\'t exist)',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to write (relative to project root)'
            },
            content: {
              type: 'string',
              description: 'The content to write to the file'
            }
          },
          required: ['path', 'content']
        }
      },
  
      {
        name: 'search_by_filename',
        description: 'Search for files by filename pattern (supports wildcards like *.js, test*, etc.)',
        input_schema: {
          type: 'object',
          properties: {
            pattern: {
              type: 'string',
              description: 'The filename pattern to search for (e.g., "*.js", "test*", "config.json")'
            },
            path: {
              type: 'string',
              description: 'The directory to search in (relative to project root, use "." for root). Optional, defaults to "."'
            }
          },
          required: ['pattern']
        }
      },
  
      {
        name: 'search_by_content',
        description: 'Search for text within file contents',
        input_schema: {
          type: 'object',
          properties: {
            text: {
              type: 'string',
              description: 'The text to search for within files'
            },
            path: {
              type: 'string',
              description: 'The directory to search in (relative to project root, use "." for root). Optional, defaults to "."'
            },
            filePattern: {
              type: 'string',
              description: 'Optional file pattern to limit search (e.g., "*.js", "*.txt"). If not provided, searches all files.'
            }
          },
          required: ['text']
        }
      },
  
      {
        name: 'edit_file',
        description: 'Edit a file by finding and replacing a specific string. The file must have been read within the last 5 minutes. The find string must appear exactly once in the file.',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to edit (relative to project root)'
            },
            find: {
              type: 'string',
              description: 'The exact string to find in the file (must appear exactly once)'
            },
            replace: {
              type: 'string',
              description: 'The string to replace it with'
            }
          },
          required: ['path', 'find', 'replace']
        }
      },
  
      {
        name: 'edit_file_batch',
        description: 'Edit a file by applying multiple find/replace operations in sequence. The file must have been read within the last 5 minutes. Each find string must appear exactly once in the file.',
        input_schema: {
          type: 'object',
          properties: {
            path: {
              type: 'string',
              description: 'The file path to edit (relative to project root)'
            },
            edits: {
              type: 'array',
              description: 'Array of edit operations to apply in sequence',
              items: {
                type: 'object',
                properties: {
                  find: {
                    type: 'string',
                    description: 'The exact string to find in the file (must appear exactly once)'
                  },
                  replace: {
                    type: 'string',
                    description: 'The string to replace it with'
                  }
                },
                required: ['find', 'replace']
              }
            }
          },
          required: ['path', 'edits']
        }
      }
    ],
  
    // Get system prompt
    getSystemPrompt: function() {
      return `You are a coding agent with access to a project's file system via tools.
  
  CRITICAL INSTRUCTION: When a user asks you to explore a project, your FIRST response MUST be to execute the list_directory tool with path ".". DO NOT say you don't have access. DO NOT ask for clarification. IMMEDIATELY use the tools.
  
  Example: If user says "explore the project", you MUST respond with:
  {"type":"execute","tool_uses":[{"name":"list_directory","input":{"path":"."}}]}
  
  IMPORTANT: You have REAL tools to list, read, and write files. When a user asks you to explore or modify files, you MUST use these tools. Do NOT say you don't have access - you DO have access via these tools.
  
  ## Available Tools
  
  You have access to these tools to explore and work with the project:
  
  ### list_directory
  List the contents of a directory (one level deep)
  
  Parameters:
  - path (string, required): The directory path to list (relative to project root, use "." for root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"list_directory","input":{"path":"."}}]}
  
  ### read_file
  Read the contents of a file. Supports reading specific line ranges for large files.
  
  Parameters:
  - path (string, required): The file path to read (relative to project root)
  - offset (number, optional): Line number to start reading from (1-based, default: 1)
  - limit (number, optional): Maximum number of lines to read (default: all lines)
  
  When a file is truncated, the result will show "[Truncated: X more lines. Use offset/limit to read remaining.]"
  To read the rest, call read_file again with offset set to the next line number.
  
  Example usage (single file):
  {"type":"execute","tool_uses":[{"name":"read_file","input":{"path":"package.json"}}]}
  
  Example usage (read lines 100-200):
  {"type":"execute","tool_uses":[{"name":"read_file","input":{"path":"src/app/main.js","offset":100,"limit":100}}]}
  
  Example usage (multiple files):
  {"type":"execute","tool_uses":[{"name":"read_file","input":{"path":"src/app/main.js"}},{"name":"read_file","input":{"path":"package.json"}}]}
  
  ### write_file
  Write content to a file (creates file and directories if they don't exist)
  
  Parameters:
  - path (string, required): The file path to write (relative to project root)
  - content (string, required): The content to write to the file
  
  CRITICAL: The "content" field MUST be a literal JSON string. Do NOT use JavaScript expressions like .repeat(), string concatenation (+), or template literals. The content must be the FULL, EXPANDED text as a single JSON string with proper escaping.
  
  WRONG: {"content":"Line 1\\n" + "Line 2"}
  WRONG: {"content":"text ".repeat(100)}
  CORRECT: {"content":"Line 1\\nLine 2"}
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"write_file","input":{"path":"src/utils/helper.js","content":"// Helper functions\\nexport function add(a, b) {\\n  return a + b;\\n}"}}]}
  
  ### search_by_filename
  Search for files by filename pattern (supports wildcards)
  
  Parameters:
  - pattern (string, required): The filename pattern to search for (e.g., "*.js", "test*", "config.json")
  - path (string, optional): The directory to search in (relative to project root, defaults to ".")
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"search_by_filename","input":{"pattern":"*.js","path":"src"}}]}
  
  ### search_by_content
  Search for text within file contents
  
  Parameters:
  - text (string, required): The text to search for within files
  - path (string, optional): The directory to search in (relative to project root, defaults to ".")
  - filePattern (string, optional): File pattern to limit search (e.g., "*.js")
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"search_by_content","input":{"text":"executeTools","filePattern":"*.js"}}]}
  
  ### edit_file
  Edit a file by finding and replacing a specific string (for single edits)
  
  IMPORTANT REQUIREMENTS:
  1. You MUST read the file within the last 5 minutes before editing
  2. The find string MUST appear exactly once in the file (otherwise you'll get an error)
  3. If the file is blank/empty, use write_file instead
  
  Parameters:
  - path (string, required): The file path to edit (relative to project root)
  - find (string, required): The exact string to find (must appear exactly once)
  - replace (string, required): The string to replace it with
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"edit_file","input":{"path":"src/config.js","find":"debug: false","replace":"debug: true"}}]}
  
  ### edit_file_batch
  Edit a file by applying multiple find/replace operations in sequence (for multiple edits to the same file)
  
  IMPORTANT REQUIREMENTS:
  1. You MUST read the file within the last 5 minutes before editing
  2. Each find string MUST appear exactly once in the file at the time it's applied (otherwise you'll get an error)
  3. Edits are applied in sequence, so later edits see the results of earlier edits
  4. If the file is blank/empty, use write_file instead
  
  Parameters:
  - path (string, required): The file path to edit (relative to project root)
  - edits (array, required): Array of {find, replace} operations to apply in sequence
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"edit_file_batch","input":{"path":"src/config.js","edits":[{"find":"version: '1.0.0'","replace":"version: '2.0.0'"},{"find":"debug: false","replace":"debug: true"}]}}]}
  
  ### delete_file
  Delete a file
  
  Parameters:
  - path (string, required): The file path to delete (relative to project root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"delete_file","input":{"path":"temp/old-file.js"}}]}
  
  ### move_file
  Move or rename a file
  
  Parameters:
  - source (string, required): The source file path (relative to project root)
  - destination (string, required): The destination file path (relative to project root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"move_file","input":{"source":"src/old-name.js","destination":"src/new-name.js"}}]}
  
  ### copy_file
  Copy a file to a new location
  
  Parameters:
  - source (string, required): The source file path (relative to project root)
  - destination (string, required): The destination file path (relative to project root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"copy_file","input":{"source":"src/template.js","destination":"src/new-component.js"}}]}
  
  ### create_directory
  Create a new directory (and any parent directories as needed)
  
  Parameters:
  - path (string, required): The directory path to create (relative to project root)
  
  Example usage:
  {"type":"execute","tool_uses":[{"name":"create_directory","input":{"path":"src/components/new-feature"}}]}
  
  ## Workflow
  
  When asked to explore a project:
  1. Use list_directory to see what files/folders exist
  2. Use search_by_filename to find specific files by pattern
  3. Use search_by_content to find files containing specific text
  4. Use read_file to read relevant files (you can read multiple files at once)
  5. File contents will remain in the conversation for context
  6. Use write_file to create or update files
  7. Then provide your analysis or response
  
  ## Response Format
  
  You MUST respond with valid JSON followed by a terminator. Your response MUST be ONLY the JSON object, followed immediately by ||||END||||
  
  **To execute tools:**
  {"type":"execute","tool_uses":[{"name":"tool_name","input":{"param":"value"}}]}||||END||||
  
  **To send a message:**
  {"type":"message","content":"Your response text here"}||||END||||
  
  CRITICAL:
  - Do NOT use any other response type. Only "execute" or "message".
  - Do NOT wrap your JSON in markdown code blocks
  - Do NOT include any explanatory text before or after the JSON
  - Your ENTIRE response must be valid JSON starting with { and ending with }
  - JSON fields MUST contain literal values only - NO JavaScript expressions, concatenation (+), .repeat(), template literals, or any code
  - All string values must be fully expanded as literal JSON strings with proper escaping (\\n for newlines, \\" for quotes)
  - ALWAYS end your response with ||||END|||| immediately after the closing }
  - If your response is blank or empty, just send ||||END|||| to indicate completion`;
    },
  
    // Attempt to fix malformed JSON
    tryFixJSON: function(jsonText) {
      // If last character is "}", try removing it and parsing again
      if (jsonText.trim().endsWith('}')) {
        const withoutLastBrace = jsonText.trim().slice(0, -1);
        try {
          const parsed = JSON.parse(withoutLastBrace);
          console.log('[tryFixJSON] Successfully fixed JSON by removing trailing }');
          return { fixed: true, json: withoutLastBrace, parsed };
        } catch (e) {
          return { fixed: false };
        }
      }
      return { fixed: false };
    },
  
    // Attempt to fix unescaped newlines in JSON content
    tryFixNewlines: function(jsonText) {
      try {
        // Strategy: Find content field and escape newlines within it
        // This is a heuristic approach for common AI response patterns
        const contentMatch = jsonText.match(/"content"\s*:\s*"([\s\S]*?)(?:"(?:\s*[,}]))/);
        if (contentMatch) {
          const originalContent = contentMatch[1];
          const fixedContent = originalContent
            .replace(/\r/g, '\\r')
            .replace(/\n/g, '\\n')
            .replace(/\t/g, '\\t');
  
          const fixedJson = jsonText.replace(
            `"content":"${originalContent}"`,
            `"content":"${fixedContent}"`
          );
  
          const parsed = JSON.parse(fixedJson);
          console.log('[tryFixNewlines] Successfully fixed JSON by escaping newlines');
          return { fixed: true, json: fixedJson, parsed };
        }
      } catch (e) {
        console.log('[tryFixNewlines] Failed to fix:', e.message);
        return { fixed: false };
      }
      return { fixed: false };
    },
  
    // Attempt to extract valid JSON when AI adds text before/after the JSON
    tryExtractJSON: function(text) {
      const diagnostics = window.module['diagnostics.js'];
  
      try {
        // Strategy: Find the first '{' and count braces to find where JSON ends
        // Must properly handle braces inside strings
        const startIdx = text.indexOf('{');
        if (startIdx === -1) {
          return { fixed: false };
        }
  
        let braceCount = 0;
        let endIdx = -1;
        let inString = false;
        let escapeNext = false;
  
        for (let i = startIdx; i < text.length; i++) {
          const char = text[i];
  
          // Handle escape sequences
          if (escapeNext) {
            escapeNext = false;
            continue;
          }
  
          if (char === '\\') {
            escapeNext = true;
            continue;
          }
  
          // Handle string boundaries
          if (char === '"') {
            inString = !inString;
            continue;
          }
  
          // Only count braces outside of strings
          if (!inString) {
            if (char === '{') {
              braceCount++;
            } else if (char === '}') {
              braceCount--;
              if (braceCount === 0) {
                endIdx = i + 1;
                break;
              }
            }
          }
        }
  
        if (endIdx === -1) {
          return { fixed: false };
        }
  
        const extractedJson = text.substring(startIdx, endIdx);
        const parsed = JSON.parse(extractedJson);
  
        const prefixText = text.substring(0, startIdx).trim();
        const suffixText = text.substring(endIdx).trim();
  
        if (prefixText || suffixText) {
          diagnostics.log('json', '[tryExtractJSON] Extracted JSON, discarded surrounding text', {
            extractedLength: extractedJson.length,
            discardedPrefix: prefixText.substring(0, 100),
            discardedSuffix: suffixText.substring(0, 100)
          });
        }
  
        console.log('[tryExtractJSON] Successfully extracted JSON from response with surrounding text');
        return {
          fixed: true,
          json: extractedJson,
          parsed,
          prefixText: prefixText || null,
          suffixText: suffixText || null
        };
      } catch (e) {
        console.log('[tryExtractJSON] Failed to extract:', e.message);
        return { fixed: false };
      }
    },
  
    // Parse and validate AI response
    parseResponse: function(responseText) {
      let response;
      let extractedText = null;  // Store any text that was extracted
  
      // Try to parse JSON
      try {
        response = JSON.parse(responseText);
      } catch (parseError) {
        // Try to fix the JSON
        console.log('[parseResponse] Initial JSON parse failed:', parseError.message);
  
        // Try multiple fix strategies
        let fixResult = this.tryFixJSON(responseText);
  
        if (!fixResult.fixed) {
          // If that didn't work, try escaping newlines in content
          fixResult = this.tryFixNewlines(responseText);
        }
  
        if (!fixResult.fixed) {
          // If that didn't work, try extracting just the JSON portion (AI adding text after JSON)
          fixResult = this.tryExtractJSON(responseText);
        }
  
        if (fixResult.fixed) {
          console.log('[parseResponse] JSON was fixed, using repaired version');
          response = fixResult.parsed;
  
          // If extraction found prefix/suffix text, store it
          if (fixResult.prefixText || fixResult.suffixText) {
            extractedText = {
              prefix: fixResult.prefixText,
              suffix: fixResult.suffixText
            };
          }
        } else {
          return {
            valid: false,
            error: `Invalid JSON: ${parseError.message}`
          };
        }
      }
  
      // Validate response structure
      if (!response.type) {
        return {
          valid: false,
          error: 'Response missing required "type" field'
        };
      }
  
      if (response.type === 'message') {
        if (!response.content || typeof response.content !== 'string') {
          return {
            valid: false,
            error: 'Message response missing "content" field or content is not a string'
          };
        }
      } else if (response.type === 'execute') {
        if (!response.tool_uses || !Array.isArray(response.tool_uses)) {
          return {
            valid: false,
            error: 'Execute response missing "tool_uses" array'
          };
        }
  
        // Validate each tool use
        for (let i = 0; i < response.tool_uses.length; i++) {
          const toolUse = response.tool_uses[i];
          if (!toolUse.name || typeof toolUse.name !== 'string') {
            return {
              valid: false,
              error: `Tool use ${i} missing "name" field or name is not a string`
            };
          }
          if (!toolUse.input || typeof toolUse.input !== 'object') {
            return {
              valid: false,
              error: `Tool use ${i} missing "input" field or input is not an object`
            };
          }
        }
      } else {
        return {
          valid: false,
          error: `Unknown response type: "${response.type}". Must be "message" or "execute"`
        };
      }
  
      return {
        valid: true,
        parsed: response,
        extractedText: extractedText  // Include any prefix/suffix text that was extracted
      };
    }
  };
  

  // Module: ui.js
  // UI rendering and interaction
  window.module['ui.js'] = {
    // Track last clicked message for shift-click range selection
    lastClickedMessageId: null,
  
    showDirectorySelection: function(onSelect) {
      const container = document.createElement('div');
      container.id = 'app-container';
  
      const screen = document.createElement('div');
      screen.id = 'directory-screen';
  
      const title = document.createElement('h1');
      title.textContent = 'AI Coding Agent';
  
      const button = document.createElement('button');
      button.id = 'select-dir-btn';
      button.textContent = 'Select Project Directory';
      button.onclick = onSelect;
  
      screen.appendChild(title);
      screen.appendChild(button);
      container.appendChild(screen);
      document.body.appendChild(container);
    },
  
    showChatScreen: function(selectedDirectory, onAddMessage, onSubmitToAI) {
      const container = document.getElementById('app-container');
      container.innerHTML = '';
  
      const screen = document.createElement('div');
      screen.id = 'chat-screen';
  
      // Chat container
      const chatContainer = document.createElement('div');
      chatContainer.id = 'chat-container';
  
      // Input container
      const inputContainer = document.createElement('div');
      inputContainer.id = 'input-container';
  
      // Input wrapper
      const inputWrapper = document.createElement('div');
      inputWrapper.id = 'input-wrapper';
  
      const textarea = document.createElement('textarea');
      textarea.id = 'message-input';
      textarea.placeholder = 'Type your message...';
      textarea.rows = 1;
  
      // Auto-resize textarea
      const resizeTextarea = () => {
        textarea.style.height = '0px';
        textarea.style.height = Math.min(textarea.scrollHeight, window.innerHeight * 0.33) + 'px';
      };
  
      textarea.addEventListener('input', resizeTextarea);
  
      textarea.addEventListener('keydown', (e) => {
        // Enter = add message (no shift)
        // Shift+Enter = newline
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
  
          // If input is empty and submit button is visible, submit to AI
          const inputValue = textarea.value.trim();
          const submitBtn = document.getElementById('submit-ai-btn');
          const submitBtnVisible = submitBtn && submitBtn.style.display !== 'none';
  
          if (!inputValue && submitBtnVisible) {
            onSubmitToAI();
          } else {
            onAddMessage();
          }
        }
      });
  
      // Submit to AI button
      const submitBtn = document.createElement('button');
      submitBtn.id = 'submit-ai-btn';
      submitBtn.className = 'submit-ai-btn';
      submitBtn.textContent = 'Submit to AI';
      submitBtn.onclick = onSubmitToAI;
  
      inputWrapper.appendChild(textarea);
      inputWrapper.appendChild(submitBtn);
      inputContainer.appendChild(inputWrapper);
  
      // Project path display
      const projectPath = document.createElement('div');
      projectPath.id = 'project-path';
  
      // Get full path from directory handle
      if (selectedDirectory) {
        // Try to resolve the full path if available (Chrome 86+)
        selectedDirectory.resolve().then(path => {
          if (path && path.length > 0) {
            projectPath.textContent = path.join('/');
          } else {
            projectPath.textContent = selectedDirectory.name;
          }
        }).catch(() => {
          // Fallback to just the directory name
          projectPath.textContent = selectedDirectory.name;
        });
      }
  
      inputContainer.appendChild(projectPath);
  
      // Context stats display
      const contextStats = document.createElement('div');
      contextStats.id = 'context-stats';
  
      const messagesBtn = document.createElement('button');
      messagesBtn.className = 'context-stat-btn';
      messagesBtn.id = 'messages-stat-btn';
      messagesBtn.textContent = '0K';
      messagesBtn.onclick = () => this.showConversationModal();
  
      contextStats.appendChild(messagesBtn);
  
      inputContainer.appendChild(contextStats);
  
      screen.appendChild(chatContainer);
      screen.appendChild(inputContainer);
      container.appendChild(screen);
  
      // Focus the input
      textarea.focus();
  
      // Initial stats update
      this.updateContextStats();
  
      // Initial button visibility update
      this.updateSubmitButtonVisibility();
    },
  
    renderMessages: function(messages) {
      const container = document.getElementById('chat-container');
  
      // Preserve loading indicator if it exists
      const loadingIndicator = document.getElementById('loading-indicator');
      const loadingHTML = loadingIndicator ? loadingIndicator.outerHTML : null;
  
      container.innerHTML = '';
  
      messages.forEach((msg, index) => {
        // Skip marker messages
        if (msg.isMarker) {
          return;
        }
  
        // Skip API-only messages
        if (msg.apiOnly) {
          return;
        }
  
        // Skip assistant messages that contain raw JSON tool execution requests
        // These are for API conversation structure only, not for UI display
        // We detect them by checking if the content starts with JSON (contains "type": "execute")
        if (msg.type === 'assistant_msg' && msg.apiData && msg.content && msg.content.includes('"type"')) {
          return;
        }
  
        // Regular message rendering
        const messageDiv = document.createElement('div');
  
        // Add click handler for selection (with shift-click support)
        const state = window.module['state.js'];
        messageDiv.addEventListener('click', (e) => {
          // Don't interfere with edit/delete buttons or contenteditable
          if (e.target.closest('.message-actions') || e.target.isContentEditable) {
            return;
          }
  
          e.stopPropagation();
  
          const ui = window.module['ui.js'];
          if (e.shiftKey && ui.lastClickedMessageId) {
            // Range selection
            state.selectMessageRange(ui.lastClickedMessageId, msg.id);
          } else {
            // Toggle single selection
            state.toggleMessageSelection(msg.id);
          }
  
          ui.lastClickedMessageId = msg.id;
  
          // Re-render to show selection
          this.renderMessages(state.getMessages());
          this.updateContextStats();
          this.updateCompactButtonVisibility();
        });
  
        // Handle new tool-use and tool-result types
        // Check if this is a tool-use followed by tool-result (pair them)
        if (msg.type === 'tool-use') {
          const nextMsg = messages[index + 1];
          const isPaired = nextMsg && nextMsg.type === 'tool-result';
  
          if (isPaired) {
            // Create a container for both messages
            const pairDiv = document.createElement('div');
            pairDiv.className = 'message tool-pair';
  
            // Tool use part
            const toolUseDiv = document.createElement('div');
            toolUseDiv.className = 'tool-use-inline';
  
            const toolName = document.createElement('span');
            toolName.className = 'tool-name';
            toolName.textContent = msg.toolName;
  
            const toolParams = document.createElement('span');
            toolParams.className = 'tool-params';
            toolParams.textContent = ' ' + JSON.stringify(msg.params);
  
            toolUseDiv.appendChild(toolName);
            toolUseDiv.appendChild(toolParams);
            pairDiv.appendChild(toolUseDiv);
  
            // Tool result part
            const toolResultDiv = document.createElement('div');
            toolResultDiv.className = nextMsg.error ? 'tool-result-inline error' : 'tool-result-inline';
            toolResultDiv.textContent = nextMsg.summary;
            pairDiv.appendChild(toolResultDiv);
  
            // Add selection state (using tool-use message ID)
            if (state.isMessageSelected(msg.id)) {
              pairDiv.classList.add('selected');
            }
  
            // Add click handler for selection
            pairDiv.addEventListener('click', (e) => {
              if (e.target.closest('.message-actions') || e.target.isContentEditable) {
                return;
              }
              e.stopPropagation();
  
              const ui = window.module['ui.js'];
              if (e.shiftKey && ui.lastClickedMessageId) {
                state.selectMessageRange(ui.lastClickedMessageId, msg.id);
              } else {
                state.toggleMessageSelection(msg.id);
              }
              ui.lastClickedMessageId = msg.id;
  
              this.renderMessages(state.getMessages());
              this.updateContextStats();
              this.updateCompactButtonVisibility();
            });
  
            // Add single edit/delete button for the pair
            if (msg.id) {
              this.addMessageActions(pairDiv, msg.id, nextMsg.id, msg.toolName);
            }
  
            // Add character count for the pair (combined)
            const pairCharCount = this.getMessageCharCount(msg) + this.getMessageCharCount(nextMsg);
            if (pairCharCount > 0) {
              const charBadge = document.createElement('div');
              charBadge.className = 'message-char-count';
              charBadge.textContent = this.formatSizeDecimal(pairCharCount);
              pairDiv.appendChild(charBadge);
            }
  
            container.appendChild(pairDiv);
            return;
          }
  
          // Unpaired tool-use (shouldn't normally happen)
          messageDiv.className = 'message tool-use-inline';
  
          const toolName = document.createElement('span');
          toolName.className = 'tool-name';
          toolName.textContent = msg.toolName;
  
          const toolParams = document.createElement('span');
          toolParams.className = 'tool-params';
          toolParams.textContent = ' ' + JSON.stringify(msg.params);
  
          messageDiv.appendChild(toolName);
          messageDiv.appendChild(toolParams);
  
          if (msg.id) {
            this.addMessageActions(messageDiv, msg.id);
          }
  
          if (state.isMessageSelected(msg.id)) {
            messageDiv.classList.add('selected');
          }
  
          // Add character count
          const charCount = this.getMessageCharCount(msg);
          if (charCount > 0) {
            const charBadge = document.createElement('div');
            charBadge.className = 'message-char-count';
            charBadge.textContent = this.formatSizeDecimal(charCount);
            messageDiv.appendChild(charBadge);
          }
  
          container.appendChild(messageDiv);
          return;
        } else if (msg.type === 'tool-result') {
          // Check if previous message was tool-use (if so, skip - already rendered as pair)
          const prevMsg = messages[index - 1];
          if (prevMsg && prevMsg.type === 'tool-use') {
            return; // Skip, already rendered with tool-use
          }
  
          // Unpaired tool-result (shouldn't normally happen)
          messageDiv.className = msg.error ? 'message tool-result-inline error' : 'message tool-result-inline';
          messageDiv.textContent = msg.summary;
  
          if (msg.id) {
            this.addMessageActions(messageDiv, msg.id);
          }
  
          if (state.isMessageSelected(msg.id)) {
            messageDiv.classList.add('selected');
          }
  
          // Add character count
          const charCount = this.getMessageCharCount(msg);
          if (charCount > 0) {
            const charBadge = document.createElement('div');
            charBadge.className = 'message-char-count';
            charBadge.textContent = this.formatSizeDecimal(charCount);
            messageDiv.appendChild(charBadge);
          }
  
          container.appendChild(messageDiv);
          return;
        }
  
        // Apply styling based on message type
        // Translate type to CSS class (e.g., user_msg -> user-message)
        const cssClass = msg.type === 'user_msg' ? 'user' : msg.type === 'assistant_msg' ? 'assistant' : msg.type;
        messageDiv.className = `message ${cssClass}-message`;
  
        // Add fromSystem class for system messages
        if (msg.fromSystem) {
          messageDiv.classList.add('from-system');
        }
  
        // Check for compaction notice - apply special gray italic styling
        if (msg.isCompactionNotice) {
          messageDiv.style.color = '#888';
          messageDiv.style.fontStyle = 'italic';
        }
  
        if (msg.type === 'user_msg') {
          const prefix = document.createElement('span');
          prefix.className = 'message-prefix';
          prefix.textContent = '> ';
  
          const content = document.createElement('span');
          content.className = 'message-content';
          content.textContent = msg.content;
  
          messageDiv.appendChild(prefix);
          messageDiv.appendChild(content);
  
          // Add edit/delete buttons
          if (msg.id) {
            this.addMessageActions(messageDiv, msg.id);
          }
        } else if (msg.type === 'assistant_msg') {
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
          messageDiv.appendChild(content);
  
          // Add edit/delete buttons
          if (msg.id) {
            this.addMessageActions(messageDiv, msg.id);
          }
        } else if (msg.type === 'summary') {
          // Summary message - special styling
          const header = document.createElement('div');
          header.className = 'summary-header';
          header.textContent = 'ðŸ“ Conversation Summary';
  
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
  
          messageDiv.appendChild(header);
          messageDiv.appendChild(content);
        } else {
          const content = document.createElement('div');
          content.className = 'message-content';
          content.textContent = msg.content;
          messageDiv.appendChild(content);
  
          // Add edit/delete buttons for all other message types
          if (msg.id) {
            this.addMessageActions(messageDiv, msg.id);
          }
        }
  
        // Add selection state
        if (state.isMessageSelected(msg.id)) {
          messageDiv.classList.add('selected');
        }
  
        // Add character count
        const charCount = this.getMessageCharCount(msg);
        if (charCount > 0) {
          const charBadge = document.createElement('div');
          charBadge.className = 'message-char-count';
          charBadge.textContent = this.formatSizeDecimal(charCount);
          messageDiv.appendChild(charBadge);
        }
  
        container.appendChild(messageDiv);
      });
  
      // Restore loading indicator if it was present
      if (loadingHTML) {
        container.insertAdjacentHTML('beforeend', loadingHTML);
      }
  
      // Update context stats
      this.updateContextStats();
  
      // Update submit button visibility
      this.updateSubmitButtonVisibility();
    },
  
    showToolModal: function(toolMessage) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const title = document.createElement('div');
      title.className = 'modal-title';
      title.textContent = 'Tool Execution Details';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(title);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      // If there's toolData, show specific tool information
      if (toolMessage.toolData && toolMessage.toolData.results) {
        toolMessage.toolData.results.forEach((toolResult, index) => {
          const toolUse = toolMessage.toolData.toolUses[index];
  
          // Tool name section
          const nameSection = document.createElement('div');
          nameSection.className = 'modal-section';
  
          const nameTitle = document.createElement('div');
          nameTitle.className = 'modal-section-title';
          nameTitle.textContent = `Tool: ${toolUse.tool}`;
  
          const nameContent = document.createElement('div');
          nameContent.className = 'modal-section-content';
          nameContent.textContent = `Parameters: ${JSON.stringify(toolUse.params, null, 2)}`;
  
          nameSection.appendChild(nameTitle);
          nameSection.appendChild(nameContent);
          body.appendChild(nameSection);
  
          // Special handling for read_file
          if (toolUse.tool === 'read_file' && toolResult.result.success) {
            // File contents
            if (toolResult.result.fileContents) {
              const contentsSection = document.createElement('div');
              contentsSection.className = 'modal-section';
  
              const contentsTitle = document.createElement('div');
              contentsTitle.className = 'modal-section-title';
              contentsTitle.textContent = `File: ${toolResult.result.path}`;
  
              const contentsContent = document.createElement('div');
              contentsContent.className = 'modal-section-content';
              contentsContent.textContent = toolResult.result.fileContents;
  
              contentsSection.appendChild(contentsTitle);
              contentsSection.appendChild(contentsContent);
              body.appendChild(contentsSection);
            }
  
            // Previous mental model notes
            if (toolResult.result.currentNotes) {
              const notesSection = document.createElement('div');
              notesSection.className = 'modal-section';
  
              const notesTitle = document.createElement('div');
              notesTitle.className = 'modal-section-title';
              notesTitle.textContent = 'Mental Model (Before)';
  
              const notesContent = document.createElement('div');
              notesContent.className = 'modal-section-content';
              notesContent.textContent = toolResult.result.currentNotes;
  
              notesSection.appendChild(notesTitle);
              notesSection.appendChild(notesContent);
              body.appendChild(notesSection);
            }
          } else {
            // For other tools, show result
            const resultSection = document.createElement('div');
            resultSection.className = 'modal-section';
  
            const resultTitle = document.createElement('div');
            resultTitle.className = 'modal-section-title';
            resultTitle.textContent = 'Result';
  
            const resultContent = document.createElement('div');
            resultContent.className = 'modal-section-content';
            resultContent.textContent = JSON.stringify(toolResult.result, null, 2);
  
            resultSection.appendChild(resultTitle);
            resultSection.appendChild(resultContent);
            body.appendChild(resultSection);
          }
        });
      } else {
        // Fallback: show basic tool execution message
        const toolSection = document.createElement('div');
        toolSection.className = 'modal-section';
  
        const toolTitle = document.createElement('div');
        toolTitle.className = 'modal-section-title';
        toolTitle.textContent = 'Tool Execution';
  
        const toolContent = document.createElement('div');
        toolContent.className = 'modal-section-content';
        toolContent.textContent = toolMessage.content;
  
        toolSection.appendChild(toolTitle);
        toolSection.appendChild(toolContent);
        body.appendChild(toolSection);
      }
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    },
  
    showLoading: function(text = 'Thinking') {
      const container = document.getElementById('chat-container');
      let loading = document.getElementById('loading-indicator');
      if (loading) {
        // Update text but keep cancel button
        const textSpan = loading.querySelector('.loading-text');
        if (textSpan) {
          textSpan.textContent = text;
        }
      } else {
        loading = document.createElement('div');
        loading.id = 'loading-indicator';
        loading.className = 'message assistant-message loading';
  
        // Create text span
        const textSpan = document.createElement('span');
        textSpan.className = 'loading-text';
        textSpan.textContent = text;
        loading.appendChild(textSpan);
  
        // Create cancel button
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'loading-cancel-btn';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.onclick = () => {
          const state = window.module['state.js'];
          state.setProcessing(false);
          this.hideLoading();
          this.setInputDisabled(false);
          this.updateSubmitButtonVisibility();
        };
        loading.appendChild(cancelBtn);
  
        container.appendChild(loading);
      }
      this.updateSubmitButtonVisibility();
    },
  
    hideLoading: function() {
      const loading = document.getElementById('loading-indicator');
      if (loading) {
        loading.remove();
      }
      this.updateSubmitButtonVisibility();
    },
  
    // Update submit button visibility based on processing state
    updateSubmitButtonVisibility: function() {
      const submitBtn = document.getElementById('submit-ai-btn');
      if (!submitBtn) return;
  
      const state = window.module['state.js'];
      const isProcessing = state.isProcessing();
      const hasMessages = state.getMessages().length > 0;
  
      // Show button only when NOT processing AND has messages
      if (isProcessing || !hasMessages) {
        submitBtn.style.display = 'none';
      } else {
        submitBtn.style.display = 'block';
      }
    },
  
    updateCompactButtonVisibility: function() {
      const state = window.module['state.js'];
      let compactBtn = document.getElementById('compact-btn');
  
      if (state.hasSelection()) {
        // Show button if selection exists
        if (!compactBtn) {
          // Create the button if it doesn't exist
          compactBtn = document.createElement('button');
          compactBtn.id = 'compact-btn';
          compactBtn.className = 'compact-button';
          compactBtn.textContent = 'Compact';
          compactBtn.addEventListener('click', () => {
            const main = window.module['main.js'];
            if (main && main.compactSelection) {
              main.compactSelection();
            }
          });
          document.body.appendChild(compactBtn);
        }
        compactBtn.style.display = 'block';
      } else {
        // Hide button if no selection
        if (compactBtn) {
          compactBtn.style.display = 'none';
        }
      }
    },
  
    getInputValue: function() {
      const input = document.getElementById('message-input');
      return input ? input.value.trim() : '';
    },
  
    clearInput: function() {
      const input = document.getElementById('message-input');
      if (input) {
        input.value = '';
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      }
    },
  
    setInputDisabled: function(disabled) {
      const input = document.getElementById('message-input');
      if (input) {
        input.disabled = disabled;
        if (!disabled) {
          input.focus();
        }
      }
    },
  
    showToolUseModal: function(toolUseMessage) {
      const data = toolUseMessage.toolUseData;
      const toolUse = data.toolUse;
  
      const overlay = this.createModalOverlay('Tool Use');
      const body = overlay.querySelector('.modal-body');
  
      // Tool and parameters
      const toolSection = this.createModalSection('Tool', `${toolUse.tool}`);
      body.appendChild(toolSection);
  
      const paramsSection = this.createModalSection('Parameters', JSON.stringify(toolUse.params, null, 2));
      body.appendChild(paramsSection);
  
      // For read_file, show additional context
      if (toolUse.tool === 'read_file') {
        const pathSection = this.createModalSection('File Path', toolUse.params.path);
        body.appendChild(pathSection);
      }
  
      // For update_mental_model, show the mental model updates
      if (toolUse.tool === 'update_mental_model' && toolUse.params.notes) {
        const notesSection = this.createModalSection(
          'Mental Model Updates',
          JSON.stringify(toolUse.params.notes, null, 2)
        );
        body.appendChild(notesSection);
  
        // Show individual file notes for easier reading
        const notes = toolUse.params.notes;
        if (Object.keys(notes).length > 0) {
          Object.entries(notes).forEach(([filePath, fileNotes]) => {
            const fileSection = this.createModalSection(
              `File: ${filePath}`,
              fileNotes
            );
            body.appendChild(fileSection);
          });
        }
      }
  
      // Full tool use object
      const fullSection = this.createModalSection('Full Tool Use Object', JSON.stringify(toolUse, null, 2));
      body.appendChild(fullSection);
  
      document.body.appendChild(overlay);
    },
  
    showToolResultModal: function(toolResultMessage) {
      const overlay = this.createModalOverlay('Tool Execution Details');
      const body = overlay.querySelector('.modal-body');
  
      const state = window.module['state.js'];
      const messages = state.getMessages();
      const currentIndex = messages.indexOf(toolResultMessage);
  
      // Find the previous assistant message (contains the tool execution request)
      let inputMessage = null;
      if (currentIndex !== -1) {
        for (let i = currentIndex - 1; i >= 0; i--) {
          if (messages[i].role === 'assistant') {
            inputMessage = messages[i];
            break;
          }
        }
      }
  
      // INPUT: Show the full API request body that generated this tool execution
      if (inputMessage && inputMessage.apiData && inputMessage.apiData.inputFull) {
        const inputSection = this.createModalSection(
          'Input',
          JSON.stringify(inputMessage.apiData.inputFull, null, 2)
        );
        body.appendChild(inputSection);
      } else {
        const noInputSection = this.createModalSection(
          'Input',
          'Could not find the associated API request'
        );
        body.appendChild(noInputSection);
      }
  
      // OUTPUT: Show the full API response that came back
      if (inputMessage && inputMessage.apiData && inputMessage.apiData.output) {
        const outputSection = this.createModalSection(
          'Output',
          JSON.stringify(inputMessage.apiData.output, null, 2)
        );
        body.appendChild(outputSection);
      } else {
        const noOutputSection = this.createModalSection(
          'Output',
          'Could not find the associated API response'
        );
        body.appendChild(noOutputSection);
      }
  
      document.body.appendChild(overlay);
    },
  
    createModalOverlay: function(title) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = title;
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      return overlay;
    },
  
    createModalSection: function(title, content) {
      const section = document.createElement('div');
      section.className = 'modal-section';
  
      const titleRow = document.createElement('div');
      titleRow.className = 'modal-section-title-row';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-section-title';
      titleEl.textContent = title;
  
      const copyBtn = document.createElement('button');
      copyBtn.className = 'modal-section-copy-btn';
      copyBtn.textContent = 'Copy';
      copyBtn.onclick = () => this.copySectionContent(content, copyBtn);
  
      titleRow.appendChild(titleEl);
      titleRow.appendChild(copyBtn);
  
      const contentEl = document.createElement('div');
      contentEl.className = 'modal-section-content';
      contentEl.textContent = content;
  
      section.appendChild(titleRow);
      section.appendChild(contentEl);
  
      return section;
    },
  
    copySectionContent: function(content, button) {
      navigator.clipboard.writeText(content).then(() => {
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.style.backgroundColor = 'var(--color-gold)';
        button.style.color = 'var(--color-bg-primary)';
  
        setTimeout(() => {
          button.textContent = originalText;
          button.style.backgroundColor = '';
          button.style.color = '';
        }, 2000);
      }).catch(err => {
        const diagnostics = window.module['diagnostics.js'];
        diagnostics.log('ui', 'Failed to copy: ' + err);
        button.textContent = 'Failed';
        setTimeout(() => {
          button.textContent = 'Copy';
        }, 2000);
      });
    },
  
    showAssistantMessageModal: function(message) {
      const apiData = message.apiData;
  
      const overlay = this.createModalOverlay('Assistant Message Details');
      const body = overlay.querySelector('.modal-body');
  
      if (!apiData) {
        // No API data available (e.g., initial greeting)
        const noDataSection = this.createModalSection(
          'No API Data',
          'No API interaction data available for this message'
        );
        body.appendChild(noDataSection);
      } else {
        // Input: Full API request body (stored at time of request)
        if (apiData.inputFull) {
          const inputSection = this.createModalSection(
            'Input',
            JSON.stringify(apiData.inputFull, null, 2)
          );
          body.appendChild(inputSection);
        }
  
        // Output: Full API response
        if (apiData.output) {
          const outputSection = this.createModalSection(
            'Output',
            JSON.stringify(apiData.output, null, 2)
          );
          body.appendChild(outputSection);
        }
      }
  
      document.body.appendChild(overlay);
    },
  
    // Show conversation management modal
    showConversationModal: function() {
      const state = window.module['state.js'];
      const overlay = this.createModalOverlay('Conversation');
      const body = overlay.querySelector('.modal-body');
  
      // Current stats
      const messages = state.getMessages();
      const currentChars = state.calculateChars();
      const messageCount = messages.length;
  
      const statsDiv = document.createElement('div');
      statsDiv.style.marginBottom = '20px';
      statsDiv.style.color = 'var(--color-text-primary)';
      statsDiv.style.fontSize = '14px';
      statsDiv.innerHTML = `
        <div style="margin-bottom: 8px;"><strong>Messages:</strong> ${messageCount}</div>
        <div><strong>Size:</strong> ${this.formatSize(currentChars)}</div>
      `;
  
      body.appendChild(statsDiv);
  
      // Clear button
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.justifyContent = 'flex-end';
      buttonContainer.style.marginTop = '20px';
  
      const clearBtn = document.createElement('button');
      clearBtn.textContent = 'Clear Conversation';
      clearBtn.style.padding = '8px 16px';
      clearBtn.style.background = '#ff6b6b';
      clearBtn.style.border = 'none';
      clearBtn.style.color = 'white';
      clearBtn.style.cursor = 'pointer';
      clearBtn.style.borderRadius = '4px';
      clearBtn.style.fontSize = '14px';
      clearBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      clearBtn.style.fontWeight = 'bold';
      clearBtn.onclick = () => {
        if (confirm('Are you sure you want to clear all messages?')) {
          state.clearMessages();
          this.renderMessages(state.getMessages());
          this.updateContextStats();
          overlay.remove();
        }
      };
  
      buttonContainer.appendChild(clearBtn);
      body.appendChild(buttonContainer);
  
      document.body.appendChild(overlay);
    },
  
    // Calculate messages size in characters
    calculateMessagesSize: function() {
      const state = window.module['state.js'];
      return state.calculateChars();
    },
  
    // Format size in K (1K = 1000 chars)
    formatSize: function(chars) {
      const k = Math.ceil(chars / 1000);
      return k + 'K';
    },
  
    // Format size with 1 decimal place (e.g., 7.3K)
    formatSizeDecimal: function(chars) {
      const k = chars / 1000;
      return k.toFixed(1) + 'K';
    },
  
    // Calculate character count for a message (excluding fromSystem and uiOnly)
    getMessageCharCount: function(msg) {
      if (msg.uiOnly || msg.fromSystem || !msg.content) {
        return 0;
      }
      return msg.content.length;
    },
  
    // Update context stats display
    updateContextStats: function() {
      const messagesBtn = document.getElementById('messages-stat-btn');
  
      if (!messagesBtn) {
        return;
      }
  
      const state = window.module['state.js'];
  
      // If there are selected messages, show selected count instead of total
      if (state.hasSelection()) {
        const selectedMessages = state.getSelectedMessages();
        const selectedChars = state.calculateChars(selectedMessages);
        messagesBtn.textContent = `Selected: ${this.formatSize(selectedChars)}`;
      } else {
        const chars = this.calculateMessagesSize();
        messagesBtn.textContent = this.formatSize(chars);
      }
    },
  
    // Show clear confirmation modal
    showClearModal: function(contextType) {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = 'Clear Messages';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      const message = document.createElement('div');
      message.style.marginBottom = '20px';
      message.style.color = 'var(--color-text-primary)';
      message.textContent = 'Are you sure you want to clear all messages? This will reset the conversation history (except the initial greeting).';
  
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.justifyContent = 'flex-end';
  
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.style.background = 'var(--color-bg-primary)';
      cancelBtn.style.border = '1px solid var(--color-border)';
      cancelBtn.style.color = 'var(--color-text-primary)';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      cancelBtn.onclick = () => overlay.remove();
  
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'Clear';
      confirmBtn.style.padding = '8px 16px';
      confirmBtn.style.background = 'var(--color-gold)';
      confirmBtn.style.border = 'none';
      confirmBtn.style.color = 'var(--color-bg-primary)';
      confirmBtn.style.cursor = 'pointer';
      confirmBtn.style.borderRadius = '4px';
      confirmBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      confirmBtn.style.fontWeight = 'bold';
      confirmBtn.onclick = () => {
        this.clearContext(contextType);
        overlay.remove();
      };
  
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(confirmBtn);
  
      body.appendChild(message);
      body.appendChild(buttonContainer);
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    },
  
    // Clear context
    clearContext: function(contextType) {
      const state = window.module['state.js'];
      state.clearMessages();
  
      // Update UI
      this.renderMessages(state.getMessages());
      this.updateContextStats();
    },
  
    // Show context management modal (new)
    showContextModal: function() {
      const state = window.module['state.js'];
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
  
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-container';
  
      // Header
      const header = document.createElement('div');
      header.className = 'modal-header';
  
      const titleEl = document.createElement('div');
      titleEl.className = 'modal-title';
      titleEl.textContent = 'Context Management';
  
      const closeBtn = document.createElement('button');
      closeBtn.className = 'modal-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = () => overlay.remove();
  
      header.appendChild(titleEl);
      header.appendChild(closeBtn);
  
      // Body
      const body = document.createElement('div');
      body.className = 'modal-body';
  
      // Current stats
      const statsDiv = document.createElement('div');
      statsDiv.style.marginBottom = '20px';
      statsDiv.style.color = 'var(--color-text-primary)';
      const currentChars = state.calculateChars();
      const currentLimit = state.getContextLimit();
      statsDiv.innerHTML = `Current: <strong>${this.formatSize(currentChars)}</strong> / ${this.formatSize(currentLimit)}`;
  
      // Context limit input
      const limitLabel = document.createElement('div');
      limitLabel.style.marginBottom = '8px';
      limitLabel.style.color = 'var(--color-text-primary)';
      limitLabel.textContent = 'Context limit (chars):';
  
      const limitInput = document.createElement('input');
      limitInput.type = 'number';
      limitInput.value = currentLimit;
      limitInput.min = '1000';
      limitInput.step = '1000';
      limitInput.style.width = '100%';
      limitInput.style.padding = '8px';
      limitInput.style.marginBottom = '20px';
      limitInput.style.background = 'var(--color-bg-primary)';
      limitInput.style.border = '1px solid var(--color-border)';
      limitInput.style.color = 'var(--color-text-primary)';
      limitInput.style.borderRadius = '4px';
      limitInput.style.fontSize = '14px';
      limitInput.style.fontFamily = "'Consolas', 'Courier New', monospace";
  
      // Tool output limit input
      const core = window.module['core.js'];
      const currentToolLimit = core.toolCharLimits.default;
  
      const toolLimitLabel = document.createElement('div');
      toolLimitLabel.style.marginBottom = '8px';
      toolLimitLabel.style.color = 'var(--color-text-primary)';
      toolLimitLabel.textContent = 'Tool output limit (chars):';
  
      const toolLimitInput = document.createElement('input');
      toolLimitInput.type = 'number';
      toolLimitInput.value = currentToolLimit;
      toolLimitInput.min = '500';
      toolLimitInput.step = '100';
      toolLimitInput.style.width = '100%';
      toolLimitInput.style.padding = '8px';
      toolLimitInput.style.marginBottom = '20px';
      toolLimitInput.style.background = 'var(--color-bg-primary)';
      toolLimitInput.style.border = '1px solid var(--color-border)';
      toolLimitInput.style.color = 'var(--color-text-primary)';
      toolLimitInput.style.borderRadius = '4px';
      toolLimitInput.style.fontSize = '14px';
      toolLimitInput.style.fontFamily = "'Consolas', 'Courier New', monospace";
  
      // Buttons
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.justifyContent = 'flex-end';
      buttonContainer.style.marginTop = '20px';
  
      const clearBtn = document.createElement('button');
      clearBtn.textContent = 'Clear All';
      clearBtn.style.padding = '8px 16px';
      clearBtn.style.background = 'var(--color-bg-primary)';
      clearBtn.style.border = '1px solid #ff6b6b';
      clearBtn.style.color = '#ff6b6b';
      clearBtn.style.cursor = 'pointer';
      clearBtn.style.borderRadius = '4px';
      clearBtn.style.fontSize = '14px';
      clearBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      clearBtn.style.marginRight = 'auto';
      clearBtn.onclick = () => {
        if (confirm('Are you sure you want to clear all messages?')) {
          state.clearMessages();
          this.renderMessages(state.getMessages());
          this.updateContextStats();
          overlay.remove();
        }
      };
  
      const compactBtn = document.createElement('button');
      compactBtn.textContent = 'Compact Now';
      compactBtn.style.padding = '8px 16px';
      compactBtn.style.background = 'var(--color-bg-primary)';
      compactBtn.style.border = '1px solid var(--color-gold)';
      compactBtn.style.color = 'var(--color-gold)';
      compactBtn.style.cursor = 'pointer';
      compactBtn.style.borderRadius = '4px';
      compactBtn.style.fontSize = '14px';
      compactBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      compactBtn.onclick = async () => {
        compactBtn.disabled = true;
        compactBtn.textContent = 'Compacting...';
        try {
          const main = window.module['main.js'];
          await main.compactContext();
          this.renderMessages(state.getMessages());
          this.updateContextStats();
          // Update stats display in modal
          statsDiv.innerHTML = `Current: <strong>${this.formatSize(state.calculateChars())}</strong> / ${this.formatSize(state.getContextLimit())}`;
          compactBtn.textContent = 'Compacted!';
          setTimeout(() => {
            compactBtn.textContent = 'Compact Now';
            compactBtn.disabled = false;
          }, 2000);
        } catch (error) {
          compactBtn.textContent = 'Error';
          setTimeout(() => {
            compactBtn.textContent = 'Compact Now';
            compactBtn.disabled = false;
          }, 2000);
        }
      };
  
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.style.background = 'var(--color-bg-primary)';
      cancelBtn.style.border = '1px solid var(--color-border)';
      cancelBtn.style.color = 'var(--color-text-primary)';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      cancelBtn.onclick = () => overlay.remove();
  
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'Save Limits';
      saveBtn.style.padding = '8px 16px';
      saveBtn.style.background = 'var(--color-gold)';
      saveBtn.style.border = 'none';
      saveBtn.style.color = 'var(--color-bg-primary)';
      saveBtn.style.cursor = 'pointer';
      saveBtn.style.borderRadius = '4px';
      saveBtn.style.fontSize = '14px';
      saveBtn.style.fontFamily = "'Consolas', 'Courier New', monospace";
      saveBtn.style.fontWeight = 'bold';
      saveBtn.onclick = async () => {
        const newLimit = parseInt(limitInput.value);
        const newToolLimit = parseInt(toolLimitInput.value);
  
        // Validate inputs
        if (!newLimit || newLimit < 1000) {
          alert('Please enter a valid context limit (minimum 1000 chars)');
          return;
        }
        if (!newToolLimit || newToolLimit < 500) {
          alert('Please enter a valid tool limit (minimum 500 chars)');
          return;
        }
  
        // Save context limit
        state.setContextLimit(newLimit);
  
        // Save tool limit (apply to all tools)
        core.toolCharLimits.read_file = newToolLimit;
        core.toolCharLimits.list_directory = newToolLimit;
        core.toolCharLimits.search_by_content = newToolLimit;
        core.toolCharLimits.search_by_filename = newToolLimit;
        core.toolCharLimits.default = newToolLimit;
  
        // If new limit is lower than current usage, trigger compaction
        if (currentChars > newLimit) {
          const main = window.module['main.js'];
          await main.compactContext();
          this.renderMessages(state.getMessages());
        }
  
        this.updateContextStats();
        overlay.remove();
      };
  
      buttonContainer.appendChild(clearBtn);
      buttonContainer.appendChild(compactBtn);
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(saveBtn);
  
      body.appendChild(statsDiv);
      body.appendChild(limitLabel);
      body.appendChild(limitInput);
      body.appendChild(toolLimitLabel);
      body.appendChild(toolLimitInput);
      body.appendChild(buttonContainer);
  
      modalContainer.appendChild(header);
      modalContainer.appendChild(body);
      overlay.appendChild(modalContainer);
  
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
  
      // Close on ESC key
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          overlay.remove();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      document.body.appendChild(overlay);
    },
  
    // Add edit/delete buttons to a message element
    // For tool pairs, pass both messageId (tool-use) and pairedMessageId (tool-result)
    addMessageActions: function(messageElement, messageId, pairedMessageId = null, toolName = null) {
      const state = window.module['state.js'];
  
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'message-actions';
  
      // Add extract button for read_file tools
      if (toolName === 'read_file' && pairedMessageId) {
        const extractBtn = document.createElement('button');
        extractBtn.className = 'message-action-btn';
        extractBtn.textContent = 'Extract';
        extractBtn.onclick = async (e) => {
          e.stopPropagation();
          if (state.isProcessing()) {
            return;
          }
          await this.extractRelevantCode(messageId, pairedMessageId);
        };
        actionsDiv.appendChild(extractBtn);
      }
  
      const editBtn = document.createElement('button');
      editBtn.className = 'message-action-btn';
      editBtn.textContent = 'Edit';
      editBtn.onclick = (e) => {
        e.stopPropagation();
        // Don't allow editing while processing
        if (state.isProcessing()) {
          return;
        }
        this.enterEditMode(messageElement, messageId, pairedMessageId);
      };
  
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'message-action-btn';
      deleteBtn.textContent = 'Delete';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        // Don't allow deleting while processing
        if (state.isProcessing()) {
          return;
        }
        this.deleteMessage(messageId, pairedMessageId);
      };
  
      actionsDiv.appendChild(editBtn);
      actionsDiv.appendChild(deleteBtn);
      messageElement.appendChild(actionsDiv);
    },
  
    // Enter edit mode for a message
    // For tool pairs, pass both messageId (tool-use) and pairedMessageId (tool-result)
    enterEditMode: function(messageElement, messageId, pairedMessageId = null) {
      const state = window.module['state.js'];
      const message = state.getMessages().find(m => m.id === messageId);
      if (!message) return;
  
      // For tool pairs, make both divs editable
      if (pairedMessageId) {
        const pairedMessage = state.getMessages().find(m => m.id === pairedMessageId);
        if (!pairedMessage) return;
  
        const toolUseDiv = messageElement.querySelector('.tool-use-inline');
        const toolResultDiv = messageElement.querySelector('.tool-result-inline');
  
        if (!toolUseDiv || !toolResultDiv) return;
  
        // Make tool-use editable (just the params span)
        const paramsSpan = toolUseDiv.querySelector('.tool-params');
        if (paramsSpan) {
          paramsSpan.contentEditable = true;
          paramsSpan.classList.add('editing');
          paramsSpan.focus();
  
          // Select all text
          const range = document.createRange();
          range.selectNodeContents(paramsSpan);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
  
        // Make tool-result editable
        toolResultDiv.contentEditable = true;
        toolResultDiv.classList.add('editing');
  
        // Create save/cancel buttons
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'edit-actions';
  
        const saveBtn = document.createElement('button');
        saveBtn.className = 'edit-action-btn edit-save-btn';
        saveBtn.textContent = 'Save';
        saveBtn.onclick = () => {
          if (paramsSpan) {
            const newParamsText = paramsSpan.textContent.trim();
            try {
              const newParams = JSON.parse(newParamsText);
              // Update tool-use message
              state.editMessage(messageId, `${message.toolName} ${JSON.stringify(newParams)}`);
              // Also update params property
              const msg = state.getMessages().find(m => m.id === messageId);
              if (msg) msg.params = newParams;
            } catch (e) {
              alert('Invalid JSON in parameters');
              return;
            }
          }
  
          const newSummary = toolResultDiv.textContent.trim();
          if (!newSummary) {
            alert('Result summary cannot be empty');
            return;
          }
          // For tool-result messages, only update the summary property (not content)
          // Content is what gets sent to API and should remain the full result
          const pairedMsg = state.getMessages().find(m => m.id === pairedMessageId);
          if (pairedMsg) pairedMsg.summary = newSummary;
  
          this.renderMessages(state.getMessages());
          this.updateContextStats();
        };
  
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'edit-action-btn edit-cancel-btn';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.onclick = () => {
          this.renderMessages(state.getMessages());
        };
  
        actionsDiv.appendChild(saveBtn);
        actionsDiv.appendChild(cancelBtn);
        messageElement.appendChild(actionsDiv);
  
        // ESC to cancel
        const escHandler = (e) => {
          if (e.key === 'Escape') {
            this.renderMessages(state.getMessages());
            document.removeEventListener('keydown', escHandler);
          }
        };
        document.addEventListener('keydown', escHandler);
  
        return;
      }
  
      // Regular single message editing
      const contentDiv = messageElement.querySelector('.message-content');
      if (!contentDiv) return;
  
      const originalContent = message.content;
  
      // Make contenteditable
      contentDiv.contentEditable = true;
      contentDiv.classList.add('editing');
      contentDiv.focus();
  
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(contentDiv);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
  
      // Create save/cancel buttons
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'edit-actions';
  
      const saveBtn = document.createElement('button');
      saveBtn.className = 'edit-action-btn edit-save-btn';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => {
        const newContent = contentDiv.textContent.trim();
        if (!newContent) {
          alert('Message content cannot be empty');
          return;
        }
        state.editMessage(messageId, newContent);
        this.renderMessages(state.getMessages());
        this.updateContextStats();
      };
  
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'edit-action-btn edit-cancel-btn';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => {
        this.renderMessages(state.getMessages());
      };
  
      actionsDiv.appendChild(saveBtn);
      actionsDiv.appendChild(cancelBtn);
      messageElement.appendChild(actionsDiv);
  
      // ESC to cancel
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          this.renderMessages(state.getMessages());
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
  
      // Update char count in real-time
      contentDiv.addEventListener('input', () => {
        const tempMessages = [...state.getMessages()];
        const msgIndex = tempMessages.findIndex(m => m.id === messageId);
        if (msgIndex >= 0) {
          tempMessages[msgIndex].content = contentDiv.textContent;
          const newCharCount = state.calculateChars(tempMessages);
          this.updateContextStats(newCharCount);
        }
      });
    },
  
    // Delete a message with confirmation
    // For tool pairs, pass both messageId (tool-use) and pairedMessageId (tool-result)
    deleteMessage: function(messageId, pairedMessageId = null) {
      const state = window.module['state.js'];
      const messages = state.getMessages();
      const message = messages.find(m => m.id === messageId);
  
      if (!message) return;
  
      if (confirm('Delete this message?')) {
        // If this is a tool pair, delete both
        if (pairedMessageId) {
          state.deleteMessage(messageId);
          state.deleteMessage(pairedMessageId);
        } else {
          // Delete single message
          state.deleteMessage(messageId);
        }
  
        this.renderMessages(state.getMessages());
        this.updateContextStats();
      }
    },
  
    // Extract relevant code from a read_file tool result
    extractRelevantCode: async function(toolUseId, toolResultId) {
      const state = window.module['state.js'];
      const api = window.module['api.js'];
      const messages = state.getMessages();
  
      const toolUseMsg = messages.find(m => m.id === toolUseId);
      const toolResultMsg = messages.find(m => m.id === toolResultId);
  
      if (!toolUseMsg || !toolResultMsg) return;
  
      // Get original content size
      const originalSize = toolResultMsg.content.length;
  
      // Build messages up to and including this tool pair
      const indexOfToolUse = messages.indexOf(toolUseMsg);
      const conversationContext = messages.slice(0, indexOfToolUse + 2); // Include tool-use and tool-result
  
      // Add extraction request
      const extractionPrompt = {
        type: 'user_msg',
        content: 'From the file you just read, extract ONLY the specific code sections, functions, or lines that are directly relevant to this conversation. Return the extracted code with minimal context. Format as:\n\n[Brief description of what was extracted]\n\n```\n[extracted code]\n```\n\nBe very selective - only include what is actually needed.',
        uiOnly: true  // Don't save this to conversation
      };
  
      conversationContext.push(extractionPrompt);
  
      // Show loading state
      this.showLoading('Extracting relevant code');
      state.setProcessing(true);
  
      try {
        // Call API with the context
        const response = await api.callAPISimple(conversationContext);
  
        this.hideLoading();
        state.setProcessing(false);
  
        if (!response.valid) {
          alert('Failed to extract code: ' + response.error);
          return;
        }
  
        const extractedContent = response.text;
        const extractedSize = extractedContent.length;
  
        // Check if extraction is actually smaller
        if (extractedSize >= originalSize) {
          alert(`Extraction did not reduce size.\nOriginal: ${this.formatSizeDecimal(originalSize)}, Extracted: ${this.formatSizeDecimal(extractedSize)}\n\nKeeping original content.`);
          return;
        }
  
        // Update the tool result with extracted content
        toolResultMsg.content = `[EXTRACTED - Relevant sections only. Original file was ${this.formatSizeDecimal(originalSize)}]\n\n${extractedContent}`;
        toolResultMsg.summary = `Extracted relevant code (${this.formatSizeDecimal(extractedSize)} from ${this.formatSizeDecimal(originalSize)})`;
        toolResultMsg.wasExtracted = true;
  
        // Re-render
        this.renderMessages(state.getMessages());
        this.updateContextStats();
  
      } catch (error) {
        this.hideLoading();
        state.setProcessing(false);
        alert('Error during extraction: ' + error.message);
      }
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
