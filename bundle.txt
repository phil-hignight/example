FILE: com/codeboss/bridgelayer/BridgeTestRunner.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.bridgelayer;

import com.codeboss.javalayer.system.*;

import java.io.*;
import java.nio.file.*;
import java.util.*;

public class BridgeTestRunner {

    private static ConfigManager configManager;
    private static ClipboardManager clipboardManager;
    private static SystemTrayManager systemTrayManager;
    private static Logger logger;
    private static String workingDirectory;
    private static int passCount = 0;
    private static int failCount = 0;

    // Error code mapping:
    // 1: Clipboard mismatch
    // 2: Clipboard exception
    // 3: Not in automatic mode
    // 4: Invalid click coordinates
    // 5: Auto-click setup exception
    // 6: Round-trip null response
    // 7: Round-trip mouse cancelled
    // 8: Round-trip token limit
    // 9: Round-trip empty
    // 10: Round-trip exception
    // 11: Continuation null response
    // 12: Continuation mouse cancelled
    // 13: Continuation token limit
    // 14: Continuation exception
    // 15: Empty test null response
    // 16: Empty test mouse cancelled
    // 17: Empty test got response instead of TOKEN_LIMIT_EXCEEDED
    // 18: Empty test exception
    // 19: Size limit failed even at 1000 chars
    // 20: Size limit exception
    // 21: Mouse cancel expected MOUSE_CANCELLED
    // 22: Mouse cancel exception
    // 23: Response format unexpected
    // 24: Special chars null response
    // 25: Special chars mouse cancelled
    // 26: Special chars token limit
    // 27: Special chars response missing expected content
    // 28: Special chars exception
    // 29: Large response null
    // 30: Large response mouse cancelled
    // 31: Large response token limit
    // 32: Large response too small
    // 33: Large response exception
    // 34: Rapid requests null response
    // 35: Rapid requests mouse cancelled
    // 36: Rapid requests token limit
    // 37: Rapid requests exception
    // 38: Continuation END marker not found
    // 39: Continuation END marker exception

    public static void main(String[] args) {
        try {
            workingDirectory = args.length > 0 ? args[0] : System.getProperty("user.dir");

            System.out.println("=== Bridge Test Suite ===");
            System.out.println("Working directory: " + workingDirectory);
            System.out.println();

            // Initialize
            String logFile = workingDirectory + "/.agent/debug.log";
            logger = new Logger(logFile);
            configManager = new ConfigManager(workingDirectory, logger);
            clipboardManager = new ClipboardManager();
            systemTrayManager = new SystemTrayManager(logger);
            systemTrayManager.setupSystemTray();

            // Copy bridge JS to clipboard and prompt user
            copyBridgeScriptToClipboard();
            promptUserToSetupBridge();

            // Run all tests
            testClipboardAccess();
            testAutoClickSetup();
            testSimpleMessageRoundTrip();
            testSpecialCharacters();
            testLargeResponse();
            testRapidRequests();
            testContinuationEndMarker();
            testEmptyResponseHandling();
            testMouseCancellation();

            // Summary
            System.out.println();
            System.out.println("=== Test Summary ===");
            System.out.println("PASS: " + passCount);
            System.out.println("FAIL: " + failCount);

            if (failCount == 0) {
                System.out.println("All tests passed!");
                systemTrayManager.updateTrayStatus("Tests: All Passed");
            } else {
                System.out.println("Some tests failed.");
                systemTrayManager.updateTrayStatus("Tests: " + failCount + " Failed");
            }

        } catch (Exception e) {
            System.out.println("FATAL: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void pass(String test) {
        System.out.println("[PASS] " + test);
        passCount++;
    }

    private static void fail(String test, int errorCode, String data) {
        System.out.println("[FAIL] " + test + " - " + errorCode + " " + data);
        failCount++;
    }

    private static void fail(String test, int errorCode) {
        System.out.println("[FAIL] " + test + " - " + errorCode);
        failCount++;
    }

    // Test 1: Clipboard Access
    private static void testClipboardAccess() {
        try {
            String testData = "TEST_" + System.currentTimeMillis();
            clipboardManager.copyToClipboard(testData);
            String retrieved = clipboardManager.getClipboardContent();

            if (testData.equals(retrieved)) {
                pass("Clipboard access");
            } else {
                fail("Clipboard access", 1, "`" + retrieved + "` `" + testData + "`");
            }
        } catch (Exception e) {
            fail("Clipboard access", 2, e.getMessage());
        }
    }

    // Test 2: Auto-click Setup
    private static void testAutoClickSetup() {
        try {
            if (!true) {
                fail("Auto-click setup", 3);
                return;
            }

            int x = configManager.getClickX();
            int y = configManager.getClickY();

            if (x >= -10000 && y >= -10000 && x <= 10000 && y <= 10000) {
                pass("Auto-click setup (" + x + "," + y + ")");
            } else {
                fail("Auto-click setup", 4, x + " " + y);
            }
        } catch (Exception e) {
            fail("Auto-click setup", 5, e.getMessage());
        }
    }

    // Test 3: Simple Message Round-trip
    private static void testSimpleMessageRoundTrip() {
        try {
            if (!true) {
                System.out.println("[SKIP] Round-trip - not auto mode");
                return;
            }

            systemTrayManager.updateTrayStatus("Test: Round-trip");

            String testMessage = buildTestMessage("Test message");
            clipboardManager.copyToClipboard(testMessage);

            String response = clipboardManager.waitForAutomaticResponse(
                configManager.getClickX(),
                configManager.getClickY()
            );

            // Validate format
            String formatIssue = validateResponseFormat(response);
            if (formatIssue != null) {
                fail("Round-trip", 23, formatIssue);
                return;
            }

            if (response == null) {
                fail("Round-trip", 6);
            } else if (response.equals("MOUSE_CANCELLED")) {
                fail("Round-trip", 7);
            } else if (response.equals("TOKEN_LIMIT_EXCEEDED")) {
                fail("Round-trip", 8);
            } else if (response.trim().length() > 0) {
                pass("Round-trip (" + response.length() + "ch)");
            } else {
                fail("Round-trip", 9);
            }
        } catch (Exception e) {
            fail("Round-trip", 10, e.getMessage());
        }
    }

    // Test 4: Continuation Handling
    private static void testContinuationHandling() {
        try {
            if (!true) {
                System.out.println("[SKIP] Continuation - not auto mode");
                return;
            }

            // Wait for clipboard to settle from previous test
            Thread.sleep(500);

            systemTrayManager.updateTrayStatus("Test: Continuation");

            String testMessage = buildTestMessage(
                "Write 500-word essay on Java. End with |||||END|||||"
            );
            clipboardManager.copyToClipboard(testMessage);

            String response = clipboardManager.waitForAutomaticResponse(
                configManager.getClickX(),
                configManager.getClickY()
            );

            String formatIssue = validateResponseFormat(response);
            if (formatIssue != null) {
                fail("Continuation", 23, formatIssue);
                return;
            }

            if (response == null) {
                fail("Continuation", 11);
            } else if (response.equals("MOUSE_CANCELLED")) {
                fail("Continuation", 12);
            } else if (response.equals("TOKEN_LIMIT_EXCEEDED")) {
                fail("Continuation", 13);
            } else {
                pass("Continuation (" + response.length() + "ch)");
            }
        } catch (Exception e) {
            fail("Continuation", 14, e.getMessage());
        }
    }

    // Test 5: Token Limit Discovery
    private static void testEmptyResponseHandling() {
        try {
            if (!true) {
                System.out.println("[SKIP] Token limit - not auto mode");
                return;
            }

            // Wait for clipboard to settle from previous test
            Thread.sleep(500);

            systemTrayManager.updateTrayStatus("Test: Token limit");

            // Test increasing sizes to find the actual token limit
            // Starting at 100K to verify no truncation, then go higher
            int[] sizes = {100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 1500000, 2000000};
            int maxWorking = 0;

            for (int size : sizes) {
                System.out.println("  Testing " + size + " chars...");

                // Build message with unique marker at the END to verify full input processing
                String uniqueMarker = "ENDMARKER_" + System.currentTimeMillis();
                StringBuilder large = new StringBuilder("Reply with the end marker if you can see it. ");
                for (int i = 0; i < size; i++) {
                    large.append("x");
                }
                large.append(" ").append(uniqueMarker);

                String testMessage = buildTestMessage(large.toString());
                clipboardManager.copyToClipboard(testMessage);

                String response = clipboardManager.waitForAutomaticResponse(
                    configManager.getClickX(),
                    configManager.getClickY()
                );

                if (response == null) {
                    fail("Token limit", 15);
                    return;
                } else if (response.equals("MOUSE_CANCELLED")) {
                    fail("Token limit", 16);
                    return;
                } else if (response.equals("TOKEN_LIMIT_EXCEEDED")) {
                    // Found the limit!
                    pass("Token limit found at ~" + size + " chars");
                    return;
                } else if (response.trim().length() > 0) {
                    // Check if response mentions the end marker to verify full input was processed
                    boolean sawEndMarker = response.contains(uniqueMarker) || response.contains("ENDMARKER");
                    maxWorking = size;
                    System.out.println("    ✓ " + size + " chars OK (response: " + response.length() + " chars, saw_end_marker: " + sawEndMarker + ")");
                    if (!sawEndMarker) {
                        System.out.println("    WARNING: Response doesn't mention end marker - input may be truncated!");
                    }
                } else {
                    fail("Token limit", 17, "`empty_at_" + size + "`");
                    return;
                }
            }

            // If we got here, even 2M worked
            pass("Token limit >2M chars (tested up to " + maxWorking + ")");

        } catch (Exception e) {
            fail("Token limit", 18, e.getMessage());
        }
    }

    // Test 6: Special Characters
    private static void testSpecialCharacters() {
        try {
            if (!true) {
                System.out.println("[SKIP] Special chars - not auto mode");
                return;
            }

            Thread.sleep(500);
            systemTrayManager.updateTrayStatus("Test: Special chars");

            // Test message with various special characters, unicode, emojis
            String specialContent = "Reply PASS_SPECIAL. Test: \n\t\"quotes\" 'apostrophe' \\backslash\\ {braces} [brackets] (parens) <angles> & ampersand | pipe $ dollar % percent @ at # hash ! bang ? question * asterisk ~ tilde ` backtick 你好 مرحبا 😀🎉🚀 ñáéíóú Δφλ";

            String testMessage = buildTestMessage(specialContent);
            clipboardManager.copyToClipboard(testMessage);

            String response = clipboardManager.waitForAutomaticResponse(
                configManager.getClickX(),
                configManager.getClickY()
            );

            if (response == null) {
                fail("Special chars", 24);
            } else if (response.equals("MOUSE_CANCELLED")) {
                fail("Special chars", 25);
            } else if (response.equals("TOKEN_LIMIT_EXCEEDED")) {
                fail("Special chars", 26);
            } else if (response.contains("PASS_SPECIAL")) {
                pass("Special chars (" + response.length() + "ch)");
            } else {
                fail("Special chars", 27, "`" + response.substring(0, Math.min(50, response.length())) + "`");
            }
        } catch (Exception e) {
            fail("Special chars", 28, e.getMessage());
        }
    }

    // Test 7: Large Response (Multi-continuation)
    private static void testLargeResponse() {
        try {
            if (!true) {
                System.out.println("[SKIP] Large response - not auto mode");
                return;
            }

            Thread.sleep(500);
            systemTrayManager.updateTrayStatus("Test: Large response");

            // Request massive output - bridge should automatically get all continuations
            String testMessage = buildTestMessage("Generate a 50000 character response (about 10000 words). Start with RESPONSE_START, fill the middle with repeated text, end with RESPONSE_END, then finish with |||||END|||||");
            clipboardManager.copyToClipboard(testMessage);

            String response = clipboardManager.waitForAutomaticResponse(
                configManager.getClickX(),
                configManager.getClickY()
            );

            if (response == null) {
                fail("Large response", 29);
            } else if (response.equals("MOUSE_CANCELLED")) {
                fail("Large response", 30);
            } else if (response.equals("TOKEN_LIMIT_EXCEEDED")) {
                fail("Large response", 31);
            } else if (response.length() > 20000 && response.contains("RESPONSE_START") && response.contains("RESPONSE_END")) {
                pass("Large response (" + response.length() + "ch)");
            } else {
                String preview = response.length() > 60 ? response.substring(response.length() - 60) : response;
                fail("Large response", 32, "len=" + response.length() + " start=" + response.contains("RESPONSE_START") + " end=" + response.contains("RESPONSE_END") + " last60=\"" + preview + "\"");
            }
        } catch (Exception e) {
            fail("Large response", 33, e.getMessage());
        }
    }

    // Test 8: Rapid Requests
    private static void testRapidRequests() {
        try {
            if (!true) {
                System.out.println("[SKIP] Rapid requests - not auto mode");
                return;
            }

            Thread.sleep(500);
            systemTrayManager.updateTrayStatus("Test: Rapid requests");

            // Send 3 requests in quick succession
            for (int i = 1; i <= 3; i++) {
                String testMessage = buildTestMessage("Reply: Request " + i + " of 3");
                clipboardManager.copyToClipboard(testMessage);

                String response = clipboardManager.waitForAutomaticResponse(
                    configManager.getClickX(),
                    configManager.getClickY()
                );

                if (response == null) {
                    fail("Rapid requests", 34, "req_" + i);
                    return;
                } else if (response.equals("MOUSE_CANCELLED")) {
                    fail("Rapid requests", 35, "req_" + i);
                    return;
                } else if (response.equals("TOKEN_LIMIT_EXCEEDED")) {
                    fail("Rapid requests", 36, "req_" + i);
                    return;
                }

                System.out.println("    ✓ Request " + i + " OK");
                Thread.sleep(100); // Small delay between requests
            }

            pass("Rapid requests (3/3)");
        } catch (Exception e) {
            fail("Rapid requests", 37, e.getMessage());
        }
    }

    // Test 9: Continuation END Marker
    private static void testContinuationEndMarker() {
        try {
            if (!true) {
                System.out.println("[SKIP] Continuation END - not auto mode");
                return;
            }

            Thread.sleep(500);
            systemTrayManager.updateTrayStatus("Test: Continuation END");

            String testMessage = buildTestMessage(
                "Write a 500-word essay about Java. After the essay, you MUST write exactly these 13 characters to signal completion: five pipes, the word END in capital letters, then five more pipes. Do not put it in a code block. Write it as plain text immediately after your essay."
            );
            clipboardManager.copyToClipboard(testMessage);

            String response = clipboardManager.waitForAutomaticResponse(
                configManager.getClickX(),
                configManager.getClickY()
            );

            String formatIssue = validateResponseFormat(response);
            if (formatIssue != null) {
                fail("Continuation END", 23, formatIssue);
                return;
            }

            if (response != null && !response.equals("MOUSE_CANCELLED") && !response.equals("TOKEN_LIMIT_EXCEEDED")) {
                // Success! If we got a response, it means the bridge successfully processed the END marker
                // The bridge strips the marker before returning, so we shouldn't see it in the response
                if (!response.contains("|||||END|||||") && response.length() > 0) {
                    pass("Continuation END (" + response.length() + "ch, marker processed)");
                } else if (response.contains("|||||END|||||")) {
                    // This would be weird - marker shouldn't be in the response
                    fail("Continuation END", 38, "marker_not_stripped");
                } else {
                    fail("Continuation END", 38, "empty_response");
                }
            } else {
                fail("Continuation END", 38, "`" + response + "`");
            }
        } catch (Exception e) {
            fail("Continuation END", 39, e.getMessage());
        }
    }

    // Test 7: Mouse Cancellation
    private static void testMouseCancellation() {
        System.out.println("[MANUAL] Mouse cancel - Move >300px after ENTER");
        System.out.print("         Press ENTER: ");

        try {
            Scanner scanner = new Scanner(System.in);
            scanner.nextLine();

            String testMessage = buildTestMessage("Test");
            clipboardManager.copyToClipboard(testMessage);

            String response = clipboardManager.waitForAutomaticResponse(
                configManager.getClickX(),
                configManager.getClickY()
            );

            if (response != null && response.equals("MOUSE_CANCELLED")) {
                pass("Mouse cancel");
            } else {
                fail("Mouse cancel", 21, "`" + response + "`");
            }
        } catch (Exception e) {
            fail("Mouse cancel", 22, e.getMessage());
        }
    }

    // Validate response format
    private static String validateResponseFormat(String response) {
        if (response == null) {
            return null; // null is a valid case, handled separately
        }

        if (response.equals("MOUSE_CANCELLED") || response.equals("TOKEN_LIMIT_EXCEEDED")) {
            return null; // These are special valid responses
        }

        // Check for unexpected format issues
        if (response.contains("|||||CLIP:TO_BRIDGE|||||")) {
            return "contains_bridge_marker";
        }

        if (response.contains("|||||CLIP:TO_JAVA|||||")) {
            return "contains_java_marker";
        }

        if (response.startsWith("{\"messages\":")) {
            return "looks_like_request_json";
        }

        // All good
        return null;
    }

    // Build test message in bridge protocol format
    private static String buildTestMessage(String content) {
        String escaped = content
            .replace("\\", "\\\\")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("\t", "\\t");

        return "{\"messages\":[{\"role\":\"user\",\"content\":\"" + escaped + "\"}]}|||||CLIP:TO_BRIDGE|||||";
    }

    public static String getWorkingDirectory() {
        return workingDirectory;
    }

    public static String getLogFile() {
        return workingDirectory + "/.agent/debug.log";
    }

    private static void copyBridgeScriptToClipboard() {
        try {
            Path bridgeScriptPath = Paths.get(workingDirectory, "bridge-button.js");

            if (!Files.exists(bridgeScriptPath)) {
                System.out.println("WARNING: bridge-button.js not found at: " + bridgeScriptPath);
                return;
            }

            String bridgeScript = new String(Files.readAllBytes(bridgeScriptPath));
            clipboardManager.copyToClipboard(bridgeScript);

            System.out.println("✓ Bridge script copied to clipboard (" + bridgeScript.length() + " chars)");

        } catch (Exception e) {
            System.out.println("WARNING: Failed to copy bridge script: " + e.getMessage());
        }
    }

    private static void promptUserToSetupBridge() {
        System.out.println();
        System.out.println("=== Setup Instructions ===");
        System.out.println("1. Open your browser and navigate to Claude");
        System.out.println("2. Open browser console (F12 or Cmd+Option+J)");
        System.out.println("3. Paste the bridge script (already in clipboard)");
        System.out.println("4. Press Enter in console to run the script");
        System.out.println("5. You should see the green bridge button appear");
        System.out.println("6. Come back here and press ENTER to continue");
        System.out.println();
        System.out.print("Press ENTER when bridge is ready: ");

        try {
            Scanner scanner = new Scanner(System.in);
            scanner.nextLine();
            System.out.println("✓ Starting tests...");
            System.out.println();
        } catch (Exception e) {
            System.out.println("Error waiting for user input: " + e.getMessage());
        }
    }

}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/bridgelayer/ClipboardManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.bridgelayer;

import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.util.Scanner;

public class ClipboardManager implements com.codeboss.javalayer.bridge.IClipboardManager {
    private Scanner scanner = new Scanner(System.in);

    private void log(String message) {
        System.out.println("[ClipboardManager] " + message);
    }
    
    public void copyToClipboard(String text) {
        int maxRetries = 3;
        int retryDelay = 100; // Start with 100ms

        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                StringSelection selection = new StringSelection(text);
                clipboard.setContents(selection, null);
                // Success - no logging for normal operations
                return;
            } catch (Exception e) {
                log("Error copying to clipboard (attempt " + attempt + "): " + e.getMessage());

                if (attempt < maxRetries) {
                    try {
                        Thread.sleep(retryDelay);
                        retryDelay *= 2; // Exponential backoff
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                } else {
                    System.err.println("Error copying to clipboard after " + maxRetries + " attempts: " + e.getMessage());
                }
            }
        }
    }
    
    public String getClipboardContent() {
        try {
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            Transferable contents = clipboard.getContents(null);
            
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                return (String) contents.getTransferData(DataFlavor.stringFlavor);
            }
        } catch (Exception e) {
            log("Error reading from clipboard: " + e.getMessage());
        }
        return null;
    }
    
    public String getResponseFromClipboard(String originalPrompt) {
        while (true) {
            try {
                String input = scanner.nextLine().trim();
                
                if (input.equalsIgnoreCase("quit")) {
                    log("Quit requested from clipboard loop");
                    return "QUIT_REQUESTED";
                }
                
                if (input.equalsIgnoreCase("c")) {
                    this.copyToClipboard(originalPrompt);
                    log("Prompt re-copied to clipboard");
                    System.out.println("~{ Prompt re-copied to clipboard }~");
                    continue;
                }

                String clipboardContent = this.getClipboardContent();
                log("Clipboard read: " + (clipboardContent != null ? clipboardContent.length() : 0) + " characters");
                
                // CRITICAL: Log details about what was actually read from clipboard
                if (clipboardContent != null) {
                    if (clipboardContent.trim().isEmpty()) {
                        log("CRITICAL: Clipboard contains only whitespace: '" + clipboardContent + "'");
                    } else if (clipboardContent.length() < 10) {
                        log("WARNING: Very short clipboard content: '" + clipboardContent + "'");
                    } else {
                        log("Clipboard first 100 chars: " + clipboardContent.substring(0, Math.min(100, clipboardContent.length())));
                        log("Clipboard last 50 chars: " + clipboardContent.substring(Math.max(0, clipboardContent.length() - 50)));
                    }
                } else {
                    log("CRITICAL: Clipboard content is NULL");
                }
                
                if (clipboardContent == null || clipboardContent.trim().isEmpty()) {
                    System.out.println("Clipboard is empty. Please copy Claude's response and try again.");
                    System.out.print("Press Enter when response is copied (or 'c' to copy prompt again): ");
                    continue;
                }
                
                // Check if clipboard still contains the original prompt (user hasn't pasted response yet)
                if (clipboardContent.trim().equals(originalPrompt.trim())) {
                    System.out.println("Clipboard still contains the original prompt. Please copy Claude's response.");
                    System.out.print("Press Enter when response is copied (or 'c' to copy prompt again): ");
                    continue;
                }
                
                return clipboardContent;
                
            } catch (Exception e) {
                log("Error in clipboard interaction: " + e.getMessage());
                System.out.println("Error reading clipboard. Please try again.");
                System.out.print("Press Enter to retry: ");
            }
        }
    }
    
    public void clickAtCoordinates(int x, int y) {
        try {
            Robot robot = new Robot();
            robot.mouseMove(x, y);
            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
            // Log removed - too verbose during polling
        } catch (Exception e) {
            log("Error clicking at coordinates: " + e.getMessage());
        }
    }
    
    public void moveMouseTo(int x, int y) {
        try {
            Robot robot = new Robot();
            robot.mouseMove(x, y);
            log("Mouse moved to coordinates: " + x + ", " + y);
        } catch (Exception e) {
            log("Error moving mouse to coordinates: " + e.getMessage());
            throw new RuntimeException("Failed to move mouse: " + e.getMessage());
        }
    }
    
    public String waitForAutomaticResponse(int clickX, int clickY) {
        // Minimal logging - only errors
        int pollCount = 0;

        while (true) {
            try {
                pollCount++;
                // Move mouse to coordinates and click
                this.clickAtCoordinates(clickX, clickY);

                // Check clipboard for response with terminator
                String clipboardContent = this.getClipboardContent();
                if (clipboardContent != null && (clipboardContent.endsWith("|||||CLIP:TO_JAVA|||||") || clipboardContent.endsWith("|||||CLIP:TO_JAVA_END|||||"))) {
                    // Remove terminator and return response
                    String marker = clipboardContent.endsWith("|||||CLIP:TO_JAVA_END|||||") ? "|||||CLIP:TO_JAVA_END|||||" : "|||||CLIP:TO_JAVA|||||";
                    String response = clipboardContent.substring(0, clipboardContent.length() - marker.length());

                    // Reject empty or very short responses
                    if (response.trim().isEmpty() || response.length() < 10) {
                        log("Empty/short response, continuing to poll");
                        return null;
                    }

                    return response;
                }
                
                // Sleep for 1 second, but check mouse position during this time
                Thread.sleep(1000);
                
                // After waiting, check if mouse moved outside the allowed area
                Point currentMousePos = MouseInfo.getPointerInfo().getLocation();
                int deltaX = Math.abs(currentMousePos.x - clickX);
                int deltaY = Math.abs(currentMousePos.y - clickY);
                
                if (deltaX > 300 || deltaY > 300) {
                    log("Mouse moved outside 300px square from click position - canceling auto-clicking");
                    return "MOUSE_CANCELLED";
                }
                
            } catch (InterruptedException e) {
                log("Automatic polling interrupted: " + e.getMessage());
                Thread.currentThread().interrupt();
                return null;
            } catch (Exception e) {
                log("Error in automatic polling: " + e.getMessage());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    return null;
                }
            }
        }
    }
    
    public String handleAutoCancelRetry(String originalPrompt, int clickX, int clickY) {
        System.out.println("Auto-clicking cancelled (mouse moved too far)");
        System.out.println("Press 'r' to retry auto-clicking or 'a' to abort: ");
        
        while (true) {
            try {
                String input = scanner.nextLine().trim().toLowerCase();
                
                if (input.equals("r")) {
                    log("User chose to retry auto-clicking");
                    System.out.println("Retrying auto-clicking...");
                    return this.waitForAutomaticResponse(clickX, clickY);
                } else if (input.equals("a")) {
                    log("User chose to abort auto-clicking");
                    return null;
                } else {
                    System.out.println("Invalid input. Press 'r' to retry or 'a' to abort: ");
                }
            } catch (Exception e) {
                log("Error in cancel retry handler: " + e.getMessage());
                return null;
            }
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/IClipboardManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge;

/**
 * Interface for clipboard operations and bridge communication
 *
 * This interface abstracts clipboard operations to allow mock implementations
 * for testing without requiring actual system clipboard access.
 */
public interface IClipboardManager {
    /**
     * Copy text to system clipboard
     * @param text Text to copy
     */
    void copyToClipboard(String text);

    /**
     * Get current clipboard content
     * @return Clipboard text or null if empty
     */
    String getClipboardContent();

    /**
     * Click at specified coordinates (for bridge button)
     * @param x X coordinate
     * @param y Y coordinate
     */
    void clickAtCoordinates(int x, int y);

    /**
     * Wait for automatic response from bridge with polling
     *
     * This method will:
     * 1. Click at the specified coordinates
     * 2. Poll clipboard for response with |||||CLIP:TO_JAVA||||| or |||||CLIP:TO_JAVA_END||||| marker
     * 3. Return when response is found or timeout occurs
     *
     * @param clickX X coordinate to click
     * @param clickY Y coordinate to click
     * @return Response text (without marker), "MOUSE_CANCELLED", or null on timeout
     */
    String waitForAutomaticResponse(int clickX, int clickY);
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/IConfigManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge;

/**
 * Interface for configuration management
 *
 * This interface provides access to application configuration values,
 * allowing mock implementations for testing.
 */
public interface IConfigManager {
    /**
     * Get maximum message characters limit
     * @return Max message chars (e.g., 350000)
     */
    int getMaxMessageChars();

    /**
     * Get X coordinate for auto-click
     * @return X coordinate in pixels
     */
    int getClickX();

    /**
     * Get Y coordinate for auto-click
     * @return Y coordinate in pixels
     */
    int getClickY();

    /**
     * Get server port for HTTP server
     * @return Port number (e.g., 3000)
     */
    int getServerPort();

    /**
     * Get auto-launch browser setting
     * @return true if browser should launch on startup
     */
    boolean shouldAutoLaunchBrowser();

    /**
     * Set server port (for command-line override)
     * @param port Port number to set
     */
    void setServerPort(int port);
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/ILogger.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge;

/**
 * Interface for logging
 *
 * This interface provides a simple logging abstraction,
 * allowing mock implementations for testing that capture log messages.
 */
public interface ILogger {
    /**
     * Log a message
     *
     * @param message Message to log (will be timestamped and written to log file)
     */
    void log(String message);
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/system/ConfigManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.system;

import java.io.*;
import java.nio.file.*;

public class ConfigManager implements com.codeboss.javalayer.bridge.IConfigManager {
    private String workingDirectory;
    private Logger logger;

    private String getConfigFile() {
        return Paths.get(workingDirectory, ".agent", "config.json").toString();
    }

    private int maxMessageChars = 350000; // Default max message chars
    private int clickX = 500; // Default click X coordinate for automatic mode
    private int clickY = 300; // Default click Y coordinate for automatic mode
    private int serverPort = 3000; // Default server port
    private boolean autoLaunchBrowser = true; // Default auto-launch browser setting

    public ConfigManager(String workingDirectory, Logger logger) throws IOException {
        this.workingDirectory = workingDirectory;
        this.logger = logger;
        loadConfig();
    }

    private void loadConfig() throws IOException {
        Path configPath = Paths.get(getConfigFile());
        if (!Files.exists(configPath)) {
            // Ensure .agent directory exists
            Path agentDir = configPath.getParent();
            if (!Files.exists(agentDir)) {
                Files.createDirectories(agentDir);
            }
            
            // Create default config
            String defaultConfig = "{\n" +
                "  \"maxMessageChars\": 350000,\n" +
                "  \"clickX\": 500,\n" +
                "  \"clickY\": 300,\n" +
                "  \"server\": {\n" +
                "    \"port\": 3000,\n" +
                "    \"autoLaunchBrowser\": true\n" +
                "  }\n" +
                "}";
            Files.write(configPath, defaultConfig.getBytes());
            maxMessageChars = 350000;
            clickX = 500;
            clickY = 300;
            serverPort = 3000;
            autoLaunchBrowser = true;
            logger.log("Created default config file");
        } else {
            try {
                String configContent = new String(Files.readAllBytes(configPath));
                
                // Simple JSON parsing for maxMessageChars
                String maxCharsPattern = "\"maxMessageChars\"\\s*:\\s*(\\d+)";
                java.util.regex.Pattern p1 = java.util.regex.Pattern.compile(maxCharsPattern);
                java.util.regex.Matcher m1 = p1.matcher(configContent);
                if (m1.find()) {
                    maxMessageChars = Integer.parseInt(m1.group(1));
                } else {
                    maxMessageChars = 350000; // fallback
                }
                
                // Simple JSON parsing for clickX (support negative numbers)
                String clickXPattern = "\"clickX\"\\s*:\\s*(-?\\d+)";
                java.util.regex.Pattern p2 = java.util.regex.Pattern.compile(clickXPattern);
                java.util.regex.Matcher m2 = p2.matcher(configContent);
                if (m2.find()) {
                    clickX = Integer.parseInt(m2.group(1));
                } else {
                    clickX = 500; // fallback
                }

                // Simple JSON parsing for clickY (support negative numbers)
                String clickYPattern = "\"clickY\"\\s*:\\s*(-?\\d+)";
                java.util.regex.Pattern p3 = java.util.regex.Pattern.compile(clickYPattern);
                java.util.regex.Matcher m3 = p3.matcher(configContent);
                if (m3.find()) {
                    clickY = Integer.parseInt(m3.group(1));
                } else {
                    clickY = 300; // fallback
                }

                // Simple JSON parsing for server.port (nested)
                String portPattern = "\"port\"\\s*:\\s*(\\d+)";
                java.util.regex.Pattern p4 = java.util.regex.Pattern.compile(portPattern);
                java.util.regex.Matcher m4 = p4.matcher(configContent);
                if (m4.find()) {
                    serverPort = Integer.parseInt(m4.group(1));
                } else {
                    serverPort = 3000; // fallback
                }

                // Simple JSON parsing for server.autoLaunchBrowser (nested)
                String autoLaunchPattern = "\"autoLaunchBrowser\"\\s*:\\s*(true|false)";
                java.util.regex.Pattern p5 = java.util.regex.Pattern.compile(autoLaunchPattern);
                java.util.regex.Matcher m5 = p5.matcher(configContent);
                if (m5.find()) {
                    autoLaunchBrowser = Boolean.parseBoolean(m5.group(1));
                } else {
                    autoLaunchBrowser = true; // fallback
                }

                logger.log("Loaded config: maxMessageChars = " + maxMessageChars + ", clickX = " + clickX + ", clickY = " + clickY + ", serverPort = " + serverPort + ", autoLaunchBrowser = " + autoLaunchBrowser);
                
                // Validate configuration
                validateConfig(configContent);
                
            } catch (Exception e) {
                logger.log("Error loading config, using defaults: " + e.getMessage());
                maxMessageChars = 350000;
                clickX = 500;
                clickY = 300;
                serverPort = 3000;
                autoLaunchBrowser = true;
            }
        }
    }
    
    private void validateConfig(String configContent) throws IOException {
        // Validate coordinates are reasonable (allow negative for multi-monitor setups)
        if (clickX < -10000 || clickY < -10000 || clickX > 10000 || clickY > 10000) {
            String error = "Configuration Error: Click coordinates must be between -10000 and 10000. Found clickX=" + clickX + ", clickY=" + clickY;
            logger.log(error);
            System.err.println(error);
            throw new IOException("Invalid click coordinates");
        }

        logger.log("Configuration validated: clickX=" + clickX + ", clickY=" + clickY);
    }
    
    public int getMaxMessageChars() {
        return maxMessageChars;
    }
    
    public void setMaxMessageChars(int maxMessageChars) {
        this.maxMessageChars = maxMessageChars;
    }

    public int getClickX() {
        return clickX;
    }

    public int getClickY() {
        return clickY;
    }

    public int getServerPort() {
        return serverPort;
    }

    public void setServerPort(int serverPort) {
        this.serverPort = serverPort;
    }

    public boolean shouldAutoLaunchBrowser() {
        return autoLaunchBrowser;
    }

    public void setAutoLaunchBrowser(boolean autoLaunchBrowser) {
        this.autoLaunchBrowser = autoLaunchBrowser;
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/system/Logger.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.system;

import java.io.*;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Logger implements com.codeboss.javalayer.bridge.ILogger {
    private final String workingDirectory;

    public Logger(String workingDirectory) {
        this.workingDirectory = workingDirectory;
    }

    private String getLogFile() {
        return Paths.get(workingDirectory, ".agent", "debug.log").toString();
    }

    @Override
    public void log(String message) {
        try {
            String logFile = getLogFile();
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
            String logMessage = "[" + timestamp + "] " + message + "\n";

            Path logPath = Paths.get(logFile);
            Path agentDir = logPath.getParent();
            if (!Files.exists(agentDir)) {
                Files.createDirectories(agentDir);
            }

            Files.write(logPath, logMessage.getBytes(),
                       StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } catch (Exception e) {
            System.err.println("Failed to write to log: " + e.getMessage());
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/system/SystemTrayManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.system;

import com.codeboss.javalayer.bridge.ILogger;
import java.awt.*;
import java.awt.image.BufferedImage;

public class SystemTrayManager {
    private final ILogger logger;
    private TrayIcon trayIcon;

    public SystemTrayManager(ILogger logger) {
        this.logger = logger;
    }

    public void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            logger.log("System tray not supported on this platform");
            return;
        }

        try {
            SystemTray tray = SystemTray.getSystemTray();

            // Create a simple green icon (16x16)
            Image image = createTrayIcon();

            // Create popup menu
            PopupMenu popup = new PopupMenu();

            MenuItem statusItem = new MenuItem("Conversation CLI - Running");
            statusItem.setEnabled(false);
            popup.add(statusItem);

            popup.addSeparator();

            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> {
                logger.log("Exit requested from system tray");
                cleanup();
                System.exit(0);
            });
            popup.add(exitItem);

            // Create tray icon
            trayIcon = new TrayIcon(image, "Conversation CLI", popup);
            trayIcon.setImageAutoSize(true);
            trayIcon.setToolTip("Conversation CLI - Maintaining clipboard access");

            // Add to system tray
            tray.add(trayIcon);

            logger.log("System tray icon added successfully");

        } catch (Exception e) {
            logger.log("Failed to setup system tray: " + e.getMessage());
            System.err.println("Warning: Could not setup system tray: " + e.getMessage());
        }
    }
    
    private Image createTrayIcon() {
        BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();
        
        // Enable antialiasing
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        // Draw a green circle
        g2d.setColor(new Color(76, 175, 80)); // Material Design Green
        g2d.fillOval(2, 2, 12, 12);
        
        // Add a white "C" for CLI
        g2d.setColor(Color.WHITE);
        g2d.setFont(new Font("Arial", Font.BOLD, 10));
        FontMetrics fm = g2d.getFontMetrics();
        String text = "C";
        int x = (16 - fm.stringWidth(text)) / 2;
        int y = (16 - fm.getHeight()) / 2 + fm.getAscent();
        g2d.drawString(text, x, y);
        
        g2d.dispose();
        return image;
    }
    
    public void updateTrayStatus(String status) {
        if (trayIcon != null) {
            trayIcon.setToolTip("Conversation CLI - " + status);
        }
    }
    
    public void cleanup() {
        if (trayIcon != null) {
            SystemTray.getSystemTray().remove(trayIcon);
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: bridge-button.js
|~|~|~|~|~|~|~|~|~|~|~|
// Claude Bridge Script - Button Interface with Clipboard Protocol

/* DEV_MOCK_PLACEHOLDER */

(function() {
    'use strict';
    
    // Init
    
    // State management
    let currentState = 'listening'; // 'listening' or 'response'
    let isProcessing = false;
    let currentResponse = '';
    
    // Protocol constants
    const TO_BRIDGE_MARKER = '|||||CLIP:TO_BRIDGE|||||';
    const TO_JAVA_MARKER = '|||||CLIP:TO_JAVA|||||';
    
    // Remove any existing bridge UI
    const existingBridge = document.getElementById('claude-bridge-ui');
    if (existingBridge) {
        existingBridge.remove();
    }
    
    // Create main UI container
    const bridgeUI = document.createElement('div');
    bridgeUI.id = 'claude-bridge-ui';
    bridgeUI.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 999999;
        background: rgba(0, 0, 0, 0.9);
        border: 3px solid #4CAF50;
        border-radius: 20px;
        padding: 40px;
        text-align: center;
        font-family: Arial, sans-serif;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        user-select: none;
    `;
    
    // Create main button
    const mainButton = document.createElement('button');
    mainButton.id = 'bridge-main-button';
    mainButton.style.cssText = `
        width: 300px;
        height: 150px;
        background: linear-gradient(45deg, #4CAF50, #45a049);
        color: white;
        border: none;
        border-radius: 15px;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        margin-bottom: 20px;
    `;
    
    // Create status text
    const statusText = document.createElement('div');
    statusText.id = 'bridge-status';
    statusText.style.cssText = `
        color: #4CAF50;
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 15px;
    `;
    
    // Create info text
    const infoText = document.createElement('div');
    infoText.id = 'bridge-info';
    infoText.style.cssText = `
        color: #ccc;
        font-size: 14px;
        max-width: 400px;
        line-height: 1.4;
    `;
    
    // Create close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'X';
    closeButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 15px;
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
    `;
    
    closeButton.addEventListener('click', () => {
        bridgeUI.remove();
    });
    
    closeButton.addEventListener('mouseenter', () => {
        closeButton.style.background = 'rgba(255, 255, 255, 0.1)';
    });
    
    closeButton.addEventListener('mouseleave', () => {
        closeButton.style.background = 'none';
    });
    
    // Add hover effects to main button
    mainButton.addEventListener('mouseenter', () => {
        if (!isProcessing) {
            mainButton.style.transform = 'scale(1.05)';
            mainButton.style.boxShadow = '0 8px 25px rgba(76, 175, 80, 0.4)';
        }
    });
    
    mainButton.addEventListener('mouseleave', () => {
        if (!isProcessing) {
            mainButton.style.transform = 'scale(1)';
            mainButton.style.boxShadow = '0 5px 15px rgba(76, 175, 80, 0.3)';
        }
    });
    
    // Main button click handler
    mainButton.addEventListener('click', async () => {
        if (isProcessing) return;

        if (currentState === 'listening') {
            await handleListeningClick();
        } else if (currentState === 'response') {
            await handleResponseClick();
        }
    });
    
    // Handle click in listening mode
    async function handleListeningClick() {
        try {
            const clipboardText = await navigator.clipboard.readText();

            if (!clipboardText.endsWith(TO_BRIDGE_MARKER)) {
                updateUI('listening', 'No valid request found in clipboard');
                return;
            }

            const jsonText = clipboardText.slice(0, -TO_BRIDGE_MARKER.length);
            let request;
            try {
                request = JSON.parse(jsonText);
                if (!request.messages || !Array.isArray(request.messages)) {
                    throw new Error('Invalid request format');
                }
            } catch (e) {
                updateUI('listening', 'Invalid JSON in clipboard');
                return;
            }

            isProcessing = true;
            updateUI('processing', 'Processing request...');

            const token = getAuthToken();
            if (!token) {
                updateUI('listening', 'No auth token found');
                isProcessing = false;
                return;
            }

            const response = await submitToInternalAPIWithContinuation(request.messages, token);

            if (response === 'TOKEN_LIMIT_EXCEEDED') {
                currentResponse = response;
                currentState = 'response';
                isProcessing = false;
                updateUI('response', 'Token limit detected - click to copy');
            } else {
                currentResponse = response;
                currentState = 'response';
                isProcessing = false;
                updateUI('response', 'Response ready - click to copy');
            }

        } catch (error) {
            updateUI('listening', `Error: ${error.message}`);
            isProcessing = false;
        }
    }
    
    // Handle click in response mode
    async function handleResponseClick() {
        try {
            const responseWithMarker = currentResponse + TO_JAVA_MARKER;
            await navigator.clipboard.writeText(responseWithMarker);
            currentState = 'listening';
            currentResponse = '';
            updateUI('listening', 'Response copied - ready for next request');
        } catch (error) {
            updateUI('response', `Copy failed: ${error.message}`);
        }
    }
    
    // Get auth token from localStorage
    function getAuthToken() {
        return localStorage.getItem('token');
    }
    
    // Submit to internal API with automatic continuation handling
    async function submitToInternalAPIWithContinuation(messages, token) {
        let fullResponse = '';
        let conversationMessages = [...messages];
        let attemptCount = 0;
        const maxAttempts = 10;

        while (attemptCount < maxAttempts) {
            attemptCount++;
            const response = await submitToInternalAPI(conversationMessages, token);

            if (response.trim() === '') {
                return 'TOKEN_LIMIT_EXCEEDED';
            }

            fullResponse += response;
            const hasEnd = fullResponse.endsWith('|||||END|||||');

            if (hasEnd) {
                return fullResponse.slice(0, -13);
            }

            // Prepare continuation request
            const lastChars = fullResponse.slice(-30);
            const continuationContent = `Your previous response was cut off. The last 30 characters were: "${lastChars}". Start writing immediately after these exact characters. We will append your response to the previous output. End with |||||END||||| when complete.`;

            conversationMessages.push({
                role: 'assistant',
                content: response
            });
            conversationMessages.push({
                role: 'user',
                content: continuationContent
            });
        }

        return fullResponse;
    }
    
    // Submit to internal API (original implementation)
    async function submitToInternalAPI(messages, token) {
        const timestamp = Date.now();
        const userMessageId = 'msg-' + timestamp + '-user';
        const assistantMessageId = 'msg-' + timestamp + '-assistant';
        const sessionId = 'session-' + Math.random().toString(36).substr(2, 9);
        const apiBase = window.location.origin;

        // Fire /new in background
        fetch(`${apiBase}/api/v1/chats/new`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                chat: {
                    id: '',
                    title: 'Chat Pending',
                    models: ['Anthropic Claude 4 Sonnet'],
                    params: {},
                    history: {
                        messages: {
                            [userMessageId]: {
                                id: userMessageId,
                                parentId: null,
                                childrenIds: [],
                                role: 'user',
                                content: messages.length > 0 ? messages[messages.length - 1].content : '',
                                timestamp: Math.floor(timestamp / 1000),
                                models: ['Anthropic Claude 4 Sonnet']
                            }
                        },
                        currentId: userMessageId
                    },
                    messages: [
                        {
                            id: userMessageId,
                            role: 'user',
                            content: messages.length > 0 ? messages[messages.length - 1].content : '',
                            timestamp: Math.floor(timestamp / 1000),
                            models: ['Anthropic Claude 4 Sonnet']
                        }
                    ],
                    files: []
                }
            })
        }).catch(err => {});

        const completionsResponse = await fetch(`${apiBase}/api/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                stream: true,
                model: 'Anthropic Claude 4 Sonnet',
                messages: messages,
                params: {},
                features: {
                    web_search: false
                },
                session_id: sessionId,
                id: assistantMessageId,
                background_tasks: {
                    title_generation: true,
                    tags_generation: true
                }
            })
        });

        if (!completionsResponse.ok) {
            throw new Error(`Completions failed: ${completionsResponse.status}`);
        }

        const reader = completionsResponse.body.getReader();
        const decoder = new TextDecoder();
        let finalContent = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    if (data === '[DONE]') {
                        return finalContent;
                    }

                    try {
                        const parsed = JSON.parse(data);
                        if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                            finalContent += parsed.choices[0].delta.content;
                        }
                    } catch (e) {
                        // Ignore parsing errors
                    }
                }
            }
        }

        return finalContent;
    }
    
    // Update UI based on state
    function updateUI(state, statusMessage) {
        if (state === 'listening') {
            mainButton.textContent = 'LISTENING';
            mainButton.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            statusText.textContent = 'READY TO RECEIVE';
            infoText.textContent = statusMessage || 'Waiting for request with |||||TO BRIDGE||||| marker';
        } else if (state === 'processing') {
            mainButton.textContent = 'PROCESSING...';
            mainButton.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';
            statusText.textContent = 'WORKING...';
            infoText.textContent = statusMessage || 'Calling /completions (fire-and-forget /new)...';
        } else if (state === 'response') {
            mainButton.textContent = 'CLICK TO COPY';
            mainButton.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
            statusText.textContent = 'RESPONSE READY';
            infoText.textContent = statusMessage || 'Click to copy response with |||||TO JAVA||||| marker';
        }
        
        // Update button colors
        if (state === 'listening') {
            statusText.style.color = '#4CAF50';
        } else if (state === 'processing') {
            statusText.style.color = '#FF9800';
        } else if (state === 'response') {
            statusText.style.color = '#2196F3';
        }
    }
    
    // Assemble UI
    bridgeUI.appendChild(closeButton);
    bridgeUI.appendChild(statusText);
    bridgeUI.appendChild(mainButton);
    bridgeUI.appendChild(infoText);
    
    // Add to page
    document.body.appendChild(bridgeUI);
    
    // Initialize UI
    updateUI('listening', 'Bridge ready - paste requests ending with |||||TO BRIDGE|||||');

    // Keepalive mechanism - send simple request every 5 minutes to keep session alive
    let keepaliveInterval = setInterval(async () => {
        try {
            const token = getAuthToken();
            if (!token) return;

            const keepaliveMessages = [{
                role: 'user',
                content: 'reply "k"'
            }];

            await submitToInternalAPI(keepaliveMessages, token);
        } catch (error) {
            // Silent fail
        }
    }, 5 * 60 * 1000);
    
})();
|~|~|~|~|~|~|~|~|~|~|~|

