FILE: com/codeboss/Main.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss;

import com.codeboss.bridgelayer.*;
import com.codeboss.javalayer.MiddleLayer;
import com.codeboss.javalayer.system.*;
import com.codeboss.javalayer.toolexecutor.*;

/**
 * Main entry point for Code Boss application
 *
 * Usage: java -jar code-boss.jar [--port=3000]
 */
public class Main {
    public static void main(String[] args) {
        try {
            System.out.println("Code Boss starting...");

            // Parse command line arguments
            int port = 3002;
            String workingDir = null;

            // First positional argument (if not starting with --) is working directory
            for (String arg : args) {
                if (arg.startsWith("--port=")) {
                    port = Integer.parseInt(arg.substring(7));
                } else if (workingDir == null && !arg.startsWith("--")) {
                    workingDir = arg;
                }
            }

            // Get working directory - use argument if provided, otherwise use current directory
            if (workingDir == null) {
                workingDir = System.getProperty("user.dir");
            }
            System.out.println("Working directory: " + workingDir);

            // Set codeboss.home to the directory containing this jar/classes
            // This allows Router to find frontend files regardless of working directory
            String codeBaseHome = System.getProperty("codeboss.home");
            if (codeBaseHome == null) {
                // Hard-coded path to Code Boss installation
                String codeBossHome = "D:\\code_boss";
                System.setProperty("codeboss.home", codeBossHome);
                System.out.println("Code Boss home: " + codeBossHome);
            }

            // Initialize Layer 2 (Bridge) components
            Logger logger = new Logger(workingDir);
            ConfigManager config = new ConfigManager(workingDir, logger);
            ClipboardManager clipboard = new ClipboardManager();

            // Override port if specified on command line
            if (port != 3002) {
                config.setServerPort(port);
            }

            // Initialize Layer 3 (Middle Layer)
            MiddleLayer middleLayer = new MiddleLayer(
                clipboard,
                config,
                new ToolExecutor(logger, workingDir),
                logger,
                workingDir
            );

            // Start application
            middleLayer.start();

            System.out.println("Code Boss started successfully");
            System.out.println("Server running on port: " + config.getServerPort());

            // Keep application running
            System.out.println("Press Ctrl+C to stop");
            Thread.currentThread().join();

        } catch (Exception e) {
            System.err.println("Failed to start Code Boss: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/bridgelayer/ClipboardManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.bridgelayer;

import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.util.Scanner;

public class ClipboardManager implements com.codeboss.javalayer.bridge.IClipboardManager {
    private Scanner scanner = new Scanner(System.in);

    private void log(String message) {
        System.out.println("[ClipboardManager] " + message);
    }
    
    public void copyToClipboard(String text) {
        int maxRetries = 3;
        int retryDelay = 100; // Start with 100ms

        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                StringSelection selection = new StringSelection(text);
                clipboard.setContents(selection, null);
                log("SUCCESS: Copied " + text.length() + " characters to clipboard");
                return;
            } catch (Exception e) {
                log("Error copying to clipboard (attempt " + attempt + "): " + e.getMessage());

                if (attempt < maxRetries) {
                    try {
                        Thread.sleep(retryDelay);
                        retryDelay *= 2; // Exponential backoff
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                } else {
                    System.err.println("Error copying to clipboard after " + maxRetries + " attempts: " + e.getMessage());
                }
            }
        }
    }
    
    public String getClipboardContent() {
        try {
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            Transferable contents = clipboard.getContents(null);
            
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                return (String) contents.getTransferData(DataFlavor.stringFlavor);
            }
        } catch (Exception e) {
            log("Error reading from clipboard: " + e.getMessage());
        }
        return null;
    }
    
    public String getResponseFromClipboard(String originalPrompt) {
        while (true) {
            try {
                String input = scanner.nextLine().trim();
                
                if (input.equalsIgnoreCase("quit")) {
                    log("Quit requested from clipboard loop");
                    return "QUIT_REQUESTED";
                }
                
                if (input.equalsIgnoreCase("c")) {
                    this.copyToClipboard(originalPrompt);
                    log("Prompt re-copied to clipboard");
                    System.out.println("~{ Prompt re-copied to clipboard }~");
                    continue;
                }

                String clipboardContent = this.getClipboardContent();
                log("Clipboard read: " + (clipboardContent != null ? clipboardContent.length() : 0) + " characters");
                
                // CRITICAL: Log details about what was actually read from clipboard
                if (clipboardContent != null) {
                    if (clipboardContent.trim().isEmpty()) {
                        log("CRITICAL: Clipboard contains only whitespace: '" + clipboardContent + "'");
                    } else if (clipboardContent.length() < 10) {
                        log("WARNING: Very short clipboard content: '" + clipboardContent + "'");
                    } else {
                        log("Clipboard first 100 chars: " + clipboardContent.substring(0, Math.min(100, clipboardContent.length())));
                        log("Clipboard last 50 chars: " + clipboardContent.substring(Math.max(0, clipboardContent.length() - 50)));
                    }
                } else {
                    log("CRITICAL: Clipboard content is NULL");
                }
                
                if (clipboardContent == null || clipboardContent.trim().isEmpty()) {
                    System.out.println("Clipboard is empty. Please copy Claude's response and try again.");
                    System.out.print("Press Enter when response is copied (or 'c' to copy prompt again): ");
                    continue;
                }
                
                // Check if clipboard still contains the original prompt (user hasn't pasted response yet)
                if (clipboardContent.trim().equals(originalPrompt.trim())) {
                    System.out.println("Clipboard still contains the original prompt. Please copy Claude's response.");
                    System.out.print("Press Enter when response is copied (or 'c' to copy prompt again): ");
                    continue;
                }
                
                return clipboardContent;
                
            } catch (Exception e) {
                log("Error in clipboard interaction: " + e.getMessage());
                System.out.println("Error reading clipboard. Please try again.");
                System.out.print("Press Enter to retry: ");
            }
        }
    }
    
    public void clickAtCoordinates(int x, int y) {
        try {
            Robot robot = new Robot();
            robot.mouseMove(x, y);
            Thread.sleep(50); // Small delay to ensure mouse has moved
            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
            // Log on first click only to avoid spam
            if (System.currentTimeMillis() % 5000 < 100) {
                log("Click executed at (" + x + ", " + y + ")");
            }
        } catch (Exception e) {
            log("Error clicking at coordinates (" + x + ", " + y + "): " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    public void moveMouseTo(int x, int y) {
        try {
            Robot robot = new Robot();
            robot.mouseMove(x, y);
            log("Mouse moved to coordinates: " + x + ", " + y);
        } catch (Exception e) {
            log("Error moving mouse to coordinates: " + e.getMessage());
            throw new RuntimeException("Failed to move mouse: " + e.getMessage());
        }
    }
    
    public String waitForAutomaticResponse(int clickX, int clickY) {
        int pollCount = 0;
        log("Starting auto-click polling at coordinates: (" + clickX + ", " + clickY + ")");

        while (true) {
            try {
                pollCount++;

                // Log every 5 polls to avoid spam
                if (pollCount % 5 == 1) {
                    log("Auto-click poll #" + pollCount + " - clicking at (" + clickX + ", " + clickY + ")");
                }

                // Move mouse to coordinates and click
                this.clickAtCoordinates(clickX, clickY);

                // Small delay after click to let browser respond
                Thread.sleep(100);

                // Check clipboard for response with terminator
                String clipboardContent = this.getClipboardContent();

                if (clipboardContent != null) {
                    // Log clipboard content for debugging (first 100 chars)
                    if (pollCount % 5 == 1) {
                        String preview = clipboardContent.length() > 100 ?
                            clipboardContent.substring(0, 100) + "..." : clipboardContent;
                        log("Clipboard content preview: " + preview);
                        log("Clipboard ends with TO_JAVA marker: " + clipboardContent.endsWith("|||||CLIP:TO_JAVA|||||"));
                        log("Clipboard ends with TO_JAVA_END marker: " + clipboardContent.endsWith("|||||CLIP:TO_JAVA_END|||||"));
                    }

                    if (clipboardContent.endsWith("|||||CLIP:TO_JAVA|||||") || clipboardContent.endsWith("|||||CLIP:TO_JAVA_END|||||")) {
                        // Remove terminator and return response
                        String marker = clipboardContent.endsWith("|||||CLIP:TO_JAVA_END|||||") ? "|||||CLIP:TO_JAVA_END|||||" : "|||||CLIP:TO_JAVA|||||";
                        String response = clipboardContent.substring(0, clipboardContent.length() - marker.length());

                        // Reject empty or very short responses
                        if (response.trim().isEmpty() || response.length() < 10) {
                            log("Empty/short response, continuing to poll");
                            continue;
                        }

                        log("SUCCESS: Received valid response (" + response.length() + " chars)");
                        return response;
                    }
                } else {
                    if (pollCount % 5 == 1) {
                        log("Clipboard is NULL after clicking");
                    }
                }

                // Sleep for 1 second, but check mouse position during this time
                Thread.sleep(1000);

                // After waiting, check if mouse moved outside the allowed area
                Point currentMousePos = MouseInfo.getPointerInfo().getLocation();
                int deltaX = Math.abs(currentMousePos.x - clickX);
                int deltaY = Math.abs(currentMousePos.y - clickY);

                if (deltaX > 300 || deltaY > 300) {
                    log("Mouse moved outside 300px square from click position - canceling auto-clicking");
                    log("Current mouse position: (" + currentMousePos.x + ", " + currentMousePos.y + ")");
                    log("Delta: (" + deltaX + ", " + deltaY + ")");
                    return "MOUSE_CANCELLED";
                }

            } catch (InterruptedException e) {
                log("Automatic polling interrupted: " + e.getMessage());
                Thread.currentThread().interrupt();
                return null;
            } catch (Exception e) {
                log("Error in automatic polling: " + e.getMessage());
                e.printStackTrace();
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    return null;
                }
            }
        }
    }
    
    public String handleAutoCancelRetry(String originalPrompt, int clickX, int clickY) {
        System.out.println("Auto-clicking cancelled (mouse moved too far)");
        System.out.println("Press 'r' to retry auto-clicking or 'a' to abort: ");
        
        while (true) {
            try {
                String input = scanner.nextLine().trim().toLowerCase();
                
                if (input.equals("r")) {
                    log("User chose to retry auto-clicking");
                    System.out.println("Retrying auto-clicking...");
                    return this.waitForAutomaticResponse(clickX, clickY);
                } else if (input.equals("a")) {
                    log("User chose to abort auto-clicking");
                    return null;
                } else {
                    System.out.println("Invalid input. Press 'r' to retry or 'a' to abort: ");
                }
            } catch (Exception e) {
                log("Error in cancel retry handler: " + e.getMessage());
                return null;
            }
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/MiddleLayer.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer;

import com.codeboss.javalayer.bridge.*;
import com.codeboss.javalayer.httpserver.*;
import com.codeboss.javalayer.aiprocessor.*;
import com.codeboss.javalayer.shared.*;
import com.codeboss.javalayer.bridgepolling.*;

/**
 * Main entry point for Layer 3 (Middle Layer)
 *
 * Orchestrates the 3-thread architecture:
 * - Thread 1: HTTP server (httpserver package)
 * - Thread 2: AI processor (aiprocessor package)
 * - Thread 3: Bridge polling (bridgepolling package)
 */
public class MiddleLayer {
    private final IClipboardManager clipboard;
    private final IConfigManager config;
    private final IToolExecutor toolExecutor;
    private final ILogger logger;
    private final String workingDirectory;

    // Queues for thread communication
    private ConversationQueue conversationQueue;
    private BridgeQueue bridgeQueue;

    // Threads
    private HttpServer httpServer;
    private Thread aiProcessorThread;
    private Thread bridgePollingThread;

    // Components
    private ConversationManager conversationManager;

    public MiddleLayer(
        IClipboardManager clipboard,
        IConfigManager config,
        IToolExecutor toolExecutor,
        ILogger logger,
        String workingDirectory
    ) {
        this.clipboard = clipboard;
        this.config = config;
        this.toolExecutor = toolExecutor;
        this.logger = logger;
        this.workingDirectory = workingDirectory;
    }

    public void start() throws Exception {
        logger.log("MiddleLayer starting...");

        // 1. Create shared queues
        conversationQueue = new ConversationQueue();
        bridgeQueue = new BridgeQueue();

        // 2. Create components
        ChecklistManager checklistManager = new ChecklistManager(logger);
        conversationManager = new ConversationManager(checklistManager, logger, workingDirectory);
        ModeManager modeManager = new ModeManager(logger, conversationManager);
        PromptGenerator promptGenerator = new PromptGenerator();
        FileHashTracker fileHashTracker = new FileHashTracker(logger, workingDirectory);
        UndoStack undoStack = new UndoStack(logger, fileHashTracker, workingDirectory);

        // Publish initial conversation state so frontend can display existing conversation on load
        try {
            String initialState = conversationManager.getConversationStateJson();
            conversationQueue.publishState(initialState);
            logger.log("Published initial conversation state");
        } catch (InterruptedException e) {
            logger.log("Warning: Failed to publish initial conversation state: " + e.getMessage());
        }

        // Wire up ChecklistManager, ModeManager, and ConversationManager to ToolExecutor if it's the concrete implementation
        if (toolExecutor instanceof com.codeboss.javalayer.toolexecutor.ToolExecutor) {
            ((com.codeboss.javalayer.toolexecutor.ToolExecutor)toolExecutor).setChecklistManager(checklistManager);
            ((com.codeboss.javalayer.toolexecutor.ToolExecutor)toolExecutor).setModeManager(modeManager);
            ((com.codeboss.javalayer.toolexecutor.ToolExecutor)toolExecutor).setConversationManager(conversationManager);
        }

        // 3. Create and start Thread 2 (AI Processor)
        AIProcessorThread aiProcessor = new AIProcessorThread(
            conversationQueue, bridgeQueue, conversationManager, checklistManager, modeManager,
            promptGenerator, toolExecutor, logger, workingDirectory
        );
        aiProcessorThread = new Thread(aiProcessor, "AI-Processor");
        aiProcessorThread.start();

        // 4. Create and start Thread 3 (Bridge Polling)
        BridgePollingThread bridgePoller = new BridgePollingThread(
            bridgeQueue, clipboard, config, logger
        );
        bridgePollingThread = new Thread(bridgePoller, "Bridge-Polling");
        bridgePollingThread.start();

        // 5. Create and start Thread 1 (HTTP Server)
        Router router = new Router(
            conversationQueue,
            conversationManager,
            checklistManager,
            modeManager,
            (com.codeboss.javalayer.toolexecutor.ToolExecutor)toolExecutor,
            clipboard,
            config,
            undoStack,
            logger
        );
        httpServer = new HttpServer(config.getServerPort(), router, logger);
        httpServer.start();

        // TODO: 6. Auto-launch browser if configured
        // if (config.shouldAutoLaunchBrowser()) {
        //     // Launch browser to http://localhost:port
        // }

        logger.log("MiddleLayer started");
    }

    public void stop() {
        logger.log("MiddleLayer stopping...");

        // 1. Stop HTTP server
        if (httpServer != null) {
            httpServer.stop();
        }

        // 2. Stop AI processor thread
        if (aiProcessorThread != null) {
            aiProcessorThread.interrupt();
            try {
                aiProcessorThread.join(5000);
            } catch (InterruptedException e) {
                logger.log("Interrupted while stopping AI processor thread");
            }
        }

        // 3. Stop bridge polling thread
        if (bridgePollingThread != null) {
            bridgePollingThread.interrupt();
            try {
                bridgePollingThread.join(5000);
            } catch (InterruptedException e) {
                logger.log("Interrupted while stopping bridge polling thread");
            }
        }

        logger.log("MiddleLayer stopped");
    }

    public HttpServer getHttpServer() {
        return httpServer;
    }

    public ConversationManager getConversationManager() {
        return conversationManager;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/AIBridge.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import com.codeboss.javalayer.toolexecutor.*;
import java.util.*;

/**
 * Facade for AI communication via clipboard bridge
 */
public class AIBridge {
    private final IClipboardManager clipboard;
    private final IConfigManager config;
    private final MessageFormatter messageFormatter;
    private final ResponseParser responseParser;
    private final ToolExecutor toolExecutor;
    private final PromptGenerator promptGenerator;
    private final ILogger logger;

    public AIBridge(
        IClipboardManager clipboard,
        IConfigManager config,
        ToolExecutor toolExecutor,
        PromptGenerator promptGenerator,
        ILogger logger
    ) {
        this.clipboard = clipboard;
        this.config = config;
        this.toolExecutor = toolExecutor;
        this.promptGenerator = promptGenerator;
        this.logger = logger;
        this.messageFormatter = new MessageFormatter();
        this.responseParser = new ResponseParser();
    }

    public AIResponse sendMessage(List<ConversationState.Message> conversationHistory) {
        // TODO: Generate system prompt
        // TODO: Format messages for clipboard protocol
        // TODO: Copy to clipboard
        // TODO: Auto-click bridge button
        // TODO: Wait for response
        // TODO: Parse response
        // TODO: Execute tools if present
        // TODO: Loop until no more tools
        logger.log("AI message sent");
        return new AIResponse("TODO", false);
    }

    public static class AIResponse {
        public String content;
        public boolean isComplete;

        public AIResponse(String content, boolean isComplete) {
            this.content = content;
            this.isComplete = isComplete;
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/AIProcessorThread.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import com.codeboss.javalayer.shared.*;
import java.util.*;

/**
 * Thread 2: AI Processor
 *
 * Main loop that:
 * 1. Takes user messages from ConversationQueue
 * 2. Processes conversation (adds loading, sends to AI, executes tools, etc.)
 * 3. Publishes conversation state updates to ConversationQueue at each step
 * 4. Writes conversation.jsonl file
 */
public class AIProcessorThread implements Runnable {
    private final ConversationQueue conversationQueue;
    private final BridgeQueue bridgeQueue;
    private final ConversationManager conversationManager;
    private final ChecklistManager checklistManager;
    private final ModeManager modeManager;
    private final PromptGenerator promptGenerator;
    private final ConversationRenderer conversationRenderer;
    private final IToolExecutor toolExecutor;
    private final ILogger logger;
    private final String workingDirectory;
    private final ProjectStructure projectStructure;
    private volatile boolean running = true;

    public AIProcessorThread(
        ConversationQueue conversationQueue,
        BridgeQueue bridgeQueue,
        ConversationManager conversationManager,
        ChecklistManager checklistManager,
        ModeManager modeManager,
        PromptGenerator promptGenerator,
        IToolExecutor toolExecutor,
        ILogger logger,
        String workingDirectory
    ) {
        this.conversationQueue = conversationQueue;
        this.bridgeQueue = bridgeQueue;
        this.conversationManager = conversationManager;
        this.checklistManager = checklistManager;
        this.modeManager = modeManager;
        this.promptGenerator = promptGenerator;
        this.projectStructure = new ProjectStructure(workingDirectory);
        this.conversationRenderer = new ConversationRenderer();
        this.toolExecutor = toolExecutor;
        this.logger = logger;
        this.workingDirectory = workingDirectory;
    }

    @Override
    public void run() {
        logger.log("AI Processor thread started");

        while (running) {
            try {
                // 1. Take message from queue (blocking)
                ConversationQueue.UserMessage userMsg = conversationQueue.takeMessage();
                logger.log("Processing message: " + userMsg.text);

                // 2. Add user message to conversation first
                conversationManager.getState().setStatus("processing");
                conversationManager.addUserMessage(userMsg.text);
                conversationQueue.publishState(conversationManager.getConversationStateJson());

                // 3. Check if we just started execution after approval - add task notification AFTER "yes"
                if (conversationManager.isJustStartedExecution()) {
                    // Add first task notification AFTER the "yes" message
                    ChecklistManager.ChecklistItem firstTask = checklistManager.getNextPendingItem();
                    if (firstTask != null) {
                        List<ChecklistManager.ChecklistItem> allItems = checklistManager.getItems();
                        Map<String, Object> firstTaskNotification = new java.util.LinkedHashMap<>();
                        firstTaskNotification.put("task_number", 1);
                        firstTaskNotification.put("total_items", allItems.size());
                        firstTaskNotification.put("content", firstTask.content);
                        firstTaskNotification.put("item_type", firstTask.itemType);

                        conversationManager.addToolResult("task_start", firstTaskNotification);
                        conversationQueue.publishState(conversationManager.getConversationStateJson());
                        logger.log("Added first task notification: " + firstTask.content);
                    }

                    // Clear the flag
                    conversationManager.clearJustStartedExecution();
                }

                // 4. Build AI request with full conversation history and send to AI via bridge
                String aiRequest = buildAIRequestFromHistory();
                logger.log("Sending to AI: " + aiRequest);
                BridgeQueue.AIResponse aiResponse = submitToBridge(aiRequest);
                logger.log("Got AI response: " + aiResponse.responseXml);

                // 4. Agentic loop: parse response, execute tools, loop until AI returns message
                ResponseParser.ParsedResponse parsed = parseWithRetry(aiResponse.responseXml, true);

                while (parsed.hasTools) {
                    boolean shouldTriggerReview = false;
                    boolean firstTool = true;

                    // Filter out duplicate mark_complete calls - only keep the first one
                    // Also detect multiple update_file calls to the same file
                    List<ResponseParser.ToolUse> toolsToExecute = new ArrayList<>();
                    boolean hasMarkComplete = false;
                    Map<String, Integer> updateFileCount = new HashMap<>();
                    boolean hasMultipleUpdateFileError = false;

                    for (ResponseParser.ToolUse tool : parsed.tools) {
                        if (tool.name.equals("mark_complete")) {
                            if (!hasMarkComplete) {
                                toolsToExecute.add(tool);
                                hasMarkComplete = true;
                            } else {
                                logger.log("WARNING: Ignoring duplicate mark_complete call");
                            }
                        } else if (tool.name.equals("update_file")) {
                            // Track update_file calls by file_path
                            String filePath = tool.parameters.get("file_path");
                            if (filePath != null) {
                                int count = updateFileCount.getOrDefault(filePath, 0) + 1;
                                updateFileCount.put(filePath, count);

                                if (count > 1) {
                                    // Multiple updates to same file detected - flag error
                                    logger.log("ERROR: Multiple update_file calls detected for: " + filePath);
                                    hasMultipleUpdateFileError = true;

                                    Map<String, Object> errorContent = new HashMap<>();
                                    errorContent.put("error", "Multiple update_file calls to same file: " + filePath);
                                    errorContent.put("hint", "Use update_file_batch instead for multiple updates to the same file");
                                    errorContent.put("example", "<tool name=\"update_file_batch\"><parameter name=\"file_path\">" + filePath + "</parameter><parameter name=\"updates\"><![CDATA[[{\"old_content\":\"...\",\"new_content\":\"...\"},{\"old_content\":\"...\",\"new_content\":\"...\"}]]]></parameter></tool>");
                                    conversationManager.addError("multiple_update_file_error", errorContent);
                                    conversationQueue.publishState(conversationManager.getConversationStateJson());
                                    break; // Break out of tool filtering loop
                                }
                            }
                            toolsToExecute.add(tool);
                        } else {
                            toolsToExecute.add(tool);
                        }
                    }

                    // If multiple update_file error detected, send back to AI for correction
                    if (hasMultipleUpdateFileError) {
                        String errorRequest = buildAIRequestFromHistory();
                        logger.log("Sending multiple update_file error back to AI");
                        BridgeQueue.AIResponse errorResponse = submitToBridge(errorRequest);
                        parsed = parseWithRetry(errorResponse.responseXml, false);
                        handleParsingWarnings(parsed);
                        continue; // Restart while loop with corrected response
                    }

                    // Execute each tool and collect results
                    for (ResponseParser.ToolUse tool : toolsToExecute) {
                        logger.log("Executing tool: " + tool.name);

                        // Add tool_use message and publish state
                        Map<String, Object> params = new HashMap<>(tool.parameters);

                        // Add default parameters if missing
                        if (tool.name.equals("list_files") && !params.containsKey("directory_path")) {
                            params.put("directory_path", ".");
                        }

                        ConversationState.Message toolUseMsg = conversationManager.addToolUse(tool.name, params);
                        conversationQueue.publishState(conversationManager.getConversationStateJson());

                        // Execute tool
                        IToolExecutor.ToolExecutionResult result =
                            toolExecutor.executeToolWithSummary(tool.name, tool.parameters);

                        // Inject warnings into first tool result if present
                        Map<String, Object> resultWithWarnings = new HashMap<>(result.result);
                        if (firstTool && parsed.warnings != null && !parsed.warnings.isEmpty()) {
                            resultWithWarnings.put("_warnings", parsed.warnings);
                            logger.log("Added format warnings to first tool result: " + parsed.warnings.size() + " warnings");
                        }

                        // Add tool_result message with reference to tool_use ID, and publish state
                        conversationManager.addToolResult(tool.name, resultWithWarnings, toolUseMsg.id);
                        conversationQueue.publishState(conversationManager.getConversationStateJson());

                        logger.log("Tool completed: " + tool.name + " - " + result.summary);
                        firstTool = false;

                        // Handle mark_complete: move to next item or trigger final review
                        if (tool.name.equals("mark_complete")) {
                            // Check if final review should be triggered
                            if (result.shouldTriggerReview) {
                                shouldTriggerReview = true;
                                // Don't move to next item yet - review will be triggered below
                            } else {
                                ChecklistManager.ChecklistItem nextItem = checklistManager.getNextPendingItem();
                                if (nextItem == null) {
                                    // No more items - return to PLANNING mode for AI to summarize
                                    logger.log("All checklist items completed - returning to PLANNING mode");
                                    modeManager.transitionTo(Mode.PLANNING);

                                    conversationManager.addSystemMessage("System: All tasks completed. Please summarize what was accomplished and ask the user what they'd like to do next.");
                                    conversationQueue.publishState(conversationManager.getConversationStateJson());

                                    // Continue in PLANNING mode for AI to provide summary
                                    String summaryRequest = buildAIRequestFromHistory();
                                    BridgeQueue.AIResponse summaryResponse = submitToBridge(summaryRequest);
                                    parsed = parseWithRetry(summaryResponse.responseXml, false);
                                    handleParsingWarnings(parsed);
                                    continue;
                                } else {
                                // Move to next item - send AI back with new current task
                                logger.log("Moving to next item: " + nextItem.id);
                                conversationManager.addSystemMessage("System: Task completed. Moving to next item.");
                                conversationQueue.publishState(conversationManager.getConversationStateJson());

                                    // Continue agentic loop with next item
                                    String nextRequest = buildAIRequestFromHistory();
                                    BridgeQueue.AIResponse nextResponse = submitToBridge(nextRequest);
                                    parsed = parseWithRetry(nextResponse.responseXml, false);
                                    handleParsingWarnings(parsed);
                                    continue;
                                }
                            }
                        }

                        // Handle mark_failed: return to planning mode
                        if (tool.name.equals("mark_failed")) {
                            String reason = (String) result.result.get("reason");
                            logger.log("Task failed, returning to PLANNING mode: " + reason);

                            modeManager.transitionTo(Mode.PLANNING);

                            conversationManager.addSystemMessage("System: Task failed. Returned to planning mode. Reason: " + reason);
                            conversationQueue.publishState(conversationManager.getConversationStateJson());

                            // Continue in PLANNING mode
                            String planRequest = buildAIRequestFromHistory();
                            BridgeQueue.AIResponse planResponse = submitToBridge(planRequest);
                            parsed = parseWithRetry(planResponse.responseXml, false);
                            handleParsingWarnings(parsed);
                            continue;
                        }

                        // Check if this tool triggered a review checkpoint
                        if (result.shouldTriggerReview) {
                            shouldTriggerReview = true;
                        }
                    }

                    // Handle review trigger if needed
                    if (shouldTriggerReview) {
                        logger.log("Review checkpoint triggered - switching to REVIEW mode");

                        // Switch to REVIEW mode
                        Mode previousMode = modeManager.getCurrentMode();
                        modeManager.transitionTo(Mode.REVIEW);

                        // Add review_start notification for UI visualization
                        Map<String, Object> reviewStartNotification = new java.util.LinkedHashMap<>();
                        reviewStartNotification.put("message", "Reviewing...");
                        conversationManager.addToolResult("review_start", reviewStartNotification);
                        conversationQueue.publishState(conversationManager.getConversationStateJson());

                        // Send to AI in REVIEW mode and loop until we get a verdict
                        String reviewRequest = buildAIRequestFromHistory();
                        logger.log("Requesting code review from AI");
                        BridgeQueue.AIResponse reviewResponse = submitToBridge(reviewRequest);
                        logger.log("Got review response: " + reviewResponse.responseXml);

                        ResponseParser.ParsedResponse reviewParsed = parseWithRetry(reviewResponse.responseXml, false);

                        // Review agentic loop: execute tools until AI calls review_pass or review_fail
                        String verdict = null;
                        String failReason = null;

                        while (reviewParsed.hasTools) {
                            // Execute review tools (read_file, search, etc.)
                            for (ResponseParser.ToolUse tool : reviewParsed.tools) {
                                logger.log("Review executing tool: " + tool.name);

                                Map<String, Object> params = new HashMap<>(tool.parameters);
                                ConversationState.Message reviewToolUseMsg = conversationManager.addToolUse(tool.name, params);
                                conversationQueue.publishState(conversationManager.getConversationStateJson());

                                IToolExecutor.ToolExecutionResult result =
                                    toolExecutor.executeToolWithSummary(tool.name, tool.parameters);

                                conversationManager.addToolResult(tool.name, result.result, reviewToolUseMsg.id);
                                conversationQueue.publishState(conversationManager.getConversationStateJson());

                                logger.log("Review tool completed: " + tool.name);

                                // Check if this is a review verdict tool
                                if (tool.name.equals("review_pass") || tool.name.equals("review_fail")) {
                                    verdict = (String) result.result.get("verdict");
                                    if ("FAIL".equals(verdict)) {
                                        failReason = (String) result.result.get("reason");
                                    }
                                    logger.log("Review verdict received: " + verdict);
                                    break;
                                }
                            }

                            // Break out of review loop if we got a verdict
                            if (verdict != null) {
                                break;
                            }

                            // Continue review loop
                            String reviewContinue = buildAIRequestFromHistory();
                            BridgeQueue.AIResponse reviewContinueResponse = submitToBridge(reviewContinue);
                            reviewParsed = parseWithRetry(reviewContinueResponse.responseXml, false);
                        }

                        // If no verdict tool was called, default to PASS
                        if (verdict == null) {
                            verdict = "PASS";
                            logger.log("No review verdict tool called, defaulting to PASS");
                        }

                        logger.log("Final review verdict: " + verdict);

                        if ("FAIL".equals(verdict)) {
                            // Review failed - return to PLANNING mode to create fix plan
                            logger.log("Review failed - returning to PLANNING mode to create fix plan");
                            modeManager.transitionTo(Mode.PLANNING);

                            // Add system message explaining the failure and requesting a fix plan
                            String failMessage = "System: Review failed. Reason: " + failReason + "\n\nPlease create a plan to fix the issues mentioned above. Use begin_execution with a checklist of tasks to address each issue.";
                            conversationManager.addSystemMessage(failMessage);
                            conversationQueue.publishState(conversationManager.getConversationStateJson());

                            // Continue in PLANNING mode to create fix plan
                            String fixRequest = buildAIRequestFromHistory();
                            BridgeQueue.AIResponse fixResponse = submitToBridge(fixRequest);
                            parsed = parseWithRetry(fixResponse.responseXml, false);
                            continue;
                        } else {
                            // Review passed - mark review completed
                            checklistManager.markReviewCompleted();

                            // Add review_end notification for UI visualization
                            Map<String, Object> reviewEndNotification = new java.util.LinkedHashMap<>();
                            reviewEndNotification.put("verdict", "PASS");
                            conversationManager.addToolResult("review_end", reviewEndNotification);
                            conversationQueue.publishState(conversationManager.getConversationStateJson());

                            // Check if there are more tasks to complete
                            ChecklistManager.ChecklistItem nextItem = checklistManager.getNextPendingItem();
                            if (nextItem == null) {
                                // All tasks complete - return to PLANNING mode
                                logger.log("Review passed and all tasks complete - returning to PLANNING mode");
                                modeManager.transitionTo(Mode.PLANNING);

                                conversationManager.addSystemMessage("System: All tasks completed. Please summarize what was accomplished and ask the user what they'd like to do next.");
                                conversationQueue.publishState(conversationManager.getConversationStateJson());

                                // Continue in PLANNING mode for AI to provide summary
                                String summaryRequest = buildAIRequestFromHistory();
                                BridgeQueue.AIResponse summaryResponse = submitToBridge(summaryRequest);
                                parsed = parseWithRetry(summaryResponse.responseXml, false);
                                handleParsingWarnings(parsed);
                                continue;
                            } else {
                                // More tasks remain - return to EXECUTION mode and move to next task
                                logger.log("Review passed - moving to next task: " + nextItem.id);

                                // Determine mode based on next item type
                                String nextItemType = nextItem.itemType;
                                if ("testing".equals(nextItemType)) {
                                    modeManager.transitionTo(Mode.TESTING);
                                } else {
                                    modeManager.transitionTo(Mode.EXECUTION);
                                }

                                conversationManager.addSystemMessage("System: Review passed. Moving to next task.");
                                conversationQueue.publishState(conversationManager.getConversationStateJson());

                                // Continue with next task
                                String nextRequest = buildAIRequestFromHistory();
                                BridgeQueue.AIResponse nextResponse = submitToBridge(nextRequest);
                                parsed = parseWithRetry(nextResponse.responseXml, false);
                                handleParsingWarnings(parsed);
                                continue;
                            }
                        }
                    }

                    // Check if test command approval is pending
                    if (conversationManager.isAwaitingTestCommandApproval()) {
                        logger.log("Test command pending approval - stopping AI processing");

                        String name = conversationManager.getPendingTestCommandName();
                        String command = conversationManager.getPendingTestCommand();
                        String description = conversationManager.getPendingTestDescription();

                        String message = "Test command '" + name + "': " + command;
                        if (description != null && !description.isEmpty()) {
                            message += "\n" + description;
                        }
                        message += "\n\nCreate this test command? (yes/no)";

                        conversationManager.addSystemMessage(message);
                        conversationManager.getState().setStatus("awaiting_approval");
                        conversationQueue.publishState(conversationManager.getConversationStateJson());
                        break; // Break out of tool loop
                    }

                    // Check if plan was auto-approved (single-item plans)
                    boolean wasAutoApproved = false;
                    for (ResponseParser.ToolUse tool : toolsToExecute) {
                        if (tool.name.equals("begin_execution")) {
                            // Check the last tool result to see if it was auto-approved
                            List<ConversationState.Message> history = conversationManager.getState().getHistory();
                            if (!history.isEmpty()) {
                                ConversationState.Message lastMsg = history.get(history.size() - 1);
                                if (lastMsg.type.equals("tool_result") && lastMsg.result != null) {
                                    Object status = lastMsg.result.get("status");
                                    if ("auto_approved".equals(status)) {
                                        wasAutoApproved = true;
                                        logger.log("Plan was auto-approved (single item) - adding task_start notification and continuing");

                                        // Add task_start notification
                                        Object firstTaskObj = lastMsg.result.get("first_task");
                                        if (firstTaskObj instanceof Map) {
                                            conversationManager.addToolResult("task_start", (Map<String, Object>) firstTaskObj);
                                            conversationQueue.publishState(conversationManager.getConversationStateJson());
                                        }

                                        // Continue immediately - AI will start working on the first task
                                        String executeRequest = buildAIRequestFromHistory();
                                        logger.log("Auto-approved - calling AI in EXECUTION mode to start task");
                                        BridgeQueue.AIResponse executeResponse = submitToBridge(executeRequest);
                                        parsed = parseWithRetry(executeResponse.responseXml, false);
                                        handleParsingWarnings(parsed);
                                        continue;
                                    }
                                }
                            }
                        }
                    }

                    // Check if approval is pending - if so, stop processing and wait
                    if (!wasAutoApproved && conversationManager.isAwaitingApproval()) {
                        logger.log("Plan submitted for approval - stopping AI processing");
                        String description = conversationManager.getPendingPlanDescription();
                        conversationManager.addSystemMessage("Plan: " + description + "\nProceed with this plan? (yes/no)");
                        conversationManager.getState().setStatus("awaiting_approval");
                        conversationQueue.publishState(conversationManager.getConversationStateJson());
                        break; // Break out of tool loop - will skip to end of conversation turn
                    }

                    // Send updated conversation to AI
                    String nextRequest = buildAIRequestFromHistory();
                    logger.log("Continuing agentic loop with AI");
                    BridgeQueue.AIResponse nextResponse = submitToBridge(nextRequest);
                    logger.log("Got AI response: " + nextResponse.responseXml);

                    parsed = parseWithRetry(nextResponse.responseXml, false);

                    // Handle any parsing warnings
                    handleParsingWarnings(parsed);
                }

                // 5. Only process final message if NOT awaiting approval
                if (!conversationManager.isAwaitingApproval() &&
                    !conversationManager.isAwaitingTestCommandApproval()) {
                    // AI returned message (not tools) - add assistant message and mark complete
                    conversationManager.addAssistantMessage(parsed.messageContent);
                    conversationManager.getState().setStatus("complete");

                    // 6. Publish final state
                    String finalState = conversationManager.getConversationStateJson();
                    conversationQueue.publishState(finalState);

                    logger.log("Conversation turn complete");
                }

            } catch (Exception e) {
                if (e instanceof InterruptedException) {
                    logger.log("AI Processor interrupted");
                    break;
                }
                logger.log("AI Processor error: " + e.getMessage());

                // Send error state and stop
                try {
                    // Remove loading message, add error as assistant message, set complete
                    conversationManager.addAssistantMessage("Error: " + e.getMessage());
                    conversationManager.getState().setStatus("complete");

                    conversationQueue.publishState(conversationManager.getConversationStateJson());
                } catch (InterruptedException ie) {
                    logger.log("Interrupted while sending error state");
                }
                break; // Stop processing after error
            }
        }

        logger.log("AI Processor thread stopped");
    }

    public void shutdown() {
        running = false;
    }

    private String buildAIRequest(String userMessage) {
        Mode currentMode = modeManager.getCurrentMode();
        String systemPrompt = promptGenerator.generatePrompt(currentMode, checklistManager, projectStructure);

        StringBuilder request = new StringBuilder();
        request.append("{");
        request.append("\"system\":\"").append(escapeJson(systemPrompt)).append("\",");
        request.append("\"messages\":[");
        request.append("{\"role\":\"user\",\"content\":\"").append(escapeJson(userMessage)).append("\"}");
        request.append("]");
        request.append("}");

        return request.toString();
    }

    private String buildAIRequestFromHistory() {
        Mode currentMode = modeManager.getCurrentMode();
        String systemPrompt = promptGenerator.generatePrompt(currentMode, checklistManager, projectStructure);

        StringBuilder request = new StringBuilder();
        request.append("{");
        request.append("\"system\":\"").append(escapeJson(systemPrompt)).append("\",");
        request.append("\"messages\":[");

        // Use renderer to format conversation history
        List<ConversationState.Message> history = conversationManager.getState().getHistory();
        request.append(conversationRenderer.renderMessages(history));

        request.append("]");
        request.append("}");

        return request.toString();
    }


    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    /**
     * Submit request to AI bridge and check for errors
     * @throws RuntimeException if bridge returns an error
     */
    private BridgeQueue.AIResponse submitToBridge(String request) throws InterruptedException {
        BridgeQueue.AIResponse response = bridgeQueue.submitRequest(request);

        // Check if response is an error from the bridge
        if (response.responseXml != null && response.responseXml.startsWith("ERROR:")) {
            throw new RuntimeException("AI Bridge error: " + response.responseXml.substring(7).trim());
        }

        return response;
    }

    /**
     * Parse AI response with retry logic for formatting errors
     *
     * @param responseXml The AI response to parse
     * @param isInitialParse True if this is the first parse (manages loading message differently)
     * @return Parsed response
     * @throws IllegalArgumentException if parsing fails after max retries
     */
    private ResponseParser.ParsedResponse parseWithRetry(String responseXml, boolean isInitialParse)
            throws IllegalArgumentException, InterruptedException {
        final int MAX_RETRIES = 5;

        for (int attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                return ResponseParser.parse(responseXml);
            } catch (IllegalArgumentException parseError) {
                String errorContext = isInitialParse ? "initial parse" : "agentic loop";
                logger.log("XML parse error (" + errorContext + ", attempt " + attempt + "/" + MAX_RETRIES + "): "
                          + parseError.getMessage());

                if (attempt >= MAX_RETRIES) {
                    // Max retries exceeded - give up
                    logger.log("Max retries exceeded for XML parsing");
                    throw new IllegalArgumentException(
                        "AI failed to provide valid response format after " + MAX_RETRIES + " attempts: "
                        + parseError.getMessage()
                    );
                }

                // Remove loading message before adding error (only on first attempt for initial parse)
                if (isInitialParse && attempt == 1) {
                }

                // Add formatting error so AI can see it
                Map<String, Object> errorContent = new HashMap<>();
                errorContent.put("error", parseError.getMessage());

                // Check if response was truncated by counting tags
                boolean isTruncated = detectTruncation(responseXml);

                // Provide better hints based on the error type
                String hint;
                if (isTruncated) {
                    hint = "Response was truncated at token limit (unclosed XML tags detected). To fix: Split large files into smaller chunks, or create files one at a time in separate <execute> blocks";
                } else if (parseError.getMessage().contains("no root element") ||
                           parseError.getMessage().contains("unexpected end")) {
                    hint = "Invalid XML structure. Use <execute> for tools or <message> for text responses";
                } else {
                    hint = "Use <execute> for tools or <message> for text responses";
                }

                errorContent.put("hint", hint);
                errorContent.put("attempt", attempt);
                errorContent.put("max_attempts", MAX_RETRIES);
                conversationManager.addError("formatting_error", errorContent);

                // Re-add loading message (only on first attempt for initial parse)
                if (isInitialParse && attempt == 1) {
                }

                conversationQueue.publishState(conversationManager.getConversationStateJson());

                // Send error back to AI for correction
                String retryRequest = buildAIRequestFromHistory();
                logger.log("Sending formatting error back to AI for correction (attempt " + (attempt + 1) + ")");
                BridgeQueue.AIResponse retryResponse = submitToBridge(retryRequest);
                logger.log("Got AI response: " + retryResponse.responseXml);

                // Update responseXml for next iteration
                responseXml = retryResponse.responseXml;
            }
        }

        // Should never reach here due to throw in loop, but compiler needs this
        throw new IllegalArgumentException("Failed to parse AI response");
    }

    private String parseVerdict(String messageContent) {
        if (messageContent == null) {
            return "PASS";
        }

        if (messageContent.contains("Verdict: FAIL") || messageContent.contains("Verdict:FAIL")) {
            return "FAIL";
        }

        if (messageContent.contains("Verdict: PASS") || messageContent.contains("Verdict:PASS")) {
            return "PASS";
        }

        return "PASS";
    }

    /**
     * Handle parsing warnings by injecting them as tool results
     * so the AI knows what was stripped/modified
     */
    private void handleParsingWarnings(ResponseParser.ParsedResponse parsed) throws InterruptedException {
        if (parsed.warnings != null && !parsed.warnings.isEmpty()) {

            // Add warnings as a special tool result
            Map<String, Object> warningResult = new HashMap<>();
            warningResult.put("warnings", parsed.warnings);
            conversationManager.addError("format_warning", warningResult);

            conversationQueue.publishState(conversationManager.getConversationStateJson());

            logger.log("Added format warnings to conversation: " + parsed.warnings.size() + " warnings");
        }
    }

    /**
     * Detect if XML response was truncated by checking for unmatched tags
     *
     * @param xml The XML string to check
     * @return true if truncation is detected (more opening tags than closing tags)
     */
    private boolean detectTruncation(String xml) {
        if (xml == null || xml.isEmpty()) {
            return false;
        }

        // Count opening and closing tags for main XML elements
        int executeOpen = countOccurrences(xml, "<execute>");
        int executeClose = countOccurrences(xml, "</execute>");
        int messageOpen = countOccurrences(xml, "<message>");
        int messageClose = countOccurrences(xml, "</message>");
        int toolOpen = countOccurrences(xml, "<tool");
        int toolClose = countOccurrences(xml, "</tool>");
        int parameterOpen = countOccurrences(xml, "<parameter");
        int parameterClose = countOccurrences(xml, "</parameter>");

        // If any opening tags exceed closing tags, it's truncated
        if (executeOpen > executeClose ||
            messageOpen > messageClose ||
            toolOpen > toolClose ||
            parameterOpen > parameterClose) {
            return true;
        }

        return false;
    }

    /**
     * Count occurrences of a substring in a string
     */
    private int countOccurrences(String str, String substring) {
        int count = 0;
        int index = 0;
        while ((index = str.indexOf(substring, index)) != -1) {
            count++;
            index += substring.length();
        }
        return count;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ChecklistManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import java.util.*;

/**
 * Manages todo checklists
 */
public class ChecklistManager {
    private final ChecklistParser parser;
    private final ILogger logger;
    private List<ChecklistItem> currentChecklist;
    private int lastReviewCheckpoint = 0;
    private int codingItemsCompletedSinceReview = 0;

    public ChecklistManager(ILogger logger) {
        this.parser = new ChecklistParser();
        this.logger = logger;
        this.currentChecklist = new ArrayList<>();
    }

    public void updateFromResponse(String aiResponse) {
        // TODO: Parse and update checklist
        // Parse AI response to extract todo list with item_type for each item
        logger.log("Checklist updated");
    }

    public List<ChecklistItem> getCurrentChecklist() {
        return currentChecklist;
    }

    public ChecklistItem addItem(String content, String priority, String itemType) {
        String id = "todo-" + (currentChecklist.size() + 1);
        ChecklistItem item = new ChecklistItem(id, content, itemType);
        item.priority = priority;
        currentChecklist.add(item);
        logger.log("Added checklist item: " + id);
        return item;
    }

    public List<ChecklistItem> getItems() {
        return new ArrayList<>(currentChecklist);
    }

    public ChecklistItem getNextPendingItem() {
        for (ChecklistItem item : currentChecklist) {
            if (!item.completed) {
                return item;
            }
        }
        return null;
    }

    public boolean deleteItem(String id) {
        boolean removed = currentChecklist.removeIf(item -> item.id.equals(id));
        if (removed) {
            logger.log("Deleted checklist item: " + id);
        }
        return removed;
    }

    public boolean completeItem(String id) {
        for (ChecklistItem item : currentChecklist) {
            if (item.id.equals(id)) {
                item.completed = true;
                item.status = "completed";
                logger.log("Completed checklist item: " + id);

                if ("coding".equals(item.itemType)) {
                    codingItemsCompletedSinceReview++;
                }

                return true;
            }
        }
        return false;
    }

    public boolean shouldTriggerReview() {
        if (codingItemsCompletedSinceReview == 0) {
            return false;
        }

        int completedItems = countCompletedItems();
        int totalItems = currentChecklist.size();

        if (completedItems == totalItems) {
            return true;
        }

        if (totalItems > 5) {
            int checkpointInterval = 5;
            int nextCheckpoint = lastReviewCheckpoint + checkpointInterval;

            if (completedItems >= nextCheckpoint) {
                return true;
            }
        }

        return false;
    }

    public void markReviewCompleted() {
        lastReviewCheckpoint = countCompletedItems();
        codingItemsCompletedSinceReview = 0;
        logger.log("Review completed, checkpoint at item " + lastReviewCheckpoint);
    }

    public void clearChecklist() {
        currentChecklist.clear();
        lastReviewCheckpoint = 0;
        codingItemsCompletedSinceReview = 0;
        logger.log("Checklist cleared");
    }

    private int countCompletedItems() {
        int count = 0;
        for (ChecklistItem item : currentChecklist) {
            if (item.completed) {
                count++;
            }
        }
        return count;
    }

    public boolean hasNextPhaseChange() {
        ChecklistItem lastCompleted = getLastCompletedItem();
        ChecklistItem nextIncomplete = getNextIncompleteItem();

        if (lastCompleted != null && nextIncomplete != null) {
            return !lastCompleted.itemType.equals(nextIncomplete.itemType);
        }
        return false;
    }

    public String getNextItemType() {
        ChecklistItem nextIncomplete = getNextIncompleteItem();
        return nextIncomplete != null ? nextIncomplete.itemType : null;
    }

    private ChecklistItem getLastCompletedItem() {
        for (int i = currentChecklist.size() - 1; i >= 0; i--) {
            if (currentChecklist.get(i).completed) {
                return currentChecklist.get(i);
            }
        }
        return null;
    }

    private ChecklistItem getNextIncompleteItem() {
        for (ChecklistItem item : currentChecklist) {
            if (!item.completed) {
                return item;
            }
        }
        return null;
    }

    public boolean hasCompletedAllCodingBeforeTesting() {
        List<ChecklistItem> coding = new ArrayList<>();
        List<ChecklistItem> testing = new ArrayList<>();

        for (ChecklistItem item : currentChecklist) {
            if ("coding".equals(item.itemType)) {
                coding.add(item);
            } else if ("testing".equals(item.itemType)) {
                testing.add(item);
            }
        }

        if (coding.isEmpty() || testing.isEmpty()) {
            return false;
        }

        for (ChecklistItem item : coding) {
            if (!item.completed) {
                return false;
            }
        }

        for (ChecklistItem item : testing) {
            if (!item.completed) {
                return true;
            }
        }

        return false;
    }

    // Note: No formatForDisplay() method needed
    // Checklist data is sent as raw JSON to browser via conversation state
    // Browser JavaScript will render the checklist with proper formatting

    public static class ChecklistItem {
        public String id;
        public String content;
        public boolean completed;
        public String status;  // "pending", "in_progress", "completed"
        public String priority;  // "high", "medium", "low"
        public String itemType; // "coding" or "testing"

        public ChecklistItem(String id, String content, String itemType) {
            this.id = id;
            this.content = content;
            this.completed = false;
            this.status = "pending";
            this.priority = "medium";
            this.itemType = itemType;
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ChecklistParser.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.aiprocessor.*;
import java.util.*;

/**
 * Parses checklist XML from AI responses
 */
public class ChecklistParser {

    public List<ChecklistManager.ChecklistItem> parse(String aiResponse) {
        // TODO: Extract <checklist> block
        // TODO: Extract <item> elements
        return new ArrayList<>();
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/CommandDispatcher.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import java.util.*;

/**
 * Dispatches special commands
 */
public class CommandDispatcher {
    private final Map<String, ICommand> commands;
    private final ILogger logger;

    public CommandDispatcher(
        IClipboardManager clipboard,
        IConfigManager config,
        ILogger logger,
        UndoStack undoStack
    ) {
        this.logger = logger;
        this.commands = new HashMap<>();

        // Register commands
        commands.put("help", new HelpCommand(logger));
        commands.put("copyjs", new CopyJSCommand(clipboard, logger));
        commands.put("mousecapture", new MouseCaptureCommand(clipboard, config, logger));
        commands.put("quit", new QuitCommand(logger));
        commands.put("undo", new UndoCommand(undoStack, logger));

        logger.log("CommandDispatcher initialized with " + commands.size() + " commands: " + commands.keySet());
    }

    /**
     * Dispatch command to appropriate handler
     *
     * TODO: Add input state validation per user-interface-spec.md lines 319-335
     * - Commands can only execute in WAITING_FOR_INPUT state
     * - During AI_PROCESSING or TOOL_EXECUTING: must ESC ESC first
     * - Return error if called during wrong state:
     *   "[X] Cannot execute command while AI is processing
     *    | Press ESC ESC to interrupt, then try again"
     * - Exception: "copyjs" can execute in any state (setup command)
     */
    public CommandResult dispatch(String commandName, String[] args) {
        logger.log("CommandDispatcher: Dispatching command '" + commandName + "' with " + args.length + " args");

        ICommand command = commands.get(commandName);
        if (command == null) {
            logger.log("CommandDispatcher ERROR: Unknown command '" + commandName + "'");
            return new CommandResult(false, "Unknown command: " + commandName);
        }

        try {
            CommandResult result = command.execute(args);
            logger.log("CommandDispatcher: Command '" + commandName + "' executed, success=" + result.success);
            return result;
        } catch (Exception e) {
            logger.log("CommandDispatcher ERROR: Exception executing '" + commandName + "': " + e.getMessage());
            e.printStackTrace();
            return new CommandResult(false, "Command error: " + e.getMessage());
        }
    }

    public Set<String> getAvailableCommands() {
        return commands.keySet();
    }

    public static class CommandResult {
        public boolean success;
        public String message;

        public CommandResult(boolean success, String message) {
            this.success = success;
            this.message = message;
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/CompactionEngine.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;

/**
 * 4-level hierarchical compaction system
 *
 * Per context-spec.md:
 * - Level 1->2: Groups 5-15 related messages into message_group_detailed with summary
 * - Level 2->3: Clusters groups into message_group_highlevel with group references
 * - Level 3->4: Consolidates clusters into project_summary with comprehensive content
 * - AI-driven: Uses AI to create logical work chunks based on features/tasks
 */
public class CompactionEngine {
    private final ILogger logger;

    public CompactionEngine(ILogger logger) {
        this.logger = logger;
    }

    /**
     * Compact Level 1 messages into Level 2 message groups
     *
     * TODO: 1. Get oldest Level 1 messages that exceed budget
     * TODO: 2. Build AI prompt with message list (context-spec.md lines 158-191)
     * TODO: 3. Send prompt to AI via BridgeQueue (blocking call)
     * TODO: 4. Parse AI response JSON array of groups:
     *    [
     *      {
     *        "id": "grp_001",
     *        "summary": "User requested circle area calculation...",
     *        "message_ids": ["msg_045", "msg_046", ...]
     *      }
     *    ]
     * TODO: 5. Create ConversationState.Message objects with type=message_group_detailed
     * TODO: 6. Set fields: id (use grp_XXX format), summary, messages (array of grouped message objects)
     * TODO: 7. Remove original Level 1 messages from state
     * TODO: 8. Add Level 2 group messages to state
     * TODO: 9. Return list of created group messages
     */
    public java.util.List<ConversationState.Message> compactLevel1ToLevel2(
        ConversationState state,
        java.util.List<ConversationState.Message> oldestMessages
    ) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Compact Level 2 groups into Level 3 high-level summaries
     *
     * TODO: 1. Get oldest Level 2 groups that exceed budget
     * TODO: 2. Build AI prompt with group summaries (context-spec.md lines 193-226)
     * TODO: 3. Send prompt to AI via BridgeQueue
     * TODO: 4. Parse AI response for Level 3 groups:
     *    {
     *      "id": "hlg_001",
     *      "summary": "Calculator feature development phase...",
     *      "groups": ["grp_001", "grp_002", "grp_003"]
     *    }
     * TODO: 5. Create ConversationState.Message with type=message_group_highlevel
     * TODO: 6. Set fields: id (use hlg_XXX format), summary, groups (array of group ids), file_changes (optional)
     * TODO: 7. Remove original Level 2 groups from state
     * TODO: 8. Add Level 3 cluster to state
     * TODO: 9. Return list of created cluster messages
     */
    public java.util.List<ConversationState.Message> compactLevel2ToLevel3(
        ConversationState state,
        java.util.List<ConversationState.Message> oldestGroups
    ) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Compact Level 3 clusters into Level 4 project summary
     *
     * TODO: 1. Get existing Level 4 summary (if any) and oldest Level 3 clusters
     * TODO: 2. Build AI prompt with cluster summaries and current global summary
     * TODO: 3. Send prompt to AI via BridgeQueue
     * TODO: 4. Parse AI response for updated global summary:
     *    {
     *      "summary": "Extended calculator application with geometric shape calculations..."
     *    }
     * TODO: 5. Create or update ConversationState.Message with type=project_summary
     * TODO: 6. Set content field with comprehensive ultra-compact summary
     * TODO: 7. Remove compacted Level 3 clusters from state
     * TODO: 8. Update or add Level 4 summary in state
     * TODO: 9. Return the project summary message
     */
    public ConversationState.Message compactLevel3ToLevel4(
        ConversationState state,
        java.util.List<ConversationState.Message> oldestClusters,
        ConversationState.Message existingSummary
    ) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Build Level 1->2 compaction prompt per context-spec.md
     *
     * TODO: Format messages as list with ids, types, content
     * TODO: Include prompt template from context-spec.md lines 158-191
     * TODO: Return formatted prompt string
     */
    private String buildLevel1CompactionPrompt(java.util.List<ConversationState.Message> messages) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Build Level 2->3 compaction prompt per context-spec.md
     *
     * TODO: Format groups with their summaries and group_ids
     * TODO: Include prompt template from context-spec.md lines 193-226
     * TODO: Return formatted prompt string
     */
    private String buildLevel2CompactionPrompt(java.util.List<ConversationState.Message> groups) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Build Level 3->4 compaction prompt per context-spec.md
     *
     * TODO: Format clusters with their summaries
     * TODO: Include existing global summary if present
     * TODO: Include prompt template from context-spec.md lines 193-226
     * TODO: Return formatted prompt string
     */
    private String buildLevel3CompactionPrompt(
        java.util.List<ConversationState.Message> clusters,
        ConversationState.Message existingSummary
    ) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ContextManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import com.codeboss.javalayer.aiprocessor.*;

/**
 * Manages context window and character limits for 4-level hierarchical compaction
 *
 * Per context-spec.md:
 * - Proactively triggers compaction at 95% of maxMessageChars
 * - Normal budgets: Level 1=75%, Level 2=17.5%, Level 3=5%, Level 4=2.5%
 * - Compaction budgets: Level 1=37.5%, Level 2=8.75%, Level 3=2.5%, Level 4=2.5%
 */
public class ContextManager {
    private final IConfigManager config;
    private final ILogger logger;
    private final CompactionEngine compactionEngine;
    private int currentCharCount;
    private int maxMessageChars;

    public ContextManager(IConfigManager config, ILogger logger) {
        this.config = config;
        this.logger = logger;
        this.compactionEngine = new CompactionEngine(logger);
        this.maxMessageChars = config.getMaxMessageChars();
        this.currentCharCount = 0;
    }

    /**
     * Calculate total character count of conversation
     *
     * TODO: Iterate through all messages in ConversationState.history
     * TODO: Count characters in: content, result, parameters fields
     * TODO: Include JSON overhead (ids, timestamps, type fields)
     * TODO: Exclude: mode_transition messages, internal system messages
     * TODO: Return total character count
     */
    public int calculateTotalCharacterCount(ConversationState state) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Check if compaction should be triggered (95% threshold)
     *
     * TODO: Calculate current character count via calculateTotalCharacterCount()
     * TODO: Calculate threshold = (int)(maxMessageChars * 0.95)
     * TODO: Return true if currentCount >= threshold
     */
    public boolean shouldCompact(ConversationState state) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Calculate normal operation budgets (before compaction)
     *
     * TODO: Level 1 budget = maxMessageChars * 0.75 (75%)
     * TODO: Level 2 budget = maxMessageChars * 0.175 (17.5%)
     * TODO: Level 3 budget = maxMessageChars * 0.05 (5%)
     * TODO: Level 4 budget = maxMessageChars * 0.025 (2.5%)
     * TODO: Return as array [level1, level2, level3, level4]
     */
    public int[] calculateNormalBudgets() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Calculate compaction budgets (50% reduction for Levels 1-3)
     *
     * TODO: Level 1 budget = maxMessageChars * 0.375 (37.5%, half of 75%)
     * TODO: Level 2 budget = maxMessageChars * 0.0875 (8.75%, half of 17.5%)
     * TODO: Level 3 budget = maxMessageChars * 0.025 (2.5%, half of 5%)
     * TODO: Level 4 budget = maxMessageChars * 0.025 (2.5%, unchanged)
     * TODO: Return as array [level1, level2, level3, level4]
     */
    public int[] calculateCompactionBudgets() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Calculate character count for specific level
     *
     * TODO: Level 1: Sum characters in messages with type=user_msg, assistant_msg, tool_use, tool_result
     * TODO: Level 2: Sum characters in messages with type=message_group_detailed
     * TODO: Level 3: Sum characters in messages with type=message_group_highlevel
     * TODO: Level 4: Sum characters in messages with type=project_summary
     * TODO: Return character count for specified level
     */
    public int calculateLevelCharacterCount(ConversationState state, int level) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Trigger proactive compaction
     *
     * TODO: 1. Calculate compaction budgets (50% reduction)
     * TODO: 2. Check Level 1 - if over budget, compact Level 1->2 via compactionEngine
     * TODO: 3. Check Level 2 - if over budget, compact Level 2->3 via compactionEngine
     * TODO: 4. Check Level 3 - if over budget, compact Level 3->4 via compactionEngine
     * TODO: 5. Update ConversationState with compacted messages
     * TODO: 6. Write updated conversation to conversation.jsonl
     * TODO: 7. Log compaction completion
     */
    public void compact(ConversationState state) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    public int getCurrentCharCount() {
        return currentCharCount;
    }

    public int getMaxMessageChars() {
        return maxMessageChars;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ContinuationHandler.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;

/**
 * Handles multi-turn continuation
 * STUBBED for MVP
 */
public class ContinuationHandler {
    private final ILogger logger;

    public ContinuationHandler(ILogger logger) {
        this.logger = logger;
    }

    public boolean needsContinuation(String response) {
        // TODO: Implement (STUBBED for MVP)
        return false;
    }

    public String buildContinuationPrompt(String previousResponse) {
        // TODO: Implement (STUBBED for MVP)
        return "Continue...";
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ConversationManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import java.util.*;
import java.io.*;
import java.nio.file.*;

/**
 * Manages conversation state and operations
 *
 * Used by AIProcessorThread to build and manipulate conversation
 * This is NOT thread-safe - only Thread 2 (AIProcessorThread) should use it
 */
public class ConversationManager {
    private final ChecklistManager checklistManager;
    private final ConversationState state;
    private final ILogger logger;
    private final String workingDirectory;

    // TODO: Add per user-interface-spec.md
    private boolean awaitingUndoConfirmation;  // True when waiting for y/n/+num/-num response
    private int pendingUndoCount;              // Count for pending undo operation

    // Approval flow state - plan approval
    private boolean awaitingPlanApproval = false;
    private String pendingChecklistJson = null;
    private String pendingPlanDescription = null;

    // Approval flow state - test command approval
    private boolean awaitingTestCommandApproval = false;
    private String pendingTestCommandName = null;
    private String pendingTestCommand = null;
    private String pendingTestDescription = null;

    // Flag to indicate execution just started after plan approval
    private boolean justStartedExecution = false;

    public ConversationManager(
        ChecklistManager checklistManager,
        ILogger logger,
        String workingDirectory
    ) {
        this.checklistManager = checklistManager;
        this.logger = logger;
        this.workingDirectory = workingDirectory;
        this.state = new ConversationState();

        // Create .agent directory if it doesn't exist
        try {
            Path agentDir = Paths.get(workingDirectory, ".agent");
            if (!Files.exists(agentDir)) {
                Files.createDirectories(agentDir);
            }

            // Load conversation history from file if it exists
            Path conversationFile = Paths.get(workingDirectory, ".agent", "conversation.jsonl");
            if (Files.exists(conversationFile)) {
                loadFromFile(conversationFile.toString());
            }

            // If no conversation history exists, add initial greeting message
            if (state.getHistory().isEmpty()) {
                addAssistantMessage("How can I help you today?");
                state.setStatus("complete"); // Set status to complete so UI doesn't show loading
            }
        } catch (IOException e) {
            logger.log("Warning: Could not create .agent directory: " + e.getMessage());
        } catch (Exception e) {
            logger.log("Warning: Could not load conversation history: " + e.getMessage());
        }
    }

    public ConversationState.Message addUserMessage(String text) {
        ConversationState.Message msg = new ConversationState.Message("user_msg", text);
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added user message: " + msg.id);
        persistMessage(msg);
        return msg;
    }

    public ConversationState.Message addLoadingMessage() {
        ConversationState.Message msg = new ConversationState.Message("loading", (String)null);
        state.addMessage(msg);
        logger.log("Added loading message");
        // Don't persist loading messages - they're ephemeral
        return msg;
    }

    public void removeLoadingMessage() {
        List<ConversationState.Message> history = state.getHistory();
        for (int i = history.size() - 1; i >= 0; i--) {
            if ("loading".equals(history.get(i).type)) {
                history.remove(i);
                logger.log("Removed loading message");
                return;
            }
        }
    }

    public ConversationState.Message addToolUse(String toolName, Map<String, Object> parameters) {
        ConversationState.Message msg = new ConversationState.Message("tool_use", null, toolName, parameters);
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added tool_use: " + toolName + " (" + msg.id + ")");
        persistMessage(msg);
        return msg;
    }

    // Overload for tool results WITH tool_use_id (most cases)
    public ConversationState.Message addToolResult(String toolName, Map<String, Object> result, String toolUseId) {
        ConversationState.Message msg = new ConversationState.Message("tool_result", toolName, result, null, true);
        msg.tool_use_id = toolUseId;  // Link to the tool_use that created this result
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added tool_result: " + toolName + " (" + msg.id + ") for tool_use: " + toolUseId);
        persistMessage(msg);
        return msg;
    }

    // Overload for tool results WITHOUT tool_use_id (special cases like task_start notifications)
    public ConversationState.Message addToolResult(String toolName, Map<String, Object> result) {
        ConversationState.Message msg = new ConversationState.Message("tool_result", toolName, result, null, true);
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added tool_result: " + toolName + " (" + msg.id + ")");
        persistMessage(msg);
        return msg;
    }

    public ConversationState.Message addError(String errorType, Map<String, Object> errorDetails) {
        ConversationState.Message msg = new ConversationState.Message("error", errorType, errorDetails);
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added error: " + errorType + " (" + msg.id + ")");
        persistMessage(msg);
        return msg;
    }

    public ConversationState.Message addAssistantMessage(String text) {
        ConversationState.Message msg = new ConversationState.Message("assistant_msg", text);
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added assistant message: " + msg.id);
        persistMessage(msg);
        return msg;
    }

    public ConversationState.Message addCommandResultMessage(String clipboardData) {
        ConversationState.Message msg = new ConversationState.Message("command_result", (String)null);
        // Store clipboard data in result field
        Map<String, Object> result = new HashMap<>();
        result.put("clipboard_data", clipboardData);
        msg.result = result;
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added command_result message with " + clipboardData.length() + " bytes: " + msg.id);
        persistMessage(msg);
        return msg;
    }

    public ConversationState.Message addSystemMessage(String text) {
        ConversationState.Message msg = new ConversationState.Message("system_msg", text);
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added system message: " + msg.id);
        persistMessage(msg);
        return msg;
    }

    public ConversationState.Message addModeTransition(String transition, String trigger) {
        ConversationState.Message msg = new ConversationState.Message("mode_transition", transition, trigger);
        state.addMessage(msg);
        state.incrementMessageCount();
        logger.log("Added mode transition: " + transition + " (trigger: " + trigger + ")");
        persistMessage(msg);
        return msg;
    }

    public String getModeDisplayText(String mode) {
        // Convert mode name to display text for UI
        // Server returns plain text, browser adds "| " prefix and gray styling
        // planning -> "Planning..."
        // execution -> "Coding..."
        // testing -> "Testing..."
        // review -> "Reviewing..."
        switch (mode) {
            case "planning": return "Planning...";
            case "execution": return "Coding...";
            case "testing": return "Testing...";
            case "review": return "Reviewing...";
            default: return mode;
        }
    }

    public String getConversationStateJson() {
        List<ConversationState.Message> history = state.getHistory();
        int messageCount = history.size();

        // Log message count and last 6 message IDs to detect out-of-order issues
        StringBuilder lastMsgs = new StringBuilder();
        int start = Math.max(0, messageCount - 6);
        for (int i = start; i < messageCount; i++) {
            if (i > start) lastMsgs.append(", ");
            ConversationState.Message msg = history.get(i);
            lastMsgs.append(msg.id);
        }
        logger.log("[PUBLISH] Serializing state with " + messageCount + " messages, status=" + state.getStatus()
                   + ", last 6: [" + lastMsgs.toString() + "]");

        StringBuilder json = new StringBuilder();
        json.append("{");
        json.append("\"status\":\"").append(state.getStatus()).append("\",");
        json.append("\"mode\":\"").append(state.getCurrentMode()).append("\",");
        json.append("\"inputState\":\"").append(state.getInputState()).append("\",");
        json.append("\"messages\":[");

        for (int i = 0; i < history.size(); i++) {
            if (i > 0) json.append(",");
            ConversationState.Message msg = history.get(i);

            json.append("{");
            json.append("\"id\":\"").append(msg.id).append("\",");
            json.append("\"type\":\"").append(msg.type).append("\",");
            json.append("\"timestamp\":").append(msg.timestamp);

            if (msg.content != null) {
                json.append(",\"content\":\"").append(escapeJson(msg.content)).append("\"");
            }
            if (msg.toolName != null) {
                json.append(",\"toolName\":\"").append(msg.toolName).append("\"");
            }
            if (msg.parameters != null) {
                json.append(",\"parameters\":").append(mapToJson(msg.parameters));
            }
            if (msg.result != null) {
                json.append(",\"result\":").append(mapToJson(msg.result));
            }
            if (msg.tool_use_id != null) {
                json.append(",\"tool_use_id\":\"").append(msg.tool_use_id).append("\"");
            }
            if (msg.mode_transition != null) {
                json.append(",\"mode_transition\":\"").append(msg.mode_transition).append("\"");
            }
            if (msg.trigger != null) {
                json.append(",\"trigger\":\"").append(msg.trigger).append("\"");
            }

            json.append("}");
        }

        json.append("]");
        json.append("}");

        return json.toString();
    }

    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    private String mapToJson(Map<String, Object> map) {
        StringBuilder json = new StringBuilder();
        json.append("{");

        // Sort keys alphabetically for consistent JSON output
        java.util.List<String> sortedKeys = new java.util.ArrayList<>(map.keySet());
        java.util.Collections.sort(sortedKeys);

        int count = 0;
        for (String key : sortedKeys) {
            if (count++ > 0) json.append(",");
            json.append("\"").append(key).append("\":");
            json.append(valueToJson(map.get(key)));
        }
        json.append("}");
        return json.toString();
    }

    @SuppressWarnings("unchecked")
    private String valueToJson(Object value) {
        if (value == null) {
            return "null";
        } else if (value instanceof String) {
            return "\"" + escapeJson((String)value) + "\"";
        } else if (value instanceof Number || value instanceof Boolean) {
            return value.toString();
        } else if (value instanceof Map) {
            return mapToJson((Map<String, Object>)value);
        } else if (value instanceof java.util.List) {
            StringBuilder json = new StringBuilder();
            json.append("[");
            java.util.List<?> list = (java.util.List<?>)value;
            for (int i = 0; i < list.size(); i++) {
                if (i > 0) json.append(",");
                json.append(valueToJson(list.get(i)));
            }
            json.append("]");
            return json.toString();
        } else {
            return "\"" + escapeJson(String.valueOf(value)) + "\"";
        }
    }

    /**
     * Persist a message to conversation.jsonl
     * Does NOT persist loading messages (they are ephemeral)
     */
    private void persistMessage(ConversationState.Message message) {
        // Don't persist loading messages
        if ("loading".equals(message.type)) {
            return;
        }

        try {
            Path conversationFile = Paths.get(workingDirectory, ".agent", "conversation.jsonl");

            // Build JSON line for this message
            StringBuilder json = new StringBuilder();
            json.append("{");
            json.append("\"id\":\"").append(message.id).append("\",");
            json.append("\"timestamp\":").append(message.timestamp).append(",");
            json.append("\"type\":\"").append(message.type).append("\"");

            if (message.content != null) {
                json.append(",\"content\":\"").append(escapeJson(message.content)).append("\"");
            }
            if (message.toolName != null) {
                json.append(",\"toolName\":\"").append(message.toolName).append("\"");
            }
            if (message.parameters != null) {
                json.append(",\"parameters\":").append(mapToJson(message.parameters));
            }
            if (message.result != null) {
                json.append(",\"result\":").append(mapToJson(message.result));
            }
            if (message.tool_use_id != null) {
                json.append(",\"tool_use_id\":\"").append(message.tool_use_id).append("\"");
            }
            if (message.mode_transition != null) {
                json.append(",\"mode_transition\":\"").append(message.mode_transition).append("\"");
            }
            if (message.trigger != null) {
                json.append(",\"trigger\":\"").append(message.trigger).append("\"");
            }

            json.append("}\n");

            // Append to file
            Files.write(conversationFile, json.toString().getBytes(),
                       StandardOpenOption.CREATE, StandardOpenOption.APPEND);

        } catch (IOException e) {
            logger.log("Warning: Could not persist message to conversation.jsonl: " + e.getMessage());
        }
    }

    public void markComplete() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    public void markError() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    public String buildAIRequest() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    public ConversationState getState() {
        return state;
    }

    public void loadFromFile(String path) throws Exception {
        Path conversationFile = Paths.get(path);
        if (!Files.exists(conversationFile)) {
            logger.log("No conversation file found at: " + path);
            return;
        }

        logger.log("Loading conversation from: " + path);
        List<String> lines = Files.readAllLines(conversationFile);

        for (String line : lines) {
            if (line.trim().isEmpty()) continue;

            try {
                ConversationState.Message msg = parseMessageFromJson(line);
                if (msg != null) {
                    state.addMessage(msg);
                    state.incrementMessageCount();
                }
            } catch (Exception e) {
                logger.log("Warning: Could not parse message line: " + e.getMessage());
            }
        }

        logger.log("Loaded " + state.getHistory().size() + " messages from conversation file");
    }

    private ConversationState.Message parseMessageFromJson(String json) {
        // Simple JSON parsing without external libraries
        String type = extractJsonString(json, "type");
        String content = extractJsonString(json, "content");

        // Create message based on type
        ConversationState.Message msg;
        if ("user_msg".equals(type) || "assistant_msg".equals(type)) {
            msg = new ConversationState.Message(type, content);
        } else {
            // For other types, use basic constructor
            msg = new ConversationState.Message(type != null ? type : "", content);
        }

        // Extract and override fields
        String id = extractJsonString(json, "id");
        if (id != null) msg.id = id;

        String timestampStr = extractJsonString(json, "timestamp");
        if (timestampStr != null && !timestampStr.isEmpty()) {
            try {
                msg.timestamp = Long.parseLong(timestampStr);
            } catch (NumberFormatException e) {
                msg.timestamp = System.currentTimeMillis();
            }
        }

        String toolName = extractJsonString(json, "toolName");
        if (toolName != null) msg.toolName = toolName;

        String modeTransition = extractJsonString(json, "mode_transition");
        if (modeTransition != null) msg.mode_transition = modeTransition;

        String trigger = extractJsonString(json, "trigger");
        if (trigger != null) msg.trigger = trigger;

        String isErrorStr = extractJsonString(json, "isError");
        if ("true".equals(isErrorStr) && msg.isError != null) {
            msg.isError = Boolean.TRUE;
        }

        // For parameters and result, we'll store them as simple maps
        // This is a simplified implementation - a full JSON parser would be better
        // but this works for our use case

        return msg;
    }

    private String extractJsonString(String json, String field) {
        String pattern = "\"" + field + "\":\"";
        int start = json.indexOf(pattern);
        if (start == -1) return null;

        start += pattern.length();
        int end = start;
        while (end < json.length() && json.charAt(end) != '"') {
            if (json.charAt(end) == '\\') {
                end++; // Skip escaped character
            }
            end++;
        }

        if (end >= json.length()) return null;
        return json.substring(start, end).replace("\\n", "\n").replace("\\\"", "\"");
    }

    public void recoverModeFromHistory() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Transition input state and publish update
     *
     * TODO: Implementation per user-interface-spec.md lines 36-66
     * 1. Set state.setInputState(newInputState)
     * 2. Valid states: WAITING_FOR_INPUT, AI_PROCESSING, TOOL_EXECUTING
     * 3. Log transition: "Input state: oldState -> newState"
     * 4. Call publishStateUpdate() to send to web UI via SSE
     *
     * State transitions:
     * - WAITING_FOR_INPUT -> AI_PROCESSING (user sends message)
     * - AI_PROCESSING -> TOOL_EXECUTING (AI returns tool uses)
     * - TOOL_EXECUTING -> AI_PROCESSING (tools complete)
     * - AI_PROCESSING -> WAITING_FOR_INPUT (AI response complete)
     * - Any state -> WAITING_FOR_INPUT (ESC ESC interrupt)
     */
    public void transitionInputState(String newInputState) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Handle user response to undo confirmation
     *
     * TODO: Implementation per user-interface-spec.md lines 227-273
     * 1. Check if awaitingUndoConfirmation is true, else return error
     * 2. Parse response:
     *    - "y" or "Y" -> execute undo
     *    - "n" or "N" -> cancel
     *    - "+<num>" -> increase pendingUndoCount by num, regenerate prompt
     *    - "-<num>" -> decrease pendingUndoCount by num, regenerate prompt
     *    - anything else -> return error "Invalid response"
     * 3. If y: call undoStack.undo(pendingUndoCount), reset flags, return success
     * 4. If n: reset flags, return "Undo cancelled"
     * 5. If +/-: update count, validate bounds, regenerate prompt from UndoCommand
     */
    public String handleUndoConfirmation(String response, UndoStack undoStack) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Check if setup is complete before processing message
     *
     * TODO: Implementation per user-interface-spec.md lines 487-528
     * 1. Call setupManager.isSetupComplete()
     * 2. If false: return setupManager.getSetupRequiredError()
     * 3. If true: return null (no error)
     * 4. This is checked before submitting message to AI
     */
    public String checkSetupRequired(SetupManager setupManager) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Check if bridge connection is active
     *
     * TODO: Implementation per user-interface-spec.md lines 533-539
     * 1. Check bridge connection health (via BridgeQueue or ClipboardManager)
     * 2. If connection lost: return error message:
     *    "[X] Cannot send messages to AI yet
     *     | Bridge connection lost. Run \"copyjs\" to re-establish connection"
     * 3. If connection active: return null (no error)
     */
    public String checkBridgeConnection() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    // Approval flow methods

    public void setPendingApproval(String description, String checklistJson) {
        this.awaitingPlanApproval = true;
        this.pendingPlanDescription = description;
        this.pendingChecklistJson = checklistJson;
        logger.log("Set pending approval: " + description);
    }

    public boolean isAwaitingApproval() {
        return awaitingPlanApproval;
    }

    public String getPendingChecklistJson() {
        return pendingChecklistJson;
    }

    public String getPendingPlanDescription() {
        return pendingPlanDescription;
    }

    public void clearPendingApproval() {
        this.awaitingPlanApproval = false;
        this.pendingChecklistJson = null;
        this.pendingPlanDescription = null;
        logger.log("Cleared pending approval");
    }

    public void setJustStartedExecution() {
        this.justStartedExecution = true;
        logger.log("Marked execution as just started (will show first task notification)");
    }

    public boolean isJustStartedExecution() {
        return justStartedExecution;
    }

    public void clearJustStartedExecution() {
        this.justStartedExecution = false;
    }

    // Test command approval flow methods

    public void setPendingTestCommand(String name, String command, String description) {
        this.awaitingTestCommandApproval = true;
        this.pendingTestCommandName = name;
        this.pendingTestCommand = command;
        this.pendingTestDescription = description;
        logger.log("Set pending test command approval: " + name);
    }

    public boolean isAwaitingTestCommandApproval() {
        return awaitingTestCommandApproval;
    }

    public String getPendingTestCommandName() {
        return pendingTestCommandName;
    }

    public String getPendingTestCommand() {
        return pendingTestCommand;
    }

    public String getPendingTestDescription() {
        return pendingTestDescription;
    }

    public void clearPendingTestCommand() {
        this.awaitingTestCommandApproval = false;
        this.pendingTestCommandName = null;
        this.pendingTestCommand = null;
        this.pendingTestDescription = null;
        logger.log("Cleared pending test command approval");
    }

    public String getWorkingDirectory() {
        return workingDirectory;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ConversationRenderer.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import java.util.*;

/**
 * Renders conversation history into AI-compatible format
 *
 * Responsibilities:
 * - Filter out meta messages (loading, etc.)
 * - Convert internal message types to AI message format
 * - Format messages with proper roles (user/assistant)
 * - Build JSON structure for AI requests
 */
public class ConversationRenderer {

    /**
     * Render conversation history as JSON messages array for AI
     *
     * @param history List of conversation messages
     * @return JSON string representing the messages array (without outer brackets)
     */
    public String renderMessages(List<ConversationState.Message> history) {
        StringBuilder json = new StringBuilder();
        boolean firstMessage = true;

        for (ConversationState.Message msg : history) {
            // Skip meta messages (loading, etc.)
            if (isMetaMessage(msg.type)) {
                continue;
            }

            if (!firstMessage) {
                json.append(",");
            }
            firstMessage = false;

            // Render message based on type
            switch (msg.type) {
                case "user_msg":
                    json.append(renderUserMessage(msg));
                    break;
                case "assistant_msg":
                    json.append(renderAssistantMessage(msg));
                    break;
                case "tool_use":
                    json.append(renderToolUse(msg));
                    break;
                case "tool_result":
                    json.append(renderToolResult(msg));
                    break;
                case "error":
                    json.append(renderError(msg));
                    break;
            }
        }

        return json.toString();
    }

    /**
     * Check if message type is a meta message that should be filtered out
     */
    private boolean isMetaMessage(String type) {
        return "loading".equals(type);
    }

    /**
     * Render user message
     * Format: {"role":"user","content":"..."}
     */
    private String renderUserMessage(ConversationState.Message msg) {
        return "{\"role\":\"user\",\"content\":\"" + escapeJson(msg.content) + "\"}";
    }

    /**
     * Render assistant message
     * Format: {"role":"assistant","content":"..."}
     */
    private String renderAssistantMessage(ConversationState.Message msg) {
        return "{\"role\":\"assistant\",\"content\":\"" + escapeJson(msg.content) + "\"}";
    }

    /**
     * Render tool use as assistant message with XML format
     * Format: {"role":"assistant","content":"<execute><tool name=\"...\">...</tool></execute>"}
     */
    private String renderToolUse(ConversationState.Message msg) {
        StringBuilder content = new StringBuilder();
        content.append("<execute><tool name=\\\"")
               .append(escapeJson(msg.toolName))
               .append("\\\">");

        if (msg.parameters != null) {
            for (Map.Entry<String, Object> entry : msg.parameters.entrySet()) {
                content.append("<parameter name=\\\"")
                       .append(escapeJson(entry.getKey()))
                       .append("\\\">")
                       .append(escapeJson(String.valueOf(entry.getValue())))
                       .append("</parameter>");
            }
        }

        content.append("</tool></execute>");

        return "{\"role\":\"assistant\",\"content\":\"" + content.toString() + "\"}";
    }

    /**
     * Render tool result as user message
     * Format: {"role":"user","content":"Tool result for ...: ..."}
     */
    private String renderToolResult(ConversationState.Message msg) {
        StringBuilder content = new StringBuilder();
        content.append("Tool result for ")
               .append(escapeJson(msg.toolName))
               .append(": ")
               .append(escapeJson(String.valueOf(msg.result)));

        return "{\"role\":\"user\",\"content\":\"" + content.toString() + "\"}";
    }

    /**
     * Render error as user message
     * Format: {"role":"user","content":"Error (error_type): {...}"}
     */
    private String renderError(ConversationState.Message msg) {
        StringBuilder content = new StringBuilder();
        content.append("Error (")
               .append(escapeJson(msg.toolName))  // toolName stores error type
               .append("): ")
               .append(escapeJson(String.valueOf(msg.result)));

        return "{\"role\":\"user\",\"content\":\"" + content.toString() + "\"}";
    }

    /**
     * Escape string for JSON
     */
    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ConversationState.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import java.util.*;

/**
 * Tracks current conversation state
 *
 * Per user-interface-spec.md lines 36-66:
 * - inputState: WAITING_FOR_INPUT, AI_PROCESSING, TOOL_EXECUTING
 * - status: processing, complete, error
 */
public class ConversationState {
    private boolean busy;
    private int messageCount;
    private String currentMode;
    private String status;
    private String inputState;  // Per user-interface-spec.md: WAITING_FOR_INPUT, AI_PROCESSING, TOOL_EXECUTING
    private List<Message> history;

    public ConversationState() {
        this.busy = false;
        this.messageCount = 0;
        this.currentMode = "planning";
        this.status = "processing";
        this.inputState = "WAITING_FOR_INPUT";  // Default state
        this.history = new ArrayList<>();
    }

    public boolean isBusy() { return busy; }
    public void setBusy(boolean busy) { this.busy = busy; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public int getMessageCount() { return messageCount; }
    public void incrementMessageCount() { this.messageCount++; }

    public String getCurrentMode() { return currentMode; }
    public void setCurrentMode(String mode) { this.currentMode = mode; }

    public String getInputState() { return inputState; }
    public void setInputState(String inputState) { this.inputState = inputState; }

    public List<Message> getHistory() { return history; }
    public void addMessage(Message message) { this.history.add(message); }

    public static class Message {
        public String id;
        public String type;
        public String content;
        public long timestamp;
        public String toolName;
        public Map<String, Object> parameters;  // Structured parameter object (e.g. {"file_path": "Calculator.java"})
        public Map<String, Object> result;      // Structured result object (e.g. {"files": [...], "directory": ".", "count": 2})
        public Boolean isError;                 // True if this is an error message (for tool_result type)
        public String tool_use_id;              // For tool_result: reference to the tool_use message ID that triggered this result
        public String mode_transition;
        public String trigger;
        public List<ChecklistManager.ChecklistItem> todos;  // For todo_list_created messages

        // Fields for compacted message types (per context-spec.md)
        // NOTE: id field serves as group_id for compacted messages (grp_XXX, hlg_XXX, summary_XXX)
        public String summary;               // For message_group_detailed and message_group_highlevel
        public List<Message> messages;       // For message_group_detailed - array of grouped messages
        public List<String> groups;          // For message_group_highlevel - array of group ids
        public List<String> file_changes;    // For message_group_highlevel - optional array of modified files

        public Message(String type, String content) {
            this.id = generateMessageId();
            this.type = type;
            this.content = content;
            this.timestamp = System.currentTimeMillis();
        }

        public Message(String type, String content, String toolName, Map<String, Object> parameters) {
            this.id = generateMessageId();
            this.type = type;
            this.content = content;
            this.toolName = toolName;
            this.parameters = parameters;
            this.timestamp = System.currentTimeMillis();
        }

        // Constructor for tool_result messages (has result field instead of content)
        public Message(String type, String toolName, Map<String, Object> result, Map<String, Object> parameters, boolean isToolResult) {
            this.id = generateMessageId();
            this.type = type;
            this.toolName = toolName;
            this.result = result;
            this.parameters = parameters;
            this.timestamp = System.currentTimeMillis();
            this.isError = false;  // Default to false for backward compatibility
        }

        // Constructor for tool_result messages with error flag
        public Message(String type, String toolName, Map<String, Object> result, Map<String, Object> parameters, boolean isToolResult, boolean isError) {
            this.id = generateMessageId();
            this.type = type;
            this.toolName = toolName;
            this.result = result;
            this.parameters = parameters;
            this.timestamp = System.currentTimeMillis();
            this.isError = isError;
        }

        // Constructor for error messages
        public Message(String type, String errorType, Map<String, Object> errorDetails) {
            this.id = generateMessageId();
            this.type = type;
            this.toolName = errorType;  // Store error type in toolName field for consistency
            this.result = errorDetails;  // Store error details in result field
            this.timestamp = System.currentTimeMillis();
            this.isError = true;
        }

        // Constructor for mode_transition messages
        public Message(String type, String mode_transition, String trigger) {
            this.id = generateMessageId();
            this.type = type;
            this.mode_transition = mode_transition;
            this.trigger = trigger;
            this.timestamp = System.currentTimeMillis();
        }

        // Constructor for todo_list_created messages
        public Message(String type, List<ChecklistManager.ChecklistItem> todos) {
            this.id = generateMessageId();
            this.type = type;
            this.todos = todos;
            this.timestamp = System.currentTimeMillis();
        }

        private static int messageCounter = 0;
        private static String generateMessageId() {
            return "msg_" + String.format("%03d", ++messageCounter);
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/CopyJSCommand.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import java.nio.file.*;
import java.io.IOException;

/**
 * Copy bridge JavaScript to clipboard
 */
public class CopyJSCommand implements ICommand {
    private final IClipboardManager clipboard;
    private final ILogger logger;

    public CopyJSCommand(IClipboardManager clipboard, ILogger logger) {
        this.clipboard = clipboard;
        this.logger = logger;
    }

    @Override
    public CommandDispatcher.CommandResult execute(String[] args) {
        try {
            // Get codeboss home directory
            String codeBasePath = System.getProperty("codeboss.home");
            if (codeBasePath == null) {
                codeBasePath = ".";
                logger.log("CopyJS: codeboss.home not set, using current directory");
            }

            // Load bridge-button.js
            Path bridgePath = Paths.get(codeBasePath, "src", "browser", "bridge-button.js");
            logger.log("CopyJS: Loading bridge script from: " + bridgePath.toAbsolutePath());

            if (!Files.exists(bridgePath)) {
                String errorMsg = "Bridge script not found at: " + bridgePath.toAbsolutePath();
                logger.log("CopyJS ERROR: " + errorMsg);
                return new CommandDispatcher.CommandResult(false, errorMsg);
            }

            String bridgeScript = Files.readString(bridgePath);
            logger.log("CopyJS: Loaded " + bridgeScript.length() + " bytes, sending to browser for clipboard copy");

            // Return script with special marker so browser can detect and copy to clipboard
            String message = "CLIPBOARD_COPY:" + bridgeScript;

            logger.log("CopyJS: SUCCESS - returning script to browser");
            return new CommandDispatcher.CommandResult(true, message);

        } catch (IOException e) {
            logger.log("CopyJS ERROR: IOException - " + e.getMessage());
            e.printStackTrace();
            return new CommandDispatcher.CommandResult(false, "Failed to load bridge script: " + e.getMessage());
        } catch (Exception e) {
            logger.log("CopyJS ERROR: Unexpected exception - " + e.getMessage());
            e.printStackTrace();
            return new CommandDispatcher.CommandResult(false, "Unexpected error: " + e.getMessage());
        }
    }

    @Override
    public String getHelp() {
        return "Copy bridge JavaScript to clipboard";
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/FileHashTracker.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import java.util.*;

/**
 * Track file hashes for undo verification using SHA-256
 *
 * Per undo-system-spec.md:
 * - Uses SHA-256 algorithm for file integrity verification
 * - Computes hash on file content only (excludes metadata)
 * - Normalizes line endings to LF before hashing
 * - Uses UTF-8 encoding for consistency
 * - Streams large files (>1MB) for performance
 * - Stores hashes in conversation.jsonl via file_hash_before/after fields
 */
public class FileHashTracker {
    private final ILogger logger;
    private final String workingDirectory;
    private final Map<String, String> hashCache;  // filePath -> current hash

    public FileHashTracker(ILogger logger, String workingDirectory) {
        this.logger = logger;
        this.workingDirectory = workingDirectory;
        this.hashCache = new HashMap<>();
    }

    /**
     * Compute SHA-256 hash of file content
     *
     * TODO: Implementation per undo-system-spec.md lines 88-115
     * 1. Read file at filePath (relative to workingDirectory)
     * 2. Normalize line endings to LF (\n)
     * 3. For small files (<1MB):
     *    - Read entire content into String
     *    - Compute hash: MessageDigest.getInstance("SHA-256")
     *    - Use StandardCharsets.UTF_8 encoding
     *    - Convert byte[] to hex string
     * 4. For large files (>=1MB):
     *    - Use streaming: DigestInputStream with 8KB buffer
     *    - Avoid loading entire file into memory
     * 5. Return hex-encoded hash string (40 characters)
     * 6. Cache result in hashCache for performance
     * 7. Handle IOException and NoSuchAlgorithmException
     */
    public String computeHash(String filePath) throws Exception {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Track file hash before modification (for undo)
     *
     * TODO: Implementation
     * 1. Compute current hash via computeHash(filePath)
     * 2. Store in hashCache with key=filePath, value=hash
     * 3. Log hash for debugging: "Tracked before: filePath -> hash"
     * 4. Return computed hash string
     * 5. This hash becomes file_hash_before in conversation.jsonl
     */
    public String trackBeforeModification(String filePath) throws Exception {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Track file hash after modification (for undo)
     *
     * TODO: Implementation
     * 1. Compute new hash via computeHash(filePath)
     * 2. Update hashCache with new value
     * 3. Log hash for debugging: "Tracked after: filePath -> hash"
     * 4. Return computed hash string
     * 5. This hash becomes file_hash_after in conversation.jsonl
     */
    public String trackAfterModification(String filePath) throws Exception {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Verify file hash matches expected value
     *
     * TODO: Implementation per undo-system-spec.md lines 71-77
     * 1. Compute current hash via computeHash(filePath)
     * 2. Compare with expectedHash parameter
     * 3. If match: return true
     * 4. If mismatch:
     *    - Log warning: "Hash mismatch for filePath: expected=X, actual=Y"
     *    - Return false (caller will prompt user for confirmation)
     * 5. This is used by UndoStack.undoFileModification() to detect external changes
     */
    public boolean verifyHash(String filePath, String expectedHash) throws Exception {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Get cached hash for file (if available)
     *
     * TODO: Implementation
     * 1. Check hashCache for filePath key
     * 2. Return cached hash if present, null otherwise
     * 3. Used for performance optimization (avoid recomputing)
     */
    public String getCachedHash(String filePath) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Clear hash cache (useful for testing)
     */
    public void clearCache() {
        hashCache.clear();
    }

    /**
     * Convert byte array to hex string
     *
     * TODO: Implementation
     * 1. Iterate through byte array
     * 2. Convert each byte to 2-character hex string
     * 3. Use String.format("%02x", b) for zero-padding
     * 4. Return concatenated hex string
     * 5. Example: [0xA1, 0xB2] -> "a1b2"
     */
    private String bytesToHex(byte[] bytes) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/HelpCommand.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;

/**
 * Help command implementation
 */
public class HelpCommand implements ICommand {
    private final ILogger logger;

    public HelpCommand(ILogger logger) {
        this.logger = logger;
    }

    /**
     * Display help text per user-interface-spec.md lines 73-95
     */
    @Override
    public CommandDispatcher.CommandResult execute(String[] args) {
        String helpText =
            "Code Boss - Available Commands:\n\n" +
            "  help            Show this help message\n" +
            "  quit            Exit the application\n" +
            "  copyjs          Copy browser bridge JavaScript to clipboard\n" +
            "  mousecapture    Capture mouse coordinates for bridge (10s countdown)\n" +
            "  undo [x]        Undo last x operations (default: 1)\n\n" +
            "  ESC ESC         Interrupt AI processing\n\n" +
            "For more information, see README.md";

        logger.log("Help command executed");
        return new CommandDispatcher.CommandResult(true, helpText);
    }

    @Override
    public String getHelp() {
        return "Show available commands and tools";
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ICommand.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

/**
 * Command interface
 */
public interface ICommand {
    CommandDispatcher.CommandResult execute(String[] args);
    String getHelp();
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/LenientXMLParser.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import java.util.*;
import java.util.regex.*;

/**
 * Lenient XML parser for AI-generated XML
 * Parses XML into a tree structure of elements with text content and attributes
 */
public class LenientXMLParser {

    public static class Element {
        public final String name;
        public final Map<String, String> attributes;
        public final String textContent;
        public final List<Element> children;

        public Element(String name, Map<String, String> attributes, String textContent, List<Element> children) {
            this(name, attributes, textContent, children, true);
        }

        public Element(String name, Map<String, String> attributes, String textContent, List<Element> children, boolean trimText) {
            this.name = name;
            this.attributes = attributes != null ? attributes : new HashMap<>();
            this.textContent = textContent != null ? (trimText ? textContent.trim() : textContent) : "";
            this.children = children != null ? children : new ArrayList<>();
        }

        public Element(String name) {
            this(name, new HashMap<>(), "", new ArrayList<>());
        }

        /**
         * Get first child element with the given name
         */
        public Element getChild(String name) {
            for (Element child : children) {
                if (child.name.equals(name)) {
                    return child;
                }
            }
            return null;
        }

        /**
         * Get all child elements with the given name
         */
        public List<Element> getChildren(String name) {
            List<Element> result = new ArrayList<>();
            for (Element child : children) {
                if (child.name.equals(name)) {
                    result.add(child);
                }
            }
            return result;
        }

        /**
         * Get attribute value by name
         */
        public String getAttribute(String name) {
            return attributes.get(name);
        }

        /**
         * Check if element has attribute
         */
        public boolean hasAttribute(String name) {
            return attributes.containsKey(name);
        }
    }

    /**
     * Parse XML string into root element
     */
    public static Element parse(String xml) {
        if (xml == null || xml.trim().isEmpty()) {
            throw new IllegalArgumentException("XML cannot be null or empty");
        }

        xml = xml.trim();

        // Find root element
        Pattern rootPattern = Pattern.compile("^<([a-zA-Z_][a-zA-Z0-9_-]*)([^>]*)>(.*)</\\1>$", Pattern.DOTALL);
        Matcher rootMatcher = rootPattern.matcher(xml);

        if (!rootMatcher.find()) {
            throw new IllegalArgumentException("Invalid XML: no root element found");
        }

        String rootName = rootMatcher.group(1);
        String rootAttributesStr = rootMatcher.group(2);
        String rootContent = rootMatcher.group(3);

        Map<String, String> rootAttributes = parseAttributes(rootAttributesStr);

        // Parse content (children or text)
        ContentResult contentResult = parseContent(rootContent);

        return new Element(rootName, rootAttributes, contentResult.textContent, contentResult.children, !contentResult.preserveWhitespace);
    }

    /**
     * Helper class to hold parsing result
     */
    private static class ContentResult {
        final String textContent;
        final List<Element> children;
        final boolean preserveWhitespace;

        ContentResult(String textContent, List<Element> children) {
            this(textContent, children, false);
        }

        ContentResult(String textContent, List<Element> children, boolean preserveWhitespace) {
            this.textContent = textContent;
            this.children = children;
            this.preserveWhitespace = preserveWhitespace;
        }
    }

    /**
     * Parse content - determine if it's text or child elements
     * Handles CDATA sections: <![CDATA[...]]>
     */
    private static ContentResult parseContent(String content) {
        List<Element> children = new ArrayList<>();
        String textContent = "";

        // Check for CDATA section first
        if (content.trim().startsWith("<![CDATA[")) {
            // Extract CDATA content (everything between <![CDATA[ and ]]>)
            Pattern cdataPattern = Pattern.compile("^\\s*<!\\[CDATA\\[(.*?)\\]\\]>\\s*$", Pattern.DOTALL);
            Matcher cdataMatcher = cdataPattern.matcher(content);
            if (cdataMatcher.find()) {
                // Get raw CDATA content
                textContent = cdataMatcher.group(1);
                // Normalize AI formatting issues (line continuations, malformed JSON, etc)
                textContent = normalizeAIFormatting(textContent);
                return new ContentResult(textContent, children, true); // preserveWhitespace = true
            }
        }

        // Try to parse children - if it fails, treat as text
        if (content.trim().startsWith("<")) {
            // Starts with a tag, likely has child elements
            try {
                children = parseChildren(content);
                // If parseChildren succeeded but returned empty list, treat as text content
                if (children.isEmpty()) {
                    textContent = content;
                }
            } catch (Exception e) {
                // Failed to parse as children, treat as text (preserve original content, don't trim)
                textContent = content;
            }
        } else {
            // Doesn't start with tag, treat as text content (preserve original, don't trim)
            textContent = content;
        }

        return new ContentResult(textContent, children);
    }

    /**
     * Parse attributes from attribute string
     * Example: ' name="value" id="123"' -> {name: value, id: 123}
     */
    private static Map<String, String> parseAttributes(String attributeStr) {
        Map<String, String> attributes = new HashMap<>();

        if (attributeStr == null || attributeStr.trim().isEmpty()) {
            return attributes;
        }

        // Match name="value" or name='value'
        Pattern attrPattern = Pattern.compile("([a-zA-Z_][a-zA-Z0-9_-]*)=[\"']([^\"']*)[\"']");
        Matcher attrMatcher = attrPattern.matcher(attributeStr);

        while (attrMatcher.find()) {
            String name = attrMatcher.group(1);
            String value = attrMatcher.group(2);
            attributes.put(name, value);
        }

        return attributes;
    }

    /**
     * Parse child elements from content
     */
    private static List<Element> parseChildren(String content) {
        List<Element> children = new ArrayList<>();

        // Match child elements: <tag ...>...</tag>
        Pattern childPattern = Pattern.compile("<([a-zA-Z_][a-zA-Z0-9_-]*)([^>]*)>(.*?)</\\1>", Pattern.DOTALL);
        Matcher childMatcher = childPattern.matcher(content);

        while (childMatcher.find()) {
            String childName = childMatcher.group(1);
            String childAttributesStr = childMatcher.group(2);
            String childContent = childMatcher.group(3);

            Map<String, String> childAttributes = parseAttributes(childAttributesStr);

            // Parse content (children or text) using shared logic
            ContentResult contentResult = parseContent(childContent);

            children.add(new Element(childName, childAttributes, contentResult.textContent, contentResult.children, !contentResult.preserveWhitespace));
        }

        return children;
    }

    /**
     * Normalize AI formatting issues in CDATA content
     *
     * Common AI formatting mistakes:
     * 1. Line continuations: backslash followed by newline (e.g., "text\<newline>more")
     *    - This is not valid JSON, but AI models sometimes generate it
     * 2. Mixed line endings
     * 3. Other formatting inconsistencies
     *
     * This method fixes these issues to make AI-generated content parseable.
     */
    private static String normalizeAIFormatting(String content) {
        if (content == null || content.isEmpty()) {
            return content;
        }

        // Fix line continuations: backslash followed by newline
        // AI sometimes sends: "text\<newline>more" instead of: "text\nmore" or "textmore"
        // We remove the backslash-newline entirely (treating it as line continuation)

        // Handle all line ending variations:
        // \<CR><LF> (Windows)
        content = content.replace("\\\r\n", "");
        // \<LF> (Unix)
        content = content.replace("\\\n", "");
        // \<CR> (old Mac)
        content = content.replace("\\\r", "");

        return content;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/MessageFormatter.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.aiprocessor.*;
import java.util.*;

/**
 * Formats messages for clipboard protocol
 */
public class MessageFormatter {

    public String formatForBridge(String systemPrompt, List<ConversationState.Message> messages) {
        // TODO: Build JSON structure
        // TODO: Escape special characters
        // TODO: Add CLIP:TO_BRIDGE marker
        return "{\"messages\":[]}|||||CLIP:TO_BRIDGE|||||";
    }

    private String escapeJson(String str) {
        // TODO: Implement JSON escaping
        return str;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/MessageQueue.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import java.util.*;

/**
 * Simple FIFO message queue
 */
public class MessageQueue {
    private final Queue<String> queue;

    public MessageQueue() {
        this.queue = new LinkedList<>();
    }

    public void enqueue(String message) {
        // TODO: Implement
    }

    public String dequeue() {
        // TODO: Implement
        return null;
    }

    public boolean isEmpty() {
        // TODO: Implement
        return true;
    }

    public int size() {
        // TODO: Implement
        return 0;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/Mode.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import java.util.*;

public enum Mode {
    PLANNING,
    EXECUTION,
    REVIEW,
    TESTING;

    public Set<ToolCategory> getAvailableToolCategories() {
        switch (this) {
            case PLANNING:
                return EnumSet.of(
                    ToolCategory.FILE_READ,
                    ToolCategory.SEARCH,
                    ToolCategory.CHECKLIST,
                    ToolCategory.COMMAND_EXECUTION,
                    ToolCategory.GIT_READ
                );
            case EXECUTION:
                return EnumSet.of(
                    ToolCategory.FILE_READ,
                    ToolCategory.FILE_OPERATIONS,
                    ToolCategory.CHECKLIST,
                    ToolCategory.GIT_READ,
                    ToolCategory.GIT_WRITE
                );
            case REVIEW:
                return EnumSet.of(
                    ToolCategory.FILE_READ,
                    ToolCategory.SEARCH,
                    ToolCategory.GIT_READ,
                    ToolCategory.CHECKLIST  // For review_pass/review_fail
                );
            case TESTING:
                return EnumSet.of(
                    ToolCategory.FILE_READ,
                    ToolCategory.COMMAND_EXECUTION,
                    ToolCategory.CHECKLIST,
                    ToolCategory.GIT_READ
                );
            default:
                throw new IllegalStateException("Unknown mode: " + this);
        }
    }

    public static Mode fromString(String mode) {
        if (mode == null) {
            throw new IllegalArgumentException("Mode cannot be null");
        }
        try {
            return Mode.valueOf(mode.trim().toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid mode: " + mode + ". Must be one of: planning, execution, review, testing");
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ModeManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;

/**
 * Manages mode state machine
 *
 * Modes: planning, execution, testing, review
 * Transitions based on triggers like todo_list_created, coding_complete, etc.
 */
public class ModeManager {
    private final ILogger logger;
    private final ConversationManager conversationManager;
    private Mode currentMode;

    public ModeManager(ILogger logger, ConversationManager conversationManager) {
        this.logger = logger;
        this.conversationManager = conversationManager;
        this.currentMode = Mode.PLANNING;
    }

    public Mode getCurrentMode() {
        return currentMode;
    }

    public void transitionTo(Mode newMode) {
        if (newMode == null) {
            logger.log("Cannot transition to null mode");
            return;
        }

        if (canTransitionTo(newMode)) {
            Mode oldMode = currentMode;
            currentMode = newMode;
            String transition = oldMode.name().toLowerCase() + "_to_" + newMode.name().toLowerCase();
            logger.log("Mode transition: " + transition);

            // Add mode transition message to conversation
            conversationManager.addModeTransition(transition, "mode_change");
        } else {
            logger.log("Invalid mode transition requested: " + currentMode.name().toLowerCase() + " -> " + newMode.name().toLowerCase());
        }
    }

    public void transitionTo(String newMode) {
        try {
            Mode mode = Mode.fromString(newMode);
            transitionTo(mode);
        } catch (IllegalArgumentException e) {
            logger.log("Invalid mode string: " + newMode + " - " + e.getMessage());
        }
    }

    public boolean canTransitionTo(Mode newMode) {
        if (newMode == null) {
            return false;
        }

        // Allow any transition for now (can add specific rules later)
        // Example rules that could be added:
        // - planning -> execution (when todo_list_created)
        // - execution -> testing (when coding_complete with testing items)
        // - execution -> review (when coding_complete before testing)
        // - review -> execution (when issues_found)
        // - testing -> execution (when test_complete with failures)
        return true;
    }

    public String getTransitionName(Mode fromMode, Mode toMode) {
        return fromMode.name().toLowerCase() + "_to_" + toMode.name().toLowerCase();
    }

    public String getTransitionName(String fromMode, String toMode) {
        return fromMode + "_to_" + toMode;
    }

    public void recoverFromTransition(String transitionName) {
        // Parse transition name (e.g., "planning_to_execution")
        // Extract target mode from transition
        // Set current mode to target
        // Example: "planning_to_execution" -> set mode to "execution"

        if (transitionName == null || !transitionName.contains("_to_")) {
            logger.log("Invalid transition name, defaulting to planning: " + transitionName);
            currentMode = Mode.PLANNING;
            return;
        }

        String[] parts = transitionName.split("_to_");
        if (parts.length != 2) {
            logger.log("Invalid transition format, defaulting to planning: " + transitionName);
            currentMode = Mode.PLANNING;
            return;
        }

        String targetMode = parts[1];
        try {
            currentMode = Mode.fromString(targetMode);
            logger.log("Recovered mode from transition: " + transitionName + " -> " + currentMode.name().toLowerCase());
        } catch (IllegalArgumentException e) {
            logger.log("Invalid target mode in transition, defaulting to planning: " + targetMode);
            currentMode = Mode.PLANNING;
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/MouseCaptureCommand.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;

/**
 * Calibrate mouse coordinates for bridge button
 */
public class MouseCaptureCommand implements ICommand {
    private final IClipboardManager clipboard;
    private final IConfigManager config;
    private final ILogger logger;

    public MouseCaptureCommand(
        IClipboardManager clipboard,
        IConfigManager config,
        ILogger logger
    ) {
        this.clipboard = clipboard;
        this.config = config;
        this.logger = logger;
    }

    @Override
    public CommandDispatcher.CommandResult execute(String[] args) {
        // TODO: Capture mouse position
        // TODO: Save to config
        logger.log("MouseCapture command executed");
        return new CommandDispatcher.CommandResult(true, "Mouse coordinates captured");
    }

    @Override
    public String getHelp() {
        return "Calibrate bridge button click coordinates";
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ProjectStructure.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import java.io.IOException;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Stream;

/**
 * Captures and formats project directory structure for AI context
 */
public class ProjectStructure {
    
    private final String workingDirectory;
    private String cachedStructure;
    
    public ProjectStructure(String workingDirectory) {
        this.workingDirectory = workingDirectory;
        this.cachedStructure = null;
    }
    
    /**
     * Get project structure as formatted string
     * Caches the result until refresh() is called
     */
    public String getStructure() {
        if (cachedStructure == null) {
            cachedStructure = buildStructure();
        }
        return cachedStructure;
    }
    
    /**
     * Refresh the cached structure
     */
    public void refresh() {
        cachedStructure = buildStructure();
    }
    
    private String buildStructure() {
        StringBuilder structure = new StringBuilder();
        structure.append("PROJECT STRUCTURE (no need to list_files on root directory):\n");
        structure.append("Working Directory: ").append(workingDirectory).append("\n\n");
        
        try {
            Path rootPath = Paths.get(workingDirectory);
            
            // Get all items in root directory
            List<Path> rootItems = new ArrayList<>();
            try (Stream<Path> paths = Files.list(rootPath)) {
                paths.forEach(rootItems::add);
            }
            
            // Sort: directories first, then files, alphabetically
            rootItems.sort((a, b) -> {
                boolean aIsDir = Files.isDirectory(a);
                boolean bIsDir = Files.isDirectory(b);
                if (aIsDir && !bIsDir) return -1;
                if (!aIsDir && bIsDir) return 1;
                return a.getFileName().toString().compareTo(b.getFileName().toString());
            });
            
            // Build tree structure
            for (Path item : rootItems) {
                String fileName = item.getFileName().toString();
                
                // Skip hidden files/folders (starting with .)
                if (fileName.startsWith(".")) {
                    continue;
                }
                
                if (Files.isDirectory(item)) {
                    structure.append(formatDirectory(item, "", true));
                } else {
                    structure.append(formatFile(item, ""));
                }
            }
            
        } catch (IOException e) {
            structure.append("Error reading project structure: ").append(e.getMessage()).append("\n");
        }
        
        return structure.toString();
    }
    
    private String formatDirectory(Path dir, String indent, boolean isRoot) throws IOException {
        StringBuilder result = new StringBuilder();
        String fileName = dir.getFileName().toString();
        
        // Get child count
        int childCount = 0;
        try (Stream<Path> children = Files.list(dir)) {
            childCount = (int) children.count();
        }
        
        if (isRoot) {
            result.append(indent).append(fileName).append("/\n");
            
            // List children at second level
            List<Path> children = new ArrayList<>();
            try (Stream<Path> paths = Files.list(dir)) {
                paths.forEach(children::add);
            }
            
            // Sort: directories first, then files
            children.sort((a, b) -> {
                boolean aIsDir = Files.isDirectory(a);
                boolean bIsDir = Files.isDirectory(b);
                if (aIsDir && !bIsDir) return -1;
                if (!aIsDir && bIsDir) return 1;
                return a.getFileName().toString().compareTo(b.getFileName().toString());
            });
            
            for (int i = 0; i < children.size(); i++) {
                Path child = children.get(i);
                String childName = child.getFileName().toString();
                
                // Skip hidden files/folders
                if (childName.startsWith(".")) {
                    continue;
                }
                
                boolean isLast = (i == children.size() - 1);
                String childIndent = indent + (isLast ? "+-- " : "+-- ");
                
                if (Files.isDirectory(child)) {
                    // Second level directory - show count only
                    int grandChildCount = 0;
                    try (Stream<Path> grandChildren = Files.list(child)) {
                        grandChildCount = (int) grandChildren.count();
                    }
                    result.append(childIndent).append(childName).append("/ (").append(grandChildCount).append(" items)\n");
                } else {
                    result.append(formatFile(child, childIndent));
                }
            }
        } else {
            // Second level directory - just show count
            result.append(indent).append(fileName).append("/ (").append(childCount).append(" items)\n");
        }
        
        return result.toString();
    }
    
    private String formatFile(Path file, String indent) throws IOException {
        String fileName = file.getFileName().toString();
        long lineCount = 0;
        
        try {
            lineCount = Files.lines(file).count();
        } catch (Exception e) {
            // Binary file or error reading - just skip line count
            return indent + fileName + "\n";
        }
        
        return indent + fileName + " (" + lineCount + " lines)\n";
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/PromptGenerator.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import java.util.*;

public class PromptGenerator {

    public String generatePrompt(Mode mode) {
        return generatePrompt(mode, null, null);
    }

    public String generatePrompt(Mode mode, ChecklistManager checklistManager) {
        return generatePrompt(mode, checklistManager, null);
    }

    public String generatePrompt(Mode mode, ChecklistManager checklistManager, ProjectStructure projectStructure) {
        if (mode == null) {
            throw new IllegalArgumentException("Mode cannot be null");
        }

        StringBuilder prompt = new StringBuilder();

        prompt.append(getIdentitySection());
        prompt.append(getResponseFormatRules());  // CRITICAL: Put format rules early!
        prompt.append(getModeSpecificInstructions(mode));

        // Include project structure if available
        if (projectStructure != null) {
            prompt.append(projectStructure.getStructure()).append("\n");
        }

        // Include current checklist state if available
        if (checklistManager != null) {
            if (mode == Mode.EXECUTION || mode == Mode.TESTING) {
                // In execution/testing modes, show only the current task
                prompt.append(getCurrentTaskForExecution(checklistManager));
            } else {
                // In planning/review modes, show full checklist
                prompt.append(getCurrentChecklistState(checklistManager));
            }
        }

        prompt.append(getToolDefinitions(mode));
        prompt.append(getImportantRules(mode));

        return prompt.toString();
    }

    private String getIdentitySection() {
        return "You are Code Boss, a coding assistant.\n\n" +
               "Your job is to help users write code by:\n" +
               "1. Understanding their requests\n" +
               "2. Using tools to read/modify files and search code\n" +
               "3. Providing helpful responses\n\n";
    }

    private String getModeSpecificInstructions(Mode mode) {
        StringBuilder instructions = new StringBuilder();
        instructions.append("CURRENT MODE: ").append(mode.name().toLowerCase()).append("\n\n");

        switch (mode) {
            case PLANNING:
                instructions.append("PLANNING MODE:\n\n");
                instructions.append("FIRST: Check if previous tasks were already completed by reviewing conversation history.\n");
                instructions.append("- If tasks are done: Acknowledge completion and ask \"What else can I help with?\"\n");
                instructions.append("- If no tasks exist: Proceed with planning\n\n");
                instructions.append("HOW TO HANDLE USER REQUESTS:\n\n");
                instructions.append("1. INFORMATION REQUESTS (answering questions):\n");
                instructions.append("   - User asks: \"What's in my project?\" or \"Show me the README\"\n");
                instructions.append("   - Use read/search tools directly, then send a <message> with the answer\n");
                instructions.append("   - No checklist needed for pure information gathering\n\n");
                instructions.append("2. ACTION REQUESTS (user wants you to DO something):\n");
                instructions.append("   - User says: \"Delete the README\" or \"Create a Java project\" or \"Add a new feature\"\n");
                instructions.append("   - Create a plan using begin_execution tool\n");
                instructions.append("   - Even simple tasks like \"delete one file\" need a 1-item checklist\n");
                instructions.append("   - CRITICAL: You CANNOT modify/create/delete files in planning mode - you must create a plan first!\n\n");
                instructions.append("EXECUTION MODE CAPABILITIES (what you'll be able to do):\n");
                instructions.append("When your plan is approved, you'll enter EXECUTION mode with these tools:\n");
                instructions.append("  - create_file: Create individual files with content\n");
                instructions.append("  - update_file: Make a single edit to a file (replace old_content with new_content)\n");
                instructions.append("  - update_file_batch: Make MULTIPLE edits to the SAME file in one operation\n");
                instructions.append("  - delete_file: Delete files\n");
                instructions.append("  - read_file, search_files: Read and search code\n");
                instructions.append("  - Batch operations: You can call MULTIPLE tools in ONE turn (e.g., create 5 files at once)\n\n");
                instructions.append("Plan your tasks knowing these capabilities. For example:\n");
                instructions.append("  - \"Create model classes\" -> You'll create Todo.java, TodoList.java, etc. in one step\n");
                instructions.append("  - \"Update API endpoints\" -> You can batch-edit multiple methods in server.js at once\n");
                instructions.append("  - \"Clear project files\" -> You'll delete multiple files in one step\n\n");
                instructions.append("CREATING A PLAN:\n");
                instructions.append("  1. Read relevant files to understand the codebase (optional)\n");
                instructions.append("  2. Create a checklist with COARSE-GRAINED tasks\n");
                instructions.append("     - Each checklist item should be a logical unit of work that may involve MULTIPLE tool calls\n");
                instructions.append("     - Example: \"Clear out project files\" (deletes many files), NOT \"Delete file X\", \"Delete file Y\"\n");
                instructions.append("     - Example: \"Create TodoMVC components\" (creates 4-5 files), NOT \"Create TodoList\", \"Create TodoItem\"\n");
                instructions.append("     - Even simple tasks get 1 item: \"Delete README.md\"\n");
                instructions.append("  3. Immediately call begin_execution with description + checklist JSON\n");
                instructions.append("     - Do NOT send a message asking for approval\n");
                instructions.append("     - Do NOT wait for user response\n");
                instructions.append("     - Just call the tool with your plan\n\n");
                break;

            case EXECUTION:
                instructions.append("EXECUTION MODE:\n\n");
                instructions.append("Your job is to complete ONE checklist item, then report success or failure.\n\n");
                instructions.append("WORKFLOW:\n");
                instructions.append("1. Read the CURRENT TASK below\n");
                instructions.append("2. Use MULTIPLE tools to complete the task (create/update/delete many files as needed)\n");
                instructions.append("3. When ALL work for the task is done, call mark_complete tool ONCE\n");
                instructions.append("4. If you cannot complete it, call mark_failed with a reason\n\n");
                instructions.append("TASK GRANULARITY EXAMPLES:\n");
                instructions.append("GOOD task scope (focus on current task only):\n");
                instructions.append("  - \"Create model classes\" -> Create Todo.java and TodoModel.java in this step\n");
                instructions.append("  - \"Implement view components\" -> Create MainFrame.java, InputPanel.java, TodoPanel.java\n");
                instructions.append("  - \"Clear out project files\" -> Delete README, package.json, and src/ directory\n");
                instructions.append("BAD - doing too much:\n");
                instructions.append("  - If task is \"Create model classes\", DON'T also create controller or view classes\n");
                instructions.append("  - If task is \"Implement Todo class\", DON'T create the entire MVC structure\n");
                instructions.append("  - Only work on what the CURRENT TASK describes - nothing more!\n\n");
                instructions.append("IMPORTANT:\n");
                instructions.append("- ONE task may require MANY tool calls (e.g., \"Clear project\" = delete 10+ files)\n");
                instructions.append("- Only call mark_complete ONCE at the end when the entire task is finished\n");
                instructions.append("- Do NOT call mark_complete multiple times in one response\n");
                instructions.append("- Focus on completing the current task only\n");
                instructions.append("- Read files before modifying them\n");
                instructions.append("- Follow existing code patterns and conventions\n\n");
                instructions.append("ERROR HANDLING (CRITICAL):\n");
                instructions.append("- If a tool returns an error, try to fix it or find an alternative approach\n");
                instructions.append("- If the same error occurs twice, call mark_failed immediately\n");
                instructions.append("- Only call mark_complete if the final outcome meets the task objective\n");
                instructions.append("- If errors prevent you from achieving the goal, call mark_failed with explanation\n");
                instructions.append("- Never ignore errors and pretend the task succeeded when it didn't\n\n");
                break;

            case REVIEW:
                instructions.append("REVIEW MODE:\n\n");
                instructions.append("Quick code quality check of recent changes.\n\n");
                instructions.append("INSTRUCTIONS:\n");
                instructions.append("1. Review changes in conversation history (read files if needed)\n");
                instructions.append("2. Check: naming conventions, error handling, code duplication, hardcoded values\n");
                instructions.append("3. Call review_pass or review_fail tool:\n");
                instructions.append("   - If code looks good: call review_pass (no parameters)\n");
                instructions.append("   - If issues found: call review_fail with brief reason\n\n");
                instructions.append("CRITICAL: Just call the tool, no additional messages or analysis.\n\n");
                break;

            case TESTING:
                instructions.append("TESTING MODE:\n\n");
                instructions.append("Your job is to complete ONE testing task, then report success or failure.\n\n");
                instructions.append("WORKFLOW:\n");
                instructions.append("1. Read the CURRENT TASK below\n");
                instructions.append("2. Run tests using run_command tool\n");
                instructions.append("3. Validate behavior matches requirements\n");
                instructions.append("4. When done, call mark_complete tool (no parameters needed)\n");
                instructions.append("5. If tests fail, call mark_failed with the reason\n\n");
                instructions.append("IMPORTANT:\n");
                instructions.append("- You MUST end by calling either mark_complete or mark_failed\n");
                instructions.append("- Do NOT try to work on multiple items - focus on the current task only\n");
                instructions.append("- CANNOT modify files (read-only mode)\n\n");
                instructions.append("ERROR RECOVERY:\n");
                instructions.append("- If a command fails repeatedly, call mark_failed\n");
                instructions.append("- Do NOT retry the same failing command infinitely\n");
                instructions.append("- Explain the issue in mark_failed reason\n\n");
                break;
        }

        return instructions.toString();
    }

    private String getToolDefinitions(Mode mode) {
        Set<ToolCategory> availableCategories = mode.getAvailableToolCategories();
        StringBuilder tools = new StringBuilder();

        tools.append("AVAILABLE TOOLS:\n\n");

        if (availableCategories.contains(ToolCategory.FILE_OPERATIONS) ||
            availableCategories.contains(ToolCategory.FILE_READ)) {
            tools.append(getFileReadTools());
        }

        if (availableCategories.contains(ToolCategory.FILE_OPERATIONS)) {
            tools.append(getFileWriteTools());
        }

        if (availableCategories.contains(ToolCategory.SEARCH)) {
            tools.append(getSearchTools());
        }

        if (availableCategories.contains(ToolCategory.CHECKLIST)) {
            tools.append(getChecklistTools(mode));
        }

        if (availableCategories.contains(ToolCategory.GIT_READ) ||
            availableCategories.contains(ToolCategory.GIT_WRITE)) {
            tools.append(getGitTools(availableCategories));
        }

        if (availableCategories.contains(ToolCategory.TASK)) {
            tools.append(getTaskTool());
        }

        if (availableCategories.contains(ToolCategory.COMMAND_EXECUTION)) {
            tools.append(getCommandExecutionTools());
        }

        tools.append("\n");
        return tools.toString();
    }

    private String getFileReadTools() {
        return "READ FILE:\n" +
               "  <tool name=\"read_file\">\n" +
               "    <parameter name=\"file_path\">path/to/file.java</parameter>\n" +
               "    <parameter name=\"offset\">0</parameter>\n" +
               "    <parameter name=\"limit\">100</parameter>\n" +
               "  </tool>\n" +
               "  Note: offset and limit are optional\n" +
               "  Returns: File contents with line numbers\n\n" +

               "LIST FILES:\n" +
               "  <tool name=\"list_files\">\n" +
               "    <parameter name=\"directory_path\">src/main</parameter>\n" +
               "  </tool>\n" +
               "  Note: directory_path is optional (defaults to current directory)\n" +
               "  Returns: List of files and directories\n\n";
    }

    private String getFileWriteTools() {
        return "FILE OPERATIONS:\n\n" +

               "CREATE FILE - Use this template:\n" +
               "  <tool name=\"create_file\">\n" +
               "    <parameter name=\"file_path\">PUT_FILE_PATH_HERE</parameter>\n" +
               "    <parameter name=\"content\"><![CDATA[PUT_FILE_CONTENT_HERE]]></parameter>\n" +
               "  </tool>\n" +
               "  Instructions:\n" +
               "  - Replace PUT_FILE_PATH_HERE with the path (e.g., src/Main.java)\n" +
               "  - Replace PUT_FILE_CONTENT_HERE with your code/text\n" +
               "  - The <![CDATA[ and ]]> are already there - just replace the placeholder text\n" +
               "  - Use literal newlines (press Enter) inside CDATA, NOT \\n escapes\n" +
               "  - NEVER create empty files - always provide content\n\n" +

               "UPDATE FILE - Use this template (for ONE update):\n" +
               "  <tool name=\"update_file\">\n" +
               "    <parameter name=\"file_path\">PUT_FILE_PATH_HERE</parameter>\n" +
               "    <parameter name=\"old_content\"><![CDATA[PUT_OLD_CONTENT_HERE]]></parameter>\n" +
               "    <parameter name=\"new_content\"><![CDATA[PUT_NEW_CONTENT_HERE]]></parameter>\n" +
               "  </tool>\n" +
               "  Instructions:\n" +
               "  - Replace PUT_FILE_PATH_HERE with the path\n" +
               "  - Replace PUT_OLD_CONTENT_HERE with exact text to find (must match exactly!)\n" +
               "  - Replace PUT_NEW_CONTENT_HERE with the replacement text\n" +
               "  - Use literal newlines (press Enter) inside CDATA, NOT \\n escapes\n" +
               "  - For multiple updates to SAME file, use update_file_batch instead!\n\n" +

               "UPDATE FILE BATCH - Use this template (for MULTIPLE updates to same file):\n" +
               "  <tool name=\"update_file_batch\">\n" +
               "    <parameter name=\"file_path\">PUT_FILE_PATH_HERE</parameter>\n" +
               "    <parameter name=\"updates\">[{\"old_content\":\"PUT_OLD_1\",\"new_content\":\"PUT_NEW_1\"},{\"old_content\":\"PUT_OLD_2\",\"new_content\":\"PUT_NEW_2\"}]</parameter>\n" +
               "  </tool>\n" +
               "  Instructions:\n" +
               "  - Replace PUT_FILE_PATH_HERE with the path\n" +
               "  - Replace PUT_OLD_1, PUT_NEW_1, PUT_OLD_2, PUT_NEW_2, etc. with your content\n" +
               "  - This parameter is JSON format - NO CDATA here!\n" +
               "  - CRITICAL: Use \\n for newlines in JSON strings (NOT backslash line continuation!)\n" +
               "  - Add more {\"old_content\":\"...\",\"new_content\":\"...\"} objects as needed\n\n" +

               "  WARNING: NEWLINE HANDLING (CRITICAL):\n" +
               "  WRONG - Using backslash for line continuation (INVALID JSON!):\n" +
               "    {\"old_content\":\"function hello() {\\\n    console.log('Hi');\\\n}\"}\n" +
               "    [X] This creates INVALID JSON - backslash continuation doesn't work in JSON!\n\n" +

               "  CORRECT - Using \\n escape sequence:\n" +
               "    {\"old_content\":\"function hello() {\\n    console.log('Hi');\\n}\"}\n" +
               "    [OK] The \\n represents a newline character in the JSON string\n\n" +

               "  When to use each:\n" +
               "  - ONE update to a file -> use update_file\n" +
               "  - MULTIPLE updates to SAME file -> use update_file_batch\n" +
               "  - Updates to DIFFERENT files -> use multiple update_file calls (one per file)\n\n" +

               "DELETE FILE - Use this template:\n" +
               "  <tool name=\"delete_file\">\n" +
               "    <parameter name=\"file_path\">PUT_FILE_PATH_HERE</parameter>\n" +
               "  </tool>\n\n";
    }

    private String getSearchTools() {
        return "SEARCH FILES BY NAME:\n" +
               "  <tool name=\"search_files_by_name\">\n" +
               "    <parameter name=\"pattern\">*.java</parameter>\n" +
               "    <parameter name=\"directory_path\">src</parameter>\n" +
               "  </tool>\n" +
               "  Note: Use glob patterns like *.java, **/*Test.java\n" +
               "  Note: directory_path is optional (defaults to current directory)\n" +
               "  Returns: List of files matching the name pattern\n\n" +

               "SEARCH FILES BY CONTENT:\n" +
               "  <tool name=\"search_files_by_content\">\n" +
               "    <parameter name=\"pattern\">regex pattern</parameter>\n" +
               "    <parameter name=\"directory_path\">src</parameter>\n" +
               "    <parameter name=\"file_pattern\">*.java</parameter>\n" +
               "  </tool>\n" +
               "  Note: directory_path and file_pattern are optional\n" +
               "  Returns: List of files containing the pattern with line numbers\n\n";
    }

    private String getChecklistTools(Mode mode) {
        StringBuilder tools = new StringBuilder();

        if (mode == Mode.PLANNING) {
            // Planning mode: begin_execution with checklist as parameter
            tools.append("BEGIN EXECUTION (propose plan for approval):\n");
            tools.append("  <tool name=\"begin_execution\">\n");
            tools.append("    <parameter name=\"approval_message\">Question asking user for approval (e.g., \"May I proceed with implementing these changes?\")</parameter>\n");
            tools.append("    <parameter name=\"description\">Brief summary of what this plan will do</parameter>\n");
            tools.append("    <parameter name=\"checklist\">JSON array of todo items</parameter>\n");
            tools.append("  </tool>\n");
            tools.append("  Checklist format: [{\"content\":\"task description\",\"item_type\":\"coding\",\"priority\":\"high\"},...]\n");
            tools.append("  - item_type must be \"coding\" or \"testing\"\n");
            tools.append("  - priority can be \"high\", \"medium\", or \"low\"\n");
            tools.append("  Call this tool immediately after creating your plan. The system will handle next steps.\n\n");
        } else if (mode == Mode.REVIEW) {
            // Review mode: Pass or fail the review
            tools.append("REVIEW PASS (call if code looks good):\n");
            tools.append("  <tool name=\"review_pass\">\n");
            tools.append("  </tool>\n");
            tools.append("  Call this when the code review passes (no issues found).\n\n");

            tools.append("REVIEW FAIL (call if issues found):\n");
            tools.append("  <tool name=\"review_fail\">\n");
            tools.append("    <parameter name=\"reason\">Brief description of issue</parameter>\n");
            tools.append("  </tool>\n");
            tools.append("  Call this when code review fails. Provide a brief reason for failure.\n\n");

            // Also allow checklist management in review mode
            tools.append("MANAGE CHECKLIST:\n");
            tools.append("  Add todo:\n");
            tools.append("    <tool name=\"manage_checklist\">\n");
            tools.append("      <parameter name=\"action\">add</parameter>\n");
            tools.append("      <parameter name=\"content\">task description</parameter>\n");
            tools.append("      <parameter name=\"priority\">high|medium|low</parameter>\n");
            tools.append("      <parameter name=\"item_type\">coding|testing</parameter>\n");
            tools.append("    </tool>\n\n");

            tools.append("  Delete todo:\n");
            tools.append("    <tool name=\"manage_checklist\">\n");
            tools.append("      <parameter name=\"action\">delete</parameter>\n");
            tools.append("      <parameter name=\"id\">todo-id</parameter>\n");
            tools.append("    </tool>\n\n");

            tools.append("  List todos:\n");
            tools.append("    <tool name=\"manage_checklist\">\n");
            tools.append("      <parameter name=\"action\">list</parameter>\n");
            tools.append("    </tool>\n\n");
        } else {
            // Execution and Testing modes: mark_complete or mark_failed
            tools.append("MARK COMPLETE (call when task is FULLY done):\n");
            tools.append("  <tool name=\"mark_complete\">\n");
            tools.append("  </tool>\n");
            tools.append("  CRITICAL: Only call this if the final outcome fully meets the task requirements.\n");
            tools.append("  DO NOT call mark_complete if:\n");
            tools.append("  - The final result doesn't achieve the task objective\n");
            tools.append("  - You encountered errors you couldn't work around\n");
            tools.append("  - The task is only partially complete\n");
            tools.append("  - You're unsure if it worked correctly\n\n");
            tools.append("  WRONG - Calling mark_complete after an error:\n");
            tools.append("    <execute>\n");
            tools.append("      <tool name=\"update_file\">...</tool>  <!-- This fails with 'old_content not found' -->\n");
            tools.append("      <tool name=\"mark_complete\"></tool>  [X] WRONG - Task didn't complete!\n");
            tools.append("    </execute>\n\n");
            tools.append("  CORRECT - Call mark_failed when errors prevent completion:\n");
            tools.append("    <execute>\n");
            tools.append("      <tool name=\"mark_failed\">\n");
            tools.append("        <parameter name=\"reason\">update_file failed: old_content not found in file</parameter>\n");
            tools.append("      </tool>\n");
            tools.append("    </execute>\n\n");
            tools.append("  If tool calls failed but you found another way to complete the task successfully, mark_complete is OK.\n");
            tools.append("  When in doubt, call mark_failed and explain what prevented completion.\n\n");

            tools.append("MARK FAILED (call if you cannot complete task):\n");
            tools.append("  <tool name=\"mark_failed\">\n");
            tools.append("    <parameter name=\"reason\">Explanation of why the task failed</parameter>\n");
            tools.append("  </tool>\n");
            tools.append("  Call this if you cannot achieve the task objective. Provide a clear reason.\n");
            tools.append("  Examples: \"old_content not found in file after 2 attempts\", \"file does not exist\", \"syntax error in generated code\"\n\n");
        }

        return tools.toString();
    }

    private String getGitTools(Set<ToolCategory> availableCategories) {
        StringBuilder tools = new StringBuilder();

        if (availableCategories.contains(ToolCategory.GIT_READ)) {
            tools.append("GIT READ (read-only operations):\n");
            tools.append("  <tool name=\"git_read\">\n");
            tools.append("    <parameter name=\"project_path\">.</parameter>\n");
            tools.append("    <parameter name=\"git_args\">status</parameter>\n");
            tools.append("  </tool>\n");
            tools.append("  Allowed commands: status, log, show, diff, branch, remote, tag, ls-files, blame\n\n");
        }

        if (availableCategories.contains(ToolCategory.GIT_WRITE)) {
            tools.append("GIT WRITE (modification operations):\n");
            tools.append("  <tool name=\"git_write\">\n");
            tools.append("    <parameter name=\"project_path\">.</parameter>\n");
            tools.append("    <parameter name=\"git_args\">add .</parameter>\n");
            tools.append("  </tool>\n");
            tools.append("  Allowed commands: add, commit, checkout, reset, stash, clean\n\n");
        }

        return tools.toString();
    }

    private String getTaskTool() {
        return "TASK (delegate to specialized agent):\n" +
               "  <tool name=\"TASK\">\n" +
               "    <parameter name=\"task_description\">Run the test suite and report results</parameter>\n" +
               "  </tool>\n" +
               "  Use this to delegate complex tasks to specialized agents\n\n";
    }

    private String getCommandExecutionTools() {
        return "LIST COMMANDS:\n" +
               "  <tool name=\"list_commands\">\n" +
               "  </tool>\n" +
               "  Returns: List of all saved test commands\n\n" +

               "CREATE TEST COMMAND (requires approval):\n" +
               "  <tool name=\"create_test_command\">\n" +
               "    <parameter name=\"name\">test-app</parameter>\n" +
               "    <parameter name=\"command\">java Main</parameter>\n" +
               "    <parameter name=\"description\">Run the calculator app</parameter>\n" +
               "  </tool>\n" +
               "  Creates a reusable test command. The system will ask the user to approve it.\n" +
               "  Use this to define commands for testing/running your application.\n\n" +

               "RUN TEST:\n" +
               "  <tool name=\"run_test\">\n" +
               "    <parameter name=\"name\">test-app</parameter>\n" +
               "    <parameter name=\"background\">false</parameter>\n" +
               "    <parameter name=\"regex\">Circle area.*: ([\\d.]+)</parameter>\n" +
               "    <parameter name=\"timeout_ms\">30000</parameter>\n" +
               "  </tool>\n" +
               "  Note: background, regex, and timeout_ms are optional\n" +
               "  Runs a previously created test command. Use list_commands to see available commands.\n\n" +

               "LIST PROCESSES:\n" +
               "  <tool name=\"list_processes\">\n" +
               "  </tool>\n" +
               "  Returns: List of all running test processes started by CodeBoss\n\n" +

               "STOP TEST:\n" +
               "  <tool name=\"stop_test\">\n" +
               "    <parameter name=\"pid\">12345</parameter>\n" +
               "  </tool>\n" +
               "  Note: You can use either pid or name parameter\n" +
               "  Stops a running test process by PID or name\n\n";
    }

    private String getCurrentChecklistState(ChecklistManager checklistManager) {
        List<ChecklistManager.ChecklistItem> items = checklistManager.getItems();
        if (items.isEmpty()) {
            return "";
        }

        StringBuilder state = new StringBuilder();
        state.append("CURRENT TODO LIST:\n");
        state.append("The following checklist items already exist. DO NOT recreate them.\n\n");

        for (ChecklistManager.ChecklistItem item : items) {
            state.append("  [" + item.id + "] ");
            state.append(item.status.toUpperCase()).append(" - ");
            state.append(item.content);
            state.append(" (" + item.priority + ", " + item.itemType + ")\n");
        }
        state.append("\n");

        return state.toString();
    }

    private String getCurrentTaskForExecution(ChecklistManager checklistManager) {
        ChecklistManager.ChecklistItem nextItem = checklistManager.getNextPendingItem();
        if (nextItem == null) {
            return "";
        }

        StringBuilder task = new StringBuilder();

        // Show previous completed task for context
        List<ChecklistManager.ChecklistItem> items = checklistManager.getItems();
        ChecklistManager.ChecklistItem previousItem = null;
        for (int i = 0; i < items.size(); i++) {
            if (items.get(i).id.equals(nextItem.id) && i > 0) {
                ChecklistManager.ChecklistItem prev = items.get(i - 1);
                if ("completed".equals(prev.status)) {
                    previousItem = prev;
                }
                break;
            }
        }

        if (previousItem != null) {
            task.append("PREVIOUS TASK (completed):\n");
            task.append("[PASS] ").append(previousItem.content).append("\n\n");
        }

        task.append("CURRENT TASK:\n");
        task.append("ID: ").append(nextItem.id).append("\n");
        task.append("Type: ").append(nextItem.itemType).append("\n");
        task.append("Description: ").append(nextItem.content).append("\n\n");

        return task.toString();
    }

    private String getResponseFormatRules() {
        return "RESPONSE FORMAT:\n\n" +
               "Your response must contain EXACTLY ONE top-level tag:\n" +
               "- <execute> for tool calls\n" +
               "- <message> for text responses\n\n" +

               "Option 1 - Execute tools:\n" +
               "<execute>\n" +
               "  <tool name=\"tool_name\">\n" +
               "    <parameter name=\"param_name\">value</parameter>\n" +
               "  </tool>\n" +
               "</execute>\n\n" +

               "Option 2 - Send a message:\n" +
               "<message>Your message here</message>\n\n" +

               "[X] WRONG - Sending both:\n" +
               "<execute>...</execute>\n" +
               "<message>...</message>\n\n" +

               "[X] WRONG - Text outside tags:\n" +
               "Let me help you...\n" +
               "<execute>...</execute>\n\n" +

               "WARNING: USING TEMPLATES:\n\n" +
               "Copy templates EXACTLY. Replace only the PLACEHOLDER text (like PUT_FILE_PATH_HERE).\n\n" +

               "When you see <![CDATA[PUT_CONTENT_HERE]]>:\n" +
               "- Copy the <![CDATA[ and ]]> as-is\n" +
               "- Replace only PUT_CONTENT_HERE with your code\n" +
               "- NEVER type \"<![CDATA[\" as part of your code!\n\n" +

               "Example:\n" +
               "Template:  <parameter name=\"content\"><![CDATA[PUT_CONTENT_HERE]]></parameter>\n" +
               "You write: <parameter name=\"content\"><![CDATA[function foo() {\n" +
               "    return 42;\n" +
               "}]]></parameter>\n\n";
    }

    private String getImportantRules(Mode mode) {
        Set<ToolCategory> availableCategories = mode.getAvailableToolCategories();
        boolean hasFileOps = availableCategories.contains(ToolCategory.FILE_OPERATIONS);

        StringBuilder rules = new StringBuilder();
        rules.append("IMPORTANT RULES:\n\n");

        rules.append("1. TOOL BATCHING:\n");
        rules.append("   - Batch multiple tool calls in ONE <execute> block (much more efficient)\n");
        rules.append("   - Don't send one tool, wait for response, then send another\n");
        if (hasFileOps) {
            rules.append("   - For multiple updates to SAME file: use update_file_batch (NOT multiple update_file calls)\n");
        }
        rules.append("\n");

        rules.append("2. FORMAT RULES:\n");
        rules.append("   - NEVER send both <message> and <execute> - pick ONE only\n");
        rules.append("   - NEVER put text outside the tags - everything inside <message> or <execute>\n");
        rules.append("\n");

        if (hasFileOps) {
            rules.append("3. FILE OPERATIONS:\n");
            rules.append("   - Always use forward slashes (/) in file paths\n");
            rules.append("   - All file paths are relative to the current working directory\n");
            rules.append("   - Read files before modifying them to understand context\n");
            rules.append("   - old_content must match exactly (including whitespace and newlines)\n");
            rules.append("   - NEVER create empty files - always include content\n");
            rules.append("\n");

            rules.append("4. ERROR RECOVERY:\n");
            rules.append("   - If a tool fails, try to fix it or find alternative approach\n");
            rules.append("   - If same error occurs twice, call mark_failed immediately\n");
            rules.append("   - Only call mark_complete if final outcome meets task objective\n");
        } else {
            rules.append("3. FILE PATHS:\n");
            rules.append("   - Always use forward slashes (/) in file paths\n");
            rules.append("   - All file paths are relative to the current working directory\n");
            rules.append("\n");

            rules.append("4. ERROR RECOVERY:\n");
            rules.append("   - If a tool fails twice with same error, try different approach\n");
        }
        rules.append("\n");

        return rules.toString();
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/PromptTemplates.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

/**
 * Storage for prompt templates
 */
public class PromptTemplates {

    public String getBasePrompt() {
        // TODO: Load from file or build dynamically
        return "You are a helpful coding assistant.\n\n" +
               "Use <tool_use> blocks to execute tools.\n\n" +
               "End all responses with |||||AI:END|||||\n\n";
    }

    public String getToolDefinitions() {
        // TODO: Load tool definitions
        return "Available tools: read_file, create_file, update_file, etc.\n";
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/QuitCommand.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;

/**
 * Quit command implementation
 */
public class QuitCommand implements ICommand {
    private final ILogger logger;

    public QuitCommand(ILogger logger) {
        this.logger = logger;
    }

    @Override
    public CommandDispatcher.CommandResult execute(String[] args) {
        // TODO: Trigger graceful shutdown
        logger.log("Quit command executed");
        return new CommandDispatcher.CommandResult(true, "Shutting down...");
    }

    @Override
    public String getHelp() {
        return "Exit the application";
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ResponseParser.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import java.util.*;

/**
 * Parser for AI response format
 * Uses LenientXMLParser to parse the XML structure, then interprets it
 */
public class ResponseParser {

    public static class ParsedResponse {
        public final boolean hasTools;
        public final List<ToolUse> tools;
        public final String messageContent;
        public final List<String> warnings;

        public ParsedResponse(List<ToolUse> tools, List<String> warnings) {
            this.hasTools = true;
            this.tools = tools;
            this.messageContent = null;
            this.warnings = warnings;
        }

        public ParsedResponse(String messageContent, List<String> warnings) {
            this.hasTools = false;
            this.tools = new ArrayList<>();
            this.messageContent = messageContent;
            this.warnings = warnings;
        }
    }

    public static class ToolUse {
        public final String name;
        public final Map<String, String> parameters;

        public ToolUse(String name, Map<String, String> parameters) {
            this.name = name;
            this.parameters = parameters;
        }
    }

    /**
     * Parse AI response with graceful error handling
     * Expected format:
     *   <execute><tool name="..."><parameter name="...">value</parameter></tool></execute>
     * OR
     *   <message>content</message>
     *
     * Handles common mistakes gracefully:
     * - Text outside tags: stripped with warning
     * - Multiple execute/message blocks: merged
     * - Both execute and message: execute wins, message stripped with warning
     */
    public static ParsedResponse parse(String response) {
        if (response == null || response.trim().isEmpty()) {
            throw new IllegalArgumentException("Response cannot be null or empty");
        }

        List<String> warnings = new ArrayList<>();

        // Strip markers
        response = response.replace("|||||AI:END|||||", "");
        response = response.replace("|||||CLIP:TO_JAVA_END|||||", "");
        response = response.trim();

        // Check what tags are present
        boolean hasExecute = response.contains("<execute>");
        boolean hasMessage = response.contains("<message>");

        if (!hasExecute && !hasMessage) {
            throw new IllegalArgumentException("No valid <execute> or <message> tag found in response.");
        }

        // Handle case where both execute and message are present
        // Priority: execute > message (strip message blocks)
        if (hasExecute && hasMessage) {
            // Extract message content before stripping
            String messageContent = extractMessageContent(response);
            if (messageContent != null && !messageContent.isEmpty()) {
                warnings.add("FORMAT VIOLATION: Response contained BOTH <execute> and <message> tags. Only ONE tag is allowed. The <execute> block was processed, but the <message> content was NOT shown to the user. Message content was: \"" + messageContent + "\"");
            } else {
                warnings.add("FORMAT VIOLATION: Response contained BOTH <execute> and <message> tags. Only ONE tag is allowed. The <execute> block was processed.");
            }
            response = stripMessageBlocks(response);
        }

        // Merge multiple execute blocks: </execute>[whitespace]<execute> -> single block
        String originalResponse = response;
        response = response.replaceAll("</execute>\\s+<execute>", "\n");
        if (!response.equals(originalResponse)) {
            warnings.add("Multiple <execute> blocks were merged into one. Always put all tool calls in a single <execute> block.");
        }

        // Merge multiple message blocks: </message>[whitespace]<message> -> single block
        originalResponse = response;
        response = response.replaceAll("</message>\\s+<message>", "\n");
        if (!response.equals(originalResponse)) {
            warnings.add("Multiple <message> blocks were merged into one. Always use a single <message> tag.");
        }

        // Strip text before the first opening tag
        int firstTagPos = findFirstTagPosition(response);
        if (firstTagPos > 0) {
            String preamble = response.substring(0, firstTagPos).trim();
            if (!preamble.isEmpty()) {
                warnings.add("Text before XML tags was NOT displayed to the user: \"" + preamble + "\"");
            }
            response = response.substring(firstTagPos);
        }

        // Strip text after the last closing tag
        int lastCloseExecute = response.lastIndexOf("</execute>");
        int lastCloseMessage = response.lastIndexOf("</message>");
        int lastTagPos = Math.max(lastCloseExecute, lastCloseMessage);

        if (lastTagPos >= 0) {
            int endPos = lastTagPos + (lastCloseExecute > lastCloseMessage ? "</execute>".length() : "</message>".length());
            if (endPos < response.length()) {
                String postamble = response.substring(endPos).trim();
                if (!postamble.isEmpty()) {
                    warnings.add("Text after XML tags was NOT displayed to the user: \"" + postamble + "\"");
                }
                response = response.substring(0, endPos);
            }
        }

        // Fix common malformed XML: closing tag without opening tag
        // Check for </message> or </execute> without corresponding opening tag
        if (!hasExecute && hasMessage) {
            // Check if there's a </message> but no <message>
            int openMessagePos = response.indexOf("<message>");
            int closeMessagePos = response.indexOf("</message>");
            if (closeMessagePos >= 0 && openMessagePos < 0) {
                // Found closing tag but no opening tag - prepend <message>
                warnings.add("Fixed malformed XML: Found </message> without opening <message> tag. Added missing opening tag.");
                response = "<message>" + response;
            } else if (openMessagePos >= 0 && closeMessagePos < 0) {
                // Found opening tag but no closing tag - append </message>
                warnings.add("Fixed malformed XML: Found <message> without closing </message> tag. Added missing closing tag.");
                response = response + "</message>";
            }
        }

        if (hasExecute && !hasMessage) {
            // Check if there's a </execute> but no <execute>
            int openExecutePos = response.indexOf("<execute>");
            int closeExecutePos = response.indexOf("</execute>");
            if (closeExecutePos >= 0 && openExecutePos < 0) {
                // Found closing tag but no opening tag - prepend <execute>
                warnings.add("Fixed malformed XML: Found </execute> without opening <execute> tag. Added missing opening tag.");
                response = "<execute>" + response;
            } else if (openExecutePos >= 0 && closeExecutePos < 0) {
                // Found opening tag but no closing tag - append </execute>
                warnings.add("Fixed malformed XML: Found <execute> without closing </execute> tag. Added missing closing tag.");
                response = response + "</execute>";
            }
        }

        // Try to parse as XML
        try {
            LenientXMLParser.Element root = LenientXMLParser.parse(response);

            if (root.name.equals("execute")) {
                return parseExecuteBlock(root, warnings);
            } else if (root.name.equals("message")) {
                return new ParsedResponse(root.textContent, warnings);
            } else {
                throw new IllegalArgumentException("Response must contain either <execute> or <message> tag");
            }
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to parse AI response: " + e.getMessage());
        }
    }

    private static int findFirstTagPosition(String response) {
        int executeStart = response.indexOf("<execute>");
        int messageStart = response.indexOf("<message>");

        if (executeStart >= 0 && messageStart >= 0) {
            return Math.min(executeStart, messageStart);
        } else if (executeStart >= 0) {
            return executeStart;
        } else if (messageStart >= 0) {
            return messageStart;
        }
        return -1;
    }

    private static String extractMessageContent(String response) {
        // Extract content from all <message>...</message> blocks
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("<message>(.*?)</message>", java.util.regex.Pattern.DOTALL);
        java.util.regex.Matcher matcher = pattern.matcher(response);
        StringBuilder content = new StringBuilder();
        while (matcher.find()) {
            if (content.length() > 0) {
                content.append(" ");
            }
            String messageText = matcher.group(1).trim();
            // Limit length to avoid huge warnings
            if (messageText.length() > 200) {
                messageText = messageText.substring(0, 200) + "...";
            }
            content.append(messageText);
        }
        return content.toString();
    }

    private static String stripMessageBlocks(String response) {
        // Remove all <message>...</message> blocks
        return response.replaceAll("<message>.*?</message>", "");
    }

    private static ParsedResponse parseExecuteBlock(LenientXMLParser.Element executeElement, List<String> warnings) {
        List<ToolUse> tools = new ArrayList<>();

        List<LenientXMLParser.Element> toolElements = executeElement.getChildren("tool");

        for (LenientXMLParser.Element toolElement : toolElements) {
            String toolName = toolElement.getAttribute("name");
            if (toolName == null || toolName.trim().isEmpty()) {
                // Skip malformed tool elements without name attribute
                warnings.add("Skipped malformed <tool> element without 'name' attribute. Tool element: " + toolElement.toString());
                continue;
            }

            Map<String, String> parameters = new HashMap<>();

            List<LenientXMLParser.Element> paramElements = toolElement.getChildren("parameter");
            for (LenientXMLParser.Element paramElement : paramElements) {
                String paramName = paramElement.getAttribute("name");
                if (paramName == null) {
                    throw new IllegalArgumentException("Parameter element missing 'name' attribute");
                }

                // FIX: Also clean up parameter names (AI sometimes sends malformed attribute values)
                if (paramName != null) {
                    paramName = paramName.replace("\\\n", "\\n").replace("\\\r\n", "\\n").replace("\\", "");
                }

                String paramValue = paramElement.textContent;

                // FIX: Convert backslash line continuation to proper \n escapes
                // AI sometimes sends: "line1\<newline>line2" which is invalid JSON
                // We need: "line1\nline2" (the two-character escape sequence)
                // This fixes it BEFORE logging to conversation.jsonl and sending to UI
                if (paramValue != null) {
                    paramValue = paramValue.replace("\\\n", "\\n").replace("\\\r\n", "\\n");
                }

                parameters.put(paramName, paramValue);
            }

            tools.add(new ToolUse(toolName, parameters));
        }

        if (tools.isEmpty()) {
            throw new IllegalArgumentException("No tools found in <execute> block");
        }

        return new ParsedResponse(tools, warnings);
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/SetupManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;

/**
 * Manages setup state and bridge configuration checks
 *
 * Per user-interface-spec.md lines 487-528:
 * - Check if bridge is configured on startup
 * - Block AI messages until setup complete
 * - Allow limited commands during setup: help, copyjs, mousecapture, quit
 */
public class SetupManager {
    private final IConfigManager config;
    private final ILogger logger;
    private boolean setupComplete;

    public SetupManager(IConfigManager config, ILogger logger) {
        this.config = config;
        this.logger = logger;
        this.setupComplete = false;
    }

    /**
     * Check if bridge setup is complete
     *
     * TODO: Implementation per user-interface-spec.md lines 487-528
     * 1. Load config.json via config.get("clickX") and config.get("clickY")
     * 2. Check if both clickX and clickY are configured (not null, not empty)
     * 3. If configured: return true
     * 4. If not configured: return false
     * 5. Log result: "Bridge setup: complete" or "Bridge setup: incomplete"
     */
    public boolean isSetupComplete() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Check if setup is needed (inverse of isSetupComplete)
     */
    public boolean needsSetup() {
        return !isSetupComplete();
    }

    /**
     * Mark setup as complete (called after mousecapture succeeds)
     *
     * TODO: Implementation
     * 1. Set setupComplete flag to true
     * 2. Log: "Bridge setup marked as complete"
     * 3. This is called by MouseCaptureCommand after saving coordinates
     */
    public void markSetupComplete() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Get setup instructions message
     *
     * TODO: Implementation per user-interface-spec.md lines 493-505
     * Returns formatted message:
     * "| Setup Instructions:
     *  | 1. Open the internal AI UI in your browser
     *  | 2. Open DevTools (F12)
     *  | 3. Go to Console tab
     *  | 4. Paste and press Enter
     *  | 5. Run \"mousecapture\" command to configure click position"
     */
    public String getSetupInstructions() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Get error message for AI requests before setup
     *
     * TODO: Implementation per user-interface-spec.md lines 509-514
     * Returns:
     * "[X] Cannot send messages to AI yet
     *  | Run \"copyjs\" and set up the browser bridge first
     *  | See README.md for setup instructions"
     */
    public String getSetupRequiredError() {
        throw new RuntimeException("NOT IMPLEMENTED");
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/ToolCategory.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

public enum ToolCategory {
    FILE_OPERATIONS,
    FILE_READ,
    SEARCH,
    CHECKLIST,
    GIT_READ,
    GIT_WRITE,
    TASK,
    COMMAND_EXECUTION
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/UndoCommand.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;

/**
 * Undo command implementation
 *
 * Per user-interface-spec.md lines 201-289:
 * - Accepts optional count parameter (default 1, max 50)
 * - Shows list of operations to undo with confirmation prompt
 * - User can adjust count with +num or -num
 * - Executes undo operations via UndoStack in LIFO order
 */
public class UndoCommand implements ICommand {
    private final UndoStack undoStack;
    private final ILogger logger;

    public UndoCommand(UndoStack undoStack, ILogger logger) {
        this.undoStack = undoStack;
        this.logger = logger;
    }

    @Override
    public CommandDispatcher.CommandResult execute(String[] args) {
        /**
         * TODO: Implementation per user-interface-spec.md lines 201-289
         *
         * 1. Parse count parameter:
         *    - If args.length == 0: count = 1 (default)
         *    - If args.length == 1: parse args[0] as integer
         *    - If invalid: return error "Invalid parameter: <arg>"
         *    - If count > 50: return error "Maximum undo count is 50"
         *
         * 2. Validate undo stack:
         *    - If undoStack.isEmpty(): return error "No operations available to undo"
         *    - If count > undoStack.size(): return error "Cannot undo N operations (only X available)"
         *
         * 3. Build confirmation prompt:
         *    - Call undoStack.peekLast(count) to get operations
         *    - Format message:
         *      "Will undo the following N operations:
         *       N. File: path - description (X lines changed)
         *       ...
         *       1. Commit: "message" (X files changed)
         *
         *       Proceed? [y/n/+num/-num]"
         *
         * 4. Return CommandResult with prompt message
         *    - success = true (prompt generated)
         *    - message = formatted prompt
         *    - Note: Actual undo execution happens after user confirms
         *          (handled by ConversationManager via separate flow)
         *
         * 5. User response handling (TODO in ConversationManager):
         *    - y: Execute undoStack.undo(count)
         *    - n: Cancel operation
         *    - +num: Increase count, regenerate prompt
         *    - -num: Decrease count, regenerate prompt
         */

        // Parse count parameter
        int count = 1;
        if (args.length > 0) {
            try {
                count = Integer.parseInt(args[0]);
                if (count <= 0) {
                    return new CommandDispatcher.CommandResult(false,
                        "[X] Invalid parameter: " + args[0] + "\n| Parameter must be a positive number\n| Usage: undo [number]");
                }
                if (count > 50) {
                    return new CommandDispatcher.CommandResult(false,
                        "[X] Maximum undo count is 50\n| Usage: undo [number]");
                }
            } catch (NumberFormatException e) {
                return new CommandDispatcher.CommandResult(false,
                    "[X] Invalid parameter: " + args[0] + "\n| Usage: undo [number]\n| Example: undo 3");
            }
        }

        // Validate undo stack
        if (undoStack.isEmpty()) {
            return new CommandDispatcher.CommandResult(false,
                "[X] No operations available to undo\n| The undo history is empty");
        }

        if (count > undoStack.size()) {
            return new CommandDispatcher.CommandResult(false,
                "[X] Cannot undo " + count + " operations (only " + undoStack.size() + " available)\n| Use \"undo " + undoStack.size() + "\" or less");
        }

        // TODO: Build confirmation prompt with operation details
        // TODO: Get operations from undoStack.peekLast(count)
        // TODO: Format detailed message with file paths, descriptions, line counts

        logger.log("Undo command executed (STUBBED): count=" + count);
        return new CommandDispatcher.CommandResult(true,
            "| Will undo the following " + count + " operation(s):\n" +
            "| (STUBBED - operation details will be shown here)\n" +
            "| Proceed? [y/n/+num/-num]");
    }

    @Override
    public String getHelp() {
        return "Undo last x operations (default: 1)";
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/aiprocessor/UndoStack.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.aiprocessor;

import com.codeboss.javalayer.bridge.*;
import java.util.*;

/**
 * Stack-based (LIFO) undo system for file modifications and git commits
 *
 * Per undo-system-spec.md:
 * - Uses conversation.jsonl as source of truth
 * - LIFO order prevents file corruption from partial undos
 * - Tracks file modifications via file_hash_before/after
 * - Tracks git commits via commit_id
 */
public class UndoStack {
    private final ILogger logger;
    private final Stack<UndoOperation> operationStack;
    private final FileHashTracker hashTracker;
    private final String workingDirectory;

    public UndoStack(ILogger logger, FileHashTracker hashTracker, String workingDirectory) {
        this.logger = logger;
        this.hashTracker = hashTracker;
        this.workingDirectory = workingDirectory;
        this.operationStack = new Stack<>();
    }

    /**
     * Push undoable operation onto stack
     *
     * TODO: Implementation
     * 1. Add operation to operationStack (LIFO)
     * 2. Log operation for debugging
     * 3. Return success/failure
     */
    public void push(UndoOperation operation) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Undo the last N operations (LIFO order)
     *
     * TODO: Implementation per undo-system-spec.md lines 40-68
     * 1. Parse count from command (default 1)
     * 2. Build list of operations to undo (most recent N)
     * 3. Display confirmation prompt:
     *    "Will undo the following N operations:
     *     3. File: Calculator.java - Added input validation (3 lines changed)
     *     2. File: main.java - Updated test demonstration (2 lines changed)
     *     1. Commit: "Add circle area calculation feature" (4 files changed)
     *
     *     Proceed? [y/n/+num/-num]"
     * 4. Handle user response:
     *    - y: proceed with undo
     *    - n: cancel
     *    - +N: increase count by N
     *    - -N: decrease count by N
     * 5. For each operation in LIFO order:
     *    - Call undoFileModification() or undoGitCommit()
     * 6. Pop successfully undone operations from stack
     * 7. Return count of operations undone
     */
    public int undo(int count) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Undo single file modification operation
     *
     * TODO: Implementation per undo-system-spec.md lines 71-77
     * 1. Get file_path from operation
     * 2. Check current file hash against file_hash_after
     * 3. If mismatch:
     *    - Warn user about external changes
     *    - Prompt for confirmation to proceed
     *    - If user says no, abort
     * 4. Apply reverse diff to restore file to previous state
     * 5. Verify final hash matches file_hash_before
     * 6. If hash verification fails, throw error
     * 7. Return success/failure
     */
    private boolean undoFileModification(UndoOperation operation) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Undo git commit operation
     *
     * TODO: Implementation per undo-system-spec.md lines 79-81
     * 1. Get commit_id from operation
     * 2. Run: git reset --hard commit_id^
     * 3. If conflicts occur:
     *    - Inform user about conflicts
     *    - Request manual resolution
     *    - Abort undo
     * 4. Return success/failure
     */
    private boolean undoGitCommit(UndoOperation operation) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Peek at last N operations without removing from stack
     *
     * TODO: Implementation
     * 1. Return last N operations from stack (without removing)
     * 2. Used for displaying confirmation prompt
     * 3. Return empty list if stack has < N operations
     */
    public List<UndoOperation> peekLast(int count) {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    /**
     * Check if stack is empty
     */
    public boolean isEmpty() {
        return operationStack.isEmpty();
    }

    /**
     * Get count of operations in stack
     */
    public int size() {
        return operationStack.size();
    }

    /**
     * Represents an undoable operation (file modification or git commit)
     */
    public static class UndoOperation {
        public String description;           // Human-readable description
        public String operationType;         // "file_modification" or "git_commit"

        // For file modifications (per undo-system-spec.md lines 9-23)
        public String filePath;              // Path to modified file
        public String diff;                  // Diff showing changes (for display)
        public String fileHashBefore;        // SHA-256 hash before modification
        public String fileHashAfter;         // SHA-256 hash after modification

        // For git commits (per undo-system-spec.md lines 25-38)
        public String commitId;              // Git commit hash
        public String commitMessage;         // Commit message

        public UndoOperation(String description, String operationType) {
            this.description = description;
            this.operationType = operationType;
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/IClipboardManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge;

/**
 * Interface for clipboard operations and bridge communication
 *
 * This interface abstracts clipboard operations to allow mock implementations
 * for testing without requiring actual system clipboard access.
 */
public interface IClipboardManager {
    /**
     * Copy text to system clipboard
     * @param text Text to copy
     */
    void copyToClipboard(String text);

    /**
     * Get current clipboard content
     * @return Clipboard text or null if empty
     */
    String getClipboardContent();

    /**
     * Click at specified coordinates (for bridge button)
     * @param x X coordinate
     * @param y Y coordinate
     */
    void clickAtCoordinates(int x, int y);

    /**
     * Wait for automatic response from bridge with polling
     *
     * This method will:
     * 1. Click at the specified coordinates
     * 2. Poll clipboard for response with |||||CLIP:TO_JAVA||||| or |||||CLIP:TO_JAVA_END||||| marker
     * 3. Return when response is found or timeout occurs
     *
     * @param clickX X coordinate to click
     * @param clickY Y coordinate to click
     * @return Response text (without marker), "MOUSE_CANCELLED", or null on timeout
     */
    String waitForAutomaticResponse(int clickX, int clickY);
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/IConfigManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge;

/**
 * Interface for configuration management
 *
 * This interface provides access to application configuration values,
 * allowing mock implementations for testing.
 */
public interface IConfigManager {
    /**
     * Get maximum message characters limit
     * @return Max message chars (e.g., 350000)
     */
    int getMaxMessageChars();

    /**
     * Get X coordinate for auto-click
     * @return X coordinate in pixels
     */
    int getClickX();

    /**
     * Get Y coordinate for auto-click
     * @return Y coordinate in pixels
     */
    int getClickY();

    /**
     * Get server port for HTTP server
     * @return Port number (e.g., 3000)
     */
    int getServerPort();

    /**
     * Get auto-launch browser setting
     * @return true if browser should launch on startup
     */
    boolean shouldAutoLaunchBrowser();

    /**
     * Set server port (for command-line override)
     * @param port Port number to set
     */
    void setServerPort(int port);
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/ILogger.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge;

/**
 * Interface for logging
 *
 * This interface provides a simple logging abstraction,
 * allowing mock implementations for testing that capture log messages.
 */
public interface ILogger {
    /**
     * Log a message
     *
     * @param message Message to log (will be timestamped and written to log file)
     */
    void log(String message);
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/IToolExecutor.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge;

import java.util.Map;

/**
 * Interface for tool execution
 *
 * This interface wraps the existing ToolExecutor implementation,
 * allowing mock implementations for testing.
 */
public interface IToolExecutor {
    /**
     * Execute a tool with given parameters and return detailed result
     *
     * @param toolName Tool name (e.g., "read_file", "create_file")
     * @param params Tool parameters as a Map (e.g., {"file_path": "src/Main.java", "offset": "0"})
     * @return ToolExecutionResult with structured result and summary
     */
    ToolExecutionResult executeToolWithSummary(String toolName, Map<String, String> params);

    /**
     * Result of tool execution
     *
     * Per tools-spec.md and api-spec.md, tools return structured JSON objects.
     * The result field contains the structured data (e.g., {"file_path": "...", "content": "...", "lines": 5}).
     * The summary field contains a human-readable summary for logging/display.
     */
    public static class ToolExecutionResult {
        public Map<String, Object> result;  // Structured result per tools-spec.md
        public String summary;              // Human-readable summary
        public boolean shouldTriggerReview; // True if this tool completion should trigger a review

        public ToolExecutionResult(Map<String, Object> result, String summary) {
            this.result = result;
            this.summary = summary;
            this.shouldTriggerReview = false;
        }

        public ToolExecutionResult(Map<String, Object> result, String summary, boolean shouldTriggerReview) {
            this.result = result;
            this.summary = summary;
            this.shouldTriggerReview = shouldTriggerReview;
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/mock/DynamicTimeout.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge.mock;

/**
 * Timeout that can be extended dynamically as AI calls happen.
 * Shared between SSEAssertions, MockClipboardManager, and Exp validators.
 *
 * Uses ThreadLocal so each test thread has its own timeout.
 */
public class DynamicTimeout {
    private static final ThreadLocal<DynamicTimeout> current = new ThreadLocal<>();

    private long deadlineMs;
    private final long extensionMs;

    public DynamicTimeout(long initialTimeoutMs, long extensionMs) {
        this.deadlineMs = System.currentTimeMillis() + initialTimeoutMs;
        this.extensionMs = extensionMs;
    }

    /**
     * Set the timeout for the current thread
     */
    public static void setCurrent(DynamicTimeout timeout) {
        current.set(timeout);
    }

    /**
     * Get the timeout for the current thread
     */
    public static DynamicTimeout getCurrent() {
        return current.get();
    }

    /**
     * Clear the timeout for the current thread
     */
    public static void clearCurrent() {
        current.remove();
    }

    /**
     * Extend the deadline by the configured extension time
     */
    public synchronized void extend() {
        deadlineMs = System.currentTimeMillis() + extensionMs;
        System.out.println("  [Timeout extended by " + (extensionMs/1000) + "s]");
    }

    /**
     * Check if timeout has been exceeded
     */
    public synchronized boolean isExpired() {
        return System.currentTimeMillis() > deadlineMs;
    }

    /**
     * Get remaining time in milliseconds
     */
    public synchronized long getRemainingMs() {
        return Math.max(0, deadlineMs - System.currentTimeMillis());
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/mock/MockClipboardManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge.mock;

import com.codeboss.javalayer.bridge.*;

/**
 * Mock clipboard manager for testing
 *
 * Uses real AI API via proxy for all responses
 */
public class MockClipboardManager implements IClipboardManager {
    private String clipboard = "";
    private Object aiBridge = null;
    private String systemPrompt = "";
    private ILogger logger = null;
    private int aiCallCount = 0;
    private long totalAiTimeMs = 0;

    public void setAIBridge(Object aiBridge, String systemPrompt) {
        this.aiBridge = aiBridge;
        this.systemPrompt = systemPrompt;
    }

    public void setLogger(ILogger logger) {
        this.logger = logger;
    }

    public int getAiCallCount() {
        return aiCallCount;
    }

    public long getTotalAiTimeMs() {
        return totalAiTimeMs;
    }

    @Override
    public void copyToClipboard(String text) {
        this.clipboard = text;
    }

    @Override
    public String getClipboardContent() {
        return clipboard;
    }

    @Override
    public void clickAtCoordinates(int x, int y) {
    }

    @Override
    public String waitForAutomaticResponse(int clickX, int clickY) {
        if (aiBridge == null) {
            throw new RuntimeException("AI bridge not configured");
        }

        // Extend timeout for this AI call
        DynamicTimeout timeout = DynamicTimeout.getCurrent();
        if (timeout != null) {
            timeout.extend();
        }

        long startTime = System.currentTimeMillis();
        aiCallCount++;

        if (logger != null) {
            logger.log("AI call #" + aiCallCount + " starting...");
        }

        try {
            String userMessage = extractUserMessage(clipboard);
            Class<?> clazz = aiBridge.getClass();
            java.lang.reflect.Method method = clazz.getMethod("sendMessage", String.class, String.class);
            String response = (String) method.invoke(aiBridge, systemPrompt, userMessage);

            // Check if response is null
            if (response == null) {
                throw new RuntimeException("AI bridge returned null response (API call may have failed)");
            }

            long duration = System.currentTimeMillis() - startTime;
            totalAiTimeMs += duration;

            if (logger != null) {
                logger.log("AI call #" + aiCallCount + " completed in " + duration + "ms (total: " + totalAiTimeMs + "ms)");
            }

            return response + "\n|||||CLIP:TO_JAVA_END|||||";
        } catch (RuntimeException re) {
            long duration = System.currentTimeMillis() - startTime;
            totalAiTimeMs += duration;

            if (logger != null) {
                logger.log("AI call #" + aiCallCount + " FAILED after " + duration + "ms (total: " + totalAiTimeMs + "ms)");
            }

            // Re-throw RuntimeExceptions as-is
            throw re;
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            totalAiTimeMs += duration;

            if (logger != null) {
                logger.log("AI call #" + aiCallCount + " FAILED after " + duration + "ms (total: " + totalAiTimeMs + "ms)");
            }

            // Wrap other exceptions with more context
            String errorMsg = e.getMessage();
            if (errorMsg == null || errorMsg.trim().isEmpty()) {
                errorMsg = e.getClass().getSimpleName() + " occurred";
            }

            // Include cause information if available
            Throwable cause = e.getCause();
            if (cause != null && cause.getMessage() != null) {
                errorMsg += " (caused by: " + cause.getMessage() + ")";
            }

            throw new RuntimeException("AI bridge call failed: " + errorMsg, e);
        }
    }

    private String extractUserMessage(String clipboardContent) {
        if (clipboardContent == null || clipboardContent.isEmpty()) {
            return "";
        }

        int markerIndex = clipboardContent.indexOf("|||||CLIP:TO_BRIDGE|||||");
        if (markerIndex != -1) {
            return clipboardContent.substring(0, markerIndex).trim();
        }

        return clipboardContent;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/mock/MockConfigManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge.mock;

import com.codeboss.javalayer.bridge.*;

/**
 * Mock config manager for testing
 */
public class MockConfigManager implements IConfigManager {
    private int serverPort = 3000;
    private boolean autoLaunchBrowser = false;
    private int maxMessageChars = 350000;

    public void setServerPort(int port) {
        this.serverPort = port;
    }

    public void setAutoLaunchBrowser(boolean auto) {
        this.autoLaunchBrowser = auto;
    }

    @Override
    public int getMaxMessageChars() {
        return maxMessageChars;
    }

    @Override
    public int getClickX() {
        return 500;
    }

    @Override
    public int getClickY() {
        return 300;
    }

    @Override
    public int getServerPort() {
        return serverPort;
    }

    @Override
    public boolean shouldAutoLaunchBrowser() {
        return autoLaunchBrowser;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/mock/MockLogger.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge.mock;

import com.codeboss.javalayer.bridge.*;
import java.io.*;
import java.nio.file.*;

/**
 * Mock logger for testing - writes to stdout and optionally to a file
 */
public class MockLogger implements ILogger {
    private String logFilePath;

    public MockLogger() {
        this.logFilePath = null;
    }

    public MockLogger(String logFilePath) {
        this.logFilePath = logFilePath;
    }

    @Override
    public void log(String message) {
        String logLine = "[LOG] " + message;
        System.out.println(logLine);

        if (logFilePath != null) {
            try {
                Files.write(
                    Paths.get(logFilePath),
                    (logLine + "\n").getBytes(),
                    StandardOpenOption.CREATE,
                    StandardOpenOption.APPEND
                );
            } catch (IOException e) {
                System.err.println("Failed to write to log file: " + e.getMessage());
            }
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridge/mock/MockToolExecutor.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridge.mock;

import com.codeboss.javalayer.bridge.*;
import java.util.*;

/**
 * Mock tool executor for testing
 */
public class MockToolExecutor implements IToolExecutor {

    @Override
    public ToolExecutionResult executeToolWithSummary(String toolName, Map<String, String> params) {
        // Mock implementation for testing - return structured result
        Map<String, Object> result = new HashMap<>();
        result.put("mock", true);
        result.put("toolName", toolName);
        result.put("params", params);

        return new ToolExecutionResult(result, "Mock summary for " + toolName);
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/bridgepolling/BridgePollingThread.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.bridgepolling;

import com.codeboss.javalayer.shared.*;
import com.codeboss.javalayer.bridge.*;

/**
 * Thread 3: Bridge Polling
 *
 * Main loop that:
 * 1. Takes AI requests from BridgeQueue
 * 2. Writes request to clipboard with marker
 * 3. Triggers auto-click
 * 4. Polls clipboard for AI response
 * 5. Submits response back to BridgeQueue
 *
 * Lives in bridgelayer package but accepts interfaces for testability
 */
public class BridgePollingThread implements Runnable {
    private final BridgeQueue bridgeQueue;
    private final IClipboardManager clipboardManager;
    private final IConfigManager configManager;
    private final ILogger logger;
    private volatile boolean running = true;

    public BridgePollingThread(
        BridgeQueue bridgeQueue,
        IClipboardManager clipboardManager,
        IConfigManager configManager,
        ILogger logger
    ) {
        this.bridgeQueue = bridgeQueue;
        this.clipboardManager = clipboardManager;
        this.configManager = configManager;
        this.logger = logger;
    }

    @Override
    public void run() {
        logger.log("Bridge polling thread started");

        while (running) {
            try {
                // 1. Take AI request from queue (blocking)
                BridgeQueue.AIRequest request = bridgeQueue.takeRequest();
                logger.log("Bridge received AI request");

                // 2. Format request with bridge marker
                String markedRequest = request.messageJson + "\n|||||CLIP:TO_BRIDGE|||||";

                // 3. Write to clipboard
                clipboardManager.copyToClipboard(markedRequest);

                // 4. Wait for AI response via clipboard polling
                String response = clipboardManager.waitForAutomaticResponse(
                    configManager.getClickX(),
                    configManager.getClickY()
                );

                // 5. Handle special responses
                // NOTE: clipboardManager.waitForAutomaticResponse() already appends markers
                if ("MOUSE_CANCELLED".equals(response)) {
                    // User moved mouse - submit error or retry
                    bridgeQueue.submitResponse("ERROR: Mouse cancelled");
                } else if ("TOKEN_LIMIT_EXCEEDED".equals(response)) {
                    // Token limit reached
                    bridgeQueue.submitResponse("ERROR: Token limit exceeded");
                } else if (response == null) {
                    // Timeout or error
                    bridgeQueue.submitResponse("ERROR: No response received");
                } else {
                    // Normal response (includes |||||CLIP:TO_JAVA_END||||| marker from clipboard)
                    bridgeQueue.submitResponse(response);
                }

            } catch (Exception e) {
                if (e instanceof InterruptedException) {
                    logger.log("Bridge polling interrupted");
                    break;
                }
                logger.log("Bridge polling error: " + e.getMessage());
                e.printStackTrace();
                try {
                    bridgeQueue.submitResponse("ERROR: " + e.getMessage());
                } catch (InterruptedException ie) {
                    break;
                }
            }
        }

        logger.log("Bridge polling thread stopped");
    }

    public void shutdown() {
        running = false;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/httpserver/HttpServer.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.httpserver;

import com.codeboss.javalayer.bridge.*;
import java.io.*;
import java.net.InetSocketAddress;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * HTTP server for serving web UI and API endpoints
 * Runs on Thread 1
 */
public class HttpServer {
    private final ILogger logger;
    private final int port;
    private final Router router;
    private com.sun.net.httpserver.HttpServer server;
    private ExecutorService executor;

    public HttpServer(
        int port,
        Router router,
        ILogger logger
    ) {
        this.port = port;
        this.router = router;
        this.logger = logger;
    }

    public void start() throws IOException {
        logger.log("HTTP server starting on port " + port);

        // Create HttpServer instance with backlog of 0 (default)
        // Note: The Java HttpServer automatically sets SO_REUSEADDR=true
        server = com.sun.net.httpserver.HttpServer.create(new InetSocketAddress(port), 0);

        // Register routes via router
        router.registerRoutes(server);

        // Create executor with fixed thread pool
        executor = Executors.newFixedThreadPool(4);
        server.setExecutor(executor);
        server.start();

        logger.log("HTTP server started successfully on port " + port);
    }

    public void stop() {
        logger.log("HTTP server stopping...");
        if (server != null) {
            // Stop server with 1 second grace period to finish handling current requests
            server.stop(1);
            server = null;
        }

        // Shutdown executor
        if (executor != null) {
            executor.shutdown();
            try {
                if (!executor.awaitTermination(3, TimeUnit.SECONDS)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
            executor = null;
        }

        // Small delay to ensure port is fully released
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        logger.log("HTTP server stopped");
    }

    public int getPort() {
        return port;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/httpserver/Router.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.httpserver;

import com.codeboss.javalayer.bridge.*;
import com.codeboss.javalayer.shared.*;
import com.codeboss.javalayer.aiprocessor.ConversationManager;
import com.codeboss.javalayer.aiprocessor.ChecklistManager;
import com.codeboss.javalayer.aiprocessor.ModeManager;
import com.codeboss.javalayer.aiprocessor.CommandDispatcher;
import com.codeboss.javalayer.aiprocessor.UndoStack;
import com.codeboss.javalayer.toolexecutor.ToolExecutor;
import com.sun.net.httpserver.*;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;

/**
 * Route registration and request routing
 *
 * Single-user application: only one conversation, one frontend connection at a time
 */
public class Router {
    private final ConversationQueue conversationQueue;
    private final ILogger logger;
    private final String frontendDir;
    private final ConversationManager conversationManager;
    private final ChecklistManager checklistManager;
    private final ModeManager modeManager;
    private final ToolExecutor toolExecutor;
    private final CommandDispatcher commandDispatcher;

    // Track if an SSE stream is currently active
    private volatile boolean sseStreamActive = false;
    private final Object sseStreamLock = new Object();

    public Router(
        ConversationQueue conversationQueue,
        ConversationManager conversationManager,
        ChecklistManager checklistManager,
        ModeManager modeManager,
        ToolExecutor toolExecutor,
        IClipboardManager clipboard,
        IConfigManager config,
        UndoStack undoStack,
        ILogger logger
    ) {
        this.conversationQueue = conversationQueue;
        this.conversationManager = conversationManager;
        this.checklistManager = checklistManager;
        this.modeManager = modeManager;
        this.toolExecutor = toolExecutor;
        this.logger = logger;

        // Create CommandDispatcher
        this.commandDispatcher = new CommandDispatcher(clipboard, config, logger, undoStack);

        // Use absolute path to frontend directory
        String codeBasePath = System.getProperty("codeboss.home");
        if (codeBasePath != null) {
            this.frontendDir = codeBasePath + "/src/frontend-ui";
        } else {
            this.frontendDir = "src/frontend-ui";
        }
    }

    public void registerRoutes(com.sun.net.httpserver.HttpServer server) {
        server.createContext("/api/state", this::handleGetState);
        server.createContext("/api/message", this::handlePostMessage);
        server.createContext("/", this::handleStaticFiles);

        logger.log("Routes registered");
    }

    private void handleGetState(HttpExchange exchange) throws IOException {
        try {
            if (!"GET".equals(exchange.getRequestMethod())) {
                sendResponse(exchange, 405, "Method Not Allowed");
                return;
            }

            // Get current state from conversationQueue (non-blocking)
            String currentState = conversationQueue.getCurrentState();

            // If no state yet, return initial empty state
            if (currentState == null) {
                currentState = "{\"status\":\"complete\",\"messages\":[]}";
            }

            // Set JSON response headers
            exchange.getResponseHeaders().set("Content-Type", "application/json");

            // Send response
            sendResponse(exchange, 200, currentState);

        } catch (Exception e) {
            logger.log("Error handling GET /api/state: " + e.getMessage());
            sendResponse(exchange, 500, "{\"error\":\"Internal server error\"}");
        }
    }

    /**
     * Handle GET /api/message - SSE streaming endpoint
     *
     * Process:
     * 1. Parse query parameter: ?message=user+text
     * 2. Submit to conversation queue
     * 3. Stream SSE events with conversation state updates
     * 4. End when status is "complete" or "error"
     */
    private void handlePostMessage(HttpExchange exchange) throws IOException {
        try {
            // 1. Validate POST method
            if (!"POST".equals(exchange.getRequestMethod())) {
                sendResponse(exchange, 405, "Method Not Allowed");
                return;
            }

            // 2. Read and parse request body
            String requestBody = new String(exchange.getRequestBody().readAllBytes());
            String userMessage = parseMessageFromJson(requestBody);

            if (userMessage == null) {
                sendResponse(exchange, 400, "{\"error\":\"Missing 'message' field in JSON\"}");
                return;
            }

            logger.log("Received message: " + userMessage);

            // 3. Check if message is a command (before SSE setup and approval checks)
            CommandDispatcher.CommandResult commandResult = tryExecuteCommand(userMessage);
            if (commandResult != null) {
                // Command was executed - add user message first, then result messages
                conversationManager.addUserMessage(userMessage);
                logger.log("Command executed, success=" + commandResult.success + ", message length: " + commandResult.message.length());

                // Check if command returned clipboard data
                if (commandResult.message.startsWith("CLIPBOARD_COPY:")) {
                    String clipboardData = commandResult.message.substring(15); // Remove prefix
                    logger.log("Command returned clipboard data (" + clipboardData.length() + " bytes)");

                    // Add command_result message with clipboard data
                    conversationManager.addCommandResultMessage(clipboardData);

                    // Add user-friendly assistant message
                    conversationManager.addAssistantMessage("Bridge script copied to clipboard");
                } else {
                    // Regular command result - just add as assistant message
                    conversationManager.addAssistantMessage(commandResult.message);
                }

                // Set status to complete (commands execute instantly, no AI processing needed)
                conversationManager.getState().setStatus("complete");

                // Get and publish state
                String stateJson = conversationManager.getConversationStateJson();
                conversationQueue.publishState(stateJson);
                logger.log("Command response state published, sending SSE response");

                // Set up SSE and send single update
                exchange.getResponseHeaders().set("Content-Type", "text/event-stream; charset=utf-8");
                exchange.getResponseHeaders().set("Cache-Control", "no-cache");
                exchange.getResponseHeaders().set("Connection", "keep-alive");
                exchange.getResponseHeaders().set("X-Accel-Buffering", "no");
                exchange.sendResponseHeaders(200, 0);

                java.io.OutputStream outputStream = exchange.getResponseBody();
                final java.io.PrintWriter writer = new java.io.PrintWriter(outputStream, true);

                // Send current state and close
                writer.println("event: conversation_state");
                writer.println("data: " + stateJson);
                writer.println();
                writer.flush();
                writer.close();
                logger.log("Command SSE response sent and stream closed");
                return;
            }

            // 4. Set SSE headers FIRST before processing approvals
            exchange.getResponseHeaders().set("Content-Type", "text/event-stream; charset=utf-8");
            exchange.getResponseHeaders().set("Cache-Control", "no-cache");
            exchange.getResponseHeaders().set("Connection", "keep-alive");
            exchange.getResponseHeaders().set("X-Accel-Buffering", "no");
            exchange.sendResponseHeaders(200, 0); // 0 = unknown length for streaming

            // 5. Get output stream and writer ready
            java.io.OutputStream outputStream = exchange.getResponseBody();
            final java.io.PrintWriter writer = new java.io.PrintWriter(outputStream, true);

            // 6. Check for pending approvals and intercept yes/no responses
            if (conversationManager.isAwaitingTestCommandApproval()) {
                String normalized = userMessage.trim().toLowerCase();

                if (normalized.equals("yes") || normalized.equals("y")) {
                    handleTestCommandApprovalYes();
                    // Continue with SSE streaming below
                } else if (normalized.equals("no") || normalized.equals("n")) {
                    handleTestCommandApprovalNo(userMessage);
                    // Continue with SSE streaming below
                } else {
                    // User sent something else - treat as implicit rejection
                    conversationManager.addSystemMessage(
                        "Test command was pending approval. Processing your new request instead."
                    );
                    conversationManager.clearPendingTestCommand();
                    conversationQueue.submitMessage(userMessage);
                }
            } else if (conversationManager.isAwaitingApproval()) {
                String normalized = userMessage.trim().toLowerCase();

                if (normalized.equals("yes") || normalized.equals("y")) {
                    handleApprovalYes();
                    // Continue with SSE streaming below
                } else if (normalized.equals("no") || normalized.equals("n")) {
                    handleApprovalNo(userMessage);
                    // Continue with SSE streaming below
                } else {
                    // User sent something else - treat as implicit rejection and new message
                    conversationManager.addSystemMessage(
                        "Plan was pending approval. Processing your new request instead."
                    );
                    conversationManager.clearPendingApproval();

                    // Submit user's message to queue - AIProcessorThread will process it normally
                    conversationQueue.submitMessage(userMessage);
                }
            } else {
                // Normal message flow - clear old states and submit to AI
                // Note: AIProcessorThread will add the user message when it processes it
                conversationQueue.clearStateUpdates();
                conversationQueue.submitMessage(userMessage);
            }

            // 7. Stream conversation state updates
            // Only allow ONE SSE stream at a time (single-user app)
            synchronized (sseStreamLock) {
                if (sseStreamActive) {
                    logger.log("SSE stream already active, rejecting new connection");
                    sendResponse(exchange, 409, "{\"error\":\"Another SSE stream is already active\"}");
                    return;
                }
                sseStreamActive = true;
            }

            try {
                while (true) {
                    // Block until next state update is available
                    String stateJson = conversationQueue.takeStateUpdate();

                    if (stateJson == null) {
                        // Queue was shut down
                        break;
                    }

                    // Send SSE event
                    // Extract message count for logging
                    int msgCount = extractMessageCountFromJson(stateJson);
                    System.out.println("[HTTP-SEND] About to send SSE event with " + msgCount + " messages");

                    try {
                        writer.println("event: conversation_state");
                        writer.println("data: " + stateJson);
                        writer.println(); // Blank line terminates event
                        writer.flush();

                        // Check if writer encountered an error (client disconnected)
                        if (writer.checkError()) {
                            logger.log("SSE stream client disconnected (writer error detected)");
                            break;
                        }

                        outputStream.flush(); // Force flush of underlying stream to prevent buffering
                    } catch (IOException ioe) {
                        logger.log("SSE stream broken (IOException): " + ioe.getMessage());
                        break;
                    }

                    System.out.println("[HTTP-SEND] SSE event sent and flushed (" + msgCount + " messages)");

                    // Check if conversation is complete
                    if (stateJson.contains("\"status\":\"complete\"") ||
                        stateJson.contains("\"status\":\"error\"")) {
                        logger.log("Conversation complete, ending SSE stream");
                        break;
                    }
                }
            } catch (Exception e) {
                logger.log("SSE stream error: " + e.getMessage());
                // Fall through to finally block to clean up
            } finally {
                // Always release the SSE stream flag when done
                synchronized (sseStreamLock) {
                    sseStreamActive = false;
                }
                logger.log("SSE stream ended, flag cleared");
            }

            writer.flush();  // Ensure all data is sent before closing
            writer.close();

        } catch (InterruptedException e) {
            logger.log("SSE stream interrupted: " + e.getMessage());
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            logger.log("Error handling POST /api/message: " + e.getMessage());
            e.printStackTrace();
            sendResponse(exchange, 500, "{\"error\":\"Internal server error\"}");
        }
    }

    private String parseMessageFromJson(String json) {
        return LenientJsonParser.extractString(json, "message");
    }

    private int extractMessageCountFromJson(String json) {
        try {
            int messagesIdx = json.indexOf("\"messages\":[");
            if (messagesIdx == -1) return 0;
            int depth = 0;
            int count = 0;
            boolean inArray = false;
            for (int i = messagesIdx; i < json.length(); i++) {
                char c = json.charAt(i);
                if (c == '[') {
                    depth++;
                    if (depth == 1) inArray = true;
                } else if (c == ']') {
                    depth--;
                    if (depth == 0) break;
                } else if (c == '{' && depth == 1 && inArray) {
                    count++;
                }
            }
            return count;
        } catch (Exception e) {
            return -1;
        }
    }

    private void handleApprovalYes() throws InterruptedException {
        // Get pending checklist
        String checklistJson = conversationManager.getPendingChecklistJson();
        String description = conversationManager.getPendingPlanDescription();

        // Clear any existing checklist before adding new items
        checklistManager.clearChecklist();

        // Execute the plan: parse checklist and add to ChecklistManager
        toolExecutor.parseAndAddChecklist(checklistJson);

        // Transition to EXECUTION mode
        modeManager.transitionTo("execution");

        // Clear approval state
        conversationManager.clearPendingApproval();

        // Set flag so AIProcessorThread knows to add first task notification
        conversationManager.setJustStartedExecution();

        // Submit "yes" to wake up AI thread - AIProcessorThread will handle state publishing
        conversationQueue.submitMessage("yes");

        logger.log("Approval YES: Transitioned to EXECUTION mode, submitted 'yes' to queue");
    }

    private void handleApprovalNo(String userMessage) throws InterruptedException {
        String description = conversationManager.getPendingPlanDescription();

        // Add system message about rejection
        conversationManager.addSystemMessage(
            "User rejected plan: " + description +
            ". Please ask what changes they'd like or create a new plan."
        );

        // Clear approval state (stay in PLANNING mode)
        conversationManager.clearPendingApproval();

        // Submit the user's "no" message to queue - AIProcessorThread will process it normally
        // It will add "no" to conversation and continue in PLANNING mode
        conversationQueue.submitMessage(userMessage);

        logger.log("Approval NO: Staying in PLANNING mode, submitted '" + userMessage + "' to queue");
    }

    private void handleTestCommandApprovalYes() throws InterruptedException {
        // Get pending test command details
        String name = conversationManager.getPendingTestCommandName();
        String command = conversationManager.getPendingTestCommand();
        String description = conversationManager.getPendingTestDescription();

        // Save command to .agent/commands/<name>.txt
        try {
            String workingDir = conversationManager.getWorkingDirectory();
            com.codeboss.javalayer.toolexecutor.CommandManager cmdMgr =
                new com.codeboss.javalayer.toolexecutor.CommandManager(workingDir);
            cmdMgr.saveCommand(name, command);

            // Add system message confirming creation
            String msg = "Test command '" + name + "' created successfully";
            if (description != null && !description.isEmpty()) {
                msg += ": " + description;
            }
            conversationManager.addSystemMessage(msg);

        } catch (Exception e) {
            conversationManager.addSystemMessage(
                "Error creating test command: " + e.getMessage()
            );
        }

        // Clear approval state
        conversationManager.clearPendingTestCommand();

        // Submit "yes" to queue - AIProcessorThread will process it normally
        conversationQueue.submitMessage("yes");

        logger.log("Test command approval YES: Created command '" + name + "'");
    }

    private void handleTestCommandApprovalNo(String userMessage) throws InterruptedException {
        String name = conversationManager.getPendingTestCommandName();

        // Add system message about rejection
        conversationManager.addSystemMessage(
            "Test command '" + name + "' rejected. Please revise if needed."
        );

        // Clear approval state
        conversationManager.clearPendingTestCommand();

        // Submit user's message to queue
        conversationQueue.submitMessage(userMessage);

        logger.log("Test command approval NO: Rejected command '" + name + "'");
    }

    /**
     * Handle GET /api/interrupt - interrupt AI processing
     *
     * TODO: Implementation per user-interface-spec.md lines 338-419
     * 1. Call conversationQueue.setInterrupted()
     * 2. Return 200 OK immediately with empty body
     * 3. AIProcessorThread will detect flag and stop gracefully
     */
    private void handleInterrupt(HttpExchange exchange) throws IOException {
        throw new RuntimeException("NOT IMPLEMENTED");
    }

    private void handleStaticFiles(HttpExchange exchange) throws IOException {
        if (!"GET".equals(exchange.getRequestMethod())) {
            sendResponse(exchange, 405, "Method Not Allowed");
            return;
        }

        String path = exchange.getRequestURI().getPath();

        // Strip query parameters for file matching
        String basePath = path;
        if (path.contains("?")) {
            basePath = path.substring(0, path.indexOf("?"));
        }

        if (basePath.equals("/") || basePath.equals("/index.html")) {
            serveFile(exchange, "index.html", "text/html");
        } else if (basePath.equals("/styles.css")) {
            serveFile(exchange, "styles.css", "text/css");
        } else if (path.equals("/vdom.js")) {
            serveFile(exchange, "vdom.js", "application/javascript");
        } else if (path.equals("/diff.js")) {
            serveFile(exchange, "diff.js", "application/javascript");
        } else if (path.equals("/render.js")) {
            serveFile(exchange, "render.js", "application/javascript");
        } else if (path.equals("/api.js")) {
            serveFile(exchange, "api.js", "application/javascript");
        } else if (path.equals("/main.js")) {
            serveFile(exchange, "main.js", "application/javascript");
        } else {
            sendResponse(exchange, 404, "Not Found");
        }
    }

    private void serveFile(HttpExchange exchange, String filename, String contentType) throws IOException {
        Path filePath = Paths.get(frontendDir, filename);

        if (!Files.exists(filePath)) {
            logger.log("File not found: " + filePath);
            sendResponse(exchange, 404, "File not found");
            return;
        }

        byte[] content = Files.readAllBytes(filePath);

        exchange.getResponseHeaders().set("Content-Type", contentType + "; charset=utf-8");
        exchange.getResponseHeaders().set("Cache-Control", "no-cache, no-store, must-revalidate");
        exchange.sendResponseHeaders(200, content.length);

        try (OutputStream os = exchange.getResponseBody()) {
            os.write(content);
        }
    }

    private void sendResponse(HttpExchange exchange, int statusCode, String response) throws IOException {
        byte[] bytes = response.getBytes(StandardCharsets.UTF_8);
        exchange.sendResponseHeaders(statusCode, bytes.length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(bytes);
        }
    }

    /**
     * Try to execute user message as a command
     * Returns CommandResult if message is a command, null otherwise
     */
    private CommandDispatcher.CommandResult tryExecuteCommand(String userMessage) {
        String trimmed = userMessage.trim();

        // Check if message is a simple command (no args)
        Set<String> availableCommands = commandDispatcher.getAvailableCommands();
        if (availableCommands.contains(trimmed)) {
            logger.log("Detected command (no args): " + trimmed);
            return commandDispatcher.dispatch(trimmed, new String[0]);
        }

        // Check if message is a command with args (space-separated)
        String[] parts = trimmed.split("\\s+", 2);
        if (parts.length > 0 && availableCommands.contains(parts[0])) {
            logger.log("Detected command with args: " + parts[0] + " (args: " + (parts.length > 1 ? parts[1] : "none") + ")");
            String[] args = parts.length > 1 ? parts[1].split("\\s+") : new String[0];
            return commandDispatcher.dispatch(parts[0], args);
        }

        // Not a command
        logger.log("Message is not a command, routing to AI");
        return null;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/shared/BaseTokenizer.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.shared;

/**
 * Abstract base class for tokenizers with common functionality
 * Handles character navigation and lookahead
 */
public abstract class BaseTokenizer implements Tokenizer {
    protected final String source;
    protected int current = 0;
    protected Token peeked = null;

    public BaseTokenizer(String source) {
        this.source = source != null ? source : "";
    }

    @Override
    public Token nextToken() {
        if (peeked != null) {
            Token token = peeked;
            peeked = null;
            return token;
        }
        return scanToken();
    }

    @Override
    public Token peekToken() {
        if (peeked == null) {
            peeked = scanToken();
        }
        return peeked;
    }

    @Override
    public boolean isAtEnd() {
        return current >= source.length();
    }

    @Override
    public int getPosition() {
        return current;
    }

    /**
     * Subclasses implement this to scan the next token
     */
    protected abstract Token scanToken();

    /**
     * Advance and return current character
     */
    protected char advance() {
        return source.charAt(current++);
    }

    /**
     * Return current character without advancing
     */
    protected char peek() {
        if (isAtEnd()) return '\0';
        return source.charAt(current);
    }

    /**
     * Return character at offset without advancing
     */
    protected char peek(int offset) {
        int pos = current + offset;
        if (pos >= source.length()) return '\0';
        return source.charAt(pos);
    }

    /**
     * Check if current character matches expected, advance if so
     */
    protected boolean match(char expected) {
        if (isAtEnd()) return false;
        if (source.charAt(current) != expected) return false;
        current++;
        return true;
    }

    /**
     * Check if current character matches any of the expected characters
     */
    protected boolean matchAny(String expected) {
        if (isAtEnd()) return false;
        if (expected.indexOf(source.charAt(current)) == -1) return false;
        current++;
        return true;
    }

    /**
     * Skip whitespace characters
     */
    protected void skipWhitespace() {
        while (!isAtEnd() && Character.isWhitespace(peek())) {
            advance();
        }
    }

    /**
     * Check if character is a digit
     */
    protected boolean isDigit(char c) {
        return c >= '0' && c <= '9';
    }

    /**
     * Check if character can start an identifier/name
     */
    protected boolean isAlpha(char c) {
        return (c >= 'a' && c <= 'z') ||
               (c >= 'A' && c <= 'Z') ||
               c == '_';
    }

    /**
     * Check if character can be in an identifier/name
     */
    protected boolean isAlphaNumeric(char c) {
        return isAlpha(c) || isDigit(c) || c == '-';
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/shared/BridgeQueue.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.shared;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Thread-safe queue for communication between AI processor and bridge layer
 *
 * Thread 2 (aiprocessor): Submits AI requests, waits for responses
 * Thread 3 (bridge-layer): Takes requests, polls clipboard, submits responses
 */
public class BridgeQueue {
    private final BlockingQueue<AIRequest> outgoingRequests = new LinkedBlockingQueue<>();
    private final BlockingQueue<AIResponse> incomingResponses = new LinkedBlockingQueue<>();

    /**
     * Submit AI request to bridge (called by AI processor thread)
     * Blocks until response available
     */
    public AIResponse submitRequest(String messageJson) throws InterruptedException {
        AIRequest request = new AIRequest(messageJson);
        outgoingRequests.put(request);

        // Wait for response (blocking)
        AIResponse response = incomingResponses.take();
        return response;
    }

    /**
     * Take next AI request to process (called by bridge thread, blocks)
     */
    public AIRequest takeRequest() throws InterruptedException {
        return outgoingRequests.take();
    }

    /**
     * Submit AI response from clipboard (called by bridge thread)
     */
    public void submitResponse(String responseXml) throws InterruptedException {
        incomingResponses.put(new AIResponse(responseXml));
    }

    /**
     * Represents an AI request to be sent via clipboard
     */
    public static class AIRequest {
        public final String messageJson;
        public final long timestamp;

        public AIRequest(String messageJson) {
            this.messageJson = messageJson;
            this.timestamp = System.currentTimeMillis();
        }
    }

    /**
     * Represents an AI response received from clipboard
     */
    public static class AIResponse {
        public final String responseXml;
        public final long timestamp;

        public AIResponse(String responseXml) {
            this.responseXml = responseXml;
            this.timestamp = System.currentTimeMillis();
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/shared/ConversationQueue.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.shared;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Thread-safe queue for communication between HTTP server and AI processor
 *
 * Thread 1 (httpserver): Submits user messages, polls latest conversation state
 * Thread 2 (aiprocessor): Takes messages, publishes conversation state updates
 *
 * TODO: Add interrupt/cancellation support per user-interface-spec.md lines 338-419
 * - ESC ESC from web UI should interrupt AI processing or tool execution
 * - Interrupt mechanism: volatile boolean flag or interrupt via Thread.interrupt()
 * - Safe interruption: complete atomic operations (file writes), discard partial responses
 * - After interruption: return to WAITING_FOR_INPUT state, show what was completed
 */
public class ConversationQueue {
    private final BlockingQueue<UserMessage> incomingMessages = new LinkedBlockingQueue<>();
    private final BlockingQueue<String> stateUpdates = new LinkedBlockingQueue<>();

    // Interrupt support per user-interface-spec.md lines 338-419
    private volatile boolean interrupted = false;

    /**
     * Submit a user message for processing (called by HTTP server thread)
     */
    public void submitMessage(String messageText) throws InterruptedException {
        incomingMessages.put(new UserMessage(messageText));
    }

    /**
     * Wait for next conversation state update (called by HTTP server thread for SSE streaming)
     * Blocks until state is available.
     */
    public String takeStateUpdate() throws InterruptedException {
        return stateUpdates.take();
    }

    /**
     * Wait for next user message (called by AI processor thread, blocks)
     */
    public UserMessage takeMessage() throws InterruptedException {
        return incomingMessages.take();
    }

    /**
     * Publish updated conversation state (called by AI processor thread)
     * Queues state for SSE streaming - all updates are delivered
     */
    public void publishState(String conversationStateJson) throws InterruptedException {
        // Extract message count from JSON for logging
        int msgCount = extractMessageCount(conversationStateJson);
        System.out.println("[QUEUE] Publishing state (msg count: " + msgCount + ", queue size before: " + stateUpdates.size() + ")");
        stateUpdates.put(conversationStateJson);
        this.currentState = conversationStateJson;
    }

    private int extractMessageCount(String json) {
        try {
            int messagesIdx = json.indexOf("\"messages\":[");
            if (messagesIdx == -1) return 0;
            int depth = 0;
            int count = 0;
            boolean inArray = false;
            for (int i = messagesIdx; i < json.length(); i++) {
                char c = json.charAt(i);
                if (c == '[') {
                    depth++;
                    if (depth == 1) inArray = true;
                } else if (c == ']') {
                    depth--;
                    if (depth == 0) break;
                } else if (c == '{' && depth == 1 && inArray) {
                    count++;
                }
            }
            return count;
        } catch (Exception e) {
            return -1;
        }
    }

    // Volatile reference to current state for GET /api/state (without blocking)
    private volatile String currentState = null;

    /**
     * Get current conversation state (called by HTTP server for GET /api/state)
     * Non-blocking - returns last published state or null if none yet
     */
    public String getCurrentState() {
        return currentState;
    }

    /**
     * Set interrupt flag (called by GET /api/interrupt endpoint)
     *
     * TODO: Implementation per user-interface-spec.md lines 338-419
     * 1. Set interrupted flag to true
     * 2. This signals AIProcessorThread to stop gracefully
     * 3. Called when user presses ESC ESC in web UI
     */
    public void setInterrupted() {
        interrupted = true;
    }

    /**
     * Check if interrupt has been requested
     *
     * TODO: Implementation per user-interface-spec.md lines 338-419
     * 1. AIProcessorThread should check this periodically during processing
     * 2. If true: stop AI streaming, complete atomic operations, return status="interrupted"
     */
    public boolean isInterrupted() {
        return interrupted;
    }

    /**
     * Clear interrupt flag (called after handling interruption)
     *
     * TODO: Implementation
     * 1. Set interrupted flag to false
     * 2. Reset state after interruption has been handled
     */
    public void clearInterrupted() {
        interrupted = false;
    }

    /**
     * Clear all pending state updates from the queue
     * Used when starting a new request to ensure SSE stream gets fresh state
     */
    public void clearStateUpdates() {
        stateUpdates.clear();
        System.out.println("[QUEUE] Cleared all pending state updates");
    }

    /**
     * Represents a user message to be processed
     */
    public static class UserMessage {
        public final String text;
        public final long timestamp;

        public UserMessage(String text) {
            this.text = text;
            this.timestamp = System.currentTimeMillis();
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/shared/JSONTokenizer.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.shared;

/**
 * Lenient JSON tokenizer for AI-generated JSON
 *
 * Leniency features:
 * - Handles both single and double quotes for strings
 * - Unescapes escape sequences (\\n, \\t, etc.) during tokenization
 * - Removes line continuations (\\<newline>)
 * - Produces clean tokens for the parser to consume
 */
public class JSONTokenizer extends BaseTokenizer {

    public JSONTokenizer(String source) {
        super(source);
    }

    @Override
    protected Token scanToken() {
        skipWhitespace();

        if (isAtEnd()) {
            return new Token(Token.Type.EOF, current);
        }

        int start = current;
        char c = advance();

        switch (c) {
            case '{': return new Token(Token.Type.JSON_LBRACE, start);
            case '}': return new Token(Token.Type.JSON_RBRACE, start);
            case '[': return new Token(Token.Type.JSON_LBRACKET, start);
            case ']': return new Token(Token.Type.JSON_RBRACKET, start);
            case ':': return new Token(Token.Type.JSON_COLON, start);
            case ',': return new Token(Token.Type.JSON_COMMA, start);

            case '"':
            case '\'':
                return scanString(c, start);

            case '-':
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                return scanNumber(start);

            case 't':
                if (match('r') && match('u') && match('e')) {
                    return new Token(Token.Type.JSON_TRUE, "true", start);
                }
                break;

            case 'f':
                if (match('a') && match('l') && match('s') && match('e')) {
                    return new Token(Token.Type.JSON_FALSE, "false", start);
                }
                break;

            case 'n':
                if (match('u') && match('l') && match('l')) {
                    return new Token(Token.Type.JSON_NULL, "null", start);
                }
                break;
        }

        return new Token(Token.Type.ERROR, "Unexpected character: " + c, start);
    }

    /**
     * Scan a string token with lenient handling
     * Supports both double and single quotes
     * Unescapes escape sequences and handles line continuations
     */
    private Token scanString(char quote, int start) {
        StringBuilder value = new StringBuilder();

        while (!isAtEnd() && peek() != quote) {
            char c = advance();

            if (c == '\\') {
                // Handle escape sequences and line continuations
                if (isAtEnd()) {
                    return new Token(Token.Type.ERROR, "Unterminated string", start);
                }

                char next = advance();
                switch (next) {
                    case 'n':
                        value.append('\n');
                        break;
                    case 'r':
                        value.append('\r');
                        break;
                    case 't':
                        value.append('\t');
                        break;
                    case '\\':
                        value.append('\\');
                        break;
                    case '"':
                        value.append('"');
                        break;
                    case '\'':
                        value.append('\'');
                        break;
                    case '/':
                        value.append('/');
                        break;
                    case 'b':
                        value.append('\b');
                        break;
                    case 'f':
                        value.append('\f');
                        break;
                    case '\n':
                        // Line continuation: \<LF> - skip both
                        break;
                    case '\r':
                        // Line continuation: \<CR> or \<CR><LF> - skip
                        if (peek() == '\n') {
                            advance(); // Skip the LF in CRLF
                        }
                        break;
                    default:
                        // Unknown escape - keep the character
                        value.append(next);
                }
            } else {
                value.append(c);
            }
        }

        if (isAtEnd()) {
            return new Token(Token.Type.ERROR, "Unterminated string", start);
        }

        // Consume closing quote
        advance();

        return new Token(Token.Type.JSON_STRING, value.toString(), start);
    }

    /**
     * Scan a number token
     * Supports integers and decimals
     */
    private Token scanNumber(int start) {
        // Handle negative sign (already consumed by advance in scanToken)

        // Consume digits
        while (isDigit(peek())) {
            advance();
        }

        // Look for decimal part
        if (peek() == '.' && isDigit(peek(1))) {
            advance(); // Consume '.'
            while (isDigit(peek())) {
                advance();
            }
        }

        // Look for exponent
        if (matchAny("eE")) {
            if (matchAny("+-")) {
                // Optional sign
            }
            while (isDigit(peek())) {
                advance();
            }
        }

        String lexeme = source.substring(start, current);
        return new Token(Token.Type.JSON_NUMBER, lexeme, start);
    }

    /**
     * Peek backwards (override to handle negative offsets relative to current position after advance)
     */
    private char peekBack(int offset) {
        int pos = current + offset - 1; // -1 because we already advanced
        if (pos < 0 || pos >= source.length()) return '\0';
        return source.charAt(pos);
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/shared/LenientJsonParser.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.shared;

import java.util.*;

/**
 * Lenient JSON parser for AI-generated JSON using recursive descent parsing
 *
 * This parser is designed to handle malformed JSON that AI models commonly generate:
 * - Missing or extra commas
 * - Trailing commas
 * - Single quotes instead of double quotes
 * - Escaped newlines and other escape sequences
 * - Extra whitespace
 *
 * Architecture:
 * - Uses JSONTokenizer for lexical analysis (character-level leniency)
 * - Uses recursive descent parser for structural analysis (context-aware leniency)
 *
 * Since this is only used for parsing AI responses, we prioritize leniency over strict compliance.
 */
public class LenientJsonParser {

    private final JSONTokenizer tokenizer;
    private Token current;

    /**
     * Private constructor - use static factory methods
     */
    private LenientJsonParser(String json) {
        this.tokenizer = new JSONTokenizer(json);
        this.current = tokenizer.nextToken();
    }

    // ========== PUBLIC STATIC API ==========

    /**
     * Extract a string field from JSON
     * Example: extractString("{\"name\":\"value\"}", "name") returns "value"
     */
    public static String extractString(String json, String fieldName) {
        if (json == null || fieldName == null) {
            return null;
        }

        try {
            LenientJsonParser parser = new LenientJsonParser(json);
            Map<String, Object> obj = parser.parseObjectInternal();
            Object value = obj.get(fieldName);
            return value != null ? value.toString() : null;
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Extract an integer field from JSON
     * Example: extractInt("{\"count\":42}", "count") returns 42
     */
    public static Integer extractInt(String json, String fieldName) {
        if (json == null || fieldName == null) {
            return null;
        }

        try {
            LenientJsonParser parser = new LenientJsonParser(json);
            Map<String, Object> obj = parser.parseObjectInternal();
            Object value = obj.get(fieldName);

            if (value == null) {
                return null;
            }

            if (value instanceof Integer) {
                return (Integer) value;
            }

            // Try parsing as string
            try {
                return Integer.parseInt(value.toString());
            } catch (NumberFormatException e) {
                return null;
            }
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Check if JSON contains a field with a specific string value
     * Example: containsFieldValue("{\"status\":\"complete\"}", "status", "complete") returns true
     */
    public static boolean containsFieldValue(String json, String fieldName, String expectedValue) {
        String actualValue = extractString(json, fieldName);
        return actualValue != null && actualValue.equals(expectedValue);
    }

    /**
     * Parse a JSON object into a map
     * Example: parseObject("{\"name\":\"Alice\",\"age\":\"30\"}")
     * Returns: {name=Alice, age=30}
     */
    public static Map<String, String> parseObject(String json) {
        if (json == null || json.trim().isEmpty()) {
            return new LinkedHashMap<>();
        }

        try {
            LenientJsonParser parser = new LenientJsonParser(json);
            Map<String, Object> result = parser.parseObjectInternal();

            // Convert all values to strings for backward compatibility
            Map<String, String> stringMap = new LinkedHashMap<>();
            for (Map.Entry<String, Object> entry : result.entrySet()) {
                Object value = entry.getValue();
                stringMap.put(entry.getKey(), value != null ? value.toString() : null);
            }
            return stringMap;
        } catch (Exception e) {
            return new LinkedHashMap<>();
        }
    }

    /**
     * Parse a JSON array of objects into a list of maps
     * Example: parseArray("[{\"name\":\"Alice\"},{\"name\":\"Bob\"}]")
     * Returns: [{name=Alice}, {name=Bob}]
     */
    public static List<Map<String, String>> parseArray(String json) {
        if (json == null || json.trim().isEmpty()) {
            return new ArrayList<>();
        }

        try {
            LenientJsonParser parser = new LenientJsonParser(json);
            List<Object> result = parser.parseArrayInternal();

            // Convert to list of string maps
            List<Map<String, String>> stringMaps = new ArrayList<>();
            for (Object item : result) {
                if (item instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> objMap = (Map<String, Object>) item;
                    Map<String, String> stringMap = new LinkedHashMap<>();
                    for (Map.Entry<String, Object> entry : objMap.entrySet()) {
                        Object value = entry.getValue();
                        stringMap.put(entry.getKey(), value != null ? value.toString() : null);
                    }
                    stringMaps.add(stringMap);
                }
            }
            return stringMaps;
        } catch (Exception e) {
            return new ArrayList<>();
        }
    }

    // ========== PRIVATE RECURSIVE DESCENT PARSER ==========

    /**
     * Parse any JSON value
     */
    private Object parseValue() {
        if (current == null) {
            return null;
        }

        switch (current.type) {
            case JSON_LBRACE:
                return parseObjectInternal();
            case JSON_LBRACKET:
                return parseArrayInternal();
            case JSON_STRING:
                return parseString();
            case JSON_NUMBER:
                return parseNumber();
            case JSON_TRUE:
                advance();
                return true;
            case JSON_FALSE:
                advance();
                return false;
            case JSON_NULL:
                advance();
                return null;
            default:
                throw new RuntimeException("Unexpected token: " + current.type);
        }
    }

    /**
     * Parse a JSON object: { "key": value, ... }
     */
    private Map<String, Object> parseObjectInternal() {
        Map<String, Object> result = new LinkedHashMap<>();

        consume(Token.Type.JSON_LBRACE);

        // Empty object
        if (current != null && current.type == Token.Type.JSON_RBRACE) {
            advance();
            return result;
        }

        while (current != null && current.type != Token.Type.JSON_RBRACE) {
            // Parse key (must be string)
            if (current.type != Token.Type.JSON_STRING) {
                throw new RuntimeException("Expected string key, got: " + current.type);
            }
            String key = current.lexeme;
            advance();

            // Expect colon
            consume(Token.Type.JSON_COLON);

            // Parse value
            Object value = parseValue();
            result.put(key, value);

            // Handle comma (with leniency)
            if (current != null && current.type == Token.Type.JSON_COMMA) {
                skipCommas(); // Skip one or more commas (leniency for multiple commas)

                // LENIENCY: Trailing comma before }
                if (current != null && current.type == Token.Type.JSON_RBRACE) {
                    // Just continue to consume the }
                }
            } else if (current != null && current.type == Token.Type.JSON_STRING) {
                // LENIENCY: Missing comma - we see another string key where we expect comma or }
                // Just continue parsing the next field
                // (This handles {"a":"v1""b":"v2"} -> {"a":"v1","b":"v2"})
            } else if (current != null && current.type != Token.Type.JSON_RBRACE) {
                // Unexpected token
                throw new RuntimeException("Expected comma or }, got: " + current.type);
            }
        }

        consume(Token.Type.JSON_RBRACE);
        return result;
    }

    /**
     * Parse a JSON array: [ value, ... ]
     */
    private List<Object> parseArrayInternal() {
        List<Object> result = new ArrayList<>();

        consume(Token.Type.JSON_LBRACKET);

        // Empty array
        if (current != null && current.type == Token.Type.JSON_RBRACKET) {
            advance();
            return result;
        }

        while (current != null && current.type != Token.Type.JSON_RBRACKET) {
            // Parse value
            Object value = parseValue();
            result.add(value);

            // Handle comma (with leniency)
            if (current != null && current.type == Token.Type.JSON_COMMA) {
                skipCommas(); // Skip one or more commas (leniency for multiple commas)

                // LENIENCY: Trailing comma before ]
                if (current != null && current.type == Token.Type.JSON_RBRACKET) {
                    // Just continue to consume the ]
                }
            } else if (current != null && current.type != Token.Type.JSON_RBRACKET) {
                // In arrays, we're stricter about missing commas
                // (Arrays typically have consistent types, so missing commas are less common)
                throw new RuntimeException("Expected comma or ], got: " + current.type);
            }
        }

        consume(Token.Type.JSON_RBRACKET);
        return result;
    }

    /**
     * Parse a string value
     */
    private String parseString() {
        if (current == null || current.type != Token.Type.JSON_STRING) {
            throw new RuntimeException("Expected string");
        }
        String value = current.lexeme;
        advance();
        return value;
    }

    /**
     * Parse a number value
     */
    private Object parseNumber() {
        if (current == null || current.type != Token.Type.JSON_NUMBER) {
            throw new RuntimeException("Expected number");
        }
        String lexeme = current.lexeme;
        advance();

        // Try to parse as integer first, then as double
        try {
            return Integer.parseInt(lexeme);
        } catch (NumberFormatException e1) {
            try {
                return Double.parseDouble(lexeme);
            } catch (NumberFormatException e2) {
                throw new RuntimeException("Invalid number: " + lexeme);
            }
        }
    }

    /**
     * Consume expected token type
     */
    private void consume(Token.Type expected) {
        if (current == null || current.type != expected) {
            throw new RuntimeException("Expected " + expected + ", got: " +
                (current != null ? current.type : "EOF"));
        }
        advance();
    }

    /**
     * Move to next token
     */
    private void advance() {
        current = tokenizer.nextToken();
    }

    /**
     * Skip one or more consecutive commas (leniency for multiple commas)
     */
    private void skipCommas() {
        while (current != null && current.type == Token.Type.JSON_COMMA) {
            advance();
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/shared/Token.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.shared;

/**
 * Represents a token produced by a lexical tokenizer
 * Immutable value class
 */
public class Token {
    public enum Type {
        // Common tokens
        EOF,
        ERROR,

        // XML tokens
        XML_TAG_OPEN,        // <
        XML_TAG_CLOSE,       // >
        XML_TAG_END_OPEN,    // </
        XML_TAG_SELF_CLOSE,  // />
        XML_EQUALS,          // =
        XML_NAME,            // tag/attribute name
        XML_STRING,          // attribute value
        XML_TEXT,            // text content
        XML_CDATA,           // CDATA content (entire section)
        XML_EOF,             // End of file

        // JSON tokens
        JSON_LBRACE,         // {
        JSON_RBRACE,         // }
        JSON_LBRACKET,       // [
        JSON_RBRACKET,       // ]
        JSON_COLON,          // :
        JSON_COMMA,          // ,
        JSON_STRING,         // "value" or 'value'
        JSON_NUMBER,         // 123, 123.45
        JSON_TRUE,           // true
        JSON_FALSE,          // false
        JSON_NULL            // null
    }

    public final Type type;
    public final String lexeme;  // The actual text
    public final int position;   // Position in source

    public Token(Type type, String lexeme, int position) {
        this.type = type;
        this.lexeme = lexeme != null ? lexeme : "";
        this.position = position;
    }

    public Token(Type type, int position) {
        this(type, "", position);
    }

    @Override
    public String toString() {
        if (lexeme.isEmpty()) {
            return type.toString() + "@" + position;
        }
        return type + "(" + lexeme + ")@" + position;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Token)) return false;
        Token other = (Token) obj;
        return type == other.type && lexeme.equals(other.lexeme);
    }

    @Override
    public int hashCode() {
        return type.hashCode() * 31 + lexeme.hashCode();
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/shared/Tokenizer.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.shared;

/**
 * Base interface for lenient tokenizers
 * Tokenizers read source text character-by-character and emit tokens
 */
public interface Tokenizer {
    /**
     * Get the next token from the source
     * Returns EOF token when no more tokens available
     */
    Token nextToken();

    /**
     * Peek at the next token without consuming it
     */
    Token peekToken();

    /**
     * Check if we're at the end of the source
     */
    boolean isAtEnd();

    /**
     * Get current position in source
     */
    int getPosition();
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/shared/XMLTokenizer.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.shared;

import java.util.*;

/**
 * Stateful tokenizer for XML with lenient CDATA handling
 *
 * Uses state stack to distinguish:
 * - CONTENT: Between tags (> and <), return raw text
 * - IN_TAG: Inside tags (< and >), tokenize structure
 *
 * Handles:
 * - Basic XML tokens: <, >, </,/>, =, names, strings
 * - CDATA sections with AI formatting normalization
 * - Line continuations: \<newline> -> removed
 * - Preserves legitimate backslashes (Windows paths, escape sequences)
 */
public class XMLTokenizer extends BaseTokenizer {

    private enum State {
        CONTENT,    // Between tags - everything is text until <
        IN_TAG      // Inside a tag - tokenize names/attributes/etc
    }

    private final Deque<State> stateStack;

    public XMLTokenizer(String input) {
        super(input);
        this.stateStack = new ArrayDeque<>();
        this.stateStack.push(State.CONTENT); // Start in content mode
    }

    private State currentState() {
        return stateStack.isEmpty() ? State.CONTENT : stateStack.peek();
    }

    @Override
    protected Token scanToken() {
        if (isAtEnd()) {
            return new Token(Token.Type.XML_EOF, "", current);
        }

        // Behavior depends on current state
        if (currentState() == State.CONTENT) {
            return scanInContentMode();
        } else {
            return scanInTagMode();
        }
    }

    /**
     * Scan while in CONTENT state (between tags)
     * Only looking for:
     * - < (start of tag or CDATA)
     * - Plain text
     */
    private Token scanInContentMode() {
        char c = peek();

        // Check for tag/CDATA start
        if (c == '<') {
            // Peek ahead to see if it's CDATA
            if (peek(1) == '!' && peek(2) == '[') {
                return scanCDATA();
            }

            // It's a tag, switch to IN_TAG state
            stateStack.push(State.IN_TAG);
            return scanTagStart();
        }

        // Otherwise, scan plain text until we hit <
        return scanText();
    }

    /**
     * Scan while in IN_TAG state (inside a tag)
     * Looking for: names, attributes, =, strings, >, />, etc
     */
    private Token scanInTagMode() {
        // Skip whitespace in tags
        if (Character.isWhitespace(peek())) {
            skipWhitespace();
            if (isAtEnd()) {
                return new Token(Token.Type.XML_EOF, "", current);
            }
        }

        char c = peek();

        // Check for tag close - return to CONTENT state
        if (c == '>') {
            int pos = current;
            advance();
            stateStack.pop(); // Back to CONTENT state
            return new Token(Token.Type.XML_TAG_CLOSE, ">", pos);
        }

        // Check for self-close tag: />
        if (c == '/' && peek(1) == '>') {
            int pos = current;
            advance(); // /
            advance(); // >
            stateStack.pop(); // Back to CONTENT state
            return new Token(Token.Type.XML_TAG_SELF_CLOSE, "/>", pos);
        }

        // Check for equals (in attributes)
        if (c == '=') {
            int pos = current;
            advance();
            return new Token(Token.Type.XML_EQUALS, "=", pos);
        }

        // Check for quoted string (attribute value)
        if (c == '"' || c == '\'') {
            return scanString();
        }

        // Otherwise, scan as name (element/attribute name)
        if (isAlpha(c) || c == '_') {
            return scanName();
        }

        // Unexpected character
        throw new RuntimeException("Unexpected character '" + c + "' at position " + current +
            " in IN_TAG state. Expected one of: >, =, \", ', or name character.");
    }

    /**
     * Scan tag start: < or </
     * NOTE: We're already in IN_TAG state when this is called
     */
    private Token scanTagStart() {
        int pos = current;
        advance(); // consume <

        // Check for closing tag: </
        if (match('/')) {
            return new Token(Token.Type.XML_TAG_END_OPEN, "</", pos);
        }

        // Opening tag: <
        return new Token(Token.Type.XML_TAG_OPEN, "<", pos);
    }

    /**
     * Scan plain text content (in CONTENT mode)
     * Returns everything until we hit <
     */
    private Token scanText() {
        int pos = current;
        StringBuilder text = new StringBuilder();

        while (!isAtEnd() && peek() != '<') {
            text.append(advance());
        }

        return new Token(Token.Type.XML_TEXT, text.toString(), pos);
    }

    /**
     * Scan CDATA section with AI formatting normalization
     * Format: <![CDATA[content]]>
     *
     * AI Leniency:
     * - Line continuations: \<newline> -> removed
     * - Handles all line ending types: \r\n, \n, \r
     * - Preserves legitimate backslashes
     */
    private Token scanCDATA() {
        int pos = current;

        // Consume <![CDATA[
        advance(); // <
        advance(); // !
        advance(); // [
        advance(); // C
        advance(); // D
        advance(); // A
        advance(); // T
        advance(); // A
        advance(); // [

        StringBuilder content = new StringBuilder();

        // Scan until we find ]]>
        while (!isAtEnd()) {
            // Check for CDATA end: ]]>
            if (peek() == ']' && peek(1) == ']' && peek(2) == '>') {
                advance(); // ]
                advance(); // ]
                advance(); // >
                break;
            }

            // Check for line continuation: backslash followed by newline
            if (peek() == '\\') {
                char next = peek(1);

                // Line continuation with CRLF: \r\n
                if (next == '\r' && peek(2) == '\n') {
                    advance(); // \
                    advance(); // \r
                    advance(); // \n
                    // Skip (line continuation removed)
                    continue;
                }

                // Line continuation with LF: \n
                if (next == '\n') {
                    advance(); // \
                    advance(); // \n
                    // Skip (line continuation removed)
                    continue;
                }

                // Line continuation with CR: \r
                if (next == '\r') {
                    advance(); // \
                    advance(); // \r
                    // Skip (line continuation removed)
                    continue;
                }
            }

            // Normal character - keep it
            content.append(advance());
        }

        return new Token(Token.Type.XML_CDATA, content.toString(), pos);
    }

    /**
     * Scan XML name (element name or attribute name)
     */
    private Token scanName() {
        int pos = current;
        StringBuilder name = new StringBuilder();

        // XML name: [a-zA-Z_][a-zA-Z0-9_-]*
        while (!isAtEnd()) {
            char c = peek();
            if (isAlpha(c) || isDigit(c) || c == '_' || c == '-') {
                name.append(advance());
            } else {
                break;
            }
        }

        return new Token(Token.Type.XML_NAME, name.toString(), pos);
    }

    /**
     * Scan quoted string (attribute value)
     * Supports both double and single quotes
     */
    private Token scanString() {
        int pos = current;
        char quote = advance(); // " or '
        StringBuilder value = new StringBuilder();

        while (!isAtEnd() && peek() != quote) {
            value.append(advance());
        }

        if (!isAtEnd()) {
            advance(); // closing quote
        }

        return new Token(Token.Type.XML_STRING, value.toString(), pos);
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/system/ConfigManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.system;

import java.io.*;
import java.nio.file.*;

public class ConfigManager implements com.codeboss.javalayer.bridge.IConfigManager {
    private String workingDirectory;
    private Logger logger;

    private String getConfigFile() {
        return Paths.get(workingDirectory, ".agent", "config.json").toString();
    }

    private int maxMessageChars = 350000; // Default max message chars
    private int clickX = 500; // Default click X coordinate for automatic mode
    private int clickY = 300; // Default click Y coordinate for automatic mode
    private int serverPort = 3000; // Default server port
    private boolean autoLaunchBrowser = true; // Default auto-launch browser setting

    public ConfigManager(String workingDirectory, Logger logger) throws IOException {
        this.workingDirectory = workingDirectory;
        this.logger = logger;
        loadConfig();
    }

    private void loadConfig() throws IOException {
        Path configPath = Paths.get(getConfigFile());
        if (!Files.exists(configPath)) {
            // Ensure .agent directory exists
            Path agentDir = configPath.getParent();
            if (!Files.exists(agentDir)) {
                Files.createDirectories(agentDir);
            }
            
            // Create default config
            String defaultConfig = "{\n" +
                "  \"maxMessageChars\": 350000,\n" +
                "  \"clickX\": 500,\n" +
                "  \"clickY\": 300,\n" +
                "  \"server\": {\n" +
                "    \"port\": 3000,\n" +
                "    \"autoLaunchBrowser\": true\n" +
                "  }\n" +
                "}";
            Files.write(configPath, defaultConfig.getBytes());
            maxMessageChars = 350000;
            clickX = 500;
            clickY = 300;
            serverPort = 3000;
            autoLaunchBrowser = true;
            logger.log("Created default config file");
        } else {
            try {
                String configContent = new String(Files.readAllBytes(configPath));
                
                // Simple JSON parsing for maxMessageChars
                String maxCharsPattern = "\"maxMessageChars\"\\s*:\\s*(\\d+)";
                java.util.regex.Pattern p1 = java.util.regex.Pattern.compile(maxCharsPattern);
                java.util.regex.Matcher m1 = p1.matcher(configContent);
                if (m1.find()) {
                    maxMessageChars = Integer.parseInt(m1.group(1));
                } else {
                    maxMessageChars = 350000; // fallback
                }
                
                // Simple JSON parsing for clickX (support negative numbers)
                String clickXPattern = "\"clickX\"\\s*:\\s*(-?\\d+)";
                java.util.regex.Pattern p2 = java.util.regex.Pattern.compile(clickXPattern);
                java.util.regex.Matcher m2 = p2.matcher(configContent);
                if (m2.find()) {
                    clickX = Integer.parseInt(m2.group(1));
                } else {
                    clickX = 500; // fallback
                }

                // Simple JSON parsing for clickY (support negative numbers)
                String clickYPattern = "\"clickY\"\\s*:\\s*(-?\\d+)";
                java.util.regex.Pattern p3 = java.util.regex.Pattern.compile(clickYPattern);
                java.util.regex.Matcher m3 = p3.matcher(configContent);
                if (m3.find()) {
                    clickY = Integer.parseInt(m3.group(1));
                } else {
                    clickY = 300; // fallback
                }

                // Simple JSON parsing for server.port (nested)
                String portPattern = "\"port\"\\s*:\\s*(\\d+)";
                java.util.regex.Pattern p4 = java.util.regex.Pattern.compile(portPattern);
                java.util.regex.Matcher m4 = p4.matcher(configContent);
                if (m4.find()) {
                    serverPort = Integer.parseInt(m4.group(1));
                } else {
                    serverPort = 3000; // fallback
                }

                // Simple JSON parsing for server.autoLaunchBrowser (nested)
                String autoLaunchPattern = "\"autoLaunchBrowser\"\\s*:\\s*(true|false)";
                java.util.regex.Pattern p5 = java.util.regex.Pattern.compile(autoLaunchPattern);
                java.util.regex.Matcher m5 = p5.matcher(configContent);
                if (m5.find()) {
                    autoLaunchBrowser = Boolean.parseBoolean(m5.group(1));
                } else {
                    autoLaunchBrowser = true; // fallback
                }

                logger.log("Loaded config: maxMessageChars = " + maxMessageChars + ", clickX = " + clickX + ", clickY = " + clickY + ", serverPort = " + serverPort + ", autoLaunchBrowser = " + autoLaunchBrowser);
                
                // Validate configuration
                validateConfig(configContent);
                
            } catch (Exception e) {
                logger.log("Error loading config, using defaults: " + e.getMessage());
                maxMessageChars = 350000;
                clickX = 500;
                clickY = 300;
                serverPort = 3000;
                autoLaunchBrowser = true;
            }
        }
    }
    
    private void validateConfig(String configContent) throws IOException {
        // Validate coordinates are reasonable (allow negative for multi-monitor setups)
        if (clickX < -10000 || clickY < -10000 || clickX > 10000 || clickY > 10000) {
            String error = "Configuration Error: Click coordinates must be between -10000 and 10000. Found clickX=" + clickX + ", clickY=" + clickY;
            logger.log(error);
            System.err.println(error);
            throw new IOException("Invalid click coordinates");
        }

        logger.log("Configuration validated: clickX=" + clickX + ", clickY=" + clickY);
    }
    
    public int getMaxMessageChars() {
        return maxMessageChars;
    }
    
    public void setMaxMessageChars(int maxMessageChars) {
        this.maxMessageChars = maxMessageChars;
    }

    public int getClickX() {
        return clickX;
    }

    public int getClickY() {
        return clickY;
    }

    public int getServerPort() {
        return serverPort;
    }

    public void setServerPort(int serverPort) {
        this.serverPort = serverPort;
    }

    public boolean shouldAutoLaunchBrowser() {
        return autoLaunchBrowser;
    }

    public void setAutoLaunchBrowser(boolean autoLaunchBrowser) {
        this.autoLaunchBrowser = autoLaunchBrowser;
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/system/Logger.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.system;

import java.io.*;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Logger implements com.codeboss.javalayer.bridge.ILogger {
    private final String workingDirectory;

    public Logger(String workingDirectory) {
        this.workingDirectory = workingDirectory;
    }

    private String getLogFile() {
        return Paths.get(workingDirectory, ".agent", "debug.log").toString();
    }

    @Override
    public void log(String message) {
        try {
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
            String logMessage = "[" + timestamp + "] " + message;

            // Write to console (stdout)
            System.out.println(logMessage);

            // Also write to file
            String logFile = getLogFile();
            Path logPath = Paths.get(logFile);
            Path agentDir = logPath.getParent();
            if (!Files.exists(agentDir)) {
                Files.createDirectories(agentDir);
            }

            Files.write(logPath, (logMessage + "\n").getBytes(),
                       StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } catch (Exception e) {
            System.err.println("Failed to write to log: " + e.getMessage());
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/system/SystemTrayManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.system;

import com.codeboss.javalayer.bridge.ILogger;
import java.awt.*;
import java.awt.image.BufferedImage;

public class SystemTrayManager {
    private final ILogger logger;
    private TrayIcon trayIcon;

    public SystemTrayManager(ILogger logger) {
        this.logger = logger;
    }

    public void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            logger.log("System tray not supported on this platform");
            return;
        }

        try {
            SystemTray tray = SystemTray.getSystemTray();

            // Create a simple green icon (16x16)
            Image image = createTrayIcon();

            // Create popup menu
            PopupMenu popup = new PopupMenu();

            MenuItem statusItem = new MenuItem("Conversation CLI - Running");
            statusItem.setEnabled(false);
            popup.add(statusItem);

            popup.addSeparator();

            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> {
                logger.log("Exit requested from system tray");
                cleanup();
                System.exit(0);
            });
            popup.add(exitItem);

            // Create tray icon
            trayIcon = new TrayIcon(image, "Conversation CLI", popup);
            trayIcon.setImageAutoSize(true);
            trayIcon.setToolTip("Conversation CLI - Maintaining clipboard access");

            // Add to system tray
            tray.add(trayIcon);

            logger.log("System tray icon added successfully");

        } catch (Exception e) {
            logger.log("Failed to setup system tray: " + e.getMessage());
            System.err.println("Warning: Could not setup system tray: " + e.getMessage());
        }
    }
    
    private Image createTrayIcon() {
        BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();
        
        // Enable antialiasing
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        // Draw a green circle
        g2d.setColor(new Color(76, 175, 80)); // Material Design Green
        g2d.fillOval(2, 2, 12, 12);
        
        // Add a white "C" for CLI
        g2d.setColor(Color.WHITE);
        g2d.setFont(new Font("Arial", Font.BOLD, 10));
        FontMetrics fm = g2d.getFontMetrics();
        String text = "C";
        int x = (16 - fm.stringWidth(text)) / 2;
        int y = (16 - fm.getHeight()) / 2 + fm.getAscent();
        g2d.drawString(text, x, y);
        
        g2d.dispose();
        return image;
    }
    
    public void updateTrayStatus(String status) {
        if (trayIcon != null) {
            trayIcon.setToolTip("Conversation CLI - " + status);
        }
    }
    
    public void cleanup() {
        if (trayIcon != null) {
            SystemTray.getSystemTray().remove(trayIcon);
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/toolexecutor/CommandManager.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.toolexecutor;

import java.io.*;
import java.nio.file.*;
import java.time.Instant;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class CommandManager {
    private final String workingDirectory;
    private final String AGENT_DIR;
    private final String COMMANDS_DIR;
    private final String OUTPUT_DIR;
    private final String PROCESSES_FILE;

    public static class ProcessInfo {
        public long pid;
        public String name;
        public String command;
        public String outputFile;
        public String startedAt;

        public ProcessInfo(long pid, String name, String command, String outputFile, String startedAt) {
            this.pid = pid;
            this.name = name;
            this.command = command;
            this.outputFile = outputFile;
            this.startedAt = startedAt;
        }
    }

    public CommandManager(String workingDirectory) {
        this.workingDirectory = workingDirectory != null ? workingDirectory : ".";
        this.AGENT_DIR = this.workingDirectory + "/.agent";
        this.COMMANDS_DIR = AGENT_DIR + "/commands";
        this.OUTPUT_DIR = AGENT_DIR + "/command-output";
        this.PROCESSES_FILE = AGENT_DIR + "/processes.json";
        ensureDirectories();
    }

    private void ensureDirectories() {
        try {
            Files.createDirectories(Paths.get(COMMANDS_DIR));
            Files.createDirectories(Paths.get(OUTPUT_DIR));

            Path processesPath = Paths.get(PROCESSES_FILE);
            if (!Files.exists(processesPath)) {
                saveProcesses(new ArrayList<>());
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to create .agent directories", e);
        }
    }

    public void saveCommand(String name, String command) throws IOException {
        Path commandPath = Paths.get(COMMANDS_DIR, name + ".txt");
        Files.writeString(commandPath, command);
    }

    public String loadCommand(String name) throws IOException {
        Path commandPath = Paths.get(COMMANDS_DIR, name + ".txt");
        if (!Files.exists(commandPath)) {
            throw new FileNotFoundException("Command not found: " + name);
        }
        return Files.readString(commandPath).trim();
    }

    public List<String> listCommands() throws IOException {
        Path commandsDir = Paths.get(COMMANDS_DIR);
        if (!Files.exists(commandsDir)) {
            return new ArrayList<>();
        }

        List<String> commands = new ArrayList<>();
        Files.list(commandsDir)
            .filter(p -> p.toString().endsWith(".txt"))
            .forEach(p -> {
                String filename = p.getFileName().toString();
                commands.add(filename.substring(0, filename.length() - 4)); // Remove .txt
            });

        return commands;
    }

    public String substituteParams(String command, Map<String, String> params) {
        if (params == null || params.isEmpty()) {
            return command;
        }

        String result = command;
        for (Map.Entry<String, String> entry : params.entrySet()) {
            String placeholder = "${" + entry.getKey() + "}";
            result = result.replace(placeholder, entry.getValue());
        }
        return result;
    }

    public String generateOutputFilePath(String commandName) {
        String timestamp = Instant.now().toString()
            .replaceAll("[:]", "")
            .replaceAll("[.].*", "")
            .replace("T", "-")
            .replace("Z", "");
        return OUTPUT_DIR + "/" + commandName + "-" + timestamp + ".txt";
    }

    public List<ProcessInfo> loadProcesses() {
        try {
            String json = Files.readString(Paths.get(PROCESSES_FILE));
            if (json.trim().isEmpty() || json.trim().equals("{}") || json.trim().equals("{\"processes\":[]}")) {
                return new ArrayList<>();
            }

            return parseProcessesJson(json);
        } catch (IOException e) {
            return new ArrayList<>();
        }
    }

    private List<ProcessInfo> parseProcessesJson(String json) {
        List<ProcessInfo> processes = new ArrayList<>();

        int processesStart = json.indexOf("\"processes\":");
        if (processesStart == -1) return processes;

        int arrayStart = json.indexOf('[', processesStart);
        int arrayEnd = json.lastIndexOf(']');
        if (arrayStart == -1 || arrayEnd == -1) return processes;

        String arrayContent = json.substring(arrayStart + 1, arrayEnd).trim();
        if (arrayContent.isEmpty()) return processes;

        int depth = 0;
        int objStart = -1;
        StringBuilder currentObj = new StringBuilder();

        for (int i = 0; i < arrayContent.length(); i++) {
            char c = arrayContent.charAt(i);

            if (c == '{') {
                if (depth == 0) objStart = i;
                depth++;
            }

            if (depth > 0) currentObj.append(c);

            if (c == '}') {
                depth--;
                if (depth == 0) {
                    ProcessInfo p = parseProcessObject(currentObj.toString());
                    if (p != null) processes.add(p);
                    currentObj = new StringBuilder();
                }
            }
        }

        return processes;
    }

    private ProcessInfo parseProcessObject(String objStr) {
        try {
            long pid = parseJsonLong(objStr, "pid");
            String name = parseJsonString(objStr, "name");
            String command = parseJsonString(objStr, "command");
            String outputFile = parseJsonString(objStr, "outputFile");
            String startedAt = parseJsonString(objStr, "startedAt");
            return new ProcessInfo(pid, name, command, outputFile, startedAt);
        } catch (Exception e) {
            return null;
        }
    }

    private long parseJsonLong(String json, String key) {
        String pattern = "\"" + key + "\"\\s*:\\s*(\\d+)";
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(json);
        if (m.find()) {
            return Long.parseLong(m.group(1));
        }
        return 0;
    }

    private String parseJsonString(String json, String key) {
        String pattern = "\"" + key + "\"\\s*:\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"";
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(json);
        if (m.find()) {
            return m.group(1).replace("\\\\", "\\").replace("\\\"", "\"").replace("\\n", "\n");
        }
        return "";
    }

    public void saveProcesses(List<ProcessInfo> processes) {
        try {
            StringBuilder json = new StringBuilder();
            json.append("{\n  \"processes\": [\n");

            for (int i = 0; i < processes.size(); i++) {
                ProcessInfo p = processes.get(i);
                json.append("    {\n");
                json.append("      \"pid\": ").append(p.pid).append(",\n");
                json.append("      \"name\": \"").append(escapeJson(p.name)).append("\",\n");
                json.append("      \"command\": \"").append(escapeJson(p.command)).append("\",\n");
                json.append("      \"outputFile\": \"").append(escapeJson(p.outputFile)).append("\",\n");
                json.append("      \"startedAt\": \"").append(escapeJson(p.startedAt)).append("\"\n");
                json.append("    }");
                if (i < processes.size() - 1) json.append(",");
                json.append("\n");
            }

            json.append("  ]\n}");
            Files.writeString(Paths.get(PROCESSES_FILE), json.toString());
        } catch (IOException e) {
            throw new RuntimeException("Failed to save processes", e);
        }
    }

    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    public void addProcess(ProcessInfo process) {
        List<ProcessInfo> processes = loadProcesses();
        processes.add(process);
        saveProcesses(processes);
    }

    public void removeProcess(long pid) {
        List<ProcessInfo> processes = loadProcesses();
        processes.removeIf(p -> p.pid == pid);
        saveProcesses(processes);
    }

    public List<ProcessInfo> getActiveProcesses() {
        List<ProcessInfo> processes = loadProcesses();
        List<ProcessInfo> active = new ArrayList<>();

        for (ProcessInfo process : processes) {
            if (isProcessRunning(process.pid)) {
                active.add(process);
            }
        }

        saveProcesses(active);
        return active;
    }

    public boolean isProcessRunning(long pid) {
        try {
            ProcessBuilder pb = new ProcessBuilder("pwsh", "-Command",
                "Get-Process -Id " + pid + " -ErrorAction SilentlyContinue");
            Process process = pb.start();
            int exitCode = process.waitFor();
            return exitCode == 0;
        } catch (Exception e) {
            return false;
        }
    }

    public void killProcess(long pid) throws IOException, InterruptedException {
        ProcessBuilder pb = new ProcessBuilder("pwsh", "-Command",
            "Stop-Process -Id " + pid + " -Force");
        Process process = pb.start();
        process.waitFor();
    }

    public List<String> extractRegexMatches(String text, String regex) {
        List<String> matches = new ArrayList<>();
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(text);

        while (matcher.find()) {
            matches.add(matcher.group(0));
            for (int i = 1; i <= matcher.groupCount(); i++) {
                matches.add(matcher.group(i));
            }
        }

        return matches;
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: com/codeboss/javalayer/toolexecutor/ToolExecutor.java
|~|~|~|~|~|~|~|~|~|~|~|
package com.codeboss.javalayer.toolexecutor;

import com.codeboss.javalayer.bridge.*;
import com.codeboss.javalayer.aiprocessor.ChecklistManager;
import com.codeboss.javalayer.aiprocessor.ModeManager;
import com.codeboss.javalayer.aiprocessor.ConversationManager;
import com.codeboss.javalayer.aiprocessor.ToolCategory;
import java.io.*;
import java.nio.file.*;
import java.util.*;

/**
 * Executes tools requested by the AI
 */
public class ToolExecutor implements IToolExecutor {
    private final ILogger logger;
    private final String workingDirectory;
    private ChecklistManager checklistManager;  // Optional, for manage_checklist tool
    private ModeManager modeManager;  // Optional, for begin_execution tool
    private ConversationManager conversationManager;  // Optional, for begin_execution approval flow

    public ToolExecutor(ILogger logger, String workingDirectory) {
        this.logger = logger;
        this.workingDirectory = workingDirectory;
        this.checklistManager = null;
        this.modeManager = null;
    }

    public void setChecklistManager(ChecklistManager checklistManager) {
        this.checklistManager = checklistManager;
    }

    public void setModeManager(ModeManager modeManager) {
        this.modeManager = modeManager;
    }

    public void setConversationManager(ConversationManager conversationManager) {
        this.conversationManager = conversationManager;
    }

    @Override
    public ToolExecutionResult executeToolWithSummary(String toolName, Map<String, String> params) {
        // Validate tool is allowed in current mode
        if (modeManager != null) {
            ToolCategory requiredCategory = getToolCategory(toolName);
            if (requiredCategory != null) {
                com.codeboss.javalayer.aiprocessor.Mode currentMode = modeManager.getCurrentMode();
                java.util.Set<com.codeboss.javalayer.aiprocessor.ToolCategory> allowedCategories =
                    currentMode.getAvailableToolCategories();

                if (!allowedCategories.contains(requiredCategory)) {
                    Map<String, Object> error = new HashMap<>();
                    error.put("error", "Tool '" + toolName + "' requires " + requiredCategory +
                             " which is not available in " + currentMode + " mode");
                    error.put("hint", requiredCategory == com.codeboss.javalayer.aiprocessor.ToolCategory.FILE_OPERATIONS ?
                             "You must use begin_execution tool to create a plan before modifying files" :
                             "This tool is not available in the current mode");
                    return new ToolExecutionResult(error, "Error: Tool not allowed in current mode");
                }
            }
        }

        try {
            switch (toolName) {
                case "read_file":
                    return readFile(params);
                case "list_files":
                    return listFiles(params);
                case "create_file":
                    return createFile(params);
                case "update_file":
                    return updateFile(params);
                case "update_file_batch":
                    return updateFileBatch(params);
                case "delete_file":
                    return deleteFile(params);
                case "manage_checklist":
                    return manageChecklist(params);
                case "complete_todo":
                    return completeTodo(params);
                case "mark_complete":
                    return markComplete(params);
                case "mark_failed":
                    return markFailed(params);
                case "review_pass":
                    return reviewPass(params);
                case "review_fail":
                    return reviewFail(params);
                case "begin_execution":
                    return beginExecution(params);
                case "list_commands":
                    return listCommands(params);
                case "create_test_command":
                    return createTestCommand(params);
                case "run_test":
                    return runTest(params);
                case "stop_test":
                    return stopTest(params);
                case "list_processes":
                    return listProcesses(params);
                case "search_files_by_name":
                    return searchFilesByName(params);
                case "search_files_by_content":
                    return searchFilesByContent(params);
                case "git_read":
                    return gitRead(params);
                case "git_write":
                    return gitWrite(params);
                default:
                    Map<String, Object> error = new HashMap<>();
                    error.put("error", "Unknown tool: " + toolName);
                    return new ToolExecutionResult(error, "Error: Unknown tool");
            }
        } catch (Exception e) {
            String errorMsg = "Error executing " + toolName + ": " + e.getMessage();
            logger.log(errorMsg);
            Map<String, Object> error = new HashMap<>();
            error.put("error", errorMsg);
            return new ToolExecutionResult(error, "Error: " + e.getMessage());
        }
    }

    private ToolExecutionResult readFile(Map<String, String> params) throws IOException {
        String filePath = params.get("file_path");
        if (filePath == null || filePath.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "file_path parameter required");
            return new ToolExecutionResult(error, "Error: file_path required");
        }

        Path path = resolvePath(filePath);
        if (!Files.exists(path)) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "File not found: " + filePath);
            return new ToolExecutionResult(error, "Error: File not found");
        }

        List<String> lines = Files.readAllLines(path);

        // Handle offset and limit
        int offset = 0;
        int limit = lines.size();

        if (params.containsKey("offset")) {
            offset = Integer.parseInt(params.get("offset"));
        }
        if (params.containsKey("limit")) {
            limit = Integer.parseInt(params.get("limit"));
        }

        int endIndex = Math.min(offset + limit, lines.size());
        StringBuilder content = new StringBuilder();

        // Build content WITHOUT line numbers (per tools-spec.md)
        for (int i = offset; i < endIndex; i++) {
            content.append(lines.get(i)).append("\n");
        }

        int linesRead = endIndex - offset;
        long fileSize = Files.size(path);

        // Build structured result per tools-spec.md
        Map<String, Object> result = new java.util.LinkedHashMap<>();
        result.put("size", fileSize);
        result.put("content", content.toString());
        result.put("file_path", filePath);
        result.put("lines", linesRead);

        String summary = "Read " + linesRead + " lines from " + filePath;

        return new ToolExecutionResult(result, summary);
    }

    private ToolExecutionResult listFiles(Map<String, String> params) throws IOException {
        String directoryPath = params.getOrDefault("directory_path", ".");

        Path path = resolvePath(directoryPath);
        if (!Files.exists(path)) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Directory not found: " + directoryPath);
            return new ToolExecutionResult(error, "Error: Directory not found");
        }
        if (!Files.isDirectory(path)) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Not a directory: " + directoryPath);
            return new ToolExecutionResult(error, "Error: Not a directory");
        }

        List<Path> entries = new ArrayList<>();
        try (var stream = Files.list(path)) {
            stream.forEach(entries::add);
        }

        entries.sort((a, b) -> {
            boolean aIsDir = Files.isDirectory(a);
            boolean bIsDir = Files.isDirectory(b);
            if (aIsDir && !bIsDir) return -1;
            if (!aIsDir && bIsDir) return 1;
            return a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString());
        });

        // Build structured result per tools-spec.md
        List<Map<String, Object>> filesList = new ArrayList<>();

        for (Path entry : entries) {
            String name = entry.getFileName().toString();
            String type = Files.isDirectory(entry) ? "directory" : "file";
            long size = Files.isDirectory(entry) ? 0 : Files.size(entry);

            Map<String, Object> fileInfo = new java.util.LinkedHashMap<>();
            fileInfo.put("name", name);
            fileInfo.put("type", type);
            fileInfo.put("size", size);
            filesList.add(fileInfo);
        }

        Map<String, Object> result = new java.util.LinkedHashMap<>();
        result.put("files", filesList);
        result.put("directory", directoryPath);
        result.put("count", filesList.size());

        String summary = "Listed " + filesList.size() + " items in " + directoryPath;

        return new ToolExecutionResult(result, summary);
    }

    private ToolExecutionResult createFile(Map<String, String> params) throws IOException {
        String filePath = params.get("file_path");
        String content = params.get("content");

        if (filePath == null || filePath.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "file_path parameter required");
            return new ToolExecutionResult(error, "Error: file_path required");
        }

        if (content == null || content.trim().isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "content parameter is missing or empty");
            error.put("hint", "The content parameter is REQUIRED and must contain actual code/text. Empty files are not allowed.");
            return new ToolExecutionResult(error, "Error: content parameter is REQUIRED and must not be empty. You must provide the actual file content. Empty strings are not valid.");
        }

        Path path = resolvePath(filePath);
        boolean fileExists = Files.exists(path);

        if (fileExists) {
            // Allow overwriting with a warning in the result
            Map<String, Object> result = new HashMap<>();
            result.put("file_path", filePath);
            result.put("warning", "File already exists, overwriting");

            // Read old content for comparison
            String oldContent = Files.readString(path);
            Files.writeString(path, content);
            long fileSize = Files.size(path);

            result.put("size", fileSize);
            result.put("updated", true);

            String summary = "Updated existing file " + filePath;
            return new ToolExecutionResult(result, summary);
        }

        // Create parent directories if needed
        Path parent = path.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }

        Files.writeString(path, content);
        long fileSize = Files.size(path);

        // Build structured result
        Map<String, Object> result = new HashMap<>();
        result.put("file_path", filePath);
        result.put("size", fileSize);
        result.put("created", true);

        String summary = "Created " + filePath;

        return new ToolExecutionResult(result, summary);
    }

    private ToolExecutionResult updateFile(Map<String, String> params) throws IOException {
        String filePath = params.get("file_path");
        String oldContent = params.get("old_content");
        String newContent = params.get("new_content");

        if (filePath == null || oldContent == null || newContent == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Missing required parameter: new_content");
            error.put("hint", "Use create_file tool instead to write content to a file");
            error.put("example", "<tool name=\"create_file\"><parameter name=\"file_path\">" + (filePath != null ? filePath : "path/to/file") + "</parameter><parameter name=\"content\">your content here</parameter></tool>");
            return new ToolExecutionResult(error, "Error: new_content parameter is required. Use create_file instead to write content.");
        }

        if (oldContent.isEmpty() || oldContent.trim().isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "old_content cannot be empty or whitespace-only");
            error.put("hint", "Provide the specific text you want to replace");
            return new ToolExecutionResult(error, "Error: old_content cannot be empty or whitespace-only");
        }

        Path path = resolvePath(filePath);
        if (!Files.exists(path)) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "File not found: " + filePath);
            return new ToolExecutionResult(error, "Error: File not found");
        }

        String fileContent = Files.readString(path);

        // Try exact match first
        int firstIndex = fileContent.indexOf(oldContent);

        // If exact match fails, try lenient matching
        if (firstIndex == -1) {
            LenientMatch lenientResult = findLenientMatch(fileContent, oldContent);
            if (lenientResult != null) {
                firstIndex = lenientResult.position;
                // Replace oldContent with what we actually found so replacement works correctly
                oldContent = lenientResult.matchedText;
            } else {
                Map<String, Object> error = new HashMap<>();
                error.put("error", "old_content not found in file");
                error.put("hint", "Make sure old_content matches exactly (check whitespace, newlines, and special characters)");
                error.put("old_content_escaped", oldContent.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t"));
                return new ToolExecutionResult(error, "Error: Content not found");
            }
        }

        // Check for multiple occurrences
        int secondIndex = fileContent.indexOf(oldContent, firstIndex + oldContent.length());

        if (secondIndex != -1) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "old_content appears multiple times in file");
            error.put("hint", "Provide more context in old_content to make it unique. Include surrounding lines or more specific text.");
            error.put("occurrences", countOccurrences(fileContent, oldContent));
            return new ToolExecutionResult(error, "Error: old_content must be unique - found multiple occurrences");
        }

        String updatedContent = fileContent.replace(oldContent, newContent);
        Files.writeString(path, updatedContent);
        long fileSize = Files.size(path);

        // Build structured result
        Map<String, Object> result = new HashMap<>();
        result.put("file_path", filePath);
        result.put("size", fileSize);
        result.put("updated", true);

        String summary = "Updated " + filePath;

        return new ToolExecutionResult(result, summary);
    }

    private static class FileUpdate {
        String oldContent;
        String newContent;
        int position;  // Position of old_content in file
        int startLineNumber;  // Line number where this update starts (1-indexed)

        FileUpdate(String oldContent, String newContent, int position, int startLineNumber) {
            this.oldContent = oldContent;
            this.newContent = newContent;
            this.position = position;
            this.startLineNumber = startLineNumber;
        }
    }

    private static class LenientMatch {
        int position;
        String matchedText;  // The actual text from the file that matched

        LenientMatch(int position, String matchedText) {
            this.position = position;
            this.matchedText = matchedText;
        }
    }

    private ToolExecutionResult updateFileBatch(Map<String, String> params) throws IOException {
        String filePath = params.get("file_path");
        String updatesJson = params.get("updates");

        if (filePath == null || filePath.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "file_path parameter required");
            return new ToolExecutionResult(error, "Error: file_path required");
        }

        if (updatesJson == null || updatesJson.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "updates parameter required");
            error.put("hint", "updates should be a JSON array: [{\"old_content\":\"...\",\"new_content\":\"...\"}, ...]");
            return new ToolExecutionResult(error, "Error: updates parameter required");
        }

        // FIX: Convert backslash line continuation to proper \n escapes
        // AI sometimes sends: "line1\<newline>line2" which is invalid JSON
        // We need: "line1\nline2" (the two-character escape sequence)
        updatesJson = updatesJson.replace("\\\n", "\\n").replace("\\\r\n", "\\n");

        Path path = resolvePath(filePath);
        if (!Files.exists(path)) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "File not found: " + filePath);
            return new ToolExecutionResult(error, "Error: File not found");
        }

        String fileContent = Files.readString(path);

        // Parse updates array
        List<Map<String, String>> updatesList;
        try {
            updatesList = com.codeboss.javalayer.shared.LenientJsonParser.parseArray(updatesJson);
        } catch (Exception e) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Failed to parse updates JSON: " + e.getMessage());
            error.put("hint", "updates should be a JSON array: [{\"old_content\":\"...\",\"new_content\":\"...\"}, ...]");
            return new ToolExecutionResult(error, "Error: Invalid JSON format");
        }

        if (updatesList.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "updates array cannot be empty");
            return new ToolExecutionResult(error, "Error: Empty updates array");
        }

        // Validate and find positions for all updates
        List<FileUpdate> updates = new ArrayList<>();

        for (int i = 0; i < updatesList.size(); i++) {
            Map<String, String> update = updatesList.get(i);
            String oldContent = update.get("old_content");
            String newContent = update.get("new_content");

            if (oldContent == null || newContent == null) {
                Map<String, Object> error = new HashMap<>();
                error.put("error", "Update #" + (i + 1) + " missing old_content or new_content");
                return new ToolExecutionResult(error, "Error: Missing required fields in update");
            }

            if (oldContent.isEmpty() || oldContent.trim().isEmpty()) {
                Map<String, Object> error = new HashMap<>();
                error.put("error", "Update #" + (i + 1) + ": old_content cannot be empty or whitespace-only");
                return new ToolExecutionResult(error, "Error: old_content cannot be empty");
            }

            // Check if old_content exists in file (exact match first)
            int position = fileContent.indexOf(oldContent);

            // If exact match fails, try lenient matching
            if (position == -1) {
                LenientMatch lenientResult = findLenientMatch(fileContent, oldContent);
                if (lenientResult != null) {
                    position = lenientResult.position;
                    // Replace oldContent with what we actually found so replacements work correctly
                    oldContent = lenientResult.matchedText;
                } else {
                    Map<String, Object> error = new HashMap<>();
                    error.put("error", "Update #" + (i + 1) + ": old_content not found in file");
                    error.put("old_content_preview", oldContent.length() > 100 ? oldContent.substring(0, 100) + "..." : oldContent);
                    error.put("old_content_length", oldContent.length());
                    error.put("file_content_preview", fileContent.length() > 200 ? fileContent.substring(0, 200) + "..." : fileContent);
                    error.put("file_content_length", fileContent.length());
                    // Show escape sequences visually
                    error.put("old_content_escaped", oldContent.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t"));
                    error.put("hint", "Make sure old_content matches exactly (check whitespace, newlines, and special characters)");
                    return new ToolExecutionResult(error, "Error: Content not found");
                }
            }

            // Check for uniqueness (multiple occurrences)
            int secondOccurrence = fileContent.indexOf(oldContent, position + oldContent.length());
            if (secondOccurrence != -1) {
                Map<String, Object> error = new HashMap<>();
                error.put("error", "Update #" + (i + 1) + ": old_content appears multiple times in file");
                error.put("hint", "Provide more context in old_content to make it unique");
                error.put("occurrences", countOccurrences(fileContent, oldContent));
                return new ToolExecutionResult(error, "Error: old_content must be unique");
            }

            // Calculate the line number where this update starts
            int lineNumber = calculateLineNumber(fileContent, position);

            updates.add(new FileUpdate(oldContent, newContent, position, lineNumber));
        }

        // Check for overlaps between updates
        for (int i = 0; i < updates.size(); i++) {
            FileUpdate update1 = updates.get(i);
            int end1 = update1.position + update1.oldContent.length();

            for (int j = i + 1; j < updates.size(); j++) {
                FileUpdate update2 = updates.get(j);
                int end2 = update2.position + update2.oldContent.length();

                // Check if regions overlap
                boolean overlaps = (update1.position >= update2.position && update1.position < end2) ||
                                 (update2.position >= update1.position && update2.position < end1);

                if (overlaps) {
                    Map<String, Object> error = new HashMap<>();
                    error.put("error", "Updates #" + (i + 1) + " and #" + (j + 1) + " have overlapping regions");
                    error.put("hint", "Ensure old_content regions don't overlap. Consider combining them into a single update.");
                    return new ToolExecutionResult(error, "Error: Overlapping updates");
                }
            }
        }

        // Create a map from old_content to FileUpdate for preserving original order in result
        Map<String, FileUpdate> updateMap = new LinkedHashMap<>();
        for (FileUpdate update : updates) {
            updateMap.put(update.oldContent, update);
        }

        // Sort updates by position (last to first) for reverse application
        updates.sort((a, b) -> Integer.compare(b.position, a.position));

        // Apply updates in reverse order
        String updatedContent = fileContent;
        int updatesApplied = 0;

        for (FileUpdate update : updates) {
            // Find the old content in the current state (positions may have shifted)
            int currentPos = updatedContent.indexOf(update.oldContent);
            if (currentPos == -1) {
                // This shouldn't happen since we validated earlier, but check anyway
                Map<String, Object> error = new HashMap<>();
                error.put("error", "Failed to apply update: old_content not found during application");
                error.put("updates_applied", updatesApplied);
                return new ToolExecutionResult(error, "Error: Update application failed");
            }

            updatedContent = updatedContent.substring(0, currentPos) +
                           update.newContent +
                           updatedContent.substring(currentPos + update.oldContent.length());
            updatesApplied++;
        }

        // Write updated content back to file
        Files.writeString(path, updatedContent);
        long fileSize = Files.size(path);

        // Build structured result with line number information for each update
        Map<String, Object> result = new HashMap<>();
        result.put("file_path", filePath);
        result.put("size", fileSize);
        result.put("updates_applied", updatesApplied);
        result.put("updated", true);

        // Add detailed update information in ORIGINAL ORDER (matching parameters.updates)
        List<Map<String, Object>> updatesDetail = new ArrayList<>();
        for (Map<String, String> originalUpdate : updatesList) {
            String oldContent = originalUpdate.get("old_content");
            FileUpdate fileUpdate = updateMap.get(oldContent);
            if (fileUpdate != null) {
                Map<String, Object> updateInfo = new LinkedHashMap<>();
                updateInfo.put("start_line", fileUpdate.startLineNumber);
                updateInfo.put("old_content", fileUpdate.oldContent);
                updateInfo.put("new_content", fileUpdate.newContent);
                updatesDetail.add(updateInfo);
            }
        }
        result.put("updates_detail", updatesDetail);

        String summary = "Applied " + updatesApplied + " update(s) to " + filePath;

        return new ToolExecutionResult(result, summary);
    }

    private ToolExecutionResult deleteFile(Map<String, String> params) throws IOException {
        String filePath = params.get("file_path");

        if (filePath == null || filePath.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "file_path parameter required");
            return new ToolExecutionResult(error, "Error: file_path required");
        }

        Path path = resolvePath(filePath);
        if (!Files.exists(path)) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "File not found: " + filePath);
            return new ToolExecutionResult(error, "Error: File not found");
        }

        Files.delete(path);

        // Build structured result
        Map<String, Object> result = new HashMap<>();
        result.put("file_path", filePath);
        result.put("deleted", true);

        String summary = "Deleted " + filePath;

        return new ToolExecutionResult(result, summary);
    }

    private ToolExecutionResult manageChecklist(Map<String, String> params) {
        if (checklistManager == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "ChecklistManager not available");
            return new ToolExecutionResult(error, "Error: ChecklistManager not set");
        }

        String action = params.get("action");
        if (action == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "action parameter required");
            return new ToolExecutionResult(error, "Error: action required");
        }

        try {
            Map<String, Object> result = new HashMap<>();

            switch (action) {
                case "add":
                    String content = params.get("content");
                    String priority = params.getOrDefault("priority", "medium");
                    String itemType = params.getOrDefault("item_type", "coding");

                    ChecklistManager.ChecklistItem item = checklistManager.addItem(content, priority, itemType);
                    result.put("action", "add");
                    result.put("id", item.id);
                    result.put("content", item.content);
                    return new ToolExecutionResult(result, "Added checklist item: " + item.id);

                case "list":
                    List<ChecklistManager.ChecklistItem> items = checklistManager.getItems();
                    List<Map<String, Object>> itemsList = new ArrayList<>();
                    for (ChecklistManager.ChecklistItem it : items) {
                        Map<String, Object> itemMap = new HashMap<>();
                        itemMap.put("id", it.id);
                        itemMap.put("content", it.content);
                        itemMap.put("status", it.status);
                        itemMap.put("priority", it.priority);
                        itemMap.put("item_type", it.itemType);
                        itemsList.add(itemMap);
                    }
                    result.put("action", "list");
                    result.put("items", itemsList);
                    result.put("count", itemsList.size());
                    return new ToolExecutionResult(result, "Listed " + itemsList.size() + " items");

                case "delete":
                    String id = params.get("id");
                    boolean deleted = checklistManager.deleteItem(id);
                    result.put("action", "delete");
                    result.put("id", id);
                    result.put("deleted", deleted);
                    return new ToolExecutionResult(result, deleted ? "Deleted item " + id : "Item not found");

                default:
                    Map<String, Object> error = new HashMap<>();
                    error.put("error", "Unknown action: " + action);
                    return new ToolExecutionResult(error, "Error: Unknown action");
            }
        } catch (Exception e) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Checklist error: " + e.getMessage());
            return new ToolExecutionResult(error, "Error: " + e.getMessage());
        }
    }

    private ToolExecutionResult completeTodo(Map<String, String> params) {
        if (checklistManager == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "ChecklistManager not available");
            return new ToolExecutionResult(error, "Error: ChecklistManager not set");
        }

        String id = params.get("id");
        if (id == null || id.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "id parameter required");
            return new ToolExecutionResult(error, "Error: id required");
        }

        boolean completed = checklistManager.completeItem(id);

        Map<String, Object> result = new HashMap<>();
        result.put("id", id);
        result.put("completed", completed);

        String summary = completed ? "Completed todo: " + id : "Todo not found: " + id;

        boolean shouldTriggerReview = completed && checklistManager.shouldTriggerReview();

        return new ToolExecutionResult(result, summary, shouldTriggerReview);
    }

    private ToolExecutionResult markComplete(Map<String, String> params) {
        if (checklistManager == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "ChecklistManager not available");
            return new ToolExecutionResult(error, "Error: ChecklistManager not set");
        }

        // Get the current pending item and mark it complete
        ChecklistManager.ChecklistItem currentItem = checklistManager.getNextPendingItem();
        if (currentItem == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "No pending items to complete");
            return new ToolExecutionResult(error, "Error: No pending items");
        }

        boolean completed = checklistManager.completeItem(currentItem.id);

        Map<String, Object> result = new HashMap<>();
        result.put("id", currentItem.id);
        result.put("content", currentItem.content);
        result.put("completed", true);

        // Add stats and next task info
        List<ChecklistManager.ChecklistItem> allItems = checklistManager.getItems();
        int totalItems = allItems.size();
        int completedCount = 0;
        for (ChecklistManager.ChecklistItem item : allItems) {
            if (item.completed) completedCount++;
        }
        result.put("total_items", totalItems);
        result.put("completed_count", completedCount);

        // Get next pending item if exists
        ChecklistManager.ChecklistItem nextItem = checklistManager.getNextPendingItem();
        if (nextItem != null) {
            Map<String, Object> nextTaskInfo = new LinkedHashMap<>();
            nextTaskInfo.put("id", nextItem.id);
            nextTaskInfo.put("content", nextItem.content);
            nextTaskInfo.put("item_type", nextItem.itemType);
            nextTaskInfo.put("priority", nextItem.priority);
            result.put("next_task", nextTaskInfo);
        }

        String summary = "Completed: " + currentItem.content;

        // Check if review should be triggered
        boolean shouldTriggerReview = checklistManager.shouldTriggerReview();

        return new ToolExecutionResult(result, summary, shouldTriggerReview);
    }

    private ToolExecutionResult markFailed(Map<String, String> params) {
        if (checklistManager == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "ChecklistManager not available");
            return new ToolExecutionResult(error, "Error: ChecklistManager not set");
        }

        String reason = params.get("reason");
        if (reason == null || reason.trim().isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "reason parameter required");
            return new ToolExecutionResult(error, "Error: reason required");
        }

        // Get the current pending item
        ChecklistManager.ChecklistItem currentItem = checklistManager.getNextPendingItem();
        if (currentItem == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "No pending items to fail");
            return new ToolExecutionResult(error, "Error: No pending items");
        }

        Map<String, Object> result = new HashMap<>();
        result.put("id", currentItem.id);
        result.put("content", currentItem.content);
        result.put("failed", true);
        result.put("reason", reason);

        String summary = "Task failed: " + currentItem.content + " - " + reason;

        // Return to planning mode will be handled by AIProcessorThread
        return new ToolExecutionResult(result, summary, false);
    }

    private ToolExecutionResult reviewPass(Map<String, String> params) {
        Map<String, Object> result = new HashMap<>();
        result.put("verdict", "PASS");
        return new ToolExecutionResult(result, "Review passed");
    }

    private ToolExecutionResult reviewFail(Map<String, String> params) {
        String reason = params.get("reason");
        if (reason == null || reason.trim().isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "reason parameter required");
            return new ToolExecutionResult(error, "Error: reason required");
        }
        Map<String, Object> result = new HashMap<>();
        result.put("verdict", "FAIL");
        result.put("reason", reason);
        return new ToolExecutionResult(result, "Review failed: " + reason);
    }

    private ToolExecutionResult beginExecution(Map<String, String> params) {
        if (conversationManager == null) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "ConversationManager not set");
            return new ToolExecutionResult(error, "Error: ConversationManager not set");
        }

        // Extract and validate parameters
        String approvalMessage = params.get("approval_message");
        String description = params.get("description");
        String checklistJson = params.get("checklist");

        if (description == null || description.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "description parameter required");
            return new ToolExecutionResult(error, "Error: description required");
        }

        if (checklistJson == null || checklistJson.isEmpty()) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "checklist parameter required");
            return new ToolExecutionResult(error, "Error: checklist required");
        }

        // Parse checklist to validate format and generate preview
        List<Map<String, String>> items = parseChecklistForPreview(checklistJson);

        // AUTO-APPROVE: If there's only 1 item, skip approval and go directly to execution
        if (items.size() == 1) {
            // Clear any existing checklist before adding new items
            if (checklistManager != null) {
                checklistManager.clearChecklist();
            }

            // Add checklist items directly to ChecklistManager
            List<Map<String, String>> addedItems = parseAndAddChecklist(checklistJson);

            // Transition to EXECUTION mode immediately
            if (modeManager != null) {
                modeManager.transitionTo(com.codeboss.javalayer.aiprocessor.Mode.EXECUTION);
            }

            // Get first task to start
            ChecklistManager.ChecklistItem firstTask = checklistManager != null ?
                checklistManager.getNextPendingItem() : null;

            Map<String, Object> result = new LinkedHashMap<>();
            result.put("status", "auto_approved");
            result.put("description", description);
            result.put("checklist_preview", items);
            result.put("item_count", 1);
            result.put("reason", "Single-item plan auto-approved");

            if (firstTask != null) {
                Map<String, Object> taskInfo = new LinkedHashMap<>();
                taskInfo.put("content", firstTask.content);
                taskInfo.put("item_type", firstTask.itemType);
                taskInfo.put("task_number", 1);
                taskInfo.put("total_items", 1);
                result.put("first_task", taskInfo);
            }

            return new ToolExecutionResult(result, "Plan auto-approved (1 item) and execution started");
        }

        // NORMAL FLOW: Store for approval (DON'T add to ChecklistManager yet)
        conversationManager.setPendingApproval(description, checklistJson);

        Map<String, Object> result = new LinkedHashMap<>();
        result.put("status", "pending_approval");
        if (approvalMessage != null && !approvalMessage.isEmpty()) {
            result.put("approval_message", approvalMessage);
        }
        result.put("description", description);
        result.put("checklist_preview", items);
        result.put("item_count", items.size());

        return new ToolExecutionResult(result, "Plan submitted for approval");
    }

    /**
     * List all saved test commands
     * No approval needed - just lists what's available
     */
    private ToolExecutionResult listCommands(Map<String, String> params) {
        try {
            CommandManager cmdMgr = new CommandManager(workingDirectory);
            List<String> commands = cmdMgr.listCommands();

            Map<String, Object> result = new HashMap<>();
            result.put("commands", commands);
            result.put("count", commands.size());

            String summary = commands.isEmpty()
                ? "No test commands found"
                : "Found " + commands.size() + " test command(s): " + String.join(", ", commands);

            return new ToolExecutionResult(result, summary);
        } catch (Exception e) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Failed to list commands: " + e.getMessage());
            return new ToolExecutionResult(error, "Error listing commands");
        }
    }

    private List<Map<String, String>> parseChecklistForPreview(String checklistJson) {
        if (checklistJson == null || checklistJson.trim().isEmpty()) {
            return new ArrayList<>();
        }

        try {
            // Use SimpleJsonParser to properly handle commas in field values
            List<Map<String, String>> items = com.codeboss.javalayer.shared.LenientJsonParser.parseArray(checklistJson);

            // Ensure defaults for missing fields
            for (Map<String, String> item : items) {
                if (!item.containsKey("item_type")) {
                    item.put("item_type", "coding");
                }
                if (!item.containsKey("priority")) {
                    item.put("priority", "medium");
                }
            }

            return items;
        } catch (Exception e) {
            logger.log("Warning: Failed to parse checklist JSON: " + e.getMessage());
            return new ArrayList<>();
        }
    }

    private String extractJsonValue(String field) {
        // Extract value from "key":"value" format
        int colonIdx = field.indexOf(":");
        if (colonIdx > 0) {
            String value = field.substring(colonIdx + 1).trim();
            // Remove quotes
            if (value.startsWith("\"") && value.endsWith("\"")) {
                value = value.substring(1, value.length() - 1);
            }
            return value;
        }
        return "";
    }

    public List<Map<String, String>> parseAndAddChecklist(String checklistJson) {
        if (checklistJson == null || checklistJson.trim().isEmpty()) {
            return new ArrayList<>();
        }

        try {
            // Use SimpleJsonParser to properly handle commas in field values
            List<Map<String, String>> items = com.codeboss.javalayer.shared.LenientJsonParser.parseArray(checklistJson);

            for (Map<String, String> item : items) {
                String content = item.get("content");
                String itemType = item.getOrDefault("item_type", "coding");
                String priority = item.getOrDefault("priority", "medium");

                if (content != null && !content.isEmpty()) {
                    // Add to ChecklistManager
                    if (checklistManager != null) {
                        checklistManager.addItem(content, priority, itemType);
                    }

                    // Ensure defaults are in the returned map
                    item.put("item_type", itemType);
                    item.put("priority", priority);
                }
            }

            return items;
        } catch (Exception e) {
            logger.log("Warning: Failed to parse checklist JSON: " + e.getMessage());
            return new ArrayList<>();
        }
    }

    private Path resolvePath(String filePath) {
        Path path = Paths.get(filePath);
        if (path.isAbsolute()) {
            return path;
        } else {
            return Paths.get(workingDirectory).resolve(path);
        }
    }

    private String formatFileSize(long bytes) {
        if (bytes < 1024) return bytes + "B";
        if (bytes < 1024 * 1024) return (bytes / 1024) + "KB";
        return (bytes / (1024 * 1024)) + "MB";
    }

    private String escapeJson(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    // ============================================================================
    // Command Execution Tools (Stubbed - TODO: Implement)
    // ============================================================================

    /**
     * Create a reusable test command template
     * Requires user approval before saving
     */
    private ToolExecutionResult createTestCommand(Map<String, String> params) {
        try {
            String name = params.get("name");
            String command = params.get("command");
            String description = params.get("description");

            if (name == null || name.isEmpty()) {
                Map<String, Object> error = new HashMap<>();
                error.put("error", "name parameter required");
                return new ToolExecutionResult(error, "Error: name required");
            }

            if (command == null || command.isEmpty()) {
                Map<String, Object> error = new HashMap<>();
                error.put("error", "command parameter required");
                return new ToolExecutionResult(error, "Error: command required");
            }

            // Set pending approval state
            if (conversationManager != null) {
                conversationManager.setPendingTestCommand(name, command, description);
            }

            // Return pending_approval status
            Map<String, Object> result = new HashMap<>();
            result.put("status", "pending_approval");
            result.put("name", name);
            result.put("command", command);
            if (description != null) {
                result.put("description", description);
            }

            String summary = "Test command '" + name + "' pending approval";
            return new ToolExecutionResult(result, summary);

        } catch (Exception e) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Failed to create test command: " + e.getMessage());
            return new ToolExecutionResult(error, "Error creating test command");
        }
    }

    /**
     * Execute a saved test command
     * Command must exist in .agent/commands/ (created via create_test_command)
     */
    private ToolExecutionResult runTest(Map<String, String> params) {
        try {
            CommandManager cmdMgr = new CommandManager(workingDirectory);
            String name = params.get("name");

            // CHANGE: Only accept 'name', not 'command'
            if (name == null || name.isEmpty()) {
                Map<String, Object> error = new HashMap<>();
                error.put("error", "name parameter required - use create_test_command first to create a command");
                return new ToolExecutionResult(error, "Error: name required");
            }

            // Load the saved command
            String command;
            String commandName = name;

            try {
                command = cmdMgr.loadCommand(name);
            } catch (FileNotFoundException e) {
                Map<String, Object> error = new HashMap<>();
                error.put("error", "Test command not found: " + name + ". Use list_commands to see available commands.");
                return new ToolExecutionResult(error, "Error: command not found");
            }

            String background = params.get("background");
            String regex = params.get("regex");
            String timeoutStr = params.get("timeout_ms");

            command = cmdMgr.substituteParams(command, params);
            String outputFile = cmdMgr.generateOutputFilePath(commandName);

            boolean isBackground = "true".equalsIgnoreCase(background);
            long timeout = timeoutStr != null ? Long.parseLong(timeoutStr) : 30000;

            ProcessBuilder pb = new ProcessBuilder("pwsh", "-Command", command + " 2>&1");
            pb.directory(new File(workingDirectory));
            pb.redirectOutput(new File(outputFile));
            Process process = pb.start();
            long pid = process.pid();

            cmdMgr.addProcess(new CommandManager.ProcessInfo(
                pid, commandName, command, outputFile, java.time.Instant.now().toString()
            ));

            if (isBackground) {
                Map<String, Object> result = new HashMap<>();
                result.put("pid", pid);
                result.put("command", command);
                result.put("output_file", outputFile);
                result.put("status", "running");
                return new ToolExecutionResult(result, "Process started in background (PID: " + pid + ")");
            } else {
                boolean completed = process.waitFor(timeout, java.util.concurrent.TimeUnit.MILLISECONDS);
                int exitCode = completed ? process.exitValue() : -1;

                cmdMgr.removeProcess(pid);

                Map<String, Object> result = new HashMap<>();
                result.put("command", command);
                result.put("output_file", outputFile);
                result.put("exit_code", exitCode);

                if (regex != null && !regex.isEmpty()) {
                    String output = Files.readString(Paths.get(outputFile));
                    List<String> matches = cmdMgr.extractRegexMatches(output, regex);
                    result.put("regex_matches", matches);
                }

                if (!completed) {
                    process.destroyForcibly();
                    result.put("error", "Command timed out after " + timeout + "ms");
                    result.put("status", "timeout");
                    return new ToolExecutionResult(result, "Error: Command timed out");
                } else if (exitCode != 0) {
                    result.put("error", "Command failed with exit code " + exitCode);
                    result.put("status", "failed");
                    return new ToolExecutionResult(result, "Error: Command failed (exit code " + exitCode + ")");
                } else {
                    result.put("status", "completed");
                    return new ToolExecutionResult(result, "Command completed successfully");
                }
            }

        } catch (Exception e) {
            Map<String, Object> result = new HashMap<>();
            result.put("error", "Failed to run command: " + e.getMessage());
            return new ToolExecutionResult(result, "Error: " + e.getMessage());
        }
    }

    /**
     * List all running processes started by CodeBoss
     *
     * See: specs/COMMAND_EXECUTION.md
     */
    private ToolExecutionResult listProcesses(Map<String, String> params) {
        try {
            CommandManager cmdMgr = new CommandManager(workingDirectory);
            List<CommandManager.ProcessInfo> activeProcesses = cmdMgr.getActiveProcesses();

            List<Map<String, Object>> processList = new ArrayList<>();
            for (CommandManager.ProcessInfo p : activeProcesses) {
                Map<String, Object> processMap = new HashMap<>();
                processMap.put("pid", p.pid);
                processMap.put("name", p.name);
                processMap.put("command", p.command);
                processMap.put("output_file", p.outputFile);
                processMap.put("started_at", p.startedAt);
                processList.add(processMap);
            }

            Map<String, Object> result = new HashMap<>();
            result.put("processes", processList);
            result.put("count", processList.size());

            String message = processList.isEmpty()
                ? "No running processes"
                : "Found " + processList.size() + " running process(es)";
            return new ToolExecutionResult(result, message);

        } catch (Exception e) {
            Map<String, Object> result = new HashMap<>();
            result.put("error", "Failed to list processes: " + e.getMessage());
            return new ToolExecutionResult(result, "Error: " + e.getMessage());
        }
    }

    /**
     * Stop a running test process by PID or name
     */
    private ToolExecutionResult stopTest(Map<String, String> params) {
        try {
            CommandManager cmdMgr = new CommandManager(workingDirectory);
            String pidStr = params.get("pid");
            String name = params.get("name");

            if ((pidStr == null || pidStr.isEmpty()) && (name == null || name.isEmpty())) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Either 'pid' or 'name' parameter is required");
                return new ToolExecutionResult(result, "Error: pid or name required");
            }

            List<CommandManager.ProcessInfo> activeProcesses = cmdMgr.getActiveProcesses();
            List<Map<String, Object>> stopped = new ArrayList<>();

            for (CommandManager.ProcessInfo p : activeProcesses) {
                boolean shouldStop = false;

                if (pidStr != null && !pidStr.isEmpty()) {
                    long targetPid = Long.parseLong(pidStr);
                    shouldStop = (p.pid == targetPid);
                } else if (name != null && !name.isEmpty()) {
                    shouldStop = p.name.equals(name);
                }

                if (shouldStop) {
                    cmdMgr.killProcess(p.pid);
                    cmdMgr.removeProcess(p.pid);

                    Map<String, Object> processMap = new HashMap<>();
                    processMap.put("pid", p.pid);
                    processMap.put("name", p.name);
                    processMap.put("output_file", p.outputFile);
                    stopped.add(processMap);
                }
            }

            Map<String, Object> result = new HashMap<>();
            result.put("stopped", stopped);
            result.put("count", stopped.size());

            String message = stopped.isEmpty()
                ? "No matching processes found"
                : "Stopped " + stopped.size() + " process(es)";
            return new ToolExecutionResult(result, message);

        } catch (Exception e) {
            Map<String, Object> result = new HashMap<>();
            result.put("error", "Failed to stop command: " + e.getMessage());
            return new ToolExecutionResult(result, "Error: " + e.getMessage());
        }
    }

    // ============================================================================
    // Search Tools
    // ============================================================================

    /**
     * Search files by name using glob patterns
     * Uses PowerShell Get-ChildItem for recursive file search
     *
     * See: specs/tools-spec.md (search_files_by_name)
     */
    private ToolExecutionResult searchFilesByName(Map<String, String> params) {
        try {
            String directoryPath = params.getOrDefault("directory_path", ".");
            String pattern = params.get("pattern");

            if (pattern == null || pattern.isEmpty()) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Parameter 'pattern' is required");
                return new ToolExecutionResult(result, "Error: 'pattern' parameter required");
            }

            Path searchPath = resolvePath(directoryPath);
            if (!Files.exists(searchPath)) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Directory not found: " + directoryPath);
                return new ToolExecutionResult(result, "Error: Directory not found");
            }

            // Use PowerShell Get-ChildItem for glob pattern matching
            String psCommand = String.format(
                "Get-ChildItem -Path '%s' -Filter '%s' -Recurse -File | ForEach-Object { $_.FullName }",
                searchPath.toString().replace("'", "''"),
                pattern.replace("'", "''")
            );

            ProcessBuilder pb = new ProcessBuilder("pwsh", "-Command", psCommand);
            pb.directory(new File(workingDirectory));
            Process process = pb.start();

            boolean completed = process.waitFor(10, java.util.concurrent.TimeUnit.SECONDS);
            if (!completed) {
                process.destroyForcibly();
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Search timed out");
                return new ToolExecutionResult(result, "Error: Search timed out");
            }

            String output = new String(process.getInputStream().readAllBytes());
            String errorOutput = new String(process.getErrorStream().readAllBytes());

            if (process.exitValue() != 0 && !errorOutput.isEmpty()) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Search failed: " + errorOutput);
                return new ToolExecutionResult(result, "Error: " + errorOutput);
            }

            List<String> files = new ArrayList<>();
            if (!output.trim().isEmpty()) {
                String[] lines = output.trim().split("\n");
                Path workDir = Paths.get(workingDirectory);
                for (String line : lines) {
                    String trimmed = line.trim();
                    if (!trimmed.isEmpty()) {
                        // Convert to relative path if possible
                        Path filePath = Paths.get(trimmed);
                        try {
                            Path relative = workDir.relativize(filePath);
                            files.add(relative.toString());
                        } catch (IllegalArgumentException e) {
                            files.add(trimmed);
                        }
                    }
                }
            }

            Map<String, Object> result = new HashMap<>();
            result.put("files", files);
            result.put("count", files.size());
            result.put("pattern", pattern);
            result.put("directory", directoryPath);

            String summary = "Found " + files.size() + " file(s) matching '" + pattern + "'";
            return new ToolExecutionResult(result, summary);

        } catch (Exception e) {
            Map<String, Object> result = new HashMap<>();
            result.put("error", "Search failed: " + e.getMessage());
            return new ToolExecutionResult(result, "Error: " + e.getMessage());
        }
    }

    /**
     * Search file contents using regex patterns
     * Uses PowerShell with ripgrep (rg) for fast content search
     *
     * See: specs/tools-spec.md (search_files_by_content)
     */
    private ToolExecutionResult searchFilesByContent(Map<String, String> params) {
        try {
            String directoryPath = params.getOrDefault("directory_path", ".");
            String pattern = params.get("pattern");
            String filePattern = params.get("file_pattern");

            if (pattern == null || pattern.isEmpty()) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Parameter 'pattern' is required");
                return new ToolExecutionResult(result, "Error: 'pattern' parameter required");
            }

            Path searchPath = resolvePath(directoryPath);
            if (!Files.exists(searchPath)) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Directory not found: " + directoryPath);
                return new ToolExecutionResult(result, "Error: Directory not found");
            }

            // Build ripgrep command
            StringBuilder rgCmd = new StringBuilder();
            rgCmd.append("rg --line-number --no-heading --color never");
            rgCmd.append(" --regexp '").append(pattern.replace("'", "''")).append("'");

            if (filePattern != null && !filePattern.isEmpty()) {
                rgCmd.append(" --glob '").append(filePattern.replace("'", "''")).append("'");
            }

            rgCmd.append(" '").append(searchPath.toString().replace("'", "''")).append("'");

            ProcessBuilder pb = new ProcessBuilder("pwsh", "-Command", rgCmd.toString());
            pb.directory(new File(workingDirectory));
            Process process = pb.start();

            boolean completed = process.waitFor(10, java.util.concurrent.TimeUnit.SECONDS);
            if (!completed) {
                process.destroyForcibly();
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Search timed out");
                return new ToolExecutionResult(result, "Error: Search timed out");
            }

            String output = new String(process.getInputStream().readAllBytes());
            String errorOutput = new String(process.getErrorStream().readAllBytes());

            // ripgrep returns exit code 1 when no matches found (not an error)
            int exitCode = process.exitValue();
            if (exitCode != 0 && exitCode != 1 && !errorOutput.isEmpty()) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Search failed: " + errorOutput);
                return new ToolExecutionResult(result, "Error: " + errorOutput);
            }

            List<Map<String, Object>> matches = new ArrayList<>();
            if (!output.trim().isEmpty()) {
                String[] lines = output.trim().split("\n");
                Path workDir = Paths.get(workingDirectory);

                for (String line : lines) {
                    String trimmed = line.trim();
                    if (!trimmed.isEmpty()) {
                        // Parse ripgrep output: filepath:linenum:content
                        int firstColon = trimmed.indexOf(':');
                        int secondColon = trimmed.indexOf(':', firstColon + 1);

                        if (firstColon > 0 && secondColon > firstColon) {
                            String filePath = trimmed.substring(0, firstColon);
                            String lineNum = trimmed.substring(firstColon + 1, secondColon);
                            String content = trimmed.substring(secondColon + 1);

                            // Convert to relative path if possible
                            Path absPath = Paths.get(filePath);
                            try {
                                if (absPath.isAbsolute()) {
                                    Path relative = workDir.relativize(absPath);
                                    filePath = relative.toString();
                                }
                            } catch (IllegalArgumentException e) {
                                // Keep absolute path
                            }

                            Map<String, Object> match = new HashMap<>();
                            match.put("file", filePath);
                            match.put("line", lineNum);
                            match.put("content", content.trim());
                            matches.add(match);
                        }
                    }
                }
            }

            Map<String, Object> result = new HashMap<>();
            result.put("matches", matches);
            result.put("count", matches.size());
            result.put("pattern", pattern);
            result.put("directory", directoryPath);
            if (filePattern != null) {
                result.put("file_pattern", filePattern);
            }

            String summary = "Found " + matches.size() + " match(es) for '" + pattern + "'";
            return new ToolExecutionResult(result, summary);

        } catch (Exception e) {
            Map<String, Object> result = new HashMap<>();
            result.put("error", "Search failed: " + e.getMessage());
            return new ToolExecutionResult(result, "Error: " + e.getMessage());
        }
    }

    // ============================================================================
    // Git Tools
    // ============================================================================

    private static final java.util.Set<String> GIT_READ_COMMANDS = new java.util.HashSet<>(
        java.util.Arrays.asList("status", "log", "show", "diff", "branch", "remote", "tag", "ls-files", "blame")
    );

    private static final java.util.Set<String> GIT_WRITE_COMMANDS = new java.util.HashSet<>(
        java.util.Arrays.asList("add", "commit", "checkout", "reset", "stash", "clean")
    );

    /**
     * Execute read-only git commands
     * Uses PowerShell to execute git with allowed read commands
     *
     * See: specs/tools-spec.md (git_read)
     */
    private ToolExecutionResult gitRead(Map<String, String> params) {
        return executeGitCommand(params, GIT_READ_COMMANDS, "git_read");
    }

    /**
     * Execute git write commands
     * Uses PowerShell to execute git with allowed write commands
     *
     * See: specs/tools-spec.md (git_write)
     */
    private ToolExecutionResult gitWrite(Map<String, String> params) {
        return executeGitCommand(params, GIT_WRITE_COMMANDS, "git_write");
    }

    private ToolExecutionResult executeGitCommand(Map<String, String> params, java.util.Set<String> allowedCommands, String toolName) {
        try {
            String projectPath = params.getOrDefault("project_path", ".");
            String gitArgs = params.get("git_args");

            if (gitArgs == null || gitArgs.isEmpty()) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Parameter 'git_args' is required");
                return new ToolExecutionResult(result, "Error: 'git_args' parameter required");
            }

            // Parse the git command to validate it
            String[] parts = gitArgs.trim().split("\\s+", 2);
            String gitCommand = parts[0];

            if (!allowedCommands.contains(gitCommand)) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Git command '" + gitCommand + "' not allowed in " + toolName);
                result.put("allowed_commands", new ArrayList<>(allowedCommands));
                return new ToolExecutionResult(result, "Error: Command not allowed");
            }

            Path projectDir = resolvePath(projectPath);
            if (!Files.exists(projectDir)) {
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Project path not found: " + projectPath);
                return new ToolExecutionResult(result, "Error: Project path not found");
            }

            // Execute git command via PowerShell
            String psCommand = "git " + gitArgs;
            ProcessBuilder pb = new ProcessBuilder("pwsh", "-Command", psCommand);
            pb.directory(projectDir.toFile());
            Process process = pb.start();

            boolean completed = process.waitFor(30, java.util.concurrent.TimeUnit.SECONDS);
            if (!completed) {
                process.destroyForcibly();
                Map<String, Object> result = new HashMap<>();
                result.put("error", "Git command timed out");
                return new ToolExecutionResult(result, "Error: Command timed out");
            }

            String output = new String(process.getInputStream().readAllBytes());
            String errorOutput = new String(process.getErrorStream().readAllBytes());
            int exitCode = process.exitValue();

            Map<String, Object> result = new HashMap<>();
            result.put("command", "git " + gitArgs);
            result.put("exit_code", exitCode);
            result.put("output", output);

            if (exitCode != 0) {
                result.put("error_output", errorOutput);
                return new ToolExecutionResult(result, "Git command failed (exit code " + exitCode + ")");
            }

            String summary = "Executed: git " + gitCommand;
            return new ToolExecutionResult(result, summary);

        } catch (Exception e) {
            Map<String, Object> result = new HashMap<>();
            result.put("error", "Git command failed: " + e.getMessage());
            return new ToolExecutionResult(result, "Error: " + e.getMessage());
        }
    }

    private int countOccurrences(String text, String substring) {
        int count = 0;
        int index = 0;
        while ((index = text.indexOf(substring, index)) != -1) {
            count++;
            index += substring.length();
        }
        return count;
    }

    /**
     * Calculate the line number (1-indexed) for a given position in file content
     */
    private int calculateLineNumber(String fileContent, int position) {
        int lineNumber = 1;
        for (int i = 0; i < position && i < fileContent.length(); i++) {
            if (fileContent.charAt(i) == '\n') {
                lineNumber++;
            }
        }
        return lineNumber;
    }

    /**
     * Try to find a lenient match for old_content in fileContent.
     * Converts old_content to a regex pattern that's flexible about whitespace.
     * Returns null if no match found.
     */
    private LenientMatch findLenientMatch(String fileContent, String oldContent) {
        // Strategy: Tokenize by character class transitions AND split long alphanumeric sequences
        // This handles cases like "modulesconst" which should match "modules\nconst"

        // Tokenize by character class transitions
        List<String> tokens = new ArrayList<>();
        int i = 0;
        while (i < oldContent.length()) {
            // Skip whitespace
            while (i < oldContent.length() && Character.isWhitespace(oldContent.charAt(i))) {
                i++;
            }
            if (i >= oldContent.length()) break;

            int start = i;
            char startChar = oldContent.charAt(i);
            boolean isAlphaNum = Character.isLetterOrDigit(startChar);

            // Collect characters of the same class
            i++;
            while (i < oldContent.length()) {
                char c = oldContent.charAt(i);
                if (Character.isWhitespace(c)) {
                    break; // Stop at whitespace
                }
                boolean currentIsAlphaNum = Character.isLetterOrDigit(c);
                if (currentIsAlphaNum != isAlphaNum) {
                    break; // Stop at class transition
                }
                // ALSO stop on CamelCase transitions (lowercase to uppercase)
                if (isAlphaNum && i > start &&
                    Character.isLowerCase(oldContent.charAt(i-1)) &&
                    Character.isUpperCase(c)) {
                    break;
                }
                i++;
            }

            String token = oldContent.substring(start, i);

            // If token is very long (>8 chars) and alphanumeric, it might be missing whitespace
            // Split it into smaller chunks to increase match chances
            if (isAlphaNum && token.length() > 8) {
                // Try to split on likely word boundaries
                // For now, just add the whole token and hope regex matching helps
                tokens.add(token);
            } else {
                tokens.add(token);
            }
        }

        if (tokens.isEmpty()) {
            return null; // Nothing to match
        }

        // Build regex: token1 .+? token2 .+? token3 ...
        // Use .+? (non-greedy any character) to match anything between tokens
        // This handles cases where AI concatenates words: "modulesconst" matches "modules\nconst"
        StringBuilder regexBuilder = new StringBuilder();
        for (int j = 0; j < tokens.size(); j++) {
            if (j > 0) {
                regexBuilder.append(".*?"); // Match any characters (non-greedy) between tokens
            }
            regexBuilder.append(java.util.regex.Pattern.quote(tokens.get(j)));
        }

        try {
            java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(regexBuilder.toString());
            java.util.regex.Matcher matcher = pattern.matcher(fileContent);

            if (matcher.find()) {
                return new LenientMatch(matcher.start(), matcher.group());
            }
        } catch (java.util.regex.PatternSyntaxException e) {
            // If regex fails, return null
            return null;
        }

        return null;
    }

    /**
     * Maps tool names to their required ToolCategory
     * Returns null for tools that don't require category validation
     */
    private com.codeboss.javalayer.aiprocessor.ToolCategory getToolCategory(String toolName) {
        switch (toolName) {
            // FILE_READ category
            case "read_file":
            case "list_files":
                return com.codeboss.javalayer.aiprocessor.ToolCategory.FILE_READ;

            // FILE_OPERATIONS category (write operations)
            case "create_file":
            case "update_file":
            case "update_file_batch":
            case "delete_file":
                return com.codeboss.javalayer.aiprocessor.ToolCategory.FILE_OPERATIONS;

            // SEARCH category
            case "search_files_by_name":
            case "search_files_by_content":
                return com.codeboss.javalayer.aiprocessor.ToolCategory.SEARCH;

            // COMMAND_EXECUTION category
            case "create_test_command":
            case "run_test":
            case "stop_test":
            case "list_processes":
            case "list_commands":
                return com.codeboss.javalayer.aiprocessor.ToolCategory.COMMAND_EXECUTION;

            // GIT_READ category
            case "git_read":
                return com.codeboss.javalayer.aiprocessor.ToolCategory.GIT_READ;

            // GIT_WRITE category
            case "git_write":
                return com.codeboss.javalayer.aiprocessor.ToolCategory.GIT_WRITE;

            // CHECKLIST category (mode management tools - no validation needed)
            case "manage_checklist":
            case "complete_todo":
            case "mark_complete":
            case "mark_failed":
            case "begin_execution":
            case "review_pass":
            case "review_fail":
                return com.codeboss.javalayer.aiprocessor.ToolCategory.CHECKLIST;

            default:
                return null; // Unknown tools will fail with "Unknown tool" error
        }
    }
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: src/frontend-ui/api.js
|~|~|~|~|~|~|~|~|~|~|~|
(function() {
    async function getState() {
        try {
            const response = await fetch('/api/state');
            if (!response.ok) {
                throw new Error('Failed to fetch state');
            }
            return await response.json();
        } catch (error) {
            console.error('Error fetching state:', error);
            return { status: 'error', messages: [], error: error.message };
        }
    }

    async function sendMessage(message, onStateUpdate) {
        try {
            console.log('[API] Sending message to /api/message:', message);
            const response = await fetch('/api/message', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: message })
            });

            if (!response.ok) {
                console.error('[API] Server returned error:', response.status, response.statusText);
                throw new Error('Failed to send message');
            }

            console.log('[API] Server response OK, starting SSE stream');

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');

                buffer = lines.pop() || '';

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        try {
                            const state = JSON.parse(data);
                            const msgCount = state.messages ? state.messages.length : 0;
                            console.log('[BROWSER-RECV] Received SSE data with ' + msgCount + ' messages');
                            console.log('[SSE] Received state update:', {
                                status: state.status,
                                messageCount: msgCount,
                                lastMessage: state.messages && state.messages.length > 0 ?
                                    state.messages[state.messages.length - 1].type : 'none'
                            });

                            try {
                                onStateUpdate(state);
                            } catch (updateError) {
                                console.error('[SSE] Error updating UI, will continue:', updateError);
                                // Continue processing even if one update fails
                            }

                            if (state.status === 'complete' || state.status === 'error') {
                                console.log('[SSE] Stream ending, status:', state.status);
                                return state;
                            }
                        } catch (error) {
                            console.error('[SSE] Error parsing SSE data:', error);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Stream error:', error);
            throw error;
        }
    }

    window.module["api.js"] = {
        getState,
        sendMessage
    };
})();

|~|~|~|~|~|~|~|~|~|~|~|

FILE: src/frontend-ui/diff.js
|~|~|~|~|~|~|~|~|~|~|~|
(function() {
    const { createDOMNode } = window.module["vdom.js"];

    function diff(oldVNode, newVNode) {
        const patches = [];

        if (!oldVNode && !newVNode) {
            return patches;
        }

        if (!oldVNode && newVNode) {
            patches.push({ type: 'CREATE', vnode: newVNode });
            return patches;
        }

        if (oldVNode && !newVNode) {
            patches.push({ type: 'REMOVE' });
            return patches;
        }

        if (oldVNode.type === 'text' && newVNode.type === 'text') {
            if (oldVNode.content !== newVNode.content) {
                patches.push({ type: 'TEXT', content: newVNode.content });
            }
            return patches;
        }

        if (oldVNode.type === 'text' || newVNode.type === 'text' || oldVNode.tag !== newVNode.tag) {
            patches.push({ type: 'REPLACE', vnode: newVNode });
            return patches;
        }

        const propPatches = diffProps(oldVNode.props, newVNode.props);
        if (propPatches.length > 0) {
            patches.push({ type: 'PROPS', patches: propPatches });
        }

        const childPatches = diffChildren(oldVNode.children, newVNode.children);
        if (childPatches.length > 0) {
            patches.push({ type: 'CHILDREN', patches: childPatches });
        }

        return patches;
    }

    function diffProps(oldProps = {}, newProps = {}) {
        const patches = [];

        const allKeys = new Set([...Object.keys(oldProps), ...Object.keys(newProps)]);

        allKeys.forEach(key => {
            if (key.startsWith('on')) {
                return;
            }

            if (!(key in newProps)) {
                patches.push({ type: 'REMOVE_PROP', key });
            } else if (!(key in oldProps) || oldProps[key] !== newProps[key]) {
                patches.push({ type: 'SET_PROP', key, value: newProps[key] });
            }
        });

        return patches;
    }

    function diffChildren(oldChildren = [], newChildren = []) {
        const patches = [];
        const maxLength = Math.max(oldChildren.length, newChildren.length);

        for (let i = 0; i < maxLength; i++) {
            patches[i] = diff(oldChildren[i], newChildren[i]);
        }

        return patches;
    }

    function patch(parent, patches, index = 0) {
        if (!patches || patches.length === 0) {
            return;
        }

        // Safety check: ensure parent exists
        if (!parent) {
            console.warn('[VDOM] patch called with undefined parent, index:', index);
            return;
        }

        const el = parent.childNodes[index];

        patches.forEach(p => {
            switch (p.type) {
                case 'CREATE':
                    parent.appendChild(createDOMNode(p.vnode));
                    break;

                case 'REMOVE':
                    if (el && el.parentNode) {
                        el.parentNode.removeChild(el);
                    }
                    break;

                case 'REPLACE':
                    if (el && el.parentNode) {
                        el.parentNode.replaceChild(createDOMNode(p.vnode), el);
                    }
                    break;

                case 'TEXT':
                    if (el) {
                        el.textContent = p.content;
                    }
                    break;

                case 'PROPS':
                    if (el) {
                        patchProps(el, p.patches);
                    }
                    break;

                case 'CHILDREN':
                    if (el) {
                        patchChildren(el, p.patches);
                    }
                    break;
            }
        });
    }

    function patchProps(el, propPatches) {
        propPatches.forEach(p => {
            if (p.type === 'REMOVE_PROP') {
                if (p.key === 'className') {
                    el.className = '';
                } else {
                    el.removeAttribute(p.key);
                }
            } else if (p.type === 'SET_PROP') {
                if (p.key === 'className') {
                    el.className = p.value;
                } else {
                    el.setAttribute(p.key, p.value);
                }
            }
        });
    }

    function patchChildren(parent, childPatches) {
        childPatches.forEach((patches, i) => {
            patch(parent, patches, i);
        });
    }

    window.module["diff.js"] = {
        diff,
        patch
    };
})();

|~|~|~|~|~|~|~|~|~|~|~|

FILE: src/frontend-ui/index.html
|~|~|~|~|~|~|~|~|~|~|~|
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Boss</title>
    <link rel="stylesheet" href="/styles.css?v=20">
</head>
<body>
    <div id="app">
        <div id="chat-container"></div>
        <div id="input-container">
            <textarea id="message-input" placeholder="Type your message..." autocomplete="off" rows="1"></textarea>
        </div>
    </div>

    <script>window.module = {};</script>
    <script src="/vdom.js"></script>
    <script src="/diff.js"></script>
    <script src="/render.js"></script>
    <script src="/api.js"></script>
    <script src="/main.js"></script>
    <script>window.module["main.js"].start();</script>
</body>
</html>

|~|~|~|~|~|~|~|~|~|~|~|

FILE: src/frontend-ui/main.js
|~|~|~|~|~|~|~|~|~|~|~|
(function() {
    const { render } = window.module["render.js"];
    const { diff, patch } = window.module["diff.js"];
    const { getState, sendMessage } = window.module["api.js"];
    const { createDOMNode } = window.module["vdom.js"];

    let currentVDOM = null;
    let currentState = null;
    let isProcessing = false;

    const chatContainer = document.getElementById('chat-container');
    const messageInput = document.getElementById('message-input');
    let scrollButton = null;

    // Track scroll state for button visibility
    let lastMessageCountAtBottom = 0;
    let mouseNearBottom = false;

    function updateUI(newState) {
        currentState = newState;
        const newVDOM = render(newState);

        if (!currentVDOM) {
            const domNode = createDOMNode(newVDOM);
            chatContainer.innerHTML = '';
            chatContainer.appendChild(domNode);
            currentVDOM = newVDOM;
        } else {
            // Detect if we have fewer messages than before (out-of-order update)
            const oldMessageCount = currentState && currentState.messages ? currentState.messages.length : 0;
            const newMessageCount = newState.messages ? newState.messages.length : 0;

            if (newMessageCount < oldMessageCount) {
                console.warn('[VDOM] Detected out-of-order update (', oldMessageCount, '->', newMessageCount, '), doing full re-render');
                // Do a full re-render instead of patching
                const domNode = createDOMNode(newVDOM);
                chatContainer.innerHTML = '';
                chatContainer.appendChild(domNode);
                currentVDOM = newVDOM;
            } else {
                // Normal incremental update
                const patches = diff(currentVDOM, newVDOM);
                patch(chatContainer, patches, 0);
                currentVDOM = newVDOM;
            }
        }

        handleScroll();

        if (newState.status === 'complete' || newState.status === 'error' || newState.status === 'awaiting_approval') {
            isProcessing = false;
            messageInput.disabled = false;
            messageInput.focus();
        }
    }

    function isNearBottom() {
        const threshold = 40;
        return chatContainer.scrollHeight - chatContainer.scrollTop - chatContainer.clientHeight < threshold;
    }

    function handleScroll() {
        if (isNearBottom()) {
            scrollToBottom();
            // Update last message count when user reaches bottom
            if (currentState && currentState.messages) {
                lastMessageCountAtBottom = currentState.messages.length;
            }
            updateScrollButtonVisibility();
        } else {
            updateScrollButtonVisibility();
        }
    }

    function hasNewMessagesSinceBottom() {
        if (!currentState || !currentState.messages) return false;
        return currentState.messages.length > lastMessageCountAtBottom;
    }

    function updateScrollButtonVisibility() {
        if (isNearBottom()) {
            hideScrollButton();
        } else {
            // Show button if there are new messages, or if mouse is near bottom
            if (hasNewMessagesSinceBottom() || mouseNearBottom) {
                showScrollButton();
            } else {
                hideScrollButton();
            }
        }
    }

    function scrollToBottom() {
        requestAnimationFrame(() => {
            chatContainer.scrollTo({
                top: chatContainer.scrollHeight,
                behavior: 'smooth'
            });
        });
    }

    function createScrollButton() {
        scrollButton = document.createElement('div');
        scrollButton.id = 'scroll-to-bottom';
        scrollButton.innerHTML = '↓';
        scrollButton.style.display = 'none';
        scrollButton.addEventListener('click', scrollToBottom);
        document.body.appendChild(scrollButton);
    }

    function showScrollButton() {
        if (scrollButton) {
            scrollButton.style.display = 'flex';
        }
    }

    function hideScrollButton() {
        if (scrollButton) {
            scrollButton.style.display = 'none';
        }
    }

    function autoResize() {
        messageInput.style.height = 'auto';
        const newHeight = Math.min(messageInput.scrollHeight, parseFloat(getComputedStyle(messageInput).maxHeight));
        messageInput.style.height = newHeight + 'px';

        if (messageInput.scrollHeight > newHeight) {
            messageInput.style.overflowY = 'auto';
        } else {
            messageInput.style.overflowY = 'hidden';
        }
    }

    function handleSubmit(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            if (isProcessing) return;

            const message = messageInput.value.trim();
            if (!message) return;

            console.log('[UI] Submitting message:', message);

            messageInput.value = '';
            messageInput.style.height = 'auto';
            messageInput.disabled = true;
            isProcessing = true;

            sendMessage(message, updateUI).catch(error => {
                console.error('[UI] Error sending message:', error);
                isProcessing = false;
                messageInput.disabled = false;
                messageInput.focus();
            });
        }
    }

    async function start() {
        console.log('Code Boss UI Version: 2025-10-11-v20');
        console.log('Code Boss starting...');

        createScrollButton();

        // Focus input when clicking anywhere in the input container
        const inputContainer = document.getElementById('input-container');
        inputContainer.addEventListener('click', (e) => {
            if (e.target === inputContainer) {
                messageInput.focus();
            }
        });

        // Track mouse position to show button near bottom
        document.addEventListener('mousemove', (e) => {
            const buttonY = window.innerHeight - 100; // Approximate button position
            const inputContainerTop = inputContainer.getBoundingClientRect().top;

            // Mouse is near bottom if it's below buttonY or over input container
            mouseNearBottom = e.clientY >= buttonY || e.clientY >= inputContainerTop;

            // Update button visibility when mouse moves
            if (!isNearBottom()) {
                updateScrollButtonVisibility();
            }
        });

        messageInput.addEventListener('keydown', handleSubmit);
        messageInput.addEventListener('input', autoResize);
        chatContainer.addEventListener('scroll', handleScroll);

        try {
            const initialState = await getState();
            updateUI(initialState);
            // Scroll to bottom after loading initial conversation
            if (initialState.messages && initialState.messages.length > 0) {
                scrollToBottom();
                lastMessageCountAtBottom = initialState.messages.length;
            }
        } catch (error) {
            console.error('Failed to load initial state:', error);
            updateUI({
                status: 'error',
                messages: [],
                error: 'Failed to connect to server'
            });
        }

        messageInput.focus();
    }

    function refreshRender() {
        if (currentState) {
            updateUI(currentState);
        }
    }

    window.module["main.js"] = {
        start,
        refreshRender
    };
})();

|~|~|~|~|~|~|~|~|~|~|~|

FILE: src/frontend-ui/render.js
|~|~|~|~|~|~|~|~|~|~|~|
(function() {
    const { h, text } = window.module["vdom.js"];

    function render(state) {
        if (!state || !state.messages) {
            return h('div', { className: 'chat-history' }, []);
        }

        const messageNodes = state.messages
            .map((msg, index) => renderMessage(msg, state.messages, index, state))
            .filter(node => node !== null);

        // Add loading indicator if backend is processing (not waiting for user input)
        const shouldShowLoading = state.status === 'processing';
        if (shouldShowLoading) {
            messageNodes.push(renderLoading());
        }

        return h('div', { className: 'chat-history' }, messageNodes);
    }

    function renderMessage(msg, allMessages, index, state) {
        switch (msg.type) {
            case 'user_msg':
                return renderUserMessage(msg);
            case 'assistant_msg':
                return renderAssistantMessage(msg);
            case 'tool_use':
                return renderToolUse(msg, allMessages, index, state);
            case 'tool_result':
                return renderToolResult(msg, allMessages, index, state);
            case 'error':
                return renderError(msg);
            case 'mode_transition':
                return renderModeTransition(msg);
            case 'command_result':
                return renderCommandResult(msg);
            default:
                return null;
        }
    }

    function renderUserMessage(msg) {
        const content = msg.content.replace(/\\n/g, '\n');
        return h('div', { className: 'message user-message' }, [
            h('div', { className: 'message-prefix' }, text('> ')),
            h('div', { className: 'message-content' }, text(content))
        ]);
    }

    function renderAssistantMessage(msg) {
        const content = parseAssistantContent(msg.content);
        return h('div', { className: 'message assistant-message' }, content);
    }

    function parseAssistantContent(content) {
        if (!content) return [text('')];

        const lines = content.split('\n');
        const elements = [];
        let inChecklist = false;
        let checklistTitle = '';
        let checklistItems = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            if (line.match(/^\*\*Plan:/)) {
                inChecklist = true;
                checklistTitle = line.replace(/^\*\*/, '').replace(/\*\*$/, '');
                checklistItems = [];
                continue;
            }

            if (inChecklist) {
                const checkboxMatch = line.match(/^(\[[ ✓✗x]\])\s+(.+)$/);
                if (checkboxMatch) {
                    const status = checkboxMatch[1];
                    const itemContent = checkboxMatch[2];
                    checklistItems.push({ status, content: itemContent });
                    continue;
                } else if (line.trim() === '' || !line.match(/^\[/)) {
                    if (checklistItems.length > 0) {
                        elements.push(renderChecklist(checklistTitle, checklistItems));
                        checklistTitle = '';
                        checklistItems = [];
                    }
                    inChecklist = false;
                }
            }

            if (!inChecklist) {
                if (line.startsWith('| ')) {
                    elements.push(h('div', { className: 'system-line' }, [
                        h('span', { className: 'pipe-prefix' }, text('| ')),
                        text(line.substring(2))
                    ]));
                } else if (line.match(/^\[\d+\/\d+\]\s*→/)) {
                    elements.push(h('div', { className: 'progress-line' }, text(line)));
                } else if (line.match(/^\[✓\]/)) {
                    elements.push(h('div', { className: 'completion-line' }, text(line)));
                } else {
                    elements.push(h('div', { className: 'text-line' }, text(line)));
                }
            }
        }

        if (inChecklist && checklistItems.length > 0) {
            elements.push(renderChecklist(checklistTitle, checklistItems));
        }

        return elements;
    }

    function renderChecklist(title, items) {
        return h('div', { className: 'checklist' }, [
            h('div', { className: 'checklist-title' }, text(title)),
            ...items.map(item => {
                const statusClass = item.status === '[✓]' ? 'completed' :
                                   item.status === '[✗]' ? 'skipped' : 'pending';
                return h('div', { className: `checklist-item ${statusClass}` }, [
                    h('span', { className: 'checkbox' }, text(item.status + ' ')),
                    text(item.content)
                ]);
            })
        ]);
    }

    function renderToolUse(msg, allMessages, index, state) {
        // Hide manage_checklist tool use when action is 'add' during planning
        if (msg.toolName === 'manage_checklist' && msg.parameters && msg.parameters.action === 'add' && state.mode === 'planning') {
            return null;
        }

        // Hide begin_execution, mark_complete, review_pass, and review_fail tool use
        if (msg.toolName === 'begin_execution' ||
            msg.toolName === 'mark_complete' ||
            msg.toolName === 'review_pass' ||
            msg.toolName === 'review_fail') {
            return null;
        }

        const params = formatParams(msg.parameters);

        // Look ahead to find the next tool_result or error to determine bullet status
        let bulletClass = 'tool-bullet-pending'; // default: flashing gray
        for (let i = index + 1; i < allMessages.length; i++) {
            const nextMsg = allMessages[i];
            if (nextMsg.type === 'tool_result' || nextMsg.type === 'error') {
                // Check if it's an error: either type='error' or result contains 'error' field
                const hasError = nextMsg.type === 'error' ||
                                (nextMsg.result && nextMsg.result.error);
                if (hasError) {
                    bulletClass = 'tool-bullet-error'; // red
                } else {
                    bulletClass = 'tool-bullet-success'; // green
                }
                break;
            }
            // Stop looking if we hit another tool_use or assistant message
            if (nextMsg.type === 'tool_use' || nextMsg.type === 'assistant_msg') {
                break;
            }
        }

        // Special rendering for create_file, update_file, and update_file_batch with chevron instead of bullet
        if (msg.toolName === 'create_file' || msg.toolName === 'update_file' || msg.toolName === 'update_file_batch') {
            // Check if result has error or if there are enough lines to show chevron
            let hasError = false;
            let shouldShowChevron = false;

            // Look ahead to check for errors and line count
            for (let i = index + 1; i < allMessages.length; i++) {
                const nextMsg = allMessages[i];
                if (nextMsg.type === 'tool_result' && nextMsg.tool_use_id === msg.id) {
                    hasError = nextMsg.result && nextMsg.result.error;

                    // Calculate line count for this tool
                    if (!hasError && msg.parameters) {
                        let lineCount = 0;
                        if (msg.toolName === 'create_file' && msg.parameters.content) {
                            lineCount = msg.parameters.content.split('\n').length;
                        } else if (msg.toolName === 'update_file') {
                            const oldContent = msg.parameters.old_content || '';
                            const newContent = msg.parameters.new_content || '';
                            const diffLines = computeLineDiff(oldContent, newContent);
                            lineCount = diffLines.filter(line => line.type !== 'unchanged').length;
                        } else if (msg.toolName === 'update_file_batch' && msg.parameters.updates) {
                            try {
                                const updates = JSON.parse(msg.parameters.updates || '[]');
                                updates.forEach(update => {
                                    const oldContent = update.old_content || '';
                                    const newContent = update.new_content || '';
                                    const diffLines = computeLineDiff(oldContent, newContent);
                                    lineCount += diffLines.filter(line => line.type !== 'unchanged').length;
                                });
                            } catch (e) {
                                // JSON parse error, don't show chevron
                            }
                        }
                        shouldShowChevron = lineCount > 10;
                    }
                    break;
                }
                // Stop looking if we hit another tool_use
                if (nextMsg.type === 'tool_use') {
                    break;
                }
            }

            // Display name overrides
            let displayName;
            if (msg.toolName === 'update_file_batch') {
                displayName = 'MULTI_EDIT_FILE';
            } else if (msg.toolName === 'update_file') {
                displayName = 'EDIT_FILE';
            } else {
                displayName = msg.toolName.toUpperCase();
            }

            // Only show chevron if no error and > 10 lines
            if (shouldShowChevron) {
                const showFullContent = expandedFiles[msg.id] === true;
                const chevron = showFullContent ? '▼' : '▶';

                return h('div', { className: 'message tool-message' }, [
                    h('div', {
                        className: 'message-prefix file-chevron ' + bulletClass,
                        onclick: () => {
                            expandedFiles[msg.id] = !expandedFiles[msg.id];
                            window.module["main.js"].refreshRender();
                        }
                    }, text(chevron + ' ')),
                    h('div', {
                        className: 'tool-header clickable-header',
                        onclick: () => {
                            expandedFiles[msg.id] = !expandedFiles[msg.id];
                            window.module["main.js"].refreshRender();
                        }
                    }, [
                        text('[' + displayName + ']'),
                        params ? text(' ' + params) : null
                    ])
                ]);
            } else {
                // Show regular bullet without chevron
                return h('div', { className: 'message tool-message' }, [
                    h('div', { className: 'message-prefix ' + bulletClass }, text('• ')),
                    h('div', { className: 'tool-header' }, [
                        text('[' + displayName + ']'),
                        params ? text(' ' + params) : null
                    ])
                ]);
            }
        }

        return h('div', { className: 'message tool-message' }, [
            h('div', { className: 'message-prefix ' + bulletClass }, text('• ')),
            h('div', { className: 'tool-header' }, [
                text('[' + msg.toolName.toUpperCase() + ']'),
                params ? text(' ' + params) : null
            ])
        ]);
    }

    function renderToolResult(msg, allMessages, index, state) {
        // Hide manage_checklist result when action is 'add' during planning
        if (msg.toolName === 'manage_checklist' && msg.result && msg.result.action === 'add' && state.mode === 'planning') {
            return null;
        }

        // Custom rendering for begin_execution with pending approval
        if (msg.toolName === 'begin_execution' && msg.result && msg.result.status === 'pending_approval') {
            return renderPlanApproval(msg.result);
        }

        // Hide begin_execution result when auto-approved
        if (msg.toolName === 'begin_execution' && msg.result && msg.result.status === 'auto_approved') {
            return null;
        }

        // Hide review_pass and review_fail tool results (we show custom bars instead)
        if (msg.toolName === 'review_pass' || msg.toolName === 'review_fail') {
            return null;
        }

        // Custom rendering for begin_execution
        if (msg.toolName === 'begin_execution' && msg.result && msg.result.checklist) {
            return renderBeginExecutionChecklist(msg.result.checklist);
        }

        // Custom rendering for task_start
        if (msg.toolName === 'task_start' && msg.result) {
            return renderTaskStart(msg.result);
        }

        // Custom rendering for review_start
        if (msg.toolName === 'review_start' && msg.result) {
            return renderReviewStart(msg.result);
        }

        // Custom rendering for review_end
        if (msg.toolName === 'review_end' && msg.result) {
            return renderReviewEnd(msg.result);
        }

        // Custom rendering for mark_complete
        if (msg.toolName === 'mark_complete' && msg.result) {
            return renderMarkComplete(msg.result);
        }

        // Custom rendering for create_file and update_file - show actual content
        if ((msg.toolName === 'create_file' || msg.toolName === 'update_file') && msg.result && !msg.result.error) {
            const toolUseMsg = findToolUseMessage(allMessages, msg.tool_use_id);
            if (toolUseMsg && toolUseMsg.parameters) {
                // Always show content (either preview or full)
                const showFullContent = expandedFiles[msg.tool_use_id] === true;
                return renderFileContent(msg.toolName, toolUseMsg.parameters, msg.tool_use_id, showFullContent);
            }
        }

        // Custom rendering for update_file_batch - show all diffs with separators
        if (msg.toolName === 'update_file_batch' && msg.result && !msg.result.error) {
            const toolUseMsg = findToolUseMessage(allMessages, msg.tool_use_id);
            if (toolUseMsg && toolUseMsg.parameters) {
                const showFullContent = expandedFiles[msg.tool_use_id] === true;
                return renderBatchFileContent(toolUseMsg.parameters, msg.result, msg.tool_use_id, showFullContent);
            }
        }

        const resultLines = formatToolResult(msg.toolName, msg.result);
        return h('div', { className: 'message tool-result' },
            resultLines.map(line => {
                const className = line.startsWith('  +') ? 'diff-add' :
                                line.startsWith('  -') ? 'diff-remove' :
                                line.startsWith('  ✓') ? 'success' :
                                line.startsWith('  ❌') ? 'error' : 'result-line';
                return h('div', { className }, text(line));
            })
        );
    }

    function renderError(msg) {
        const lines = [];
        if (msg.result && msg.result.error) {
            lines.push(h('div', { className: 'error' }, text('  ❌ ' + msg.result.error)));
            if (msg.result.hint) {
                lines.push(h('div', { className: 'error-hint' }, text('     ' + msg.result.hint)));
            }
            if (msg.result.attempt && msg.result.max_attempts) {
                lines.push(h('div', { className: 'error-hint' },
                    text('     Attempt ' + msg.result.attempt + ' of ' + msg.result.max_attempts)));
            }
        }
        return h('div', { className: 'message error-message' }, lines);
    }

    function formatParams(params) {
        if (!params) return '';
        if (params.file_path) return params.file_path;
        if (params.directory_path) return params.directory_path;
        return '';
    }

    function formatToolResult(toolName, result) {
        if (!result) return ['  No result'];

        if (result.error) {
            return ['  ❌ Error: ' + result.error];
        }

        const lines = [];

        switch (toolName) {
            case 'formatting_error':
                if (result.error) {
                    lines.push('  ❌ ' + result.error);
                    if (result.hint) {
                        lines.push('     ' + result.hint);
                    }
                    if (result.attempt && result.max_attempts) {
                        lines.push('     Attempt ' + result.attempt + ' of ' + result.max_attempts);
                    }
                }
                break;

            case 'read_file':
                if (result.lines !== undefined) {
                    lines.push('  Read ' + result.lines + ' lines');
                }
                break;

            case 'list_files':
                if (result.count !== undefined) {
                    lines.push('  Listed ' + result.count + ' items');
                }
                break;

            case 'create_file':
                if (result.created) {
                    lines.push('  ✓ Created ' + result.file_path);
                }
                break;

            case 'update_file':
                if (result.updated) {
                    lines.push('  ✓ Updated ' + result.file_path);
                }
                if (result.diff) {
                    lines.push(...formatDiff(result.diff));
                }
                break;

            case 'delete_file':
                if (result.deleted) {
                    lines.push('  ✓ Deleted ' + result.file_path);
                }
                break;

            case 'manage_checklist':
                if (result.action === 'add') {
                    lines.push('  ✓ Added item: ' + result.id);
                } else if (result.action === 'list') {
                    lines.push('  ' + result.count + ' items');
                }
                break;

            default:
                if (result.success !== undefined) {
                    lines.push(result.success ? '  ✓ Success' : '  ❌ Failed');
                } else {
                    lines.push('  Completed');
                }
        }

        return lines.length > 0 ? lines : ['  Completed'];
    }

    function formatDiff(diff) {
        if (typeof diff === 'string') {
            return diff.split('\n').map(line => '  ' + line);
        }
        return ['  (diff)'];
    }

    function renderLoading() {
        return h('div', { className: 'message loading-message' }, [
            h('div', { className: 'loading-bubble' }, [
                h('span', { className: 'loading-dot' }),
                h('span', { className: 'loading-dot' }),
                h('span', { className: 'loading-dot' })
            ])
        ]);
    }

    function renderModeTransition(msg) {
        // Hide mode transitions in the UI
        return null;
    }

    function renderPlanApproval(result) {
        const elements = [];

        // Plan box with lined paper style
        const planBoxElements = [];

        // Plan header
        planBoxElements.push(
            h('div', { className: 'plan-header' }, text('Plan'))
        );

        // Plan description
        if (result.description) {
            planBoxElements.push(
                h('div', { className: 'plan-description' },
                    text(result.description)
                )
            );
        }

        // Checklist preview
        if (result.checklist_preview && result.checklist_preview.length > 0) {
            const checklistItems = result.checklist_preview.map(item =>
                h('div', { className: 'plan-checklist-item' }, [
                    h('span', { className: 'plan-checkbox' }, text('☐ ')),
                    h('span', { className: 'plan-item-content' }, text(item.content))
                ])
            );

            planBoxElements.push(
                h('div', { className: 'plan-checklist' }, checklistItems)
            );
        }

        elements.push(
            h('div', { className: 'plan-box' }, planBoxElements)
        );

        // Approval message (question from AI) below the box in terminal style
        if (result.approval_message) {
            elements.push(
                h('div', { className: 'approval-question' },
                    text(result.approval_message)
                )
            );
        }

        return h('div', { className: 'message plan-approval-message' }, elements);
    }

    function renderBeginExecutionChecklist(checklist) {
        if (!checklist || checklist.length === 0) {
            return null;
        }

        return h('div', { className: 'message begin-execution-checklist' },
            checklist.map(item => {
                const checkbox = item.completed ? '[\u2713]' : '[ ]';
                return h('div', { className: 'execution-checklist-item' }, [
                    h('span', { className: 'execution-checkbox' }, text(checkbox + ' ')),
                    text(item.content)
                ]);
            })
        );
    }

    function renderMarkComplete(result) {
        const elements = [];

        // Task completion notification with strikethrough
        if (result.content) {
            elements.push(
                h('div', { className: 'task-complete-notification' }, [
                    h('span', { className: 'task-complete-icon' }, text('✓')),
                    h('span', { className: 'task-complete-content' }, text(result.content))
                ])
            );
        }

        // Next task start notification
        if (result.next_task && result.total_items && result.completed_count) {
            const nextTaskNum = result.completed_count + 1;
            const progressText = nextTaskNum + '/' + result.total_items + ': ' + result.next_task.content;
            elements.push(
                h('div', { className: 'task-start-notification' }, [
                    h('span', { className: 'task-start-icon' }, text('→')),
                    h('span', { className: 'task-start-content' }, text(progressText))
                ])
            );
        }

        return h('div', { className: 'message mark-complete-message' }, elements);
    }

    // Helper function to find tool_use message by tool_use_id
    function findToolUseMessage(allMessages, toolUseId) {
        return allMessages.find(m => m.type === 'tool_use' && m.id === toolUseId);
    }

    // Simple line-by-line diff algorithm
    function computeLineDiff(oldText, newText) {
        const oldLines = oldText.split('\n');
        const newLines = newText.split('\n');
        const result = [];

        // Simple LCS-based diff
        const lcs = computeLCS(oldLines, newLines);
        let oldIndex = 0;
        let newIndex = 0;
        let lcsIndex = 0;

        while (oldIndex < oldLines.length || newIndex < newLines.length) {
            if (lcsIndex < lcs.length &&
                oldIndex < oldLines.length &&
                newIndex < newLines.length &&
                oldLines[oldIndex] === lcs[lcsIndex] &&
                newLines[newIndex] === lcs[lcsIndex]) {
                // Line unchanged
                result.push({
                    type: 'unchanged',
                    content: oldLines[oldIndex],
                    oldLineNum: oldIndex + 1,
                    newLineNum: newIndex + 1
                });
                oldIndex++;
                newIndex++;
                lcsIndex++;
            } else if (oldIndex < oldLines.length &&
                       (lcsIndex >= lcs.length || oldLines[oldIndex] !== lcs[lcsIndex])) {
                // Line removed
                result.push({
                    type: 'removed',
                    content: oldLines[oldIndex],
                    oldLineNum: oldIndex + 1
                });
                oldIndex++;
            } else if (newIndex < newLines.length) {
                // Line added
                result.push({
                    type: 'added',
                    content: newLines[newIndex],
                    newLineNum: newIndex + 1
                });
                newIndex++;
            }
        }

        return result;
    }

    // Compute longest common subsequence for diff
    function computeLCS(arr1, arr2) {
        const m = arr1.length;
        const n = arr2.length;
        const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                if (arr1[i - 1] === arr2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        // Backtrack to find LCS
        const lcs = [];
        let i = m;
        let j = n;
        while (i > 0 && j > 0) {
            if (arr1[i - 1] === arr2[j - 1]) {
                lcs.unshift(arr1[i - 1]);
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }

        return lcs;
    }

    // Track expanded state for file contents (keyed by tool_use_id)
    const expandedFiles = {};

    // Render file content for create_file and update_file
    function renderFileContent(toolName, parameters, toolUseId, showFullContent) {
        const maxLines = 10;

        if (toolName === 'create_file') {
            // Show each line with green "+" prefix like a diff
            const content = parameters.content || '';
            const lines = content.split('\n');

            // Show preview (10 lines) or full content based on state
            const linesToShow = showFullContent ? lines : lines.slice(0, maxLines);

            const lineElements = linesToShow.map((line, index) => {
                const lineNum = (index + 1).toString().padStart(3, ' ');
                return h('div', { className: 'diff-line diff-add' }, [
                    h('span', { className: 'diff-line-number' }, text(lineNum)),
                    h('span', { className: 'diff-line-content' }, text(' + ' + line))
                ]);
            });

            return h('div', { className: 'message tool-result file-content-result' }, lineElements);
        } else if (toolName === 'update_file') {
            // Show line-by-line diff with + for additions and - for removals
            const oldContent = parameters.old_content || '';
            const newContent = parameters.new_content || '';

            const diffLines = computeLineDiff(oldContent, newContent);
            const visibleLines = diffLines.filter(line => line.type !== 'unchanged');

            // Show preview (10 lines) or full content based on state
            const linesToShow = showFullContent ? visibleLines : visibleLines.slice(0, maxLines);

            const lineElements = linesToShow.map((line) => {
                // Use actual line numbers from the file
                const lineNum = line.type === 'added' ?
                    line.newLineNum.toString().padStart(3, ' ') :
                    line.oldLineNum.toString().padStart(3, ' ');
                const className = line.type === 'added' ? 'diff-line diff-add' : 'diff-line diff-remove';
                const prefix = line.type === 'added' ? ' + ' : ' - ';

                return h('div', { className }, [
                    h('span', { className: 'diff-line-number' }, text(lineNum)),
                    h('span', { className: 'diff-line-content' }, text(prefix + line.content))
                ]);
            });

            return h('div', { className: 'message tool-result file-content-result' }, lineElements);
        }

        return null;
    }

    // Render batch file updates with blank line separators between diffs
    function renderBatchFileContent(parameters, result, toolUseId, showFullContent) {
        const maxLines = 10;
        const updates = JSON.parse(parameters.updates || '[]');

        // Get updates_detail from result if available (includes line numbers)
        const updatesDetail = result && result.updates_detail ? result.updates_detail : [];

        if (!updates || updates.length === 0) {
            return h('div', { className: 'message tool-result' }, [text('  No updates')]);
        }

        const allElements = [];

        updates.forEach((update, updateIndex) => {
            const oldContent = update.old_content || '';
            const newContent = update.new_content || '';

            // Get the start line from updates_detail if available
            const startLine = updatesDetail[updateIndex] ? updatesDetail[updateIndex].start_line : 1;

            const diffLines = computeLineDiff(oldContent, newContent);
            const visibleLines = diffLines.filter(line => line.type !== 'unchanged');

            // Show preview (10 lines) or full content based on state
            const linesToShow = showFullContent ? visibleLines : visibleLines.slice(0, maxLines);

            const lineElements = linesToShow.map((line) => {
                // Calculate actual file line number using the start line from Java
                let lineNum;
                if (line.type === 'added') {
                    // For added lines, calculate from start line + offset in new content
                    lineNum = startLine + line.newLineNum - 1;
                } else {
                    // For removed lines, use start line + offset in old content
                    lineNum = startLine + line.oldLineNum - 1;
                }

                const className = line.type === 'added' ? 'diff-line diff-add' : 'diff-line diff-remove';
                const prefix = line.type === 'added' ? ' + ' : ' - ';

                return h('div', { className }, [
                    h('span', { className: 'diff-line-number' }, text(lineNum.toString().padStart(3, ' '))),
                    h('span', { className: 'diff-line-content' }, text(prefix + line.content))
                ]);
            });

            // Add all line elements for this update
            allElements.push(...lineElements);

            // Add 2 blank lines between updates (but not after the last one)
            if (updateIndex < updates.length - 1) {
                allElements.push(h('div', { className: 'batch-separator' }));
                allElements.push(h('div', { className: 'batch-separator' }));
            }
        });

        return h('div', { className: 'message tool-result file-content-result' }, allElements);
    }

    function renderTaskStart(result) {
        if (!result.content || !result.task_number || !result.total_items) {
            return null;
        }

        const progressText = result.task_number + '/' + result.total_items + ': ' + result.content;
        return h('div', { className: 'message task-start-message' }, [
            h('div', { className: 'task-start-notification' }, [
                h('span', { className: 'task-start-icon' }, text('→')),
                h('span', { className: 'task-start-content' }, text(progressText))
            ])
        ]);
    }

    function renderReviewStart(result) {
        const message = result.message || 'Code review checkpoint';
        return h('div', { className: 'message review-start-message' }, [
            h('div', { className: 'review-start-notification' }, [
                h('span', { className: 'review-start-icon' }, text('→')),
                h('span', { className: 'review-start-content' }, text(message))
            ])
        ]);
    }

    function renderReviewEnd(result) {
        const verdict = result.verdict || 'PASS';
        const message = verdict === 'PASS' ? 'Review passed' : 'Review failed';
        return h('div', { className: 'message review-end-message' }, [
            h('div', { className: 'review-end-notification' }, [
                h('span', { className: 'review-end-icon' }, text('✓')),
                h('span', { className: 'review-end-content' }, text(message))
            ])
        ]);
    }

    function getModeDisplayText(mode) {
        const modeMap = {
            'planning': 'Planning...',
            'execution': 'Coding...',
            'testing': 'Testing...',
            'review': 'Reviewing...'
        };
        return modeMap[mode] || mode;
    }

    function renderCommandResult(msg) {
        // This message type is never displayed - it only exists to trigger clipboard copy
        // The clipboard data is in msg.result.clipboard_data
        // Copy to clipboard when this message is encountered
        if (msg.result && msg.result.clipboard_data) {
            navigator.clipboard.writeText(msg.result.clipboard_data).then(() => {
                console.log('[UI] Command result: Copied ' + msg.result.clipboard_data.length + ' characters to clipboard');
            }).catch(err => {
                console.error('[UI] Command result: Failed to copy to clipboard:', err);
            });
        }
        // Return null so this message is not displayed in the UI
        return null;
    }

    window.module["render.js"] = {
        render
    };
})();

|~|~|~|~|~|~|~|~|~|~|~|

FILE: src/frontend-ui/styles.css
|~|~|~|~|~|~|~|~|~|~|~|
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --bg-tertiary: #3a3a3a;
    --text-primary: #e0e0e0;
    --text-secondary: #a0a0a0;
    --text-muted: #707070;
    --border-color: #404040;
    --success: #4ade80;
    --error: #f87171;
    --warning: #fbbf24;
    --info: #60a5fa;
    --user-msg: #3b82f6;
    --assistant-msg: #e0e0e0;
}

body {
    font-family: 'Consolas', 'Courier New', monospace;
    background: var(--bg-primary);
    color: var(--text-primary);
    line-height: 1.6;
    height: 100vh;
    overflow: hidden;
}

#app {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

#chat-container {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    padding-bottom: 80px;
}

#chat-container::-webkit-scrollbar {
    width: 8px;
}

#chat-container::-webkit-scrollbar-track {
    background: var(--bg-secondary);
}

#chat-container::-webkit-scrollbar-thumb {
    background: var(--bg-tertiary);
    border-radius: 4px;
}

#chat-container::-webkit-scrollbar-thumb:hover {
    background: var(--border-color);
}

.chat-history {
    max-width: 1200px;
    margin: 0 auto;
}

.message {
    margin-bottom: 16px;
    animation: fadeIn 0.2s ease-in;
}

.tool-message {
    margin-bottom: 0;
}

.tool-result {
    margin-top: 0;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.user-message {
    display: flex;
    gap: 0;
    color: var(--text-muted);
}

.user-message .message-prefix {
    width: 2ch;
    color: var(--text-muted);
    flex-shrink: 0;
}

.user-message .message-content {
    flex: 1;
    color: var(--text-muted);
    white-space: pre-wrap;
}

.assistant-message {
    color: #d4a017;
    padding-left: 2ch;
    position: relative;
    background-image: linear-gradient(to right, transparent 0px, transparent calc(1ch - 5px), #d4a017 calc(1ch - 5px), #d4a017 calc(1ch - 4px), transparent calc(1ch - 4px));
    background-repeat: repeat-y;
    background-position: left top;
}

.system-line {
    display: flex;
    gap: 8px;
    color: var(--text-secondary);
    margin: 4px 0;
}

.pipe-prefix {
    color: var(--text-muted);
}

.text-line {
    margin: 4px 0;
}

.tool-message {
    margin-top: 12px;
    display: flex;
    gap: 0;
}

.tool-message .message-prefix {
    width: 2ch;
    color: var(--text-muted);
    flex-shrink: 0;
    padding-bottom: 1px;
}

.tool-bullet-success {
    color: var(--success) !important;
}

.tool-bullet-error {
    color: var(--error) !important;
}

.tool-bullet-pending {
    color: #888 !important;
    animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% {
        opacity: 0.4;
    }
    50% {
        opacity: 1;
    }
}

.tool-content {
    flex: 1;
}

.tool-header {
    color: var(--text-muted);
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 0.9em;
    word-break: break-word;
}

.tool-result {
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 0.9em;
    margin-left: 2ch;
}

.result-line {
    color: var(--success);
    margin: 2px 0;
}

.file-content-result {
    margin-left: 2ch;
}

.file-content {
    color: var(--text-primary);
    margin: 0;
    padding: 0;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 0.9em;
    white-space: pre;
    overflow-x: auto;
    line-height: 1.4;
}

.diff-line {
    margin: 0;
    padding: 0;
    white-space: pre;
    font-family: 'Consolas', 'Courier New', monospace;
    display: flex;
    line-height: 1.4;
}

.diff-line-number {
    color: var(--text-muted);
    user-select: none;
    flex-shrink: 0;
    text-align: right;
    min-width: 3ch;
    padding-right: 1ch;
    border-right: 1px solid var(--border-color);
    margin-right: 1ch;
}

.diff-line-content {
    flex: 1;
    white-space: pre;
}

.diff-add {
    color: var(--success);
}

.diff-add .diff-line-content {
    color: var(--success);
}

.diff-remove {
    color: var(--error);
}

.diff-remove .diff-line-content {
    color: var(--error);
}

.batch-separator {
    height: 1.4em;
}

.show-more-link {
    color: var(--info);
    cursor: pointer;
    text-decoration: underline;
    font-weight: 500;
}

.show-more-link:hover {
    color: var(--text-primary);
}

.file-chevron {
    cursor: pointer;
    user-select: none;
    font-size: 0.75em;
}

.clickable-header {
    cursor: pointer;
    user-select: none;
}

.clickable-header:hover {
    opacity: 0.8;
}

.success {
    color: var(--success);
}

.error {
    color: var(--error);
}

.error-message {
    margin-top: 12px;
}

.error-hint {
    color: var(--text-secondary);
    font-size: 0.9em;
}

.checklist {
    margin: 12px 0;
    padding: 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
    border-left: 3px solid var(--info);
}

.checklist-title {
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-primary);
}

.checklist-item {
    margin: 6px 0;
    padding: 4px 0;
    display: flex;
    gap: 8px;
    align-items: flex-start;
}

.checklist-item.completed .checkbox {
    color: var(--success);
}

.checklist-item.pending .checkbox {
    color: var(--text-muted);
}

.checklist-item.skipped .checkbox {
    color: var(--text-muted);
}

.checkbox {
    font-family: 'Courier New', monospace;
}

.progress-line {
    color: var(--info);
    font-weight: 500;
    margin: 8px 0;
}

.completion-line {
    color: var(--success);
    font-weight: 500;
    margin: 8px 0;
}

.loading-message {
    display: flex;
    align-items: center;
    min-height: 40px;
}

.loading-bubble {
    display: flex;
    gap: 6px;
    padding: 12px 16px;
    background: var(--bg-secondary);
    border-radius: 18px;
}

.loading-dot {
    width: 8px;
    height: 8px;
    background: var(--text-muted);
    border-radius: 50%;
    animation: bounce 1.4s infinite ease-in-out both;
}

.loading-dot:nth-child(1) {
    animation-delay: -0.32s;
}

.loading-dot:nth-child(2) {
    animation-delay: -0.16s;
}

@keyframes bounce {
    0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
    }
    40% {
        transform: scale(1);
        opacity: 1;
    }
}

.mode-transition {
    color: var(--text-muted);
    font-style: italic;
    margin: 12px 0;
}

.begin-execution-checklist {
    margin: 12px 0;
    padding-left: 0;
}

.execution-checklist-item {
    color: #60a5fa;
    margin: 4px 0;
    display: flex;
    gap: 8px;
}

.execution-checkbox {
    font-family: 'Courier New', monospace;
    color: #60a5fa;
}

.mark-complete-message {
    margin: 12px 0;
    padding-left: 0;
}

.mark-complete-message .completion-line,
.mark-complete-message .progress-line {
    color: #60a5fa;
    margin: 4px 0;
}

.plan-approval-message {
    margin: 20px 0;
}

/* Clean plan box design */
.plan-box {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-left: 4px solid var(--info);
    border-radius: 6px;
    padding: 16px 20px;
    margin-bottom: 16px;
}

.plan-header {
    font-size: 1em;
    font-weight: 600;
    color: var(--info);
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.plan-description {
    color: var(--text-primary);
    margin-bottom: 16px;
    line-height: 1.6;
}

.plan-checklist {
    margin: 0;
}

.plan-checklist-item {
    display: flex;
    gap: 10px;
    margin: 6px 0;
    line-height: 1.6;
    align-items: flex-start;
}

.plan-checkbox {
    color: var(--info);
    font-family: 'Courier New', monospace;
    font-size: 1em;
    flex-shrink: 0;
    opacity: 0.7;
}

.plan-item-content {
    color: var(--text-secondary);
    flex: 1;
}

/* Approval question - simple terminal style */
.approval-question {
    color: var(--info);
    font-weight: 500;
    margin-top: 12px;
    padding-left: 2ch;
}

/* Task start notification - subtle background highlight */
.task-start-notification {
    margin: 12px 0;
    padding: 12px 16px;
    background: rgba(96, 165, 250, 0.15);
    border-left: 4px solid var(--info);
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 12px;
}

.task-start-icon {
    color: var(--info);
    font-size: 1.2em;
    font-weight: bold;
}

.task-start-content {
    color: var(--text-primary);
    flex: 1;
}

/* Task completion notification - checkmark and strikethrough */
.task-complete-notification {
    margin: 12px 0;
    padding: 12px 16px;
    background: rgba(74, 222, 128, 0.1);
    border-left: 4px solid var(--success);
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 12px;
}

.task-complete-icon {
    color: var(--success);
    font-size: 1.2em;
    font-weight: bold;
}

.task-complete-content {
    color: var(--text-secondary);
    flex: 1;
    text-decoration: line-through;
}

/* Review start notification - gold/amber background */
.review-start-notification {
    margin: 12px 0;
    padding: 12px 16px;
    background: rgba(251, 191, 36, 0.15);
    border-left: 4px solid #d97706;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 12px;
}

.review-start-icon {
    color: #d97706;
    font-size: 1.2em;
    font-weight: bold;
}

.review-start-content {
    color: var(--text-primary);
    flex: 1;
}

/* Review end notification - gold/amber styling with checkmark */
.review-end-notification {
    margin: 12px 0;
    padding: 12px 16px;
    background: rgba(251, 191, 36, 0.1);
    border-left: 4px solid #d97706;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 12px;
}

.review-end-icon {
    color: #d97706;
    font-size: 1.2em;
    font-weight: bold;
}

.review-end-content {
    color: var(--text-secondary);
    flex: 1;
}

#input-container {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--bg-tertiary);
    border-top: 1px solid var(--border-color);
    padding: 16px 16px 16px calc(12px + 2.5ch);
    box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.3);
}

#input-container::before {
    content: '> ';
    position: absolute;
    left: calc(12px + 0.5ch);
    top: 16px;
    color: white;
    pointer-events: none;
    z-index: 1;
}

#message-input {
    width: 100%;
    max-width: none;
    margin: 0;
    display: block;
    padding: 0;
    background: transparent;
    border: none;
    color: var(--text-primary);
    font-size: 16px;
    font-family: inherit;
    outline: none;
    box-sizing: border-box;
    resize: none;
    overflow-y: hidden;
    line-height: 1.6;
    max-height: calc(1.6em * 6);
}

#message-input:focus {
    outline: none;
}

#message-input::placeholder {
    color: var(--text-muted);
}

#message-input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

#scroll-to-bottom {
    position: fixed;
    bottom: calc(32px + 1.6em + 10px); /* input container padding (16px + 16px) + line height + 10px gap */
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 1000;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

#scroll-to-bottom:hover {
    background: var(--border-color);
    transform: translateX(-50%) scale(1.1);
}

|~|~|~|~|~|~|~|~|~|~|~|

FILE: src/frontend-ui/vdom.js
|~|~|~|~|~|~|~|~|~|~|~|
(function() {
    function h(tag, props, ...children) {
        return {
            tag,
            props: props || {},
            children: children.flat().filter(child => child != null)
        };
    }

    function text(content) {
        return {
            type: 'text',
            content: String(content)
        };
    }

    function createDOMNode(vnode) {
        if (!vnode) return null;

        if (vnode.type === 'text') {
            return document.createTextNode(vnode.content);
        }

        const el = document.createElement(vnode.tag);

        if (vnode.props) {
            Object.keys(vnode.props).forEach(key => {
                if (key === 'className') {
                    el.className = vnode.props[key];
                } else if (key.startsWith('on')) {
                    const eventName = key.substring(2).toLowerCase();
                    el.addEventListener(eventName, vnode.props[key]);
                } else {
                    el.setAttribute(key, vnode.props[key]);
                }
            });
        }

        if (vnode.children) {
            vnode.children.forEach(child => {
                const childNode = createDOMNode(child);
                if (childNode) {
                    el.appendChild(childNode);
                }
            });
        }

        return el;
    }

    window.module["vdom.js"] = {
        h,
        text,
        createDOMNode
    };
})();

|~|~|~|~|~|~|~|~|~|~|~|

FILE: src/browser/bridge-button.js
|~|~|~|~|~|~|~|~|~|~|~|
// Claude Bridge Script - Button Interface with Clipboard Protocol

/* DEV_MOCK_PLACEHOLDER */

(function() {
    'use strict';
    
    // Init
    
    // State management
    let currentState = 'listening'; // 'listening' or 'response'
    let isProcessing = false;
    let currentResponse = '';
    
    // Protocol constants
    const TO_BRIDGE_MARKER = '|||||CLIP:TO_BRIDGE|||||';
    const TO_JAVA_MARKER = '|||||CLIP:TO_JAVA|||||';
    
    // Remove any existing bridge UI
    const existingBridge = document.getElementById('claude-bridge-ui');
    if (existingBridge) {
        existingBridge.remove();
    }
    
    // Create main UI container
    const bridgeUI = document.createElement('div');
    bridgeUI.id = 'claude-bridge-ui';
    bridgeUI.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 999999;
        background: rgba(0, 0, 0, 0.9);
        border: 3px solid #4CAF50;
        border-radius: 20px;
        padding: 40px;
        text-align: center;
        font-family: Arial, sans-serif;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        user-select: none;
    `;
    
    // Create main button
    const mainButton = document.createElement('button');
    mainButton.id = 'bridge-main-button';
    mainButton.style.cssText = `
        width: 300px;
        height: 150px;
        background: linear-gradient(45deg, #4CAF50, #45a049);
        color: white;
        border: none;
        border-radius: 15px;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        margin-bottom: 20px;
    `;
    
    // Create status text
    const statusText = document.createElement('div');
    statusText.id = 'bridge-status';
    statusText.style.cssText = `
        color: #4CAF50;
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 15px;
    `;
    
    // Create info text
    const infoText = document.createElement('div');
    infoText.id = 'bridge-info';
    infoText.style.cssText = `
        color: #ccc;
        font-size: 14px;
        max-width: 400px;
        line-height: 1.4;
    `;
    
    // Create close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'X';
    closeButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 15px;
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
    `;
    
    closeButton.addEventListener('click', () => {
        bridgeUI.remove();
    });
    
    closeButton.addEventListener('mouseenter', () => {
        closeButton.style.background = 'rgba(255, 255, 255, 0.1)';
    });
    
    closeButton.addEventListener('mouseleave', () => {
        closeButton.style.background = 'none';
    });
    
    // Add hover effects to main button
    mainButton.addEventListener('mouseenter', () => {
        if (!isProcessing) {
            mainButton.style.transform = 'scale(1.05)';
            mainButton.style.boxShadow = '0 8px 25px rgba(76, 175, 80, 0.4)';
        }
    });
    
    mainButton.addEventListener('mouseleave', () => {
        if (!isProcessing) {
            mainButton.style.transform = 'scale(1)';
            mainButton.style.boxShadow = '0 5px 15px rgba(76, 175, 80, 0.3)';
        }
    });
    
    // Main button click handler
    mainButton.addEventListener('click', async () => {
        console.log('[BRIDGE] Button clicked - state:', currentState, 'isProcessing:', isProcessing);

        if (isProcessing) {
            console.log('[BRIDGE] Ignoring click - already processing');
            return;
        }

        if (currentState === 'listening') {
            console.log('[BRIDGE] Handling listening click');
            await handleListeningClick();
        } else if (currentState === 'response') {
            console.log('[BRIDGE] Handling response click');
            await handleResponseClick();
        }
    });
    
    // Handle click in listening mode
    async function handleListeningClick() {
        console.log('[BRIDGE] handleListeningClick called');
        try {
            console.log('[BRIDGE] Reading clipboard...');
            const clipboardText = await navigator.clipboard.readText();
            console.log('[BRIDGE] Clipboard read - length:', clipboardText ? clipboardText.length : 0);
            console.log('[BRIDGE] Clipboard preview (first 200 chars):', clipboardText ? clipboardText.substring(0, 200) : 'null');
            console.log('[BRIDGE] Clipboard ends with TO_BRIDGE_MARKER:', clipboardText ? clipboardText.endsWith(TO_BRIDGE_MARKER) : false);

            if (!clipboardText.endsWith(TO_BRIDGE_MARKER)) {
                console.log('[BRIDGE] No valid TO_BRIDGE marker found');
                updateUI('listening', 'No valid request found in clipboard');
                return;
            }

            console.log('[BRIDGE] Valid TO_BRIDGE marker found, parsing JSON...');
            const jsonText = clipboardText.slice(0, -TO_BRIDGE_MARKER.length);
            let request;
            try {
                request = JSON.parse(jsonText);
                console.log('[BRIDGE] JSON parsed successfully:', request);
                if (!request.messages || !Array.isArray(request.messages)) {
                    throw new Error('Invalid request format');
                }
            } catch (e) {
                console.error('[BRIDGE] JSON parse error:', e);
                updateUI('listening', 'Invalid JSON in clipboard');
                return;
            }

            isProcessing = true;
            updateUI('processing', 'Processing request...');
            console.log('[BRIDGE] Starting to process request...');

            const token = getAuthToken();
            if (!token) {
                console.error('[BRIDGE] No auth token found in localStorage');
                updateUI('listening', 'No auth token found');
                isProcessing = false;
                return;
            }
            console.log('[BRIDGE] Auth token found, submitting to API...');

            const response = await submitToInternalAPIWithContinuation(request.messages, token);
            console.log('[BRIDGE] API response received - length:', response.length);

            if (response === 'TOKEN_LIMIT_EXCEEDED') {
                console.log('[BRIDGE] Token limit exceeded detected');
                currentResponse = response;
                currentState = 'response';
                isProcessing = false;
                updateUI('response', 'Token limit detected - click to copy');
            } else {
                console.log('[BRIDGE] Normal response received, ready to copy');
                currentResponse = response;
                currentState = 'response';
                isProcessing = false;
                updateUI('response', 'Response ready - click to copy');
            }

        } catch (error) {
            console.error('[BRIDGE] Error in handleListeningClick:', error);
            updateUI('listening', `Error: ${error.message}`);
            isProcessing = false;
        }
    }
    
    // Handle click in response mode
    async function handleResponseClick() {
        console.log('[BRIDGE] handleResponseClick called');
        try {
            const responseWithMarker = currentResponse + TO_JAVA_MARKER;
            console.log('[BRIDGE] Writing response to clipboard - length:', responseWithMarker.length);
            await navigator.clipboard.writeText(responseWithMarker);
            console.log('[BRIDGE] Response successfully copied to clipboard with TO_JAVA marker');
            currentState = 'listening';
            currentResponse = '';
            updateUI('listening', 'Response copied - ready for next request');
        } catch (error) {
            console.error('[BRIDGE] Error copying response to clipboard:', error);
            updateUI('response', `Copy failed: ${error.message}`);
        }
    }
    
    // Get auth token from localStorage
    function getAuthToken() {
        return localStorage.getItem('token');
    }
    
    // Submit to internal API with automatic continuation handling
    async function submitToInternalAPIWithContinuation(messages, token) {
        let fullResponse = '';
        let conversationMessages = [...messages];
        let attemptCount = 0;
        const maxAttempts = 10;

        while (attemptCount < maxAttempts) {
            attemptCount++;
            const response = await submitToInternalAPI(conversationMessages, token);

            if (response.trim() === '') {
                return 'TOKEN_LIMIT_EXCEEDED';
            }

            fullResponse += response;
            const hasEnd = fullResponse.endsWith('|||||END|||||');

            if (hasEnd) {
                return fullResponse.slice(0, -13);
            }

            // Prepare continuation request
            const lastChars = fullResponse.slice(-30);
            const continuationContent = `Your previous response was cut off. The last 30 characters were: "${lastChars}". Start writing immediately after these exact characters. We will append your response to the previous output. End with |||||END||||| when complete.`;

            conversationMessages.push({
                role: 'assistant',
                content: response
            });
            conversationMessages.push({
                role: 'user',
                content: continuationContent
            });
        }

        return fullResponse;
    }
    
    // Submit to internal API (original implementation)
    async function submitToInternalAPI(messages, token) {
        const timestamp = Date.now();
        const userMessageId = 'msg-' + timestamp + '-user';
        const assistantMessageId = 'msg-' + timestamp + '-assistant';
        const sessionId = 'session-' + Math.random().toString(36).substr(2, 9);
        const apiBase = window.location.origin;

        // Fire /new in background
        fetch(`${apiBase}/api/v1/chats/new`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                chat: {
                    id: '',
                    title: 'Chat Pending',
                    models: ['Anthropic Claude 4 Sonnet'],
                    params: {},
                    history: {
                        messages: {
                            [userMessageId]: {
                                id: userMessageId,
                                parentId: null,
                                childrenIds: [],
                                role: 'user',
                                content: messages.length > 0 ? messages[messages.length - 1].content : '',
                                timestamp: Math.floor(timestamp / 1000),
                                models: ['Anthropic Claude 4 Sonnet']
                            }
                        },
                        currentId: userMessageId
                    },
                    messages: [
                        {
                            id: userMessageId,
                            role: 'user',
                            content: messages.length > 0 ? messages[messages.length - 1].content : '',
                            timestamp: Math.floor(timestamp / 1000),
                            models: ['Anthropic Claude 4 Sonnet']
                        }
                    ],
                    files: []
                }
            })
        }).catch(err => {});

        const completionsResponse = await fetch(`${apiBase}/api/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                stream: true,
                model: 'Anthropic Claude 4 Sonnet',
                messages: messages,
                params: {},
                features: {
                    web_search: false
                },
                session_id: sessionId,
                id: assistantMessageId,
                background_tasks: {
                    title_generation: true,
                    tags_generation: true
                }
            })
        });

        if (!completionsResponse.ok) {
            throw new Error(`Completions failed: ${completionsResponse.status}`);
        }

        const reader = completionsResponse.body.getReader();
        const decoder = new TextDecoder();
        let finalContent = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    if (data === '[DONE]') {
                        return finalContent;
                    }

                    try {
                        const parsed = JSON.parse(data);
                        if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                            finalContent += parsed.choices[0].delta.content;
                        }
                    } catch (e) {
                        // Ignore parsing errors
                    }
                }
            }
        }

        return finalContent;
    }
    
    // Update UI based on state
    function updateUI(state, statusMessage) {
        if (state === 'listening') {
            mainButton.textContent = 'LISTENING';
            mainButton.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            statusText.textContent = 'READY TO RECEIVE';
            infoText.textContent = statusMessage || 'Waiting for request with |||||TO BRIDGE||||| marker';
        } else if (state === 'processing') {
            mainButton.textContent = 'PROCESSING...';
            mainButton.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';
            statusText.textContent = 'WORKING...';
            infoText.textContent = statusMessage || 'Calling /completions (fire-and-forget /new)...';
        } else if (state === 'response') {
            mainButton.textContent = 'CLICK TO COPY';
            mainButton.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
            statusText.textContent = 'RESPONSE READY';
            infoText.textContent = statusMessage || 'Click to copy response with |||||TO JAVA||||| marker';
        }
        
        // Update button colors
        if (state === 'listening') {
            statusText.style.color = '#4CAF50';
        } else if (state === 'processing') {
            statusText.style.color = '#FF9800';
        } else if (state === 'response') {
            statusText.style.color = '#2196F3';
        }
    }
    
    // Assemble UI
    bridgeUI.appendChild(closeButton);
    bridgeUI.appendChild(statusText);
    bridgeUI.appendChild(mainButton);
    bridgeUI.appendChild(infoText);
    
    // Add to page
    document.body.appendChild(bridgeUI);
    
    // Initialize UI
    updateUI('listening', 'Bridge ready - paste requests ending with |||||TO BRIDGE|||||');
    console.log('[BRIDGE] Bridge button UI initialized and ready');
    console.log('[BRIDGE] TO_BRIDGE_MARKER:', TO_BRIDGE_MARKER);
    console.log('[BRIDGE] TO_JAVA_MARKER:', TO_JAVA_MARKER);

    // Keepalive mechanism - send simple request every 5 minutes to keep session alive
    let keepaliveInterval = setInterval(async () => {
        try {
            const token = getAuthToken();
            if (!token) return;

            const keepaliveMessages = [{
                role: 'user',
                content: 'reply "k"'
            }];

            await submitToInternalAPI(keepaliveMessages, token);
        } catch (error) {
            // Silent fail
        }
    }, 5 * 60 * 1000);
    
})();
|~|~|~|~|~|~|~|~|~|~|~|

