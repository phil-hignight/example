FILE: BridgeScript.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;

public class BridgeScript {
    
    // Embedded bridge-button.js content
    private static String BRIDGE_JS_CONTENT = null;
    
    public static String getBridgeJS() {
        if (BRIDGE_JS_CONTENT == null) {
            loadBridgeJS();
        }
        return BRIDGE_JS_CONTENT;
    }
    
    private static void loadBridgeJS() {
        try {
            // Try to read from external file first
            Path jsFile = Paths.get("bridge-button.js");
            if (Files.exists(jsFile)) {
                BRIDGE_JS_CONTENT = new String(Files.readAllBytes(jsFile));
                return;
            }
            
            // Fallback to reading from embedded resource or bundle
            InputStream is = BridgeScript.class.getResourceAsStream("/bridge-button.js");
            if (is != null) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
                StringBuilder content = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    content.append(line).append("\n");
                }
                reader.close();
                BRIDGE_JS_CONTENT = content.toString();
                return;
            }
            
            // Final fallback - hardcoded content
            BRIDGE_JS_CONTENT = getHardcodedBridgeJS();
            
        } catch (Exception e) {
            // If all else fails, use hardcoded version
            BRIDGE_JS_CONTENT = getHardcodedBridgeJS();
        }
    }
    
    private static String getHardcodedBridgeJS() {
        return "// Claude Bridge Script - Button Interface with Clipboard Protocol\\n" +
               "(function() {\\n" +
               "    'use strict';\\n" +
               "    console.log('[Button Bridge] Script not found, using minimal version');\\n" +
               "    alert('Bridge script loaded from fallback');\\n" +
               "})();";
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: ClipboardManager.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.util.Scanner;

public class ClipboardManager {
    private static Scanner scanner = new Scanner(System.in);
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    public static void copyToClipboard(String text) {
        try {
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            StringSelection selection = new StringSelection(text);
            clipboard.setContents(selection, null);
            log("Text copied to clipboard: " + text.length() + " characters");
        } catch (Exception e) {
            log("Error copying to clipboard: " + e.getMessage());
            System.err.println("Error copying to clipboard: " + e.getMessage());
        }
    }
    
    public static String getClipboardContent() {
        try {
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            Transferable contents = clipboard.getContents(null);
            
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                return (String) contents.getTransferData(DataFlavor.stringFlavor);
            }
        } catch (Exception e) {
            log("Error reading from clipboard: " + e.getMessage());
        }
        return null;
    }
    
    public static String getResponseFromClipboard(String originalPrompt) {
        while (true) {
            try {
                String input = scanner.nextLine().trim();
                
                if (input.equalsIgnoreCase("quit")) {
                    log("Quit requested from clipboard loop");
                    return "QUIT_REQUESTED";
                }
                
                if (input.equalsIgnoreCase("c")) {
                    copyToClipboard(originalPrompt);
                    log("Prompt re-copied to clipboard");
                    System.out.println(DisplayManager.ANSI_LIGHT_BLUE + "~{ Prompt re-copied to clipboard }~" + DisplayManager.ANSI_RESET);
                    continue;
                }
                
                String clipboardContent = getClipboardContent();
                log("Clipboard read: " + (clipboardContent != null ? clipboardContent.length() : 0) + " characters");
                
                // CRITICAL: Log details about what was actually read from clipboard
                if (clipboardContent != null) {
                    if (clipboardContent.trim().isEmpty()) {
                        log("CRITICAL: Clipboard contains only whitespace: '" + clipboardContent + "'");
                    } else if (clipboardContent.length() < 10) {
                        log("WARNING: Very short clipboard content: '" + clipboardContent + "'");
                    } else {
                        log("Clipboard first 100 chars: " + clipboardContent.substring(0, Math.min(100, clipboardContent.length())));
                        log("Clipboard last 50 chars: " + clipboardContent.substring(Math.max(0, clipboardContent.length() - 50)));
                    }
                } else {
                    log("CRITICAL: Clipboard content is NULL");
                }
                
                if (clipboardContent == null || clipboardContent.trim().isEmpty()) {
                    System.out.println(DisplayManager.ANSI_RED + "Clipboard is empty. Please copy Claude's response and try again." + DisplayManager.ANSI_RESET);
                    System.out.print(DisplayManager.ANSI_WHITE + "Press Enter when response is copied (or 'c' to copy prompt again): " + DisplayManager.ANSI_RESET);
                    continue;
                }
                
                // Check if clipboard still contains the original prompt (user hasn't pasted response yet)
                if (clipboardContent.trim().equals(originalPrompt.trim())) {
                    System.out.println(DisplayManager.ANSI_RED + "Clipboard still contains the original prompt. Please copy Claude's response." + DisplayManager.ANSI_RESET);
                    System.out.print(DisplayManager.ANSI_WHITE + "Press Enter when response is copied (or 'c' to copy prompt again): " + DisplayManager.ANSI_RESET);
                    continue;
                }
                
                return clipboardContent;
                
            } catch (Exception e) {
                log("Error in clipboard interaction: " + e.getMessage());
                System.out.println(DisplayManager.ANSI_RED + "Error reading clipboard. Please try again." + DisplayManager.ANSI_RESET);
                System.out.print(DisplayManager.ANSI_WHITE + "Press Enter to retry: " + DisplayManager.ANSI_RESET);
            }
        }
    }
    
    public static void clickAtCoordinates(int x, int y) {
        try {
            Robot robot = new Robot();
            robot.mouseMove(x, y);
            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
            log("Clicked at coordinates: " + x + ", " + y);
        } catch (Exception e) {
            log("Error clicking at coordinates: " + e.getMessage());
        }
    }
    
    public static void moveMouseTo(int x, int y) {
        try {
            Robot robot = new Robot();
            robot.mouseMove(x, y);
            log("Mouse moved to coordinates: " + x + ", " + y);
        } catch (Exception e) {
            log("Error moving mouse to coordinates: " + e.getMessage());
            throw new RuntimeException("Failed to move mouse: " + e.getMessage());
        }
    }
    
    public static String waitForAutomaticResponse(int clickX, int clickY) {
        log("Starting automatic response polling");
        
        while (true) {
            try {
                // Move mouse to coordinates and click
                clickAtCoordinates(clickX, clickY);
                
                // Check clipboard for response with terminator
                String clipboardContent = getClipboardContent();
                if (clipboardContent != null && clipboardContent.endsWith("|||||TO JAVA|||||")) {
                    // Remove terminator and return response
                    String response = clipboardContent.substring(0, clipboardContent.length() - "|||||TO JAVA|||||".length());
                    log("Received automatic response: " + response.length() + " characters");
                    
                    // CRITICAL: Log details about empty or problematic responses
                    if (response.trim().isEmpty()) {
                        log("CRITICAL: Received EMPTY response from Claude!");
                        log("CRITICAL: Full clipboard content was: '" + clipboardContent + "'");
                        log("CRITICAL: Response after terminator removal: '" + response + "'");
                        log("CRITICAL: Returning null to trigger retry or user intervention");
                        return null; // Treat empty responses as no response
                    } else if (response.length() < 10) {
                        log("WARNING: Received very short response: '" + response + "'");
                        log("WARNING: Short response content: '" + response + "'");
                        log("WARNING: Returning null to trigger retry or user intervention");
                        return null; // Treat very short responses as problematic
                    } else {
                        log("Response first 100 chars: " + response.substring(0, Math.min(100, response.length())));
                        log("Response last 50 chars: " + response.substring(Math.max(0, response.length() - 50)));
                    }
                    
                    return response;
                }
                
                // Sleep for 1 second, but check mouse position during this time
                Thread.sleep(1000);
                
                // After waiting, check if mouse moved outside the allowed area
                Point currentMousePos = MouseInfo.getPointerInfo().getLocation();
                int deltaX = Math.abs(currentMousePos.x - clickX);
                int deltaY = Math.abs(currentMousePos.y - clickY);
                
                if (deltaX > 300 || deltaY > 300) {
                    log("Mouse moved outside 300px square from click position - canceling auto-clicking");
                    return "MOUSE_CANCELLED";
                }
                
            } catch (InterruptedException e) {
                log("Automatic polling interrupted: " + e.getMessage());
                Thread.currentThread().interrupt();
                return null;
            } catch (Exception e) {
                log("Error in automatic polling: " + e.getMessage());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    return null;
                }
            }
        }
    }
    
    public static String handleAutoCancelRetry(String originalPrompt, int clickX, int clickY) {
        System.out.println(DisplayManager.ANSI_RED + "Auto-clicking cancelled (mouse moved too far)" + DisplayManager.ANSI_RESET);
        System.out.println(DisplayManager.ANSI_GOLD + "Press 'r' to retry auto-clicking or 'a' to abort: " + DisplayManager.ANSI_RESET);
        
        while (true) {
            try {
                String input = scanner.nextLine().trim().toLowerCase();
                
                if (input.equals("r")) {
                    log("User chose to retry auto-clicking");
                    System.out.println("Retrying auto-clicking...");
                    return waitForAutomaticResponse(clickX, clickY);
                } else if (input.equals("a")) {
                    log("User chose to abort auto-clicking");
                    return null;
                } else {
                    System.out.println(DisplayManager.ANSI_GOLD + "Invalid input. Press 'r' to retry or 'a' to abort: " + DisplayManager.ANSI_RESET);
                }
            } catch (Exception e) {
                log("Error in cancel retry handler: " + e.getMessage());
                return null;
            }
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: ConfigManager.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;

public class ConfigManager {
    private static String getConfigFile() {
        return Paths.get(ConversationCLI.getWorkingDirectory(), ".agent", "config.json").toString();
    }
    
    private int maxMessageChars = 350000; // Default max message chars
    private int wrapWidth = 110; // Default wrap width
    private String mode = "manual"; // Default mode (manual or automatic)
    private int clickX = 500; // Default click X coordinate for automatic mode
    private int clickY = 300; // Default click Y coordinate for automatic mode
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    public void loadConfig() throws IOException {
        Path configPath = Paths.get(getConfigFile());
        if (!Files.exists(configPath)) {
            // Ensure .agent directory exists
            Path agentDir = configPath.getParent();
            if (!Files.exists(agentDir)) {
                Files.createDirectories(agentDir);
            }
            
            // Create default config
            String defaultConfig = "{\"maxMessageChars\": 350000, \"wrapWidth\": 110, \"mode\": \"manual\", \"clickX\": 500, \"clickY\": 300}";
            Files.write(configPath, defaultConfig.getBytes());
            maxMessageChars = 350000;
            wrapWidth = 110;
            mode = "manual";
            clickX = 500;
            clickY = 300;
            log("Created default config file");
        } else {
            try {
                String configContent = new String(Files.readAllBytes(configPath));
                
                // Simple JSON parsing for maxMessageChars
                String maxCharsPattern = "\"maxMessageChars\"\\s*:\\s*(\\d+)";
                java.util.regex.Pattern p1 = java.util.regex.Pattern.compile(maxCharsPattern);
                java.util.regex.Matcher m1 = p1.matcher(configContent);
                if (m1.find()) {
                    maxMessageChars = Integer.parseInt(m1.group(1));
                } else {
                    maxMessageChars = 350000; // fallback
                }
                
                // Simple JSON parsing for wrapWidth
                String wrapPattern = "\"wrapWidth\"\\s*:\\s*(\\d+)";
                java.util.regex.Pattern p2 = java.util.regex.Pattern.compile(wrapPattern);
                java.util.regex.Matcher m2 = p2.matcher(configContent);
                if (m2.find()) {
                    wrapWidth = Integer.parseInt(m2.group(1));
                } else {
                    wrapWidth = 110; // fallback
                }
                
                // Simple JSON parsing for mode
                String modePattern = "\"mode\"\\s*:\\s*\"([^\"]+)\"";
                java.util.regex.Pattern p3 = java.util.regex.Pattern.compile(modePattern);
                java.util.regex.Matcher m3 = p3.matcher(configContent);
                if (m3.find()) {
                    mode = m3.group(1);
                } else {
                    mode = "manual"; // fallback
                }
                
                // Simple JSON parsing for clickX (support negative numbers)
                String clickXPattern = "\"clickX\"\\s*:\\s*(-?\\d+)";
                java.util.regex.Pattern p4 = java.util.regex.Pattern.compile(clickXPattern);
                java.util.regex.Matcher m4 = p4.matcher(configContent);
                if (m4.find()) {
                    clickX = Integer.parseInt(m4.group(1));
                } else {
                    clickX = 500; // fallback
                }
                
                // Simple JSON parsing for clickY (support negative numbers)
                String clickYPattern = "\"clickY\"\\s*:\\s*(-?\\d+)";
                java.util.regex.Pattern p5 = java.util.regex.Pattern.compile(clickYPattern);
                java.util.regex.Matcher m5 = p5.matcher(configContent);
                if (m5.find()) {
                    clickY = Integer.parseInt(m5.group(1));
                } else {
                    clickY = 300; // fallback
                }
                
                log("Loaded config: maxMessageChars = " + maxMessageChars + ", wrapWidth = " + wrapWidth + ", mode = " + mode + ", clickX = " + clickX + ", clickY = " + clickY);
                
                // Validate configuration
                validateConfig(configContent);
                
            } catch (Exception e) {
                log("Error loading config, using defaults: " + e.getMessage());
                maxMessageChars = 350000;
                wrapWidth = 110;
                mode = "manual";
                clickX = 500;
                clickY = 300;
            }
        }
    }
    
    private void validateConfig(String configContent) throws IOException {
        if (isAutomaticMode()) {
            // Check if clickX and clickY are explicitly set in the config
            boolean hasClickX = configContent.contains("\"clickX\"");
            boolean hasClickY = configContent.contains("\"clickY\"");
            
            if (!hasClickX || !hasClickY) {
                String error = "Configuration Error: Automatic mode requires 'clickX' and 'clickY' coordinates to be set in config.json";
                log(error);
                System.err.println(error);
                System.err.println("Example config.json:");
                System.err.println("{");
                System.err.println("  \"maxMessageChars\": 350000,");
                System.err.println("  \"wrapWidth\": 110,");
                System.err.println("  \"mode\": \"automatic\",");
                System.err.println("  \"clickX\": 500,");
                System.err.println("  \"clickY\": 300");
                System.err.println("}");
                throw new IOException("Invalid configuration for automatic mode");
            }
            
            // Validate coordinates are reasonable (allow negative for multi-monitor setups)
            if (clickX < -10000 || clickY < -10000 || clickX > 10000 || clickY > 10000) {
                String error = "Configuration Error: Click coordinates must be between -10000 and 10000. Found clickX=" + clickX + ", clickY=" + clickY;
                log(error);
                System.err.println(error);
                throw new IOException("Invalid click coordinates");
            }
            
            log("Automatic mode validated with coordinates: (" + clickX + ", " + clickY + ")");
        }
    }
    
    public int getMaxMessageChars() {
        return maxMessageChars;
    }
    
    public int getWrapWidth() {
        return wrapWidth;
    }
    
    public void setMaxMessageChars(int maxMessageChars) {
        this.maxMessageChars = maxMessageChars;
    }
    
    public void setWrapWidth(int wrapWidth) {
        this.wrapWidth = wrapWidth;
    }
    
    public String getMode() {
        return mode;
    }
    
    public int getClickX() {
        return clickX;
    }
    
    public int getClickY() {
        return clickY;
    }
    
    public boolean isAutomaticMode() {
        return "automatic".equals(mode);
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: ConversationCLI.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class ConversationCLI {
    public static String getLogFile() {
        return Paths.get(workingDirectory, ".agent", "debug.log").toString();
    }
    
    // Manager instances
    private static ConfigManager configManager;
    private static ConversationManager conversationManager;
    private static DisplayManager displayManager;
    private static SystemTrayManager systemTrayManager;
    private static PromptGenerator promptGenerator;
    private static Renderer renderer;
    private static ToolRenderer toolRenderer;
    
    private static Scanner scanner = new Scanner(System.in);
    private static String workingDirectory = "."; // Default to current directory
    private static java.util.List<ConversationManager.Message> temporaryMessages = new java.util.ArrayList<>();

    public static void main(String[] args) {
        try {
            // Set working directory if provided as command line argument
            if (args.length > 0) {
                workingDirectory = args[0];
                log("Working directory set to: " + workingDirectory);
            } else {
                workingDirectory = System.getProperty("user.dir");
                log("Using current working directory: " + workingDirectory);
            }
            
            initializeManagers();
            initializeFiles();
            log("Application started");
            logDisplayInformation();
            
            systemTrayManager.setupSystemTray();
            conversationManager.loadConversation();
            promptGenerator.captureProjectStructure(workingDirectory);
            
            // Add shutdown hook for tray cleanup
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                systemTrayManager.cleanup();
            }));
            
            runConversationLoop();
        } catch (Exception e) {
            log("Fatal error: " + e.getMessage());
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static void initializeManagers() throws IOException {
        configManager = new ConfigManager();
        conversationManager = new ConversationManager();
        displayManager = new DisplayManager();
        systemTrayManager = new SystemTrayManager();
        promptGenerator = new PromptGenerator();
        renderer = new Renderer();
        toolRenderer = new ToolRenderer(renderer);
        
        // Load configuration
        configManager.loadConfig();
        
        // Configure managers with loaded settings
        conversationManager.setMaxMessageChars(configManager.getMaxMessageChars());
        displayManager.setWrapWidth(configManager.getWrapWidth());
    }

    private static void initializeFiles() throws IOException {
        Path agentDir = Paths.get(workingDirectory, ".agent");
        if (!Files.exists(agentDir)) {
            Files.createDirectories(agentDir);
        }
        
        Path conversationPath = Paths.get(workingDirectory, ".agent", "conversation.txt");
        if (!Files.exists(conversationPath)) {
            Files.createFile(conversationPath);
        }
    }

    private static void runConversationLoop() throws IOException {
        
        // Display initial conversation (only once at startup)
        java.util.List<ConversationManager.Message> allMessages = new java.util.ArrayList<>(conversationManager.getConversation());
        allMessages.addAll(temporaryMessages);
        log("MAIN: Initial display with " + allMessages.size() + " messages (" + conversationManager.getConversation().size() + " from file, " + temporaryMessages.size() + " temporary)");
        
        // Render all conversation messages (only once at startup)
        for (ConversationManager.Message message : allMessages) {
            renderer.append(message);
        }
        
        // Check if last message was user message (incomplete conversation)
        boolean needsPromptCopy = conversationManager.needsPromptCopy();
        
        while (true) {
            try {
                
                if (needsPromptCopy) {
                    renderer.showLoadingIndicator("Last conversation was incomplete. Press Enter to copy prompt to clipboard...");
                    scanner.nextLine();
                    // Loading indicator will be auto-cleared by next renderer call
                    
                    String prompt = promptGenerator.generatePrompt(conversationManager.getConversation(), conversationManager);
                    ClipboardManager.copyToClipboard(prompt);
                    log("Prompt copied to clipboard on restart");
                    systemTrayManager.updateTrayStatus("Prompt copied - waiting for response");
                    
                    renderer.showLoadingIndicator("Prompt copied to clipboard! Press ENTER for response");
                    
                    String response = ClipboardManager.getResponseFromClipboard(prompt);
                    
                    if (response != null && response.equals("QUIT_REQUESTED")) {
                        System.out.println("Goodbye!");
                        cleanup();
                        System.exit(0);
                    } else if (response != null && !response.trim().isEmpty()) {
                        boolean shouldContinue = handleAiResponse(response.trim(), prompt);
                        if (shouldContinue) {
                            needsPromptCopy = false;
                            continue;
                        }
                        systemTrayManager.updateTrayStatus("Ready");
                    } else {
                        systemTrayManager.updateTrayStatus("Ready");
                    }
                    
                    needsPromptCopy = false;
                    continue;
                }
                
                // Show input caret
                renderer.showInputCaret();
                
                String userInput = scanner.nextLine().trim();
                
                if (userInput.isEmpty()) {
                    continue;
                }
                
                if (userInput.equalsIgnoreCase("quit")) {
                    System.out.println("Goodbye!");
                    cleanup();
                    // Force exit if normal exit doesn't work
                    new Thread(() -> {
                        try {
                            Thread.sleep(1000);
                            Runtime.getRuntime().halt(0);
                        } catch (InterruptedException ex) {
                            Runtime.getRuntime().halt(0);
                        }
                    }).start();
                    System.exit(0);
                }
                
                // Add user message to conversation and render it for all inputs (including special commands)
                ConversationManager.Message userMessage = new ConversationManager.Message("user", userInput);
                conversationManager.addMessage(userMessage);
                renderer.append(userMessage);  // Caret auto-cleared when message is appended
                log("User message added: " + userInput.length() + " chars");
                
                // Check for mouseto command
                if (userInput.toLowerCase().startsWith("mouseto ")) {
                    handleMouseToCommand(userInput);
                    continue;
                }
                
                // Check for copyjs command
                if (userInput.toLowerCase().equals("copyjs")) {
                    handleCopyJSCommand();
                    continue;
                }
                
                // Check for mousecapture command
                if (userInput.toLowerCase().equals("mousecapture")) {
                    handleMouseCaptureCommand();
                    continue;
                }
                
                // Clear temporary messages when conversation continues
                clearTemporaryMessages();
                
                String response;
                String lastMessage; // Track what was sent to the AI
                
                if (configManager.isAutomaticMode()) {
                    // Automatic mode: Generate JSON message with terminator
                    String automaticMessage = promptGenerator.generateAutomaticMessage(conversationManager.getConversation(), conversationManager);
                    ClipboardManager.copyToClipboard(automaticMessage);
                    log("Automatic message copied to clipboard");
                    lastMessage = automaticMessage;
                    
                    // Show loading message and wait for automatic response
                    renderer.showLoadingIndicator("Processing...");
                    response = ClipboardManager.waitForAutomaticResponse(configManager.getClickX(), configManager.getClickY());
                    
                    // Handle mouse cancellation with loop until valid response or abort
                    while (response != null && response.equals("MOUSE_CANCELLED")) {
                        response = ClipboardManager.handleAutoCancelRetry(automaticMessage, configManager.getClickX(), configManager.getClickY());
                    }
                } else {
                    // Manual mode: Generate prompt and wait for manual response
                    String prompt = promptGenerator.generatePrompt(conversationManager.getConversation(), conversationManager);
                    ClipboardManager.copyToClipboard(prompt);
                    log("Prompt copied to clipboard");
                    systemTrayManager.updateTrayStatus("Prompt copied - waiting for response");
                    lastMessage = prompt;
                    
                    renderer.showLoadingIndicator("Prompt copied to clipboard! Press ENTER for response");
                    
                    // Read response from clipboard with retry
                    response = ClipboardManager.getResponseFromClipboard(prompt);
                }
                
                if (response == null) {
                    // User aborted or error occurred, continue to next iteration
                    continue;
                }

                if (response.equals("TOKEN_LIMIT_EXCEEDED")) {
                    log("Token limit exceeded, triggering automatic summarization");

                    // Remove the last user message that caused the overflow
                    if (!conversationManager.getConversation().isEmpty()) {
                        try {
                            conversationManager.removeLastMessage();
                            log("Removed last user message that caused overflow");
                        } catch (IOException e) {
                            log("Error removing last message: " + e.getMessage());
                            System.out.println(DisplayManager.ANSI_RED + "Error: Failed to remove message from conversation." + DisplayManager.ANSI_RESET);
                            systemTrayManager.updateTrayStatus("Ready");
                            continue;
                        }
                    }

                    // Perform summarization
                    String summarizationResult;
                    try {
                        summarizationResult = conversationManager.performSummarization(configManager, renderer);
                    } catch (IOException e) {
                        log("Error during summarization: " + e.getMessage());
                        System.out.println(DisplayManager.ANSI_RED + "Error: Summarization failed - " + e.getMessage() + DisplayManager.ANSI_RESET);
                        systemTrayManager.updateTrayStatus("Ready");
                        continue;
                    }

                    if (summarizationResult.equals("TOKEN_LIMIT_EXCEEDED")) {
                        log("Summarization also exceeded token limit - cannot proceed");
                        System.out.println(DisplayManager.ANSI_RED + "Error: Unable to compact conversation - token limit exceeded even during summarization." + DisplayManager.ANSI_RESET);
                        systemTrayManager.updateTrayStatus("Ready");
                        continue;
                    } else if (summarizationResult.equals("NOT_ENOUGH_MESSAGES")) {
                        log("Not enough messages to summarize - conversation too short");
                        System.out.println(DisplayManager.ANSI_RED + "Error: Conversation too short to compact. Try a shorter message." + DisplayManager.ANSI_RESET);
                        systemTrayManager.updateTrayStatus("Ready");
                        continue;
                    } else if (summarizationResult.equals("SUCCESS")) {
                        log("Summarization successful, re-adding user message and retrying");

                        // Re-add the user message
                        ConversationManager.Message retryUserMessage = new ConversationManager.Message("user", userInput);
                        conversationManager.addMessage(retryUserMessage);

                        // Regenerate prompt and retry
                        if (configManager.isAutomaticMode()) {
                            String automaticMessage = promptGenerator.generateAutomaticMessage(conversationManager.getConversation(), conversationManager);
                            ClipboardManager.copyToClipboard(automaticMessage);
                            log("Retrying with compacted conversation (automatic mode)");

                            renderer.showLoadingIndicator("Processing...");
                            response = ClipboardManager.waitForAutomaticResponse(configManager.getClickX(), configManager.getClickY());

                            while (response != null && response.equals("MOUSE_CANCELLED")) {
                                response = ClipboardManager.handleAutoCancelRetry(automaticMessage, configManager.getClickX(), configManager.getClickY());
                            }
                        } else {
                            String prompt = promptGenerator.generatePrompt(conversationManager.getConversation(), conversationManager);
                            ClipboardManager.copyToClipboard(prompt);
                            log("Retrying with compacted conversation (manual mode)");
                            systemTrayManager.updateTrayStatus("Prompt copied - waiting for response");

                            renderer.showLoadingIndicator("Prompt copied to clipboard! Press ENTER for response");
                            response = ClipboardManager.getResponseFromClipboard(prompt);
                        }

                        // Check if retry succeeded
                        if (response == null || response.equals("TOKEN_LIMIT_EXCEEDED")) {
                            log("Retry after summarization still failed");
                            System.out.println(DisplayManager.ANSI_RED + "Error: Still exceeding token limit after summarization." + DisplayManager.ANSI_RESET);
                            systemTrayManager.updateTrayStatus("Ready");
                            continue;
                        }

                        // Fall through to normal response handling
                    }
                }

                if (response.equals("QUIT_REQUESTED")) {
                    System.out.println("Goodbye!");
                    cleanup();
                    System.exit(0);
                } else if (response != null && !response.trim().isEmpty()) {
                    boolean shouldContinue = handleAiResponse(response.trim(), lastMessage);
                    if (shouldContinue) {
                        continue;
                    }
                    systemTrayManager.updateTrayStatus("Ready");
                } else {
                    systemTrayManager.updateTrayStatus("Ready");
                }
                
            } catch (NoSuchElementException e) {
                // Input stream closed - exit gracefully
                System.out.println("\nGoodbye!");
                cleanup();
                System.exit(0);
            } catch (Exception e) {
                log("Error in conversation loop: " + e.getMessage());
                System.out.println(DisplayManager.ANSI_RED + "Error: " + e.getMessage() + DisplayManager.ANSI_RESET);
            }
        }
    }

    private static boolean handleAiResponse(String response, String lastPrompt) throws IOException {
        // Status messages are now auto-cleared by renderer when new content is appended
        
        ProcessedResponse processed = processAiResponse(response);
        
        if (processed.hasToolExecutions) {
            // Store the raw assistant response (XML with <execute>)
            ConversationManager.Message assistantMessage = new ConversationManager.Message("assistant", response.trim());
            conversationManager.addMessage(assistantMessage);
            log("Assistant response stored: " + response.length() + " chars");
            
            // Tool messages are now stored individually during processToolBlock execution
            // (No longer need to store a single system message for all tools)
            
            // Tools were executed, generate next prompt automatically
            log("Tools executed, generating automatic follow-up prompt");
            
            String followUpResponse;
            String lastFollowUpMessage; // Track what was sent to the AI
            
            if (configManager.isAutomaticMode()) {
                // Automatic mode: Generate JSON message with terminator
                String automaticMessage = promptGenerator.generateAutomaticMessage(conversationManager.getConversation(), conversationManager);
                ClipboardManager.copyToClipboard(automaticMessage);
                log("Automatic follow-up message copied to clipboard");
                lastFollowUpMessage = automaticMessage;
                
                // Show loading message and wait for automatic response
                renderer.showLoadingIndicator("Processing follow-up...");
                followUpResponse = ClipboardManager.waitForAutomaticResponse(configManager.getClickX(), configManager.getClickY());
            } else {
                // Manual mode: Generate prompt and wait for manual response
                String nextPrompt = promptGenerator.generatePrompt(conversationManager.getConversation(), conversationManager);
                ClipboardManager.copyToClipboard(nextPrompt);
                log("Automatic follow-up prompt copied to clipboard");
                systemTrayManager.updateTrayStatus("Follow-up prompt copied - waiting for response");
                lastFollowUpMessage = nextPrompt;
                
                renderer.showLoadingIndicator("Follow-up prompt copied to clipboard! Press ENTER for response");
                
                followUpResponse = ClipboardManager.getResponseFromClipboard(nextPrompt);
            }
            
            if (followUpResponse != null && followUpResponse.equals("QUIT_REQUESTED")) {
                System.out.println("Goodbye!");
                cleanup();
                System.exit(0);
            } else if (followUpResponse != null && followUpResponse.equals("TOKEN_LIMIT_EXCEEDED")) {
                log("Token limit exceeded in follow-up, triggering automatic summarization");

                // Perform summarization
                String summarizationResult;
                try {
                    summarizationResult = conversationManager.performSummarization(configManager, renderer);
                } catch (IOException e) {
                    log("Error during summarization in follow-up: " + e.getMessage());
                    System.out.println(DisplayManager.ANSI_RED + "Error: Summarization failed - " + e.getMessage() + DisplayManager.ANSI_RESET);
                    return false;
                }

                if (summarizationResult.equals("TOKEN_LIMIT_EXCEEDED")) {
                    log("Summarization also exceeded token limit during follow-up");
                    System.out.println(DisplayManager.ANSI_RED + "Error: Unable to compact conversation - token limit exceeded even during summarization." + DisplayManager.ANSI_RESET);
                    return false;
                } else if (summarizationResult.equals("NOT_ENOUGH_MESSAGES")) {
                    log("Not enough messages to summarize during follow-up");
                    System.out.println(DisplayManager.ANSI_RED + "Error: Conversation too short to compact." + DisplayManager.ANSI_RESET);
                    return false;
                } else if (summarizationResult.equals("SUCCESS")) {
                    log("Summarization successful during follow-up, retrying");

                    // Retry follow-up after summarization
                    if (configManager.isAutomaticMode()) {
                        String automaticMessage = promptGenerator.generateAutomaticMessage(conversationManager.getConversation(), conversationManager);
                        ClipboardManager.copyToClipboard(automaticMessage);
                        log("Retrying follow-up with compacted conversation (automatic mode)");

                        renderer.showLoadingIndicator("Processing follow-up...");
                        followUpResponse = ClipboardManager.waitForAutomaticResponse(configManager.getClickX(), configManager.getClickY());
                    } else {
                        String nextPrompt = promptGenerator.generatePrompt(conversationManager.getConversation(), conversationManager);
                        ClipboardManager.copyToClipboard(nextPrompt);
                        log("Retrying follow-up with compacted conversation (manual mode)");

                        renderer.showLoadingIndicator("Follow-up prompt copied to clipboard! Press ENTER for response");
                        followUpResponse = ClipboardManager.getResponseFromClipboard(nextPrompt);
                    }

                    // Check if retry succeeded
                    if (followUpResponse == null || followUpResponse.equals("TOKEN_LIMIT_EXCEEDED")) {
                        log("Follow-up retry after summarization still failed");
                        System.out.println(DisplayManager.ANSI_RED + "Error: Still exceeding token limit after summarization." + DisplayManager.ANSI_RESET);
                        return false;
                    }

                    // Fall through to normal handling
                }
            }

            if (followUpResponse != null && !followUpResponse.trim().isEmpty() && !followUpResponse.equals("QUIT_REQUESTED") && !followUpResponse.equals("TOKEN_LIMIT_EXCEEDED")) {
                // Recursively handle follow-up response until no more tools
                handleAiResponse(followUpResponse.trim(), lastFollowUpMessage);
                // Don't return true to continue the main loop, we've handled everything
                return false;
            }
            
            return false;
        } else if (!processed.finalMessage.isEmpty()) {
            // Regular assistant message
            ConversationManager.Message assistantMessage = new ConversationManager.Message("assistant", processed.finalMessage);
            conversationManager.addMessage(assistantMessage);
            renderer.append(assistantMessage);  // Loading indicator auto-cleared when message is appended
            log("Assistant message added: " + processed.finalMessage.length() + " chars");
            
            // Check if summarization is needed
            conversationManager.checkAndSummarizeIfNeeded(lastPrompt, response);
        } else {
            // CRITICAL BUG FIX: Log when no message gets saved at all
            log("CRITICAL: No assistant message saved! hasToolExecutions=" + processed.hasToolExecutions + 
                ", finalMessage.length=" + processed.finalMessage.length() + 
                ", response.length=" + response.length());
            log("CRITICAL: Original response first 200 chars: " + response.substring(0, Math.min(200, response.length())));
            
            // For debugging: save the problematic response anyway
            if (response != null && !response.trim().isEmpty()) {
                ConversationManager.Message debugMessage = new ConversationManager.Message("assistant", response.trim());
                conversationManager.addMessage(debugMessage);
                log("CRITICAL: Saved problematic response as debug message");
            }
        }
        
        return false;
    }
    
    private static ProcessedResponse processAiResponse(String response) {
        ProcessedResponse result = new ProcessedResponse();
        result.hasToolExecutions = false;
        result.toolResults = "";
        result.finalMessage = "";
        
        if (response == null || response.trim().isEmpty()) {
            return result;
        }
        
        try {
            log("RESPONSE: Processing AI response of " + response.length() + " chars");
            log("RESPONSE: First 100 chars: " + response.substring(0, Math.min(100, response.length())));
            log("RESPONSE: Last 50 chars: " + response.substring(Math.max(0, response.length() - 50)));
            
            // Check for truncation indicators
            boolean hasEndMarker = response.contains("|||||END|||||");
            boolean endsAbruptly = !response.trim().endsWith(">") && !response.trim().endsWith("|||||END|||||");
            log("RESPONSE: Has END marker: " + hasEndMarker + ", Ends abruptly: " + endsAbruptly);
            
            if (response.length() == 0) {
                log("RESPONSE: WARNING - Empty response received!");
                return result;
            }
            
            // Check if response contains <execute> or <message> at top level
            String responseContent = response.trim();
            log("RESPONSE: Processing response content directly");
            
            // Look for <execute> blocks
            String executePattern = "<execute>(.*?)</execute>";
            java.util.regex.Pattern execPattern = java.util.regex.Pattern.compile(executePattern, java.util.regex.Pattern.DOTALL);
            java.util.regex.Matcher execMatcher = execPattern.matcher(responseContent);
                
                StringBuilder toolResults = new StringBuilder();
                
                while (execMatcher.find()) {
                    String executeBlock = execMatcher.group(1).trim();
                    log("Processing execute block: " + executeBlock.substring(0, Math.min(100, executeBlock.length())) + "...");
                    String blockResults = processToolBlock(executeBlock);
                    log("Execute block results: " + blockResults.length() + " chars");
                    toolResults.append(blockResults).append("\n");
                    result.hasToolExecutions = true;
                }
                
                result.toolResults = toolResults.toString();
                log("Tool executions found: " + result.hasToolExecutions);
                
            // Look for <message> content
            String messagePattern = "<message>(.*?)</message>";
            java.util.regex.Pattern msgPattern = java.util.regex.Pattern.compile(messagePattern, java.util.regex.Pattern.DOTALL);
            java.util.regex.Matcher msgMatcher = msgPattern.matcher(responseContent);
            
            if (msgMatcher.find()) {
                result.finalMessage = msgMatcher.group(1).trim();
                log("Found final message: " + result.finalMessage.substring(0, Math.min(50, result.finalMessage.length())) + "...");
            } else if (!result.hasToolExecutions) {
                // No tools and no message tags - treat entire response as message
                result.finalMessage = responseContent;
                log("No tools or message tags found, using entire response content");
            } else {
                // Tools executed but no message found - this is expected
                result.finalMessage = "";
                log("Tools executed, no message content (expected)");
            }
            
        } catch (Exception e) {
            log("Error processing AI response: " + e.getMessage());
            result.finalMessage = response.trim();
        }
        
        return result;
    }
    
    private static String processToolBlock(String executeBlock) {
        StringBuilder promptResults = new StringBuilder();   // For AI prompt only
        
        try {
            String toolPattern = "<tool name=\"([^\"]+)\">(.*?)</tool>";
            java.util.regex.Pattern p = java.util.regex.Pattern.compile(toolPattern, java.util.regex.Pattern.DOTALL);
            java.util.regex.Matcher m = p.matcher(executeBlock);
            
            // Count total tools for spacing logic
            java.util.regex.Matcher counter = p.matcher(executeBlock);
            int totalTools = 0;
            while (counter.find()) {
                totalTools++;
            }
            
            int currentToolIndex = 0;
            List<ConversationManager.Message> toolMessages = new ArrayList<>();
            
            while (m.find()) {
                String toolName = m.group(1);
                String toolParams = m.group(2);
                
                log("Executing tool: " + toolName);
                
                // Format tool-specific arguments for display
                String formattedArgs = formatToolArgumentsFromXML(toolName, toolParams);
                
                // Execute tool
                ToolExecutor.ToolExecutionResult toolExecResult = ToolExecutor.executeToolWithSummary(toolName, toolParams, conversationManager);
                log("Tool " + toolName + " result: " + toolExecResult.fullResult.length() + " chars");
                
                // Create structured tool message for rendering
                String toolResult;
                if (toolName.equals("manage_checklist")) {
                    // For checklist, show task count
                    if (toolExecResult.fullResult.startsWith("DISPLAY_INFO:")) {
                        String[] parts = toolExecResult.fullResult.split("\\|", 2);
                        if (parts.length > 0) {
                            String countInfo = parts[0].substring("DISPLAY_INFO:".length());
                            toolResult = countInfo + " tasks";
                        } else {
                            toolResult = toolExecResult.summary;
                        }
                    } else {
                        toolResult = toolExecResult.summary;
                    }
                } else {
                    toolResult = toolExecResult.summary;
                }
                
                // Create structured tool message for rendering and storage
                String structuredContent = ConversationManager.createToolContent(toolName, formattedArgs, toolResult);
                ConversationManager.Message toolMessage = new ConversationManager.Message("tool", structuredContent);
                
                // Render immediately for real-time display
                renderer.append(toolMessage);
                
                // Store for conversation file
                toolMessages.add(toolMessage);
                
                // Collect results for prompt generation with clean format
                if (!toolExecResult.fullResult.isEmpty()) {
                    promptResults.append("## Tool: ").append(toolName).append("\n");
                    promptResults.append(toolExecResult.summary).append("\n");
                    
                    // Add content for storage - keep DISPLAY_INFO for file operations that need diff rendering
                    String contentForStorage;
                    if (toolName.equals("create_file") || toolName.equals("update_file")) {
                        // Keep DISPLAY_INFO for file operations that need it for diff rendering
                        contentForStorage = toolExecResult.fullResult;
                    } else {
                        // Clean DISPLAY_INFO for other tools
                        contentForStorage = cleanDisplayInfo(toolExecResult.fullResult);
                    }
                    
                    if (!contentForStorage.trim().isEmpty()) {
                        promptResults.append("<contents>\n");
                        promptResults.append(contentForStorage);
                        promptResults.append("\n</contents>");
                    }
                    promptResults.append("\n\n");
                }
            }
            
            // Store all tool messages in conversation
            for (ConversationManager.Message toolMsg : toolMessages) {
                conversationManager.addMessage(toolMsg);
                log("Tool message stored: " + toolMsg.role + " - " + toolMsg.content.substring(0, Math.min(50, toolMsg.content.length())));
            }
            
        } catch (Exception e) {
            log("Error processing tool block: " + e.getMessage());
            promptResults.append("Error processing tools: ").append(e.getMessage()).append("\n");
        }
        
        return promptResults.toString();
    }
    
    private static void cleanup() {
        systemTrayManager.cleanup();
    }
    
    private static void handleMouseToCommand(String command) {
        try {
            // Parse command: "mouseto 500 300" (supports negative coordinates)
            String[] parts = command.trim().split("\\s+");
            if (parts.length != 3) {
                System.out.println(DisplayManager.ANSI_RED + "Usage: mouseto <x> <y> (negative coordinates supported)" + DisplayManager.ANSI_RESET);
                return;
            }
            
            int x = Integer.parseInt(parts[1]);
            int y = Integer.parseInt(parts[2]);
            
            // Move mouse to coordinates
            ClipboardManager.moveMouseTo(x, y);
            String message = "Mouse moved to (" + x + ", " + y + ")";
            addTemporaryMessage("system", message, "command_output");
            log("Mouse moved to coordinates: " + x + ", " + y);
            
        } catch (NumberFormatException e) {
            String errorMsg = "Invalid coordinates. Usage: mouseto <x> <y> (negative coordinates supported)";
            addTemporaryMessage("system", errorMsg, "command_output");
            log("Invalid mouseto command: " + command);
        } catch (Exception e) {
            String errorMsg = "Error moving mouse: " + e.getMessage();
            addTemporaryMessage("system", errorMsg, "command_output");
            log("Error in mouseto command: " + e.getMessage());
        }
    }
    
    private static void handleCopyJSCommand() {
        try {
            String bridgeJS = BridgeScript.getBridgeJS();
            ClipboardManager.copyToClipboard(bridgeJS);
            String message = "Bridge button script copied to clipboard! (" + bridgeJS.length() + " chars)";
            addTemporaryMessage("system", message, "command_output");
            log("Bridge button script copied to clipboard: " + bridgeJS.length() + " characters");
        } catch (Exception e) {
            String errorMsg = "Error copying bridge script: " + e.getMessage();
            addTemporaryMessage("system", errorMsg, "command_output");
            log("Error in copyjs command: " + e.getMessage());
        }
    }
    
    private static void handleMouseCaptureCommand() {
        try {
            addTemporaryMessage("system", "Mouse capture starting... Move your mouse and wait 10 seconds...", "command_output");
            log("Mouse capture command initiated");
            
            // Show input caret after displaying the start message
            renderer.showInputCaret();
            
            // Wait 10 seconds
            Thread.sleep(10000);
            
            // Get current mouse position
            java.awt.Point mousePos = java.awt.MouseInfo.getPointerInfo().getLocation();
            
            String captureMsg = "Mouse captured at: (" + mousePos.x + ", " + mousePos.y + ")";
            addTemporaryMessage("system", captureMsg, "command_output");
            log("Mouse captured at coordinates: " + mousePos.x + ", " + mousePos.y);
            
            // Show input caret again after capture
            renderer.showInputCaret();
            
        } catch (InterruptedException e) {
            String errorMsg = "Mouse capture interrupted";
            addTemporaryMessage("system", errorMsg, "command_output");
            log("Mouse capture interrupted: " + e.getMessage());
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            String errorMsg = "Error capturing mouse position: " + e.getMessage();
            addTemporaryMessage("system", errorMsg, "command_output");
            log("Error in mousecapture command: " + e.getMessage());
        }
    }
    
    private static void logDisplayInformation() {
        try {
            java.awt.GraphicsEnvironment ge = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment();
            java.awt.GraphicsDevice[] devices = ge.getScreenDevices();
            
            log("Display Information:");
            log("Number of displays: " + devices.length);
            
            for (int i = 0; i < devices.length; i++) {
                java.awt.GraphicsDevice device = devices[i];
                java.awt.GraphicsConfiguration config = device.getDefaultConfiguration();
                java.awt.Rectangle bounds = config.getBounds();
                
                log("Display " + (i + 1) + ":");
                log("  ID: " + device.getIDstring());
                log("  Bounds: x=" + bounds.x + ", y=" + bounds.y + 
                    ", width=" + bounds.width + ", height=" + bounds.height);
                log("  Top-left: (" + bounds.x + ", " + bounds.y + ")");
                log("  Top-right: (" + (bounds.x + bounds.width - 1) + ", " + bounds.y + ")");
                log("  Bottom-left: (" + bounds.x + ", " + (bounds.y + bounds.height - 1) + ")");
                log("  Bottom-right: (" + (bounds.x + bounds.width - 1) + ", " + (bounds.y + bounds.height - 1) + ")");
                
                if (device == ge.getDefaultScreenDevice()) {
                    log("  [Primary Display]");
                }
            }
            
            // Also get mouse position
            java.awt.Point mousePos = java.awt.MouseInfo.getPointerInfo().getLocation();
            log("Current mouse position: (" + mousePos.x + ", " + mousePos.y + ")");
            
        } catch (Exception e) {
            log("Error getting display information: " + e.getMessage());
        }
    }
    
    private static void addTemporaryMessage(String role, String content, String type) {
        ConversationManager.Message newMessage = new ConversationManager.Message(role, content, type);
        temporaryMessages.add(newMessage);
        log("Added temporary message (" + type + "): " + content);
        log("Temporary messages count: " + temporaryMessages.size());
        
        // For command output, show immediate feedback without affecting conversation spacing
        if ("command_output".equals(type) && "system".equals(role)) {
            renderer.showImmediateSystemMessage(content);
        } else {
            // For other temporary messages, use normal conversation flow
            renderer.append(newMessage);
        }
    }
    
    private static void refreshDisplay() {
        // With the new renderer, we don't need to refresh display
        // Individual messages are rendered as they're added
        log("REFRESH: Display refresh requested - using incremental rendering instead");
    }
    
    private static void clearTemporaryMessages() {
        temporaryMessages.clear();
    }
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    public static String getWorkingDirectory() {
        return workingDirectory;
    }
    
    private static String extractMainParameter(String toolName, String toolParams) {
        try {
            String mainParamName = getMainParameterName(toolName);
            if (mainParamName != null) {
                String pattern = "<parameter name=\"" + mainParamName + "\">(.*?)</parameter>";
                java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.DOTALL);
                java.util.regex.Matcher m = p.matcher(toolParams);
                if (m.find()) {
                    return m.group(1).trim();
                }
            }
        } catch (Exception e) {
            log("Error extracting main parameter: " + e.getMessage());
        }
        return "";
    }
    
    private static String getMainParameterName(String toolName) {
        switch (toolName) {
            case "read_file":
            case "create_file":
            case "delete_file":
                return "file_path";
            case "move_file":
                return "source_path";
            case "list_files":
            case "list_recursive":
                return "path";
            case "create_directory":
            case "delete_directory_recursive":
                return "dir_path";
            case "search_files":
            case "search_content":
                return "query";
            case "git_read":
                return "project_path";
            default:
                return null;
        }
    }
    
    private static String cleanDisplayInfo(String content) {
        String[] lines = content.split("\n");
        if (lines.length > 0 && lines[0].startsWith("DISPLAY_INFO:")) {
            // Remove the DISPLAY_INFO line
            StringBuilder cleaned = new StringBuilder();
            for (int i = 1; i < lines.length; i++) {
                if (i > 1) cleaned.append("\n");
                cleaned.append(lines[i]);
            }
            return cleaned.toString();
        }
        return content;
    }
    
    
    private static String formatToolArgumentsFromXML(String toolName, String toolParams) {
        try {
            StringBuilder args = new StringBuilder();
            
            switch (toolName) {
                case "git_read":
                    String projectPath = extractParameterFromXML(toolParams, "project_path");
                    String gitArgs = extractParameterFromXML(toolParams, "git_args");
                    String offset = extractParameterFromXML(toolParams, "offset");
                    String limit = extractParameterFromXML(toolParams, "limit");
                    
                    if (!projectPath.isEmpty()) args.append(projectPath);
                    if (!gitArgs.isEmpty()) args.append(" ").append(gitArgs);
                    if (!offset.isEmpty()) args.append(" offset=").append(offset);
                    if (!limit.isEmpty()) args.append(" limit=").append(limit);
                    break;
                    
                case "read_file":
                    String filePath = extractParameterFromXML(toolParams, "file_path");
                    String findString = extractParameterFromXML(toolParams, "find_string");
                    String fileLimit = extractParameterFromXML(toolParams, "limit");

                    if (!filePath.isEmpty()) args.append(filePath);
                    if (!findString.isEmpty()) args.append(" find=\"").append(truncateString(findString, 20)).append("\"");
                    if (!fileLimit.isEmpty()) args.append(" limit=").append(fileLimit);
                    break;

                case "read_file_lines":
                    String linesFilePath = extractParameterFromXML(toolParams, "file_path");
                    String startLine = extractParameterFromXML(toolParams, "start_line");
                    String endLine = extractParameterFromXML(toolParams, "end_line");

                    if (!linesFilePath.isEmpty()) args.append(linesFilePath);
                    if (!startLine.isEmpty() && !endLine.isEmpty()) {
                        args.append(" lines ").append(startLine).append("-").append(endLine);
                    }
                    break;
                    
                case "create_file":
                    String createPath = extractParameterFromXML(toolParams, "file_path");
                    if (!createPath.isEmpty()) args.append(createPath);
                    break;
                    
                case "update_file":
                    String updatePath = extractParameterFromXML(toolParams, "file_path");
                    if (!updatePath.isEmpty()) args.append(updatePath);
                    break;
                    
                case "list_files":
                    String listPath = extractParameterFromXML(toolParams, "path");
                    if (!listPath.isEmpty()) args.append(listPath);
                    else args.append(".");
                    break;
                    
                case "list_recursive":
                    String recursivePath = extractParameterFromXML(toolParams, "path");
                    if (!recursivePath.isEmpty()) args.append(recursivePath);
                    else args.append(".");
                    break;
                    
                case "search_files":
                    String searchQuery = extractParameterFromXML(toolParams, "query");
                    if (!searchQuery.isEmpty()) args.append(searchQuery);
                    break;
                    
                case "search_content":
                    String contentQuery = extractParameterFromXML(toolParams, "query");
                    String filePattern = extractParameterFromXML(toolParams, "file_pattern");
                    String maxResults = extractParameterFromXML(toolParams, "max_results");
                    String maxPerFile = extractParameterFromXML(toolParams, "max_results_per_file");

                    if (!contentQuery.isEmpty()) args.append(contentQuery);
                    if (!filePattern.isEmpty()) args.append(" pattern=").append(filePattern);
                    if (!maxResults.isEmpty()) args.append(" max=").append(maxResults);
                    if (!maxPerFile.isEmpty()) args.append(" per_file=").append(maxPerFile);
                    break;
                    
                case "delete_file":
                    String deletePath = extractParameterFromXML(toolParams, "file_path");
                    if (!deletePath.isEmpty()) args.append(deletePath);
                    break;
                    
                case "move_file":
                    String sourcePath = extractParameterFromXML(toolParams, "source_path");
                    String destPath = extractParameterFromXML(toolParams, "dest_path");
                    
                    if (!sourcePath.isEmpty()) args.append(sourcePath);
                    if (!destPath.isEmpty()) args.append(" -> ").append(destPath);
                    break;
                    
                case "create_directory":
                    String createDirPath = extractParameterFromXML(toolParams, "dir_path");
                    if (!createDirPath.isEmpty()) args.append(createDirPath);
                    break;
                    
                case "delete_directory_recursive":
                    String deleteDirPath = extractParameterFromXML(toolParams, "dir_path");
                    if (!deleteDirPath.isEmpty()) args.append(deleteDirPath);
                    break;
                    
                default:
                    // Fallback to old main parameter extraction
                    return extractMainParameter(toolName, toolParams);
            }
            
            return args.toString();
            
        } catch (Exception e) {
            log("Error formatting tool arguments: " + e.getMessage());
            return extractMainParameter(toolName, toolParams);
        }
    }
    
    private static String extractParameterFromXML(String toolParams, String paramName) {
        try {
            String pattern = "<parameter name=\"" + paramName + "\">(.*?)</parameter>";
            java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.DOTALL);
            java.util.regex.Matcher m = p.matcher(toolParams);
            if (m.find()) {
                return m.group(1).trim();
            }
        } catch (Exception e) {
            log("Error extracting parameter " + paramName + ": " + e.getMessage());
        }
        return "";
    }
    
    private static String truncateString(String str, int maxLength) {
        if (str.length() <= maxLength) return str;
        return str.substring(0, maxLength - 3) + "...";
    }
    
    // INNER CLASSES
    private static class ProcessedResponse {
        String finalMessage;
        boolean hasToolExecutions;
        String toolResults;
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: ConversationManager.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;
import java.util.*;

public class ConversationManager {
    private static String getConversationFile() {
        return Paths.get(ConversationCLI.getWorkingDirectory(), ".agent", "conversation.txt").toString();
    }
    
    private static String getChecklistFile() {
        return Paths.get(ConversationCLI.getWorkingDirectory(), ".agent", "checklist.json").toString();
    }
    private static final String FIELD_SEP = "|`|~";
    private static final String RECORD_SEP = "\n||||||||\n";
    private static final String STRUCT_DELIMITER = "|";
    private static final String ESCAPE_CHAR = "\\";
    
    // Record type definitions - defines expected fields for each record type
    private static final Map<String, String[]> RECORD_SCHEMAS = new HashMap<>();
    static {
        RECORD_SCHEMAS.put("user", new String[]{"content"});
        RECORD_SCHEMAS.put("assistant", new String[]{"content"});
        RECORD_SCHEMAS.put("summary", new String[]{"content"});
        RECORD_SCHEMAS.put("tool", new String[]{"content"}); // Single structured content field
        RECORD_SCHEMAS.put("tool_results", new String[]{"tool_name", "lines", "path", "content"});
        RECORD_SCHEMAS.put("checklist", new String[]{"content"});
        RECORD_SCHEMAS.put("celebration", new String[]{"content"});
        RECORD_SCHEMAS.put("system", new String[]{"content"});
    }
    
    private List<Message> conversation = new ArrayList<>();
    private int conversationCharCount = 0;
    private int maxMessageChars = 200;
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    // Utility functions for escaping/unescaping structured content
    public static String escapeStructuredContent(String text) {
        if (text == null) return "";
        return text.replace(ESCAPE_CHAR, ESCAPE_CHAR + ESCAPE_CHAR)
                  .replace(STRUCT_DELIMITER, ESCAPE_CHAR + STRUCT_DELIMITER);
    }
    
    public static String unescapeStructuredContent(String text) {
        if (text == null) return "";
        return text.replace(ESCAPE_CHAR + STRUCT_DELIMITER, STRUCT_DELIMITER)
                  .replace(ESCAPE_CHAR + ESCAPE_CHAR, ESCAPE_CHAR);
    }
    
    // Create structured content for tool messages
    public static String createToolContent(String toolName, String params, String result) {
        return "TOOL_NAME:" + escapeStructuredContent(toolName) + 
               STRUCT_DELIMITER + "PARAMS:" + escapeStructuredContent(params) + 
               STRUCT_DELIMITER + "RESULT:" + escapeStructuredContent(result);
    }
    
    // Parse structured tool content
    public static Map<String, String> parseToolContent(String content) {
        Map<String, String> result = new HashMap<>();
        String[] parts = content.split("(?<!\\\\)\\|"); // Split on unescaped |
        
        for (String part : parts) {
            String[] keyValue = part.split(":", 2);
            if (keyValue.length == 2) {
                result.put(keyValue[0], unescapeStructuredContent(keyValue[1]));
            }
        }
        return result;
    }
    
    public void setMaxMessageChars(int maxMessageChars) {
        this.maxMessageChars = maxMessageChars;
    }
    
    public void removeLastMessage() throws IOException {
        if (!conversation.isEmpty()) {
            Message removed = conversation.remove(conversation.size() - 1);
            log("Removed last message: " + removed.role + " (" + removed.content.length() + " chars)");
            conversationCharCount = calculateConversationCharCount();

            // Rewrite file to persist the removal
            rewriteConversationFile();
            log("Rewrote conversation file after message removal");
        }
    }

    public List<Message> getConversation() {
        log("GET_CONVERSATION: Returning " + conversation.size() + " messages");
        // Count message types
        int userCount = 0, assistantCount = 0, checklistCount = 0, systemCount = 0;
        for (Message msg : conversation) {
            switch (msg.role) {
                case "user": userCount++; break;
                case "assistant": assistantCount++; break;
                case "checklist": checklistCount++; break;
                case "system": systemCount++; break;
            }
            log("GET_CONVERSATION: Message " + msg.role + " - " + msg.content.substring(0, Math.min(50, msg.content.length())));
        }
        log("GET_CONVERSATION: Counts - user:" + userCount + ", assistant:" + assistantCount + 
            ", checklist:" + checklistCount + ", system:" + systemCount);
        return conversation;
    }
    
    public int getConversationCharCount() {
        return conversationCharCount;
    }
    
    public void loadConversation() throws IOException {
        logPaths();
        
        Path conversationPath = Paths.get(getConversationFile());
        if (Files.exists(conversationPath)) {
            String content = new String(Files.readAllBytes(conversationPath));
            log("Loading conversation file, content length: " + content.length());
            if (!content.trim().isEmpty()) {
                String[] records = content.split(java.util.regex.Pattern.quote(RECORD_SEP));
                log("Found " + records.length + " records in conversation file");
                List<Message> allMessages = new ArrayList<>();
                
                // Parse all messages using generic parser
                for (String record : records) {
                    record = record.trim();
                    if (!record.isEmpty()) {
                        ParsedRecord parsed = parseRecord(record);
                        
                        if (parsed.type.equals("tool_results")) {
                            // Reconstruct tool_results content in internal format
                            String toolName = parsed.get("tool_name");
                            String lines = parsed.get("lines");
                            String path = parsed.get("path");
                            String toolContent = parsed.get("content");
                            
                            String internalContent = toolName + FIELD_SEP + lines + FIELD_SEP + path + FIELD_SEP + toolContent;
                            Message msg = new Message("tool_results", internalContent);
                            allMessages.add(msg);
                            log("Loaded tool_results: " + toolName + " (" + toolContent.length() + " chars)");
                        } else {
                            // Standard message types
                            String msgContent = parsed.get("content");
                            if (!msgContent.isEmpty()) {
                                Message msg = new Message(parsed.type, msgContent);
                                allMessages.add(msg);
                                log("LOAD: Loaded message: " + parsed.type + " (" + msgContent.length() + " chars)");
                                if (parsed.type.equals("checklist")) {
                                    log("LOAD: Checklist content preview: " + msgContent.substring(0, Math.min(100, msgContent.length())));
                                }
                            } else {
                                log("LOAD: Skipping record with empty content: " + parsed.type);
                            }
                        }
                    }
                }
                
                // Work backwards to find the most recent summary
                int startIndex = 0;
                for (int i = allMessages.size() - 1; i >= 0; i--) {
                    if (allMessages.get(i).role.equals("summary")) {
                        startIndex = i;
                        break;
                    }
                }
                
                // Load from the summary onwards (or from beginning if no summary)
                for (int i = startIndex; i < allMessages.size(); i++) {
                    conversation.add(allMessages.get(i));
                }
                
                log("Loaded " + conversation.size() + " messages from conversation file");
                
                // Calculate current char count
                conversationCharCount = calculateConversationCharCount();
            }
        }
        
        // If no conversation exists, add initial greeting
        if (conversation.isEmpty()) {
            Message greeting = new Message("assistant", "Hello! How can I help you today?");
            conversation.add(greeting);
            saveMessage(greeting);
            conversationCharCount = calculateConversationCharCount();
        }
    }
    
    public void saveMessage(Message message) throws IOException {
        // Convert message to file format based on type
        String recordContent;
        
        if (message.role.equals("tool_results")) {
            // Parse internal format: "toolname|`|~lines|`|~path|`|~content"
            String[] parts = message.content.split(java.util.regex.Pattern.quote(FIELD_SEP));
            if (parts.length >= 4) {
                String toolName = parts[0];
                String lines = parts[1];
                String path = parts[2];
                String content = parts[3];
                recordContent = message.role + FIELD_SEP + toolName + FIELD_SEP + lines + FIELD_SEP + path + FIELD_SEP + content;
            } else {
                // Fallback for malformed tool_results
                recordContent = message.role + FIELD_SEP + message.content;
            }
        } else {
            // Standard message types (user, assistant, summary)
            recordContent = message.role + FIELD_SEP + message.content;
        }
        
        // Write to file
        Path conversationPath = Paths.get(getConversationFile());
        String fileContent = recordContent + RECORD_SEP;
        Files.write(conversationPath, fileContent.getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        
        log("Saved message: " + message.role + " (" + message.content.length() + " chars)");
    }
    
    public void addMessage(Message message) throws IOException {
        log("ADD_MESSAGE: Before adding - conversation has " + conversation.size() + " messages");
        conversation.add(message);
        log("ADD_MESSAGE: After adding - conversation has " + conversation.size() + " messages");
        log("ADD_MESSAGE: Added message type: " + message.role + " (" + message.content.length() + " chars)");
        log("ADD_MESSAGE: Message content preview: " + message.content.substring(0, Math.min(50, message.content.length())));
        
        saveMessage(message);
        conversationCharCount += message.content.length();
        log("Added message: " + message.role + " (" + message.content.length() + " chars)");
    }
    
    public void checkAndSummarizeIfNeeded(String lastPrompt, String lastResponse) throws IOException {
        conversationCharCount = calculateConversationCharCount();

        if (conversationCharCount > maxMessageChars) {
            log("Conversation length (" + conversationCharCount + " chars) exceeds limit (" + maxMessageChars + "), creating summary");

            String summaryPrompt = generateSummarizationPrompt();

            log("Generated summarization prompt, copying to clipboard");
            ClipboardManager.copyToClipboard(summaryPrompt);

            System.out.println("\n" + DisplayManager.ANSI_GOLD + "[SUMMARY] Conversation is getting long. A summarization prompt has been copied to clipboard." + DisplayManager.ANSI_RESET);
            System.out.println(DisplayManager.ANSI_GOLD + "Please paste it into Claude, then copy the summary back here." + DisplayManager.ANSI_RESET);
            System.out.print("Press Enter when you've copied the summary to clipboard: ");

            Scanner scanner = new Scanner(System.in);
            scanner.nextLine();

            String summary = ClipboardManager.getClipboardContent();
            if (summary != null && !summary.trim().isEmpty()) {
                // Remove old messages up to halfway point and replace with summary
                int halfPoint = conversation.size() / 2;
                List<Message> newConversation = new ArrayList<>();

                // Add summary as first message
                Message summaryMessage = new Message("summary", summary.trim());
                newConversation.add(summaryMessage);

                // Add second half of conversation
                for (int i = halfPoint; i < conversation.size(); i++) {
                    newConversation.add(conversation.get(i));
                }

                // Replace conversation and rewrite file
                conversation = newConversation;
                rewriteConversationFile();

                conversationCharCount = calculateConversationCharCount();
                log("Summarization complete. New char count: " + conversationCharCount);

                System.out.println(DisplayManager.ANSI_GOLD + "[SUCCESS] Conversation summarized successfully." + DisplayManager.ANSI_RESET);
            } else {
                log("No summary received from clipboard");
                System.out.println(DisplayManager.ANSI_RED + "No summary received. Continuing without summarization." + DisplayManager.ANSI_RESET);
            }
        }
    }

    public String performSummarization(ConfigManager configManager, Renderer renderer) throws IOException {
        log("Performing automatic summarization");

        // Check if we have enough messages to summarize
        if (conversation.size() < 4) {
            log("Not enough messages to summarize (need at least 4, have " + conversation.size() + ")");
            return "NOT_ENOUGH_MESSAGES";
        }

        String summaryPrompt = generateSummarizationPrompt();

        log("Generated summarization prompt for automatic processing");

        String summary;

        if (configManager.isAutomaticMode()) {
            // Automatic mode: Generate JSON message with terminator
            String automaticMessage = PromptGenerator.wrapInAutomaticMessage(summaryPrompt);
            ClipboardManager.copyToClipboard(automaticMessage);
            log("Automatic summarization message copied to clipboard");

            // Show compacting message
            renderer.showLoadingIndicator("Compacting...");
            summary = ClipboardManager.waitForAutomaticResponse(configManager.getClickX(), configManager.getClickY());

            // Handle mouse cancellation with retry
            while (summary != null && summary.equals("MOUSE_CANCELLED")) {
                summary = ClipboardManager.handleAutoCancelRetry(automaticMessage, configManager.getClickX(), configManager.getClickY());
            }
        } else {
            // Manual mode: Generate prompt and wait for manual response
            ClipboardManager.copyToClipboard(summaryPrompt);
            log("Summarization prompt copied to clipboard for manual mode");

            renderer.showLoadingIndicator("Compacting... Paste summary and press ENTER");

            summary = ClipboardManager.getResponseFromClipboard(summaryPrompt);
        }

        if (summary == null || summary.trim().isEmpty()) {
            log("No summary received");
            throw new IOException("Summarization failed: No summary received");
        }

        if (summary.equals("TOKEN_LIMIT_EXCEEDED")) {
            log("Token limit exceeded during summarization");
            return "TOKEN_LIMIT_EXCEEDED";
        }

        // Remove old messages up to halfway point and replace with summary
        int halfPoint = conversation.size() / 2;
        List<Message> newConversation = new ArrayList<>();

        // Add summary as first message
        Message summaryMessage = new Message("summary", summary.trim());
        newConversation.add(summaryMessage);

        // Add second half of conversation
        for (int i = halfPoint; i < conversation.size(); i++) {
            newConversation.add(conversation.get(i));
        }

        // Replace conversation and rewrite file
        conversation = newConversation;
        rewriteConversationFile();

        conversationCharCount = calculateConversationCharCount();
        log("Summarization complete. New char count: " + conversationCharCount);

        return "SUCCESS";
    }
    
    private void rewriteConversationFile() throws IOException {
        Path conversationPath = Paths.get(getConversationFile());
        // Delete and recreate file
        if (Files.exists(conversationPath)) {
            Files.delete(conversationPath);
        }
        
        // Save all messages
        for (Message msg : conversation) {
            saveMessage(msg);
        }
        
        log("Rewrote conversation file with " + conversation.size() + " messages");
    }
    
    private String generateSummarizationPrompt() {
        StringBuilder prompt = new StringBuilder();
        prompt.append("Summarize the following conversation history concisely, preserving key context and decisions. ");
        prompt.append("Focus on important information that affects future interactions.\n\n");
        
        // Add first half of conversation (NO base system prompt or project structure for summarization)
        int halfPoint = conversation.size() / 2;
        for (int i = 0; i < halfPoint; i++) {
            Message msg = conversation.get(i);
            if (msg.role.equals("assistant")) {
                prompt.append("[ASSISTANT]\n\n");
            } else if (msg.role.equals("user")) {
                prompt.append("[USER]\n\n");
            } else if (msg.role.equals("summary")) {
                prompt.append("[SUMMARY]\n\n");
            }
            prompt.append(msg.content).append("\n\n");
        }
        
        prompt.append("Please provide a concise summary of the above conversation that captures the essential context and decisions made.");
        
        return prompt.toString();
    }
    
    // Generic record parser that uses schema lookup for field definitions
    private ParsedRecord parseRecord(String recordText) {
        String[] parts = recordText.split(java.util.regex.Pattern.quote(FIELD_SEP));
        if (parts.length < 1) {
            return new ParsedRecord("unknown", new HashMap<>());
        }
        
        String recordType = parts[0];
        String[] schema = RECORD_SCHEMAS.get(recordType);
        Map<String, String> fields = new HashMap<>();
        
        if (schema != null) {
            // Use schema to parse fields
            for (int i = 0; i < schema.length && i + 1 < parts.length; i++) {
                String fieldName = schema[i];
                String fieldValue = parts[i + 1];
                fields.put(fieldName, fieldValue);
            }
            
            // If there are extra parts beyond the schema, join them into the last field
            if (parts.length > schema.length + 1) {
                String lastFieldName = schema[schema.length - 1];
                StringBuilder lastFieldValue = new StringBuilder(fields.get(lastFieldName));
                for (int i = schema.length + 1; i < parts.length; i++) {
                    lastFieldValue.append(FIELD_SEP).append(parts[i]);
                }
                fields.put(lastFieldName, lastFieldValue.toString());
            }
        } else {
            // Unknown record type - treat as simple content record
            if (parts.length >= 2) {
                StringBuilder content = new StringBuilder();
                for (int i = 1; i < parts.length; i++) {
                    if (i > 1) content.append(FIELD_SEP);
                    content.append(parts[i]);
                }
                fields.put("content", content.toString());
            }
        }
        
        return new ParsedRecord(recordType, fields);
    }
    
    public String formatToolResultForPrompt(String toolResultContent) {
        ParsedRecord record = parseRecord("tool_results" + FIELD_SEP + toolResultContent);
        
        String toolName = record.get("tool_name");
        String lines = record.get("lines");
        String path = record.get("path");
        String content = record.get("content");
        
        // For prompts, we want the cleaned content without DISPLAY_INFO
        String cleanContent = content;
        String[] contentLines = content.split("\n");
        if (contentLines.length > 0 && contentLines[0].startsWith("DISPLAY_INFO:")) {
            // Remove the DISPLAY_INFO line
            StringBuilder cleanBuilder = new StringBuilder();
            for (int i = 1; i < contentLines.length; i++) {
                if (i > 1) cleanBuilder.append("\n");
                cleanBuilder.append(contentLines[i]);
            }
            cleanContent = cleanBuilder.toString();
        }
        
        return String.format("[SYSTEM]\n\n## Tool: %s\n%s", toolName, cleanContent);
    }
    
    private void logPaths() {
        try {
            String currentDir = System.getProperty("user.dir");
            log("Current working directory: " + currentDir);
            log("Conversation file path: " + Paths.get(getConversationFile()).toAbsolutePath());
            log("Conversation file exists: " + Files.exists(Paths.get(getConversationFile())));
        } catch (Exception e) {
            log("Error logging paths: " + e.getMessage());
        }
    }
    
    private int calculateConversationCharCount() {
        int total = 0;
        // Only count actual conversation messages, not the base system prompt
        // (base prompt is added dynamically to prompts but not stored in conversation)
        for (Message msg : conversation) {
            total += msg.content.length();
        }
        return total;
    }
    
    public boolean needsPromptCopy() {
        return !conversation.isEmpty() && conversation.get(conversation.size() - 1).role.equals("user");
    }
    
    // INNER CLASSES
    public static class Message {
        public String role;
        public String content;
        public String type; // Message type for different handling
        
        public Message(String role, String content) {
            this.role = role;
            this.content = content;
            this.type = "conversation"; // Default type for normal conversation
        }
        
        public Message(String role, String content, String type) {
            this.role = role;
            this.content = content;
            this.type = type;
        }
    }
    
    private static class ParsedRecord {
        String type;
        Map<String, String> fields;
        
        ParsedRecord(String type, Map<String, String> fields) {
            this.type = type;
            this.fields = fields;
        }
        
        String get(String fieldName) {
            return fields.getOrDefault(fieldName, "");
        }
    }
    
    
    // Todo management - Claude Code style
    public static class TodoItem {
        public String content;
        public String status; // "pending", "in_progress", "completed" 
        public String priority; // "high", "medium", "low"
        public String id;
        
        public TodoItem(String content, String status, String priority, String id) {
            this.content = content;
            this.status = status;
            this.priority = priority;
            this.id = id;
        }
    }
    
    public static class TodoList {
        public List<TodoItem> items;
        
        public TodoList(List<TodoItem> items) {
            this.items = items;
        }
        
        public String formatForDisplay() {
            return formatForDisplay(false);
        }
        
        public String formatForDisplay(boolean fullFormat) {
            if (!fullFormat) {
                return formatCompact();
            }
            
            StringBuilder result = new StringBuilder();
            boolean foundFirstPending = false;
            
            for (int i = 0; i < items.size(); i++) {
                TodoItem item = items.get(i);
                String icon;
                String suffix = "";
                
                switch (item.status) {
                    case "completed":
                        icon = "[X]";
                        break;
                    case "in_progress":
                        icon = "[~]";
                        suffix = " (current)";
                        break;
                    default: // pending
                        icon = "[ ]";
                        // Mark first pending item as current if no in_progress items
                        if (!foundFirstPending && !hasInProgressItems()) {
                            suffix = " (current)";
                            foundFirstPending = true;
                        }
                        break;
                }
                
                result.append(icon).append(" ").append(item.content).append(suffix);
                if (i < items.size() - 1) {
                    result.append("\n");
                }
            }
            
            return result.toString();
        }
        
        private String formatCompact() {
            int completed = (int) items.stream().filter(item -> "completed".equals(item.status)).count();
            int total = items.size();
            
            // Find current task
            String currentTask = "";
            for (TodoItem item : items) {
                if ("in_progress".equals(item.status)) {
                    currentTask = item.content;
                    break;
                }
            }
            
            // If no in_progress, find first pending
            if (currentTask.isEmpty()) {
                for (TodoItem item : items) {
                    if ("pending".equals(item.status)) {
                        currentTask = item.content;
                        break;
                    }
                }
            }
            
            // Build compact format
            StringBuilder result = new StringBuilder();
            result.append("[").append(completed).append("/").append(total).append("]");
            
            if (!currentTask.isEmpty()) {
                // Truncate long task names
                String displayTask = currentTask.length() > 50 ? 
                    currentTask.substring(0, 47) + "..." : currentTask;
                result.append(" -> ").append(displayTask);
            } else {
                result.append(" All tasks completed!");
            }
            
            return result.toString();
        }
        
        private boolean hasInProgressItems() {
            return items.stream().anyMatch(item -> item.status.equals("in_progress"));
        }
    }
    
    public boolean hasActiveTodoList() {
        return Files.exists(Paths.get(getChecklistFile()));
    }
    
    public void deleteTodoList() {
        try {
            Path checklistPath = Paths.get(getChecklistFile());
            if (Files.exists(checklistPath)) {
                Files.delete(checklistPath);
                log("Deleted todo list file");
            }
        } catch (Exception e) {
            log("Error deleting todo list: " + e.getMessage());
        }
    }
    
    // TodoList methods
    public TodoList loadTodoList() {
        try {
            String checklistPath = getChecklistFile();
            if (!Files.exists(Paths.get(checklistPath))) {
                return null;
            }
            
            String content = new String(Files.readAllBytes(Paths.get(checklistPath)));
            // Simple JSON parsing for todo list
            String[] lines = content.split("\\n");
            List<TodoItem> todos = new ArrayList<>();
            
            String currentContent = "";
            String currentStatus = "pending";
            String currentPriority = "medium";
            String currentId = "";
            
            for (String line : lines) {
                line = line.trim();
                if (line.startsWith("\"content\":")) {
                    currentContent = line.substring(line.indexOf(":") + 1).trim().replaceAll("[\",]", "");
                } else if (line.startsWith("\"status\":")) {
                    currentStatus = line.substring(line.indexOf(":") + 1).trim().replaceAll("[\",]", "");
                } else if (line.startsWith("\"priority\":")) {
                    currentPriority = line.substring(line.indexOf(":") + 1).trim().replaceAll("[\",]", "");
                } else if (line.startsWith("\"id\":")) {
                    currentId = line.substring(line.indexOf(":") + 1).trim().replaceAll("[\",]", "");
                    // When we hit the id, we have a complete todo item
                    if (!currentContent.isEmpty() && !currentId.isEmpty()) {
                        todos.add(new TodoItem(currentContent, currentStatus, currentPriority, currentId));
                        currentContent = "";
                        currentStatus = "pending";
                        currentPriority = "medium";
                        currentId = "";
                    }
                }
            }
            
            return new TodoList(todos);
        } catch (Exception e) {
            log("Error loading todo list: " + e.getMessage());
            return null;
        }
    }
    
    public void saveTodoList(TodoList todoList) {
        try {
            StringBuilder json = new StringBuilder();
            json.append("{\n");
            json.append("  \"items\": [\n");
            
            for (int i = 0; i < todoList.items.size(); i++) {
                TodoItem item = todoList.items.get(i);
                json.append("    {\n");
                json.append("      \"content\": \"").append(item.content).append("\",\n");
                json.append("      \"status\": \"").append(item.status).append("\",\n");
                json.append("      \"priority\": \"").append(item.priority).append("\",\n");
                json.append("      \"id\": \"").append(item.id).append("\"\n");
                json.append("    }");
                if (i < todoList.items.size() - 1) {
                    json.append(",");
                }
                json.append("\n");
            }
            
            json.append("  ]\n");
            json.append("}\n");
            
            Files.write(Paths.get(getChecklistFile()), json.toString().getBytes());
            log("Saved todo list with " + todoList.items.size() + " items");
        } catch (Exception e) {
            log("Error saving todo list: " + e.getMessage());
        }
    }
    
    public void addTodoListMessage(TodoList todoList) {
        try {
            String formattedTodoList = todoList.formatForDisplay();
            log("CHECKLIST: Adding todo list message with " + formattedTodoList.length() + " chars");
            log("CHECKLIST: Content: " + formattedTodoList);
            Message msg = new Message("checklist", formattedTodoList);
            addMessage(msg);
            log("CHECKLIST: Todo list message added successfully");
        } catch (IOException e) {
            log("CHECKLIST: Error adding todo list message: " + e.getMessage());
        }
    }
    
    public void addCelebrationMessage(String celebration) {
        try {
            log("CELEBRATION: Adding celebration message: " + celebration);
            Message msg = new Message("celebration", celebration);
            addMessage(msg);
            log("CELEBRATION: Message added successfully");
        } catch (IOException e) {
            log("CELEBRATION: Error adding celebration message: " + e.getMessage());
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: DirectoryOperations.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Collectors;

public class DirectoryOperations {
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    private static String getWorkingDirectory() {
        return ConversationCLI.getWorkingDirectory();
    }
    
    private static Path resolvePath(String filePath) {
        Path path = Paths.get(filePath);
        if (path.isAbsolute()) {
            return path;
        } else {
            return Paths.get(getWorkingDirectory()).resolve(path);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeCreateDirectoryWithSummary(String toolParams) {
        try {
            String dirPath = ToolParameterExtractor.extractParameter(toolParams, "dir_path");
            
            if (dirPath == null || dirPath.trim().isEmpty()) {
                String error = "Error: dir_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Path path = resolvePath(dirPath);
            
            Files.createDirectories(path);
            
            String fullResult = String.format("Directory: %s\nCreated successfully", dirPath);
            String summary = "Directory created";
            
            String enhancedResult = "DISPLAY_INFO:0|" + dirPath + "\n" + fullResult;
            
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error creating directory: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeDeleteDirectoryWithSummary(String toolParams) {
        try {
            String dirPath = ToolParameterExtractor.extractParameter(toolParams, "dir_path");
            
            if (dirPath == null || dirPath.trim().isEmpty()) {
                String error = "Error: dir_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Path path = resolvePath(dirPath);
            
            if (!Files.exists(path)) {
                String error = "Error: Directory not found: " + dirPath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            if (!Files.isDirectory(path)) {
                String error = "Error: Path is not a directory: " + dirPath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Files.walk(path)
                .sorted((a, b) -> b.compareTo(a))
                .forEach(p -> {
                    try {
                        Files.delete(p);
                    } catch (Exception e) {
                        throw new RuntimeException("Failed to delete: " + p, e);
                    }
                });
            
            String fullResult = String.format("Directory: %s\nDeleted successfully (recursive)", dirPath);
            String summary = "Directory deleted (recursive)";
            
            String enhancedResult = "DISPLAY_INFO:0|" + dirPath + "\n" + fullResult;
            
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error deleting directory: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeListFilesWithSummary(String toolParams) {
        try {
            String pathParam = ToolParameterExtractor.extractParameter(toolParams, "path");
            String targetPath = (pathParam != null && !pathParam.trim().isEmpty()) ? pathParam : getWorkingDirectory();
            
            Path path = resolvePath(targetPath);
            
            if (!Files.exists(path)) {
                String error = "Error: Path not found: " + targetPath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            if (!Files.isDirectory(path)) {
                String error = "Error: Path is not a directory: " + targetPath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            StringBuilder results = new StringBuilder();
            int fileCount = 0;
            int dirCount = 0;
            
            try {
                List<Path> entries = Files.list(path)
                    .sorted((a, b) -> {
                        boolean aIsDir = Files.isDirectory(a);
                        boolean bIsDir = Files.isDirectory(b);
                        if (aIsDir && !bIsDir) return -1;
                        if (!aIsDir && bIsDir) return 1;
                        return a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString());
                    })
                    .collect(Collectors.toList());
                
                for (Path entry : entries) {
                    String fileName = entry.getFileName().toString();
                    if (Files.isDirectory(entry)) {
                        results.append(String.format("[DIR]  %s/\n", fileName));
                        dirCount++;
                    } else {
                        long fileSize = Files.size(entry);
                        results.append(String.format("[FILE] %s (%s)\n", fileName, ToolParameterExtractor.formatFileSize(fileSize)));
                        fileCount++;
                    }
                }
            } catch (Exception e) {
                String error = "Error listing directory: " + e.getMessage();
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            String fullResult = String.format("Directory listing for: %s\n\n%s\nTotal: %d directories, %d files", 
                targetPath, results.toString(), dirCount, fileCount);
            String summary = "Listed " + dirCount + " dirs, " + fileCount + " files";
            
            String enhancedResult = "DISPLAY_INFO:" + (dirCount + fileCount) + "|" + targetPath + "\n" + fullResult;
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error listing files: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeListRecursiveWithSummary(String toolParams) {
        try {
            String pathParam = ToolParameterExtractor.extractParameter(toolParams, "path");
            String targetPath = (pathParam != null && !pathParam.trim().isEmpty()) ? pathParam : getWorkingDirectory();
            
            Path path = resolvePath(targetPath);
            
            if (!Files.exists(path)) {
                String error = "Error: Path not found: " + targetPath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            if (!Files.isDirectory(path)) {
                String error = "Error: Path is not a directory: " + targetPath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            StringBuilder results = new StringBuilder();
            int fileCount = 0;
            int dirCount = 0;
            
            try {
                List<Path> entries = Files.walk(path)
                    .filter(p -> !p.equals(path))
                    .sorted()
                    .collect(Collectors.toList());
                
                for (Path entry : entries) {
                    String relativePath = path.relativize(entry).toString();
                    if (Files.isDirectory(entry)) {
                        results.append(String.format("[DIR]  %s/\n", relativePath));
                        dirCount++;
                    } else {
                        long fileSize = Files.size(entry);
                        results.append(String.format("[FILE] %s (%s)\n", relativePath, ToolParameterExtractor.formatFileSize(fileSize)));
                        fileCount++;
                    }
                }
            } catch (Exception e) {
                String error = "Error listing directory recursively: " + e.getMessage();
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            String fullResult = String.format("Recursive listing for: %s\n\n%s\nTotal: %d directories, %d files", 
                targetPath, results.toString(), dirCount, fileCount);
            String summary = "Listed " + dirCount + " dirs, " + fileCount + " files (recursive)";
            
            String enhancedResult = "DISPLAY_INFO:" + (dirCount + fileCount) + "|" + targetPath + "\n" + fullResult;
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error listing files recursively: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: DisplayManager.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.util.*;

public class DisplayManager {
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_GRAY = "\u001B[90m";
    public static final String ANSI_GOLD = "\u001B[33m";
    public static final String ANSI_RED = "\u001B[31m";
    public static final String ANSI_WHITE = "\u001B[37m";
    public static final String ANSI_CYAN = "\u001B[36m";
    public static final String ANSI_LIGHT_BLUE = "\u001B[94m";
    public static final String ANSI_BLUE = "\u001B[34m";
    public static final String ANSI_DIM = "\u001B[2m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_LIGHT_GREEN = "\u001B[92m";
    public static final String ANSI_DARK_GREEN = "\u001B[2;32m";
    public static final String ANSI_DARK_RED = "\u001B[2;31m";
    
    private static final String FIELD_SEP = "|`|~";
    
    private MessageRenderer messageRenderer;
    private int statusMessageCount = 0;
    private boolean isShowingLoading = false;
    
    public DisplayManager() {
        this.messageRenderer = new MessageRenderer();
    }
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    private static String getToolSummary(String toolName, String mainParam) {
        // Generate contextual summaries for different tool types
        switch (toolName) {
            case "create_file":
                return "File created";
            case "create_directory":
                return "Directory created";
            case "delete_file":
                return "File deleted";
            case "delete_directory_recursive":
                return "Directory deleted";
            case "move_file":
                return "File moved";
            case "update_file":
                return "File updated";
            case "read_file":
                return "File read";
            case "list_files":
                return "Files listed";
            case "list_recursive":
                return "Files listed recursively";
            case "search_files":
                return "Files searched";
            case "search_content":
                return "Content searched";
            case "git_read":
                return "Git command executed";
            case "manage_checklist":
                return "Checklist updated";
            default:
                return "Tool executed";
        }
    }
    
    public void setWrapWidth(int wrapWidth) {
        messageRenderer.setWrapWidth(wrapWidth);
    }
    
    public MessageRenderer getMessageRenderer() {
        return messageRenderer;
    }
    
    /**
     * Render a single message without re-rendering the entire conversation
     */
    public void renderSingleMessage(ConversationManager.Message message) {
        List<MessageRenderer.RenderableItem> items = convertConversationToRenderableItems(Arrays.asList(message));
        messageRenderer.renderItems(items);
    }
    
    /**
     * Show just the tool header immediately when tool execution starts
     */
    public void renderToolHeader(String toolName, String formattedArgs) {
        // Display tool execution header (green brackets) for all tools
        String toolDisplay = toolName.toUpperCase();
        String paramDisplay = formattedArgs.isEmpty() ? "" : " " + formattedArgs;
        System.out.println(MessageRenderer.ANSI_GREEN + "  [" + toolDisplay + "]" + paramDisplay + MessageRenderer.ANSI_RESET);
    }
    
    /**
     * Show tool details (summary/diff) when tool execution completes
     */
    public void renderToolDetails(String toolName, ToolExecutor.ToolExecutionResult result) {
        // Display tool-specific content for all tools
        if (toolName.equals("create_file") || toolName.equals("update_file")) {
            messageRenderer.renderFileOperationDiff(result.fullResult, toolName);
        } else if (toolName.equals("manage_checklist")) {
            // For checklist, show the updated checklist immediately
            messageRenderer.renderChecklistResult(result.fullResult);
        } else {
            System.out.println(MessageRenderer.ANSI_DARK_GREEN + "    " + result.summary + MessageRenderer.ANSI_RESET);
        }
    }
    
    /**
     * Legacy method kept for real-time display compatibility.
     * Real-time tool execution still uses this method, while re-render uses MessageRenderer.
     */
    public void renderToolResult(String toolName, ToolExecutor.ToolExecutionResult result, String formattedArgs) {
        // Skip display for manage_checklist - it handles its own display via conversation refresh
        if (toolName.equals("manage_checklist")) {
            return;
        }
        
        // Create a single tool execution item and render it using MessageRenderer
        MessageRenderer.ToolExecutionData toolData = new MessageRenderer.ToolExecutionData(toolName, formattedArgs, result);
        MessageRenderer.RenderableItem item = new MessageRenderer.RenderableItem(
            MessageRenderer.RenderableItemType.TOOL_EXECUTION, "", toolData);
        
        List<MessageRenderer.RenderableItem> singleItem = new ArrayList<>();
        singleItem.add(item);
        messageRenderer.renderItems(singleItem);
    }
    
    
    
    private ToolExecutor.ToolExecutionResult findToolResult(String toolName, List<ConversationManager.Message> systemMessages) {
        // Find the system message containing results for this tool
        for (ConversationManager.Message msg : systemMessages) {
            if (msg.role.equals("system") && msg.content.contains("## Tool: " + toolName)) {
                return parseSystemMessageToToolResult(msg.content, toolName);
            }
        }
        return null;
    }
    
    private ToolExecutor.ToolExecutionResult parseSystemMessageToToolResult(String systemContent, String toolName) {
        try {
            String[] sections = systemContent.split("## Tool: " + toolName);
            if (sections.length < 2) return null;
            
            String toolSection = "## Tool: " + toolName + sections[1];
            String[] lines = toolSection.split("\n");
            if (lines.length < 2) return null;
            
            String summary = lines[1].trim();
            
            // Extract content between <contents> tags
            StringBuilder content = new StringBuilder();
            boolean inContents = false;
            for (int i = 2; i < lines.length; i++) {
                if (lines[i].equals("<contents>")) {
                    inContents = true;
                    continue;
                } else if (lines[i].equals("</contents>")) {
                    break;
                } else if (inContents) {
                    if (content.length() > 0) content.append("\n");
                    content.append(lines[i]);
                }
            }
            
            return new ToolExecutor.ToolExecutionResult(content.toString(), summary);
        } catch (Exception e) {
            log("Error parsing system message to tool result: " + e.getMessage());
            return null;
        }
    }
    
    private String extractMainParameterFromXML(String toolName, String toolParams) {
        try {
            String mainParamName = getMainParameterName(toolName);
            if (mainParamName != null) {
                String pattern = "<parameter name=\"" + mainParamName + "\">(.*?)</parameter>";
                java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.DOTALL);
                java.util.regex.Matcher m = p.matcher(toolParams);
                if (m.find()) {
                    return m.group(1).trim();
                }
            }
        } catch (Exception e) {
            log("Error extracting main parameter: " + e.getMessage());
        }
        return "";
    }
    
    private String formatToolArgumentsFromXML(String toolName, String toolParams) {
        try {
            StringBuilder args = new StringBuilder();
            
            switch (toolName) {
                case "git_read":
                    String projectPath = extractParameterFromXML(toolParams, "project_path");
                    String gitArgs = extractParameterFromXML(toolParams, "git_args");
                    String offset = extractParameterFromXML(toolParams, "offset");
                    String limit = extractParameterFromXML(toolParams, "limit");
                    
                    if (!projectPath.isEmpty()) args.append(projectPath);
                    if (!gitArgs.isEmpty()) args.append(" ").append(gitArgs);
                    if (!offset.isEmpty()) args.append(" offset=").append(offset);
                    if (!limit.isEmpty()) args.append(" limit=").append(limit);
                    break;
                    
                case "read_file":
                    String filePath = extractParameterFromXML(toolParams, "file_path");
                    String findString = extractParameterFromXML(toolParams, "find_string");
                    String fileLimit = extractParameterFromXML(toolParams, "limit");
                    
                    if (!filePath.isEmpty()) args.append(filePath);
                    if (!findString.isEmpty()) args.append(" find=\"").append(truncateString(findString, 20)).append("\"");
                    if (!fileLimit.isEmpty()) args.append(" limit=").append(fileLimit);
                    break;
                    
                case "create_file":
                    String createPath = extractParameterFromXML(toolParams, "file_path");
                    if (!createPath.isEmpty()) args.append(createPath);
                    break;
                    
                case "update_file":
                    String updatePath = extractParameterFromXML(toolParams, "file_path");
                    if (!updatePath.isEmpty()) args.append(updatePath);
                    break;
                    
                case "list_files":
                    String listPath = extractParameterFromXML(toolParams, "path");
                    if (!listPath.isEmpty()) args.append(listPath);
                    else args.append(".");
                    break;
                    
                case "list_recursive":
                    String recursivePath = extractParameterFromXML(toolParams, "path");
                    if (!recursivePath.isEmpty()) args.append(recursivePath);
                    else args.append(".");
                    break;
                    
                case "search_files":
                    String searchQuery = extractParameterFromXML(toolParams, "query");
                    if (!searchQuery.isEmpty()) args.append(searchQuery);
                    break;
                    
                case "search_content":
                    String contentQuery = extractParameterFromXML(toolParams, "query");
                    String filePattern = extractParameterFromXML(toolParams, "file_pattern");
                    
                    if (!contentQuery.isEmpty()) args.append(contentQuery);
                    if (!filePattern.isEmpty()) args.append(" pattern=").append(filePattern);
                    break;
                    
                case "delete_file":
                    String deletePath = extractParameterFromXML(toolParams, "file_path");
                    if (!deletePath.isEmpty()) args.append(deletePath);
                    break;
                    
                case "move_file":
                    String sourcePath = extractParameterFromXML(toolParams, "source_path");
                    String destPath = extractParameterFromXML(toolParams, "dest_path");
                    
                    if (!sourcePath.isEmpty()) args.append(sourcePath);
                    if (!destPath.isEmpty()) args.append(" -> ").append(destPath);
                    break;
                    
                case "create_directory":
                    String createDirPath = extractParameterFromXML(toolParams, "dir_path");
                    if (!createDirPath.isEmpty()) args.append(createDirPath);
                    break;
                    
                case "delete_directory_recursive":
                    String deleteDirPath = extractParameterFromXML(toolParams, "dir_path");
                    if (!deleteDirPath.isEmpty()) args.append(deleteDirPath);
                    break;
                    
                default:
                    // Fallback to old main parameter extraction
                    return extractMainParameterFromXML(toolName, toolParams);
            }
            
            return args.toString();
            
        } catch (Exception e) {
            log("Error formatting tool arguments: " + e.getMessage());
            return extractMainParameterFromXML(toolName, toolParams);
        }
    }
    
    private String extractParameterFromXML(String toolParams, String paramName) {
        try {
            String pattern = "<parameter name=\"" + paramName + "\">(.*?)</parameter>";
            java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.DOTALL);
            java.util.regex.Matcher m = p.matcher(toolParams);
            if (m.find()) {
                return m.group(1).trim();
            }
        } catch (Exception e) {
            log("Error extracting parameter " + paramName + ": " + e.getMessage());
        }
        return "";
    }
    
    private String truncateString(String str, int maxLength) {
        if (str.length() <= maxLength) return str;
        return str.substring(0, maxLength - 3) + "...";
    }
    
    private String getMainParameterName(String toolName) {
        switch (toolName) {
            case "read_file":
            case "create_file":
            case "delete_file":
                return "file_path";
            case "move_file":
                return "source_path";
            case "list_files":
            case "list_recursive":
                return "path";
            case "create_directory":
            case "delete_directory_recursive":
                return "dir_path";
            case "search_files":
            case "search_content":
                return "query";
            case "git_read":
                return "project_path";
            default:
                return null;
        }
    }
    
    public void displayConversation(List<ConversationManager.Message> conversation) {
        try {
            // Clear any loading message first
            clearLoadingMessage();
            
            log("DISPLAY: Starting conversation display with " + conversation.size() + " messages");
            
            // Count message types for debugging
            int userCount = 0, assistantCount = 0, checklistCount = 0, systemCount = 0;
            for (ConversationManager.Message msg : conversation) {
                switch (msg.role) {
                    case "user": userCount++; break;
                    case "assistant": assistantCount++; break;
                    case "checklist": checklistCount++; break;
                    case "system": systemCount++; break;
                }
            }
            log("DISPLAY: Message counts - user:" + userCount + ", assistant:" + assistantCount + 
                ", checklist:" + checklistCount + ", system:" + systemCount);
            
            // Clear screen and move to top
            System.out.print("\u001B[2J\u001B[H");
            
            System.out.println("=== Conversation ===");
            System.out.println();
            
            // Convert conversation to renderable items
            List<MessageRenderer.RenderableItem> renderableItems = convertConversationToRenderableItems(conversation);
            
            // Use centralized renderer for consistent spacing
            messageRenderer.renderItems(renderableItems);
            
            // Add one blank line after the conversation for input prompt spacing
            System.out.println();
            
        } catch (Exception e) {
            log("Error displaying conversation: " + e.getMessage());
            System.err.println("Error displaying conversation: " + e.getMessage());
        }
    }
    
    private List<MessageRenderer.RenderableItem> convertConversationToRenderableItems(List<ConversationManager.Message> conversation) {
        List<MessageRenderer.RenderableItem> items = new ArrayList<>();
        
        for (int i = 0; i < conversation.size(); i++) {
            ConversationManager.Message msg = conversation.get(i);
            
            if (msg.role.equals("user")) {
                items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.USER_MESSAGE, msg.content));
                
            } else if (msg.role.equals("assistant")) {
                if (msg.content.trim().startsWith("<execute>")) {
                    // Parse tool executions and add them as separate renderable items
                    List<ConversationManager.Message> followingSystemMessages = getFollowingSystemMessages(conversation, i);
                    addToolExecutionItems(items, msg.content, followingSystemMessages);
                } else {
                    // Regular assistant message
                    items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.ASSISTANT_MESSAGE, msg.content));
                }
                
            } else if (msg.role.equals("summary")) {
                items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.SUMMARY, msg.content));
                
            } else if (msg.role.equals("checklist")) {
                log("DISPLAY: Adding checklist renderable item with " + msg.content.length() + " chars");
                items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.CHECKLIST, msg.content));
                
            } else if (msg.role.equals("celebration")) {
                log("DISPLAY: Adding celebration renderable item with " + msg.content.length() + " chars");
                items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.CELEBRATION, msg.content));
                
            } else if (msg.role.equals("system")) {
                if ("command_output".equals(msg.type)) {
                    items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.SYSTEM_OUTPUT, msg.content));
                } else if (msg.content.startsWith("## Tool:")) {
                    // Skip system tool messages - they're handled by execute block processing
                    log("DISPLAY: Skipping system tool message (handled by execute block processing)");
                    continue;
                } else {
                    log("DISPLAY: Skipping system message (not a tool result)");
                    continue;
                }
            }
        }
        
        return items;
    }
    
    private List<ConversationManager.Message> getFollowingSystemMessages(List<ConversationManager.Message> conversation, int startIndex) {
        List<ConversationManager.Message> systemMessages = new ArrayList<>();
        for (int j = startIndex + 1; j < conversation.size(); j++) {
            ConversationManager.Message msg = conversation.get(j);
            if (msg.role.equals("system")) {
                systemMessages.add(msg);
            } else {
                break; // Stop at first non-system message
            }
        }
        return systemMessages;
    }
    
    private void addToolExecutionItems(List<MessageRenderer.RenderableItem> items, String xmlContent, List<ConversationManager.Message> systemMessages) {
        // Extract tool executions from <execute> block
        String toolPattern = "<tool name=\"([^\"]+)\">(.*?)</tool>";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(toolPattern, java.util.regex.Pattern.DOTALL);
        java.util.regex.Matcher m = p.matcher(xmlContent);
        
        while (m.find()) {
            String toolName = m.group(1);
            String toolParams = m.group(2);
            
            // Skip manage_checklist as it handles its own display
            if (toolName.equals("manage_checklist")) {
                continue;
            }
            
            // Format tool-specific arguments for display
            String formattedArgs = formatToolArgumentsFromXML(toolName, toolParams);
            
            // Find corresponding system message with tool results
            ToolExecutor.ToolExecutionResult result = findToolResult(toolName, systemMessages);
            if (result != null) {
                // Create tool execution renderable item using actual result
                MessageRenderer.ToolExecutionData toolData = new MessageRenderer.ToolExecutionData(toolName, formattedArgs, result);
                items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.TOOL_EXECUTION, "", toolData));
            } else {
                // Try to re-execute tool to get proper result instead of using generic fallback
                ToolExecutor.ToolExecutionResult reExecutedResult = tryReExecuteTool(toolName, toolParams);
                if (reExecutedResult != null) {
                    MessageRenderer.ToolExecutionData toolData = new MessageRenderer.ToolExecutionData(toolName, formattedArgs, reExecutedResult);
                    items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.TOOL_EXECUTION, "", toolData));
                } else {
                    // Last resort fallback: create a basic tool result
                    String summary = getToolSummary(toolName, extractMainParameterFromXML(toolName, toolParams));
                    ToolExecutor.ToolExecutionResult fallbackResult = new ToolExecutor.ToolExecutionResult("", summary);
                    MessageRenderer.ToolExecutionData toolData = new MessageRenderer.ToolExecutionData(toolName, formattedArgs, fallbackResult);
                    items.add(new MessageRenderer.RenderableItem(MessageRenderer.RenderableItemType.TOOL_EXECUTION, "", toolData));
                }
            }
        }
    }
    
    private ToolExecutor.ToolExecutionResult tryReExecuteTool(String toolName, String toolParams) {
        try {
            // For safe read-only operations, re-execute to get proper results
            switch (toolName) {
                case "read_file":
                case "list_files":  
                case "list_recursive":
                case "search_files":
                case "search_content":
                case "git_read":
                    // These are safe to re-execute for consistent display
                    return ToolExecutor.executeToolWithSummary(toolName, toolParams, null);
                default:
                    // Don't re-execute write operations or other potentially harmful tools
                    return null;
            }
        } catch (Exception e) {
            // If re-execution fails, return null to fall back to generic summary
            return null;
        }
    }
    
    
    public void showStatusMessage(String message) {
        System.out.println(ANSI_LIGHT_BLUE + "~{ " + message + " }~" + ANSI_RESET);
        statusMessageCount++;
    }
    
    public void clearStatusMessages() {
        for (int i = 0; i < statusMessageCount; i++) {
            // Move cursor up one line and clear it
            System.out.print("\u001B[1A\u001B[2K");
        }
        statusMessageCount = 0;
    }
    
    public void showLoadingMessage() {
        System.out.println();
        System.out.println(ANSI_GRAY + "Loading..." + ANSI_RESET);
        isShowingLoading = true;
    }
    
    public void clearLoadingMessage() {
        if (isShowingLoading) {
            // Move cursor up two lines and clear them
            System.out.print("\u001B[2A\u001B[2K\u001B[1B\u001B[2K");
            isShowingLoading = false;
        }
    }
    
    
    
    
    
    
    private String extractGitCommandFromContent(String content) {
        // Extract git command from the DISPLAY_INFO line format: "DISPLAY_INFO:lines|path|GIT:command"
        String[] lines = content.split("\n");
        if (lines.length > 0 && lines[0].startsWith("DISPLAY_INFO:")) {
            String displayInfo = lines[0].substring(13); // Remove "DISPLAY_INFO:"
            String[] infoParts = displayInfo.split("\\|");
            if (infoParts.length >= 3 && infoParts[2].startsWith("GIT:")) {
                return infoParts[2].substring(4); // Remove "GIT:" prefix
            }
        }
        return "";
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: FileOperations.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;
import java.nio.file.StandardCopyOption;
import java.util.*;

public class FileOperations {
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    private static String getWorkingDirectory() {
        return ConversationCLI.getWorkingDirectory();
    }
    
    private static Path resolvePath(String filePath) {
        Path path = Paths.get(filePath);
        if (path.isAbsolute()) {
            return path;
        } else {
            return Paths.get(getWorkingDirectory()).resolve(path);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeReadFileWithSummary(String toolParams) {
        try {
            String filePath = ToolParameterExtractor.extractParameter(toolParams, "file_path");
            String findString = ToolParameterExtractor.extractParameter(toolParams, "find_string");
            String limitStr = ToolParameterExtractor.extractParameter(toolParams, "limit");
            
            if (filePath == null || filePath.trim().isEmpty()) {
                String error = "Error: file_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Path path = resolvePath(filePath);
            
            if (!Files.exists(path)) {
                String error = "Error: File not found: " + filePath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            List<String> lines = Files.readAllLines(path);
            int startIndex = 0;
            int limit = lines.size();
            
            if (findString != null && !findString.trim().isEmpty()) {
                FindResult findResult = findStringInLines(lines, findString);
                if (findResult.isError()) {
                    return new ToolExecutor.ToolExecutionResult(findResult.errorMessage, findResult.errorMessage);
                }
                startIndex = findResult.lineIndex;
            }
            
            if (limitStr != null && !limitStr.trim().isEmpty()) {
                try {
                    limit = Integer.parseInt(limitStr.trim());
                } catch (NumberFormatException e) {
                    String error = "Error: limit parameter must be a valid number: " + limitStr;
                    return new ToolExecutor.ToolExecutionResult(error, error);
                }
            }
            
            int endIndex = Math.min(startIndex + limit, lines.size());
            StringBuilder content = new StringBuilder();
            
            for (int i = startIndex; i < endIndex; i++) {
                content.append(lines.get(i)).append("\n");
            }
            
            int linesRead = endIndex - startIndex;
            String summary = linesRead + " lines";
            
            if (findString != null && !findString.trim().isEmpty()) {
                summary += " starting from \"" + findString + "\"";
            }
            
            String enhancedResult = "DISPLAY_INFO:" + linesRead + "|" + filePath + "\n" + content.toString();
            
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error reading file: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeReadFileLinesWithSummary(String toolParams) {
        try {
            String filePath = ToolParameterExtractor.extractParameter(toolParams, "file_path");
            String startLineStr = ToolParameterExtractor.extractParameter(toolParams, "start_line");
            String endLineStr = ToolParameterExtractor.extractParameter(toolParams, "end_line");

            if (filePath == null || filePath.trim().isEmpty()) {
                String error = "Error: file_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            if (startLineStr == null || startLineStr.trim().isEmpty()) {
                String error = "Error: start_line parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            if (endLineStr == null || endLineStr.trim().isEmpty()) {
                String error = "Error: end_line parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            Path path = resolvePath(filePath);

            if (!Files.exists(path)) {
                String error = "Error: File not found: " + filePath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            int startLine, endLine;
            try {
                startLine = Integer.parseInt(startLineStr.trim());
                endLine = Integer.parseInt(endLineStr.trim());
            } catch (NumberFormatException e) {
                String error = "Error: start_line and end_line must be valid numbers";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            if (startLine < 1) {
                String error = "Error: start_line must be >= 1 (line numbers are 1-indexed)";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            if (endLine < startLine) {
                String error = "Error: end_line must be >= start_line";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            List<String> lines = Files.readAllLines(path);

            // Convert to 0-indexed
            int startIndex = startLine - 1;
            int endIndex = Math.min(endLine, lines.size()); // endLine is inclusive, but we use it as exclusive upper bound

            if (startIndex >= lines.size()) {
                String error = String.format("Error: start_line %d exceeds file length (%d lines)", startLine, lines.size());
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            StringBuilder content = new StringBuilder();

            for (int i = startIndex; i < endIndex; i++) {
                content.append(String.format("%d: %s\n", i + 1, lines.get(i)));
            }

            int linesRead = endIndex - startIndex;
            String summary = String.format("Lines %d-%d (%d lines)", startLine, endIndex, linesRead);

            String enhancedResult = "DISPLAY_INFO:" + linesRead + "|" + filePath + "\n" + content.toString();

            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);

        } catch (Exception e) {
            String error = "Error reading file lines: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }

    public static ToolExecutor.ToolExecutionResult executeCreateFileWithSummary(String toolParams) {
        try {
            String filePath = ToolParameterExtractor.extractParameter(toolParams, "file_path");
            String content = ToolParameterExtractor.extractParameter(toolParams, "content");

            if (filePath == null || filePath.trim().isEmpty()) {
                String error = "Error: file_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            if (content == null) {
                content = "";
            }
            
            Path path = resolvePath(filePath);
            
            Path parentDir = path.getParent();
            if (parentDir != null && !Files.exists(parentDir)) {
                Files.createDirectories(parentDir);
            }
            
            Files.write(path, content.getBytes());
            
            long lines = content.isEmpty() ? 0 : content.split("\n").length;
            String summary = "Created (" + lines + " lines)";
            
            // Generate diff display for new file (all lines are additions)
            String diffContent = generateCreateFileDiff(content);
            String enhancedResult = "DISPLAY_INFO:" + lines + "|" + filePath + "\n\n" + diffContent;
            
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error creating file: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeDeleteFileWithSummary(String toolParams) {
        try {
            String filePath = ToolParameterExtractor.extractParameter(toolParams, "file_path");
            
            if (filePath == null || filePath.trim().isEmpty()) {
                String error = "Error: file_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Path path = resolvePath(filePath);
            
            if (!Files.exists(path)) {
                String error = "Error: File not found: " + filePath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Files.delete(path);
            
            String fullResult = String.format("File: %s\nDeleted successfully", filePath);
            String summary = "File deleted";
            
            String enhancedResult = "DISPLAY_INFO:0|" + filePath + "\n" + fullResult;
            
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error deleting file: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeMoveFileWithSummary(String toolParams) {
        try {
            String sourcePath = ToolParameterExtractor.extractParameter(toolParams, "source_path");
            String destPath = ToolParameterExtractor.extractParameter(toolParams, "dest_path");
            
            if (sourcePath == null || sourcePath.trim().isEmpty()) {
                String error = "Error: source_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            if (destPath == null || destPath.trim().isEmpty()) {
                String error = "Error: dest_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Path source = resolvePath(sourcePath);
            Path dest = resolvePath(destPath);
            
            if (!Files.exists(source)) {
                String error = "Error: Source file not found: " + sourcePath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Path destParent = dest.getParent();
            if (destParent != null && !Files.exists(destParent)) {
                Files.createDirectories(destParent);
            }
            
            Files.move(source, dest, StandardCopyOption.REPLACE_EXISTING);
            
            String fullResult = String.format("File moved successfully\nFrom: %s\nTo: %s", sourcePath, destPath);
            String summary = "File moved";
            
            long fileSize = Files.size(dest);
            long lines = 0;
            try {
                lines = Files.lines(dest).count();
            } catch (Exception e) {
                // Non-text file or reading issue, keep lines as 0
            }
            
            String enhancedResult = "DISPLAY_INFO:" + lines + "|" + destPath + "\n" + fullResult;
            
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error moving file: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeUpdateFileWithSummary(String toolParams) {
        try {
            String filePath = ToolParameterExtractor.extractParameter(toolParams, "file_path");
            String findString = ToolParameterExtractor.extractParameter(toolParams, "find_string");
            String replaceString = ToolParameterExtractor.extractParameter(toolParams, "replace_string");
            
            if (filePath == null || filePath.trim().isEmpty()) {
                String error = "Error: file_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            if (findString == null || findString.trim().isEmpty()) {
                String error = "Error: find_string parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            if (replaceString == null) {
                replaceString = ""; // Allow replacing with empty string
            }
            
            Path path = resolvePath(filePath);
            
            if (!Files.exists(path)) {
                String error = "Error: File not found: " + filePath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            // Read the file content
            String content = new String(Files.readAllBytes(path));
            
            // Count occurrences of find_string
            int occurrences = countOccurrences(content, findString);
            
            if (occurrences == 0) {
                String error = String.format("Error: String '%s' not found in file %s", findString, filePath);
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            if (occurrences > 1) {
                String error = String.format("Error: String '%s' appears %d times in file %s. The find_string must be unique to avoid ambiguity.", 
                    findString, occurrences, filePath);
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            // Perform the replacement (we know it's exactly 1 occurrence)
            String updatedContent = content.replace(findString, replaceString);
            
            // Write the updated content back to the file
            Files.write(path, updatedContent.getBytes());
            
            // Calculate line changes
            long originalLines = content.isEmpty() ? 0 : content.split("\n").length;
            long updatedLines = updatedContent.isEmpty() ? 0 : updatedContent.split("\n").length;
            long lineChange = updatedLines - originalLines;
            
            String changeInfo = "";
            if (lineChange > 0) {
                changeInfo = String.format(" (+%d lines)", lineChange);
            } else if (lineChange < 0) {
                changeInfo = String.format(" (%d lines)", lineChange);
            }
            
            String summary = "Updated" + changeInfo;
            
            // Generate context diff for display - this is all we need to show
            String contextDiff = generateContextDiff(content, findString, replaceString);
            String enhancedResult = "DISPLAY_INFO:" + updatedLines + "|" + filePath + "\n\n" + contextDiff;
            
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error updating file: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    private static int countOccurrences(String text, String searchString) {
        int count = 0;
        int index = 0;
        while ((index = text.indexOf(searchString, index)) != -1) {
            count++;
            index += searchString.length();
        }
        return count;
    }
    
    private static String generateContextDiff(String originalContent, String findString, String replaceString) {
        try {
            String[] originalLines = originalContent.split("\n");
            
            // Find the line(s) containing the findString
            int findStartLine = -1;
            int findEndLine = -1;
            
            for (int i = 0; i < originalLines.length; i++) {
                if (originalLines[i].contains(findString)) {
                    if (findStartLine == -1) {
                        findStartLine = i;
                    }
                    findEndLine = i;
                }
            }
            
            if (findStartLine == -1) {
                // If we can't find the exact string, try to find it in the full content
                // This handles multi-line replacements better
                String fullContent = String.join("\n", originalLines);
                if (fullContent.contains(findString)) {
                    // Found it in content but line-by-line search failed
                    // Show a simple before/after diff
                    StringBuilder diff = new StringBuilder();
                    String[] findLines = findString.split("\n");
                    String[] replaceLines = replaceString.split("\n");
                    
                    for (String line : findLines) {
                        diff.append("- ").append(line).append("\n");
                    }
                    for (String line : replaceLines) {
                        diff.append("+ ").append(line).append("\n");
                    }
                    return diff.toString().replaceAll("\\s+$", "");
                } else {
                    // Last resort fallback - show clean diff format instead of verbose
                    StringBuilder diff = new StringBuilder();
                    String[] findLines = findString.split("\n");
                    String[] replaceLines = replaceString.split("\n");
                    
                    for (String line : findLines) {
                        diff.append("- ").append(line).append("\n");
                    }
                    for (String line : replaceLines) {
                        diff.append("+ ").append(line).append("\n");
                    }
                    return diff.toString().replaceAll("\\s+$", "");
                }
            }
            
            // Show context: 3 lines before and 3 lines after
            int contextStart = Math.max(0, findStartLine - 3);
            int contextEnd = Math.min(originalLines.length - 1, findEndLine + 3);
            
            StringBuilder diff = new StringBuilder();
            
            // Add context lines before the change
            for (int i = contextStart; i < findStartLine; i++) {
                diff.append("  ").append(originalLines[i]).append("\n");
            }
            
            // Smart diff: detect insertion vs replacement patterns
            String[] oldLines = findString.split("\n");
            String[] newLines = replaceString.split("\n");
            
            // Check if this is an insertion pattern (replaceString contains findString + more content)
            if (oldLines.length == 1 && newLines.length > 1 && replaceString.startsWith(findString)) {
                // This is an insertion after existing content - show unchanged part and additions only
                
                // Show the unchanged content as context (not as removal/addition)
                diff.append("  ").append(oldLines[0]).append("\n");
                
                // Show only the newly added lines (skip the first one which is the unchanged original)
                for (int i = 1; i < newLines.length; i++) {
                    diff.append("+ ").append(newLines[i]).append("\n");
                }
            } else {
                // This is a replacement - show removed and added lines only (no duplicate context)
                
                // Show removed lines 
                for (String oldLine : oldLines) {
                    diff.append("- ").append(oldLine).append("\n");
                }
                
                // Show added lines
                for (String newLine : newLines) {
                    diff.append("+ ").append(newLine).append("\n");
                }
            }
            
            // Add context lines after the change
            for (int i = findEndLine + 1; i <= contextEnd; i++) {
                diff.append("  ").append(originalLines[i]).append("\n");
            }
            
            // Don't trim - this would remove the leading spaces from context lines
            String result = diff.toString();
            // Only remove trailing whitespace, preserve leading spaces for diff prefixes
            return result.replaceAll("\\s+$", "");
            
        } catch (Exception e) {
            // Fallback to simple format if anything goes wrong
            return String.format("Replaced: '%s'\nWith: '%s'", findString, replaceString);
        }
    }
    
    private static FindResult findStringInLines(List<String> lines, String findString) {
        for (int i = 0; i < lines.size(); i++) {
            if (lines.get(i).contains(findString)) {
                return FindResult.success(i);
            }
        }
        return FindResult.error("String not found: " + findString);
    }
    
    private static class FindResult {
        boolean isError;
        String errorMessage;
        int lineIndex;
        
        FindResult(boolean isError, String errorMessage, int lineIndex) {
            this.isError = isError;
            this.errorMessage = errorMessage;
            this.lineIndex = lineIndex;
        }
        
        boolean isError() {
            return isError;
        }
        
        static FindResult success(int lineIndex) {
            return new FindResult(false, null, lineIndex);
        }
        
        static FindResult error(String message) {
            return new FindResult(true, message, -1);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeGitReadWithSummary(String toolParams) {
        try {
            String projectPath = ToolParameterExtractor.extractParameter(toolParams, "project_path");
            String gitArgs = ToolParameterExtractor.extractParameter(toolParams, "git_args");
            String offsetStr = ToolParameterExtractor.extractParameter(toolParams, "offset");
            String limitStr = ToolParameterExtractor.extractParameter(toolParams, "limit");
            
            if (projectPath == null || projectPath.trim().isEmpty()) {
                String error = "Error: project_path parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            if (gitArgs == null || gitArgs.trim().isEmpty()) {
                String error = "Error: git_args parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Path projectDir = resolvePath(projectPath);
            if (!Files.exists(projectDir) || !Files.isDirectory(projectDir)) {
                String error = "Error: Project directory not found: " + projectPath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            // Check if it's a git repository
            Path gitDir = projectDir.resolve(".git");
            if (!Files.exists(gitDir)) {
                String error = "Error: Not a git repository: " + projectPath;
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            // Validate git command safety
            String[] args = gitArgs.trim().split("\\s+");
            if (args.length == 0) {
                String error = "Error: git_args cannot be empty";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            // Check whitelist for first argument (git command)
            String gitCommand = args[0].toLowerCase();
            if (!isAllowedGitCommand(gitCommand)) {
                String error = "Error: Git command '" + gitCommand + "' is not allowed. Only read-only commands are permitted.";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            // Check blacklist for dangerous arguments
            for (String arg : args) {
                if (isBlacklistedGitArg(arg)) {
                    String error = "Error: Git argument '" + arg + "' is not allowed for security reasons.";
                    return new ToolExecutor.ToolExecutionResult(error, error);
                }
            }
            
            // Execute git command
            ProcessBuilder pb = new ProcessBuilder();
            pb.command("git", "-C", projectDir.toAbsolutePath().toString());
            for (String arg : args) {
                pb.command().add(arg);
            }
            pb.redirectErrorStream(true);
            
            Process process = pb.start();
            
            // Read output
            StringBuilder output = new StringBuilder();
            try (java.io.BufferedReader reader = new java.io.BufferedReader(
                    new java.io.InputStreamReader(process.getInputStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }
            }
            
            int exitCode = process.waitFor();
            if (exitCode != 0) {
                String error = "Git command failed with exit code " + exitCode + ":\n" + output.toString();
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            String fullOutput = output.toString();
            String[] outputLines = fullOutput.split("\n");
            
            // Apply offset and limit if provided
            int offset = 0;
            int limit = outputLines.length;
            
            if (offsetStr != null && !offsetStr.trim().isEmpty()) {
                try {
                    offset = Integer.parseInt(offsetStr.trim());
                } catch (NumberFormatException e) {
                    String error = "Error: offset parameter must be a valid number: " + offsetStr;
                    return new ToolExecutor.ToolExecutionResult(error, error);
                }
            }
            
            if (limitStr != null && !limitStr.trim().isEmpty()) {
                try {
                    limit = Integer.parseInt(limitStr.trim());
                } catch (NumberFormatException e) {
                    String error = "Error: limit parameter must be a valid number: " + limitStr;
                    return new ToolExecutor.ToolExecutionResult(error, error);
                }
            }
            
            // Extract the requested slice of output
            int startIndex = Math.max(0, Math.min(offset, outputLines.length));
            int endIndex = Math.min(startIndex + limit, outputLines.length);
            
            StringBuilder slicedOutput = new StringBuilder();
            for (int i = startIndex; i < endIndex; i++) {
                if (i > startIndex) slicedOutput.append("\n");
                slicedOutput.append(outputLines[i]);
            }
            
            int linesShown = endIndex - startIndex;
            String summary = "git " + gitCommand + ": " + linesShown + " lines";
            if (offset > 0) {
                summary += " (offset " + offset + ")";
            }
            
            // Use standard 4-part format but put git command info in a way that can be extracted
            String enhancedResult = "DISPLAY_INFO:" + linesShown + "|" + projectPath + "|GIT:" + gitArgs + "\n" + slicedOutput.toString();
            
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error executing git command: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    private static boolean isAllowedGitCommand(String command) {
        // Whitelist of safe, read-only git commands
        String[] allowedCommands = {
            "status", "log", "show", "diff", "branch", "remote", "tag",
            "ls-files", "ls-tree", "ls-remote", "rev-parse", "describe", 
            "config", "blame", "annotate", "reflog", "shortlog", "whatchanged",
            "cat-file", "rev-list", "name-rev", "symbolic-ref", "for-each-ref",
            "merge-base", "show-branch", "show-ref"
        };
        
        for (String allowed : allowedCommands) {
            if (command.equals(allowed)) {
                return true;
            }
        }
        return false;
    }
    
    private static boolean isBlacklistedGitArg(String arg) {
        // Blacklist of dangerous arguments
        String[] blacklistedArgs = {
            "--exec", "--upload-pack", "--receive-pack", "--upload-archive",
            "--exec=", "--upload-pack=", "--receive-pack=", "--upload-archive="
        };
        
        for (String blacklisted : blacklistedArgs) {
            if (arg.equals(blacklisted) || arg.startsWith(blacklisted)) {
                return true;
            }
        }
        return false;
    }
    
    private static String generateCreateFileDiff(String content) {
        if (content.isEmpty()) {
            return ""; // Empty file, no diff to show
        }
        
        StringBuilder diff = new StringBuilder();
        String[] lines = content.split("\n", -1); // -1 to preserve trailing empty strings
        
        for (String line : lines) {
            diff.append("+ ").append(line).append("\n");
        }
        
        return diff.toString();
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: Logger.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Logger {
    
    public static void log(String message) {
        try {
            String logFile = ConversationCLI.getLogFile();
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
            String logMessage = "[" + timestamp + "] " + message + "\n";
            Files.write(Paths.get(logFile), logMessage.getBytes(), 
                       StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } catch (Exception e) {
            System.err.println("Failed to write to log: " + e.getMessage());
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: MessageRenderer.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.util.*;

/**
 * Centralized message renderer that handles all display formatting and spacing.
 * Eliminates scattered spacing logic by providing a single source of truth for display rules.
 */
public class MessageRenderer {
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_GRAY = "\u001B[90m";
    public static final String ANSI_GOLD = "\u001B[33m";
    public static final String ANSI_RED = "\u001B[31m";
    public static final String ANSI_WHITE = "\u001B[37m";
    public static final String ANSI_CYAN = "\u001B[36m";
    public static final String ANSI_LIGHT_BLUE = "\u001B[94m";
    public static final String ANSI_BLUE = "\u001B[34m";
    public static final String ANSI_DIM = "\u001B[2m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_LIGHT_GREEN = "\u001B[92m";
    public static final String ANSI_DARK_GREEN = "\u001B[2;32m";
    public static final String ANSI_DARK_RED = "\u001B[2;31m";
    
    private int wrapWidth = 100;
    
    public void setWrapWidth(int wrapWidth) {
        this.wrapWidth = wrapWidth;
    }
    
    /**
     * Renders a list of renderable items with consistent spacing between all items.
     * This is the single method responsible for ALL spacing decisions.
     */
    public void renderItems(List<RenderableItem> items) {
        for (int i = 0; i < items.size(); i++) {
            RenderableItem item = items.get(i);
            boolean isLastItem = (i == items.size() - 1);
            
            // Render the item content
            renderSingleItem(item);
            
            // Apply consistent spacing: exactly one blank line between items (but not after the last one)
            if (!isLastItem) {
                System.out.println();
            }
        }
    }
    
    private void renderSingleItem(RenderableItem item) {
        switch (item.type) {
            case USER_MESSAGE:
                renderUserMessage(item);
                break;
            case ASSISTANT_MESSAGE:
                renderAssistantMessage(item);
                break;
            case TOOL_EXECUTION:
                renderToolExecution(item);
                break;
            case CHECKLIST:
                renderChecklist(item);
                break;
            case CELEBRATION:
                renderCelebration(item);
                break;
            case SUMMARY:
                renderSummary(item);
                break;
            case SYSTEM_OUTPUT:
                renderSystemOutput(item);
                break;
        }
    }
    
    private void renderUserMessage(RenderableItem item) {
        System.out.println(ANSI_GRAY + "> " + item.content + ANSI_RESET);
    }
    
    private void renderAssistantMessage(RenderableItem item) {
        String[] lines = wrapText(item.content, wrapWidth);
        for (String line : lines) {
            System.out.println(ANSI_GOLD + "| " + line + ANSI_RESET);
        }
    }
    
    private void renderToolExecution(RenderableItem item) {
        ToolExecutionData toolData = (ToolExecutionData) item.data;
        
        // Display tool execution header (green brackets)
        String toolDisplay = toolData.toolName.toUpperCase();
        String paramDisplay = toolData.formattedArgs.isEmpty() ? "" : " " + toolData.formattedArgs;
        System.out.println(ANSI_GREEN + "  [" + toolDisplay + "]" + paramDisplay + ANSI_RESET);
        
        // Display tool-specific content
        if (toolData.toolName.equals("create_file") || toolData.toolName.equals("update_file")) {
            renderFileOperationDiff(toolData.result.fullResult, toolData.toolName);
        } else {
            System.out.println(ANSI_DARK_GREEN + "    " + toolData.result.summary + ANSI_RESET);
        }
    }
    
    private void renderChecklist(RenderableItem item) {
        String[] lines = item.content.split("\\n");
        for (String line : lines) {
            System.out.println(ANSI_CYAN + "  " + line + ANSI_RESET);
        }
    }
    
    private void renderCelebration(RenderableItem item) {
        String[] lines = item.content.split("\\n");
        for (String line : lines) {
            System.out.println(ANSI_LIGHT_GREEN + "  " + line + ANSI_RESET);
        }
    }
    
    private void renderSummary(RenderableItem item) {
        System.out.println(ANSI_CYAN + "[SUMMARY]" + ANSI_RESET);
        String[] lines = wrapText(item.content, wrapWidth - 4);
        for (String line : lines) {
            System.out.println(ANSI_CYAN + "| " + line + ANSI_RESET);
        }
    }
    
    private void renderSystemOutput(RenderableItem item) {
        System.out.println(ANSI_LIGHT_GREEN + "| " + item.content + ANSI_RESET);
    }
    
    public void renderFileOperationDiff(String fullResult, String toolName) {
        // Parse DISPLAY_INFO format: "DISPLAY_INFO:lines|filepath\nresult\n\ndiff"
        if (!fullResult.startsWith("DISPLAY_INFO:")) {
            // Fallback to just showing the summary
            System.out.println(ANSI_DARK_GREEN + "    " + fullResult + ANSI_RESET);
            return;
        }
        
        // Find the diff content after first \n
        int firstNewline = fullResult.indexOf('\n');
        if (firstNewline == -1) {
            return;
        }
        
        // Skip the DISPLAY_INFO line and get everything after the next \n
        int secondNewline = fullResult.indexOf('\n', firstNewline + 1);
        if (secondNewline == -1) {
            return;
        }
        
        String diffContent = fullResult.substring(secondNewline + 1);
        if (diffContent.isEmpty()) return;
        
        // For all file operations, just show the clean diff
        renderCleanDiff(diffContent);
    }
    
    private void renderCleanDiff(String content) {
        String[] lines = content.split("\\n");
        for (String line : lines) {
            if (line.startsWith("+ ")) {
                // Green for additions - align with [
                System.out.println(ANSI_GREEN + line + ANSI_RESET);
            } else if (line.startsWith("- ")) {
                // Red for deletions - align with [
                System.out.println(ANSI_RED + line + ANSI_RESET);
            } else if (line.startsWith("  ")) {
                // Gray for context lines - align with [
                System.out.println(ANSI_GRAY + line + ANSI_RESET);
            } else {
                // For lines without proper diff prefix, check if it looks like context (indented) or addition
                if (line.trim().isEmpty()) {
                    // Skip empty lines
                    System.out.println();
                } else {
                    // Treat unformatted content as additions (for create_file only) - align with [
                    System.out.println(ANSI_GREEN + "  + " + line + ANSI_RESET);
                }
            }
        }
    }
    
    /**
     * Render checklist result from manage_checklist tool
     */
    public void renderChecklistResult(String fullResult) {
        // Parse DISPLAY_INFO format for checklist: "DISPLAY_INFO:count|checklist"
        if (fullResult.startsWith("DISPLAY_INFO:")) {
            // Extract the count and show summary
            String[] parts = fullResult.split("\\|", 2);
            if (parts.length > 0) {
                String countInfo = parts[0].substring("DISPLAY_INFO:".length());
                System.out.println(ANSI_DARK_GREEN + "    " + countInfo + " tasks" + ANSI_RESET);
            }
        } else {
            // Fallback to just showing the result
            System.out.println(ANSI_DARK_GREEN + "    " + fullResult + ANSI_RESET);
        }
    }
    
    
    private String extractActualContent(String content) {
        String[] lines = content.split("\\n");
        StringBuilder actualContent = new StringBuilder();
        boolean skipFirst = lines.length > 0 && lines[0].startsWith("DISPLAY_INFO:");
        
        for (int i = skipFirst ? 1 : 0; i < lines.length; i++) {
            if (actualContent.length() > 0) {
                actualContent.append("\\n");
            }
            actualContent.append(lines[i]);
        }
        
        return actualContent.toString();
    }
    
    private String[] wrapText(String text, int width) {
        List<String> lines = new ArrayList<>();
        
        String[] paragraphs = text.split("\\n");
        
        for (String paragraph : paragraphs) {
            if (paragraph.trim().isEmpty()) {
                lines.add("");
                continue;
            }
            
            String[] words = paragraph.split("\\s+");
            StringBuilder currentLine = new StringBuilder();
            
            for (String word : words) {
                if (currentLine.length() + word.length() + 1 > width) {
                    if (currentLine.length() > 0) {
                        lines.add(currentLine.toString());
                        currentLine = new StringBuilder();
                    }
                }
                if (currentLine.length() > 0) {
                    currentLine.append(" ");
                }
                currentLine.append(word);
            }
            
            if (currentLine.length() > 0) {
                lines.add(currentLine.toString());
            }
        }
        
        return lines.toArray(new String[0]);
    }
    
    // Data classes for renderable items
    public enum RenderableItemType {
        USER_MESSAGE,
        ASSISTANT_MESSAGE,
        TOOL_EXECUTION,
        CHECKLIST,
        CELEBRATION,
        SUMMARY,
        SYSTEM_OUTPUT
    }
    
    public static class RenderableItem {
        public RenderableItemType type;
        public String content;
        public Object data; // For additional data like ToolExecutionData
        
        public RenderableItem(RenderableItemType type, String content) {
            this.type = type;
            this.content = content;
        }
        
        public RenderableItem(RenderableItemType type, String content, Object data) {
            this.type = type;
            this.content = content;
            this.data = data;
        }
    }
    
    public static class ToolExecutionData {
        public String toolName;
        public String formattedArgs;
        public ToolExecutor.ToolExecutionResult result;
        
        public ToolExecutionData(String toolName, String formattedArgs, ToolExecutor.ToolExecutionResult result) {
            this.toolName = toolName;
            this.formattedArgs = formattedArgs;
            this.result = result;
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: PromptGenerator.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;
import java.util.List;

public class PromptGenerator {
private static final String BASE_SYSTEM_PROMPT = "<system-reminder>\n" +
        "Never start responses by saying a question, idea, or observation was good, great, fascinating, profound, excellent, or any other positive adjective. Skip flattery and respond directly.\n\n" +
        "Critically evaluate code proposals, architecture decisions, technical theories, claims, and ideas rather than automatically agreeing or praising them. When presented with dubious, incorrect, ambiguous, or unverifiable approaches, respectfully point out flaws, potential security issues, performance concerns, or lack of clarity rather than validating them. Prioritize technical accuracy and best practices over agreeability.\n\n" +
        "Provide honest and accurate technical feedback even when it might not be what the developer hopes to hear, rather than prioritizing immediate approval or agreement. While remaining helpful, maintain objectivity about code quality, point out anti-patterns, suggest improvements, and identify potential issues. A developer's long-term success is often best served by honest, constructive technical feedback.\n\n" +
        "Do not use emojis unless the person asks for it or if the person's message contains an emoji, and be judicious about emoji use even then.\n\n" +
        "Avoid emotes or actions inside asterisks unless specifically requested.\n" +
        "</system-reminder>\n\n" +
        "You are a Windows Code Assistant, an interactive CLI tool that helps users with software engineering tasks. Use the instructions below and the tools available to you to assist the user.\n\n" +
        "**IMPORTANT:** Assist with defensive security tasks only. Refuse to create, modify, or improve code that may be used maliciously. Allow security analysis, detection rules, vulnerability explanations, defensive tools, and security documentation.\n\n" +
        "**IMPORTANT:** You must NEVER generate or guess URLs for the user unless you are confident that the URLs are for helping the user with programming. You may use URLs provided by the user in their messages or local files.\n\n" +
        "## Core Operational Guidelines\n\n" +
        "Do what has been asked; nothing more, nothing less.\n" +
        "NEVER create files unless they're absolutely necessary for achieving your goal.\n" +
        "ALWAYS prefer editing an existing file to creating a new one.\n" +
        "NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.\n\n" +
        "## Tone and Style\n\n" +
        "- Be friendly but professional with a helpful, knowledgeable tone while staying focused\n" +
        "- Be concise but helpful - provide brief context when useful for understanding\n" +
        "- Keep responses brief (typically 2-4 lines) unless more detail is specifically needed\n" +
        "- Only address the specific query or task at hand, avoiding tangential information unless absolutely critical\n" +
        "- Should NOT answer with unnecessary preamble or postamble unless the user asks you to\n" +
        "- When modifying code, include a one-line explanation of what changed and why\n" +
        "- Answer the user's question directly with brief but complete information\n\n" +
        "### Response Examples\n\n" +
        "- User: \"2 + 2\" -> Assistant: \"4\"\n" +
        "- User: \"what is 2+2?\" -> Assistant: \"4\"\n" +
        "- User: \"is 11 a prime number?\" -> Assistant: \"Yes, 11 is prime (only divisible by 1 and itself)\"\n" +
        "- User: \"what command should I run to list files in the current directory?\" -> Assistant: \"`dir` lists files in the current directory\"\n\n" +
        "## Proactiveness\n\n" +
        "You are allowed to be proactive, but only when the user asks you to do something. Strike a balance between:\n" +
        "- Doing the right thing when asked, including taking actions and follow-up actions\n" +
        "- Not surprising the user with actions you take without asking\n\n" +
        "## Following Conventions\n\n" +
        "When making changes to files, first understand the file's code conventions:\n" +
        "- Mimic code style, use existing libraries and utilities, and follow existing patterns\n" +
        "- **NEVER** assume that a given library is available, even if it is well known\n" +
        "- Whenever you write code that uses a library or framework, first check that this codebase already uses the given library\n" +
        "- When you create a new component, first look at existing components to see how they're written\n" +
        "- When you edit a piece of code, first look at the code's surrounding context to understand the code's choice of frameworks and libraries\n" +
        "- Always follow security best practices. Never introduce code that exposes or logs secrets and keys. Never commit secrets or keys to the repository\n\n" +
        "## Code Style\n\n" +
        "- **IMPORTANT:** DO NOT ADD ***ANY*** COMMENTS unless asked\n" +
        "- **IMPORTANT:** DO NOT USE UNICODE CHARACTERS (emojis, symbols, etc.) in responses. Use standard ASCII text only\n\n" +
        "---\n\n" +
        "**Note:** This prompt is designed to be used as the first message in a conversation along with the actual user input.\n\n";
    
    private String currentProjectStructure = "";
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    private String generateCoreSystemPrompt(ConversationManager conversationManager, boolean isAutomaticMode) {
        StringBuilder prompt = new StringBuilder();
        
        // Add base system prompt
        prompt.append(BASE_SYSTEM_PROMPT);
        
        // Add context-aware tools
        prompt.append("\n\n").append(generateAvailableTools(conversationManager));
        
        // Add tool usage guidelines and response format
        prompt.append("## Tool Usage Guidelines\n\n");
        prompt.append("**CRITICAL:** When using tools:\n");
        prompt.append("- **CRITICAL:** Each response must be EITHER tools OR a message, never both\n");
        prompt.append("- If you need information, use <execute> with tools and NO message\n");
        prompt.append("- If you have enough information, provide ONLY a <message> with NO tools\n");
        prompt.append("- **ALWAYS** batch as many tool calls as possible into a single execute block\n");
        prompt.append("- Use multiple tools simultaneously whenever you can anticipate what information you'll need\n");
        prompt.append("- Never provide running commentary during tool execution\n");
        
        // Different checklist requirements based on mode
        if (isAutomaticMode) {
            prompt.append("- **MANDATORY:** ALWAYS create a checklist with manage_checklist FIRST, before any other tools\n\n");
        } else {
            prompt.append("- **IMPORTANT:** For complex tasks requiring multiple steps, use manage_checklist FIRST to track progress\n\n");
        }
        
        prompt.append("## Checklist Usage Guidelines\n\n");
        
        if (isAutomaticMode) {
            prompt.append("**DEFAULT: Create checklist for ALL tasks using manage_checklist as your FIRST action**\n\n");
            
            prompt.append("**ONLY skip checklist for these rare exceptions:**\n");
            prompt.append("- Single word answers or simple math (e.g., 'What is 2+2?')\n");
            prompt.append("- Pure explanatory questions with no action required\n");
            prompt.append("- Reading a single file when specifically asked to read it\n");
            prompt.append("- One-line code fixes when file location is already known\n\n");
            
            prompt.append("**For everything else, ALWAYS start with manage_checklist:**\n");
            prompt.append("- ANY file creation, modification, or project work\n");
            prompt.append("- ANY multi-step process or task breakdown\n");
            prompt.append("- ALL programming, development, or technical work\n");
            prompt.append("- Mark ONE task as in_progress when working on it, complete immediately when finished\n\n");
        } else {
            prompt.append("**Use manage_checklist proactively for:**\n");
            prompt.append("- Complex multi-step tasks (3+ distinct steps or actions)\n");
            prompt.append("- Non-trivial tasks requiring careful planning or multiple operations\n");
            prompt.append("- When user provides multiple tasks (numbered or comma-separated)\n");
            prompt.append("- After receiving new instructions to capture requirements as todos\n");
            prompt.append("- **IMPORTANT EXAMPLES:** 'expand to multi-user app', 'convert to Angular', 'add authentication', etc.\n");
            prompt.append("- Mark ONE task as in_progress when working on it, complete immediately when finished\n\n");
            
            prompt.append("**Skip checklist for:**\n");
            prompt.append("- Single, straightforward tasks\n");
            prompt.append("- Trivial tasks providing no organizational benefit\n");
            prompt.append("- Tasks completable in less than 3 trivial steps\n");
            prompt.append("- Purely conversational or informational requests\n\n");
        }
        
        prompt.append("## Response Format\n\n");
        prompt.append("IMPORTANT: Respond with EITHER a message OR tool execution, never both:\n\n");
        prompt.append("For messages:\n<message>Your response</message>\n\n");
        prompt.append("For tool execution:\n<execute>\n  <tool name=\"tool_name\">\n    <parameter name=\"param_name\">value</parameter>\n  </tool>\n  <tool name=\"another_tool\">\n    <parameter name=\"param_name\">value</parameter>\n  </tool>\n</execute>\n\n");
        prompt.append("Rules:\n- Use <execute> when you need to gather information or perform actions\n");
        prompt.append("- Use <message> when you want to communicate with the user (analysis, results, questions, etc.)\n");
        prompt.append("- **CRITICAL:** After executing tools, you MUST provide a <message> analyzing the results\n");
        prompt.append("- Never use both <execute> and <message> in the same response\n");
        prompt.append("- Put ALL related tool calls in a single <execute> block\n");
        prompt.append("- Keep messages concise per the tone guidelines above\n\n");
        
        prompt.append("Examples:\n\nExample 1 (message only - when communicating):\n<message>Based on the search results, I found 3 JavaScript files...</message>\n\n");
        prompt.append("Example 2 (tools only - when you need information):\n<execute>\n  <tool name=\"search_files\">\n    <parameter name=\"query\">*.js</parameter>\n  </tool>\n  <tool name=\"read_file\">\n    <parameter name=\"file_path\">package.json</parameter>\n  </tool>\n</execute>\n\n");
        prompt.append("WRONG (never do this):\n<execute>\n  <tool name=\"read_file\">\n    <parameter name=\"file_path\">file.txt</parameter>\n  </tool>\n</execute>\n<message>Here's what I found</message>\n\n");
        
        prompt.append("## Response Length Handling\n\n");
        prompt.append("**CRITICAL:** Due to response length limits, you MUST end every complete response with the exact marker: |||||END|||||\n");
        prompt.append("- If your response is complete (whether it's a <message> or </execute>), add |||||END||||| at the very end\n");
        prompt.append("- For tool execution: close the </execute> block, then add |||||END||||| on a new line\n");
        prompt.append("- For messages: end the </message> block, then add |||||END||||| on a new line\n");
        prompt.append("- If your response gets cut off mid-sentence or mid-XML, do NOT add the marker\n");
        prompt.append("- The system will automatically request continuation if no marker is present\n");
        prompt.append("- Example complete tool response:\n</execute>\n|||||END|||||\n");
        prompt.append("- Example complete message response:\n</message>\n|||||END|||||\n\n");
        
        // Add project structure if available
        if (!currentProjectStructure.trim().isEmpty()) {
            prompt.append("\n\n## Project Structure\n\n");
            prompt.append("Current project file tree:\n");
            prompt.append("```\n");
            prompt.append(currentProjectStructure);
            prompt.append("```\n");
        }
        
        return prompt.toString();
    }
    
    private String generateAvailableTools(ConversationManager conversationManager) {
        StringBuilder tools = new StringBuilder();
        tools.append("## Available Tools\n\n");
        
        // Always available tools
        tools.append("search_files: Search for files by name pattern\n");
        tools.append("- Parameters: <parameter name=\"query\">search_term</parameter>\n\n");
        
        tools.append("search_content: Search for content within files (returns matching line with line number only)\n");
        tools.append("- Parameters: <parameter name=\"query\">search_term</parameter>, <parameter name=\"file_pattern\">*.ext</parameter> (optional), <parameter name=\"max_results\">100</parameter> (optional, default 100), <parameter name=\"max_results_per_file\">10</parameter> (optional, default 10)\n");
        tools.append("- Output is limited to 50KB. Use file_pattern to narrow results. Use read_file_lines to see context around matches.\n\n");

        tools.append("list_files: List files and directories in a path\n");
        tools.append("- Parameters: <parameter name=\"path\">directory_path</parameter> (defaults to current directory if not specified)\n\n");

        tools.append("read_file: Read the contents of a file\n");
        tools.append("- Parameters: <parameter name=\"file_path\">path/to/file</parameter>, <parameter name=\"find_string\">unique text to start from</parameter>, <parameter name=\"limit\">number of lines</parameter> (find_string and limit are optional)\n\n");

        tools.append("read_file_lines: Read specific line range from a file (use after search_content to see context)\n");
        tools.append("- Parameters: <parameter name=\"file_path\">path/to/file</parameter>, <parameter name=\"start_line\">10</parameter>, <parameter name=\"end_line\">20</parameter> (line numbers are 1-indexed)\n");
        tools.append("- Example: After search_content finds match at Line 42, use read_file_lines with start_line=37, end_line=47 to see context\n\n");
        
        tools.append("create_file: Create a new file with content\n");
        tools.append("- Parameters: <parameter name=\"file_path\">path/to/file</parameter>, <parameter name=\"content\">file content</parameter> (content is optional - defaults to empty file)\n\n");
        
        tools.append("delete_file: Delete an existing file\n");
        tools.append("- Parameters: <parameter name=\"file_path\">path/to/file</parameter>\n\n");
        
        tools.append("move_file: Move/rename a file from source to destination\n");
        tools.append("- Parameters: <parameter name=\"source_path\">path/to/source/file</parameter>, <parameter name=\"dest_path\">path/to/destination/file</parameter>\n\n");
        
        tools.append("update_file: Update an existing file using find and replace (find_string must be unique)\n");
        tools.append("- Parameters: <parameter name=\"file_path\">path/to/file</parameter>, <parameter name=\"find_string\">text to find</parameter>, <parameter name=\"replace_string\">replacement text</parameter>\n\n");
        
        tools.append("list_recursive: List all files and directories recursively in a path\n");
        tools.append("- Parameters: <parameter name=\"path\">directory_path</parameter> (defaults to current directory if not specified)\n\n");
        
        tools.append("create_directory: Create a new directory\n");
        tools.append("- Parameters: <parameter name=\"dir_path\">path/to/directory</parameter>\n\n");
        
        tools.append("delete_directory_recursive: Delete a directory and all its contents (safety check: requires recent list_recursive call)\n");
        tools.append("- Parameters: <parameter name=\"dir_path\">path/to/directory</parameter>\n\n");
        
        tools.append("git_read: Execute read-only git commands on a repository\n");
        tools.append("- Parameters: <parameter name=\"project_path\">path/to/git/repo</parameter>, <parameter name=\"git_args\">git command arguments</parameter>, <parameter name=\"offset\">skip N lines</parameter>, <parameter name=\"limit\">show N lines</parameter> (offset and limit are optional)\n");
        tools.append("- Safe commands only: status, log, show, diff, branch, remote, tag, ls-files, etc.\n");
        tools.append("- **IMPORTANT**: First use list_files to find directories, then look for project folders that contain .git repositories\n\n");
        
        // Checklist management tool
        tools.append("manage_checklist: Create and manage a structured task list for complex multi-step tasks\n");
        tools.append("- Parameters: <parameter name=\"todos\">array of objects with {content, status, priority, id}</parameter>\n");
        tools.append("- Status values: pending, in_progress, completed\n");
        tools.append("- Priority values: high, medium, low (for AI decision-making, not visual display)\n");
        tools.append("- **Use proactively for tasks requiring 3+ steps, multiple operations, or when user provides multiple tasks**\n");
        tools.append("- **Mark ONE task as in_progress when working on it, complete immediately when finished**\n\n");
        
        return tools.toString();
    }
    
    private String formatConversationHistoryForPrompt(List<ConversationManager.Message> conversation, ConversationManager conversationManager) {
        StringBuilder prompt = new StringBuilder();
        
        // Add conversation history (excluding the first message if it's just the greeting)
        prompt.append("\n\n## Previous Conversation\n\n");
        
        for (int i = 0; i < conversation.size(); i++) {
            ConversationManager.Message msg = conversation.get(i);
            
            // Skip the initial greeting unless it's the only message
            if (i == 0 && msg.role.equals("assistant") && msg.content.equals("Hello! How can I help you today?") && conversation.size() > 1) {
                continue;
            }
            
            if (msg.role.equals("user")) {
                prompt.append("[USER]\n\n");
                prompt.append(msg.content).append("\n\n");
            } else if (msg.role.equals("assistant")) {
                prompt.append("[ASSISTANT]\n\n");
                prompt.append(msg.content).append("\n\n");
            } else if (msg.role.equals("summary")) {
                prompt.append("[SUMMARY]\n\n");
                prompt.append(msg.content).append("\n\n");
            } else if (msg.role.equals("tool_results")) {
                String formattedToolResult = conversationManager.formatToolResultForPrompt(msg.content);
                prompt.append(formattedToolResult).append("\n\n");
            } else if (msg.role.equals("system")) {
                prompt.append("[SYSTEM]\n\n");
                prompt.append(msg.content).append("\n\n");
            } else if (msg.role.equals("tool")) {
                // Parse structured tool content for AI consumption
                java.util.Map<String, String> toolData = ConversationManager.parseToolContent(msg.content);
                String toolName = toolData.get("TOOL_NAME");
                String params = toolData.get("PARAMS");
                String result = toolData.get("RESULT");
                
                prompt.append("## Tool: ").append(toolName != null ? toolName : "unknown").append("\n");
                if (params != null && !params.isEmpty()) {
                    prompt.append("Parameters: ").append(params).append("\n");
                }
                if (result != null && !result.isEmpty()) {
                    prompt.append("Result: ").append(result).append("\n");
                }
                prompt.append("\n");
            }
        }
        
        prompt.append("[ASSISTANT]\n\nGenerate the next assistant message to be appended to this conversation.");
        
        return prompt.toString();
    }
    
    public void captureProjectStructure(String workingDirectory) {
        try {
            currentProjectStructure = generateProjectStructure(Paths.get(workingDirectory), "");
            log("Project structure captured from " + workingDirectory + ": " + currentProjectStructure.length() + " chars");
        } catch (Exception e) {
            log("Error capturing project structure: " + e.getMessage());
            currentProjectStructure = "";
        }
    }
    
    public String generatePrompt(List<ConversationManager.Message> conversation, ConversationManager conversationManager) {
        StringBuilder prompt = new StringBuilder();
        
        // Add core system prompt (non-automatic mode)
        prompt.append(generateCoreSystemPrompt(conversationManager, false));
        
        // Add conversation history
        prompt.append(formatConversationHistoryForPrompt(conversation, conversationManager));
        
        return prompt.toString();
    }
    
    public String generateAutomaticMessage(List<ConversationManager.Message> conversation, ConversationManager conversationManager) {
        StringBuilder messages = new StringBuilder();
        messages.append("{\"messages\":[");

        boolean first = true;
        boolean firstUserMessage = true;

        for (ConversationManager.Message msg : conversation) {
            if (msg.role.equals("user")) {
                if (!first) messages.append(",");

                String userContent = msg.content;
                // Prepend full system prompt to the first user message (using automatic mode)
                if (firstUserMessage) {
                    StringBuilder fullContent = new StringBuilder();
                    fullContent.append(generateCoreSystemPrompt(conversationManager, true));

                    fullContent.append("\n\n").append(userContent);
                    userContent = fullContent.toString();
                    firstUserMessage = false;
                }

                messages.append("{\"role\":\"user\",\"content\":\"").append(escapeJson(userContent)).append("\"}");
                first = false;
            } else if (msg.role.equals("assistant")) {
                if (!first) messages.append(",");
                messages.append("{\"role\":\"assistant\",\"content\":\"").append(escapeJson(msg.content)).append("\"}");
                first = false;
            } else if (msg.role.equals("system") || msg.role.equals("tool_results")) {
                if (!first) messages.append(",");
                // Convert system messages and tool results to user messages with SYSTEM: prefix
                String systemContent = "SYSTEM: " + msg.content;
                messages.append("{\"role\":\"user\",\"content\":\"").append(escapeJson(systemContent)).append("\"}");
                first = false;
            } else if (msg.role.equals("summary")) {
                if (!first) messages.append(",");
                // Convert summary to user message with SUMMARY: prefix
                String summaryContent = "SUMMARY: " + msg.content;
                messages.append("{\"role\":\"user\",\"content\":\"").append(escapeJson(summaryContent)).append("\"}");
                first = false;
            }
        }

        messages.append("]}|||||TO BRIDGE|||||");
        return messages.toString();
    }

    public static String wrapInAutomaticMessage(String content) {
        StringBuilder messages = new StringBuilder();
        messages.append("{\"messages\":[");
        messages.append("{\"role\":\"user\",\"content\":\"").append(escapeJsonStatic(content)).append("\"}");
        messages.append("]}|||||TO BRIDGE|||||");
        return messages.toString();
    }
    
    private String escapeJson(String text) {
        return text.replace("\\", "\\\\")
                  .replace("\"", "\\\"")
                  .replace("\n", "\\n")
                  .replace("\r", "\\r")
                  .replace("\t", "\\t");
    }

    private static String escapeJsonStatic(String text) {
        return text.replace("\\", "\\\\")
                  .replace("\"", "\\\"")
                  .replace("\n", "\\n")
                  .replace("\r", "\\r")
                  .replace("\t", "\\t");
    }
    
    private String generateProjectStructure(Path startPath, String indent) {
        StringBuilder structure = new StringBuilder();
        
        try {
            java.util.stream.Stream<Path> entries = Files.list(startPath)
                .filter(path -> !shouldSkipPath(path))
                .sorted((a, b) -> {
                    // Directories first, then files
                    boolean aIsDir = Files.isDirectory(a);
                    boolean bIsDir = Files.isDirectory(b);
                    if (aIsDir && !bIsDir) return -1;
                    if (!aIsDir && bIsDir) return 1;
                    return a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString());
                });
            
            entries.forEach(path -> {
                String fileName = path.getFileName().toString();
                if (Files.isDirectory(path)) {
                    structure.append(indent).append(fileName).append("/\n");
                    // Recursively add subdirectory contents (limited depth)
                    if (indent.length() < 12) { // Limit to 3 levels deep
                        addDirectoryContents(structure, path, indent + "  ");
                    }
                } else {
                    structure.append(indent).append(fileName);
                    try {
                        long size = Files.size(path);
                        structure.append(" (").append(formatFileSize(size)).append(")");
                    } catch (Exception e) {
                        // Ignore size errors
                    }
                    structure.append("\n");
                }
            });
            
        } catch (Exception e) {
            structure.append(indent).append("Error reading directory: ").append(e.getMessage()).append("\n");
        }
        
        return structure.toString();
    }
    
    private boolean shouldSkipPath(Path path) {
        String fileName = path.getFileName().toString();
        return fileName.startsWith(".") ||
               fileName.equals("node_modules") ||
               fileName.equals("target") ||
               fileName.equals("build") ||
               fileName.equals("dist") ||
               fileName.equals("out") ||
               fileName.equals("bin") ||
               fileName.equals("obj") ||
               fileName.endsWith(".class") ||
               fileName.endsWith(".jar") ||
               fileName.endsWith(".war");
    }
    
    private void addDirectoryContents(StringBuilder structure, Path dir, String indent) {
        try {
            java.util.stream.Stream<Path> entries = Files.list(dir)
                .filter(path -> !shouldSkipPath(path))
                .sorted((a, b) -> {
                    boolean aIsDir = Files.isDirectory(a);
                    boolean bIsDir = Files.isDirectory(b);
                    if (aIsDir && !bIsDir) return -1;
                    if (!aIsDir && bIsDir) return 1;
                    return a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString());
                });
            
            entries.forEach(path -> {
                String fileName = path.getFileName().toString();
                if (Files.isDirectory(path)) {
                    structure.append(indent).append(fileName).append("/\n");
                    if (indent.length() < 8) { // Limit recursion depth
                        addDirectoryContents(structure, path, indent + "  ");
                    }
                } else {
                    structure.append(indent).append(fileName);
                    try {
                        long size = Files.size(path);
                        structure.append(" (").append(formatFileSize(size)).append(")");
                    } catch (Exception e) {
                        // Ignore size errors
                    }
                    structure.append("\n");
                }
            });
            
        } catch (Exception e) {
            structure.append(indent).append("Error reading directory: ").append(e.getMessage()).append("\n");
        }
    }
    
    private String formatFileSize(long bytes) {
        if (bytes < 1024) return bytes + "B";
        if (bytes < 1024 * 1024) return String.format("%.1fKB", bytes / 1024.0);
        if (bytes < 1024 * 1024 * 1024) return String.format("%.1fMB", bytes / (1024.0 * 1024.0));
        return String.format("%.1fGB", bytes / (1024.0 * 1024.0 * 1024.0));
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: Renderer.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.util.*;

/**
 * Centralized rendering system that handles both permanent conversation messages
 * and ephemeral UI state (loading indicators, input carets, etc.)
 * 
 * Ephemeral state is automatically cleared when new permanent content is appended.
 */
public class Renderer {
    // ANSI color constants
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_GRAY = "\u001B[90m";
    public static final String ANSI_GOLD = "\u001B[33m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_LIGHT_BLUE = "\u001B[94m";
    public static final String ANSI_WHITE = "\u001B[37m";
    
    private EphemeralState currentEphemeral = null;
    private boolean isFirstMessage = true;
    private boolean justClearedCaret = false;
    
    /**
     * Append a permanent conversation message.
     * Automatically clears any ephemeral state first.
     */
    public void append(ConversationManager.Message message) {
        clearEphemeralState();
        
        // Add single blank line before messages except the first
        if (!isFirstMessage) {
            System.out.println();
        }
        isFirstMessage = false;
        justClearedCaret = false; // Reset after each append
        
        renderMessage(message);
    }
    
    /**
     * Show loading indicator. Auto-cleared when next message is appended.
     */
    public void showLoadingIndicator(String message) {
        clearEphemeralState();
        currentEphemeral = new LoadingIndicator(message);
        currentEphemeral.render();
    }
    
    /**
     * Show input caret. Auto-cleared when next message is appended.
     */
    public void showInputCaret() {
        clearEphemeralState();
        currentEphemeral = new InputCaret();
        currentEphemeral.render();
    }
    
    /**
     * Show immediate system feedback using normal message flow.
     * This ensures consistent spacing with other messages.
     */
    public void showImmediateSystemMessage(String message) {
        ConversationManager.Message systemMessage = new ConversationManager.Message("system", message);
        append(systemMessage);
    }
    
    /**
     * Clear any current ephemeral state using ANSI escape sequences
     */
    private void clearEphemeralState() {
        if (currentEphemeral != null) {
            if (currentEphemeral instanceof InputCaret) {
                justClearedCaret = true;
            }
            currentEphemeral.clear();
            currentEphemeral = null;
        }
    }
    
    /**
     * Render a conversation message based on its type
     */
    private void renderMessage(ConversationManager.Message message) {
        switch (message.role) {
            case "user":
                System.out.println(ANSI_GRAY + "> " + message.content + ANSI_RESET);
                break;
                
            case "assistant":
                String[] lines = wrapText(message.content, 100);
                for (String line : lines) {
                    System.out.println(ANSI_GOLD + "| " + line + ANSI_RESET);
                }
                break;
                
            case "checklist":
                renderChecklist(message.content);
                break;
                
            case "celebration":
                renderCelebration(message.content);
                break;
                
            case "summary":
                renderSummary(message.content);
                break;
                
            case "system":
                renderSystemMessage(message.content);
                break;
                
            case "tool":
                renderToolMessage(message.content);
                break;
                
            case "tool_results":
                renderLegacyToolResults(message.content);
                break;
                
            default:
                // Handle other message types
                System.out.println(message.content);
                break;
        }
    }
    
    private void renderChecklist(String content) {
        String[] lines = content.split("\\n");
        for (String line : lines) {
            System.out.println(ANSI_LIGHT_BLUE + "  " + line + ANSI_RESET);
        }
    }
    
    private void renderCelebration(String content) {
        String[] lines = content.split("\\n");
        for (String line : lines) {
            System.out.println(ANSI_GREEN + "  " + line + ANSI_RESET);
        }
    }
    
    private void renderSummary(String content) {
        System.out.println(ANSI_LIGHT_BLUE + "[SUMMARY]" + ANSI_RESET);
        String[] lines = wrapText(content, 96);
        for (String line : lines) {
            System.out.println(ANSI_LIGHT_BLUE + "| " + line + ANSI_RESET);
        }
    }
    
    private void renderSystemMessage(String content) {
        System.out.println(ANSI_GREEN + content + ANSI_RESET);
    }
    
    private void renderToolMessage(String content) {
        // Parse structured tool content
        java.util.Map<String, String> toolData = ConversationManager.parseToolContent(content);
        String toolName = toolData.get("TOOL_NAME");
        String params = toolData.get("PARAMS");
        String result = toolData.get("RESULT");
        
        // Format for display
        String toolDisplay = toolName != null ? toolName.toUpperCase() : "UNKNOWN";
        String paramDisplay = (params != null && !params.isEmpty()) ? " " + params : "";
        
        System.out.println(ANSI_GREEN + "  [" + toolDisplay + "]" + paramDisplay + ANSI_RESET);
        if (result != null && !result.isEmpty()) {
            System.out.println(ANSI_GREEN + "    " + result + ANSI_RESET);
        }
    }
    
    private void renderLegacyToolResults(String content) {
        // Parse legacy tool_results format: "toolname|`|~lines|`|~path|`|~content"
        String[] parts = content.split("\\|`\\|~");
        if (parts.length >= 1) {
            String toolName = parts[0];
            String toolDisplay = toolName.toUpperCase();
            
            System.out.println(ANSI_GREEN + "  [" + toolDisplay + "]" + ANSI_RESET);
            
            // If there's content, show it
            if (parts.length >= 4 && !parts[3].trim().isEmpty()) {
                String toolContent = parts[3].trim();
                // Show first line of content as summary
                String[] lines = toolContent.split("\n");
                if (lines.length > 0) {
                    System.out.println(ANSI_GREEN + "    " + lines[0] + ANSI_RESET);
                }
            }
        }
    }
    
    private String[] wrapText(String text, int width) {
        List<String> lines = new ArrayList<>();
        String[] paragraphs = text.split("\\n");
        
        for (String paragraph : paragraphs) {
            if (paragraph.trim().isEmpty()) {
                lines.add("");
                continue;
            }
            
            String[] words = paragraph.split("\\s+");
            StringBuilder currentLine = new StringBuilder();
            
            for (String word : words) {
                if (currentLine.length() + word.length() + 1 <= width) {
                    if (currentLine.length() > 0) {
                        currentLine.append(" ");
                    }
                    currentLine.append(word);
                } else {
                    if (currentLine.length() > 0) {
                        lines.add(currentLine.toString());
                        currentLine = new StringBuilder(word);
                    } else {
                        lines.add(word);
                    }
                }
            }
            
            if (currentLine.length() > 0) {
                lines.add(currentLine.toString());
            }
        }
        
        return lines.toArray(new String[0]);
    }
    
    /**
     * Base class for ephemeral UI state that can be shown and cleared
     */
    private abstract static class EphemeralState {
        protected int linesRendered = 0;
        
        abstract void render();
        
        void clear() {
            // Move cursor up and clear each line we rendered
            for (int i = 0; i < linesRendered; i++) {
                System.out.print("\u001B[1A\u001B[2K");
            }
        }
    }
    
    /**
     * Loading indicator ephemeral state
     */
    private static class LoadingIndicator extends EphemeralState {
        private final String message;
        
        LoadingIndicator(String message) {
            this.message = message;
        }
        
        @Override
        void render() {
            System.out.println();
            System.out.println(ANSI_GRAY + message + ANSI_RESET);
            linesRendered = 2;
        }
    }
    
    /**
     * Input caret ephemeral state
     */
    private static class InputCaret extends EphemeralState {
        @Override
        void render() {
            System.out.println(); // Add blank line before caret
            System.out.print(ANSI_WHITE + "> " + ANSI_RESET);
            System.out.flush();
            linesRendered = 2; // Track blank line + caret line
        }
        
        @Override
        void clear() {
            // Move cursor up one line and clear it (the line with white caret + user input)
            // The blank line above the caret stays as spacing for the next message
            System.out.print("\u001B[1A\u001B[2K");
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: SearchOperations.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.io.*;
import java.nio.file.*;
import java.util.*;

public class SearchOperations {
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    private static String getWorkingDirectory() {
        return ConversationCLI.getWorkingDirectory();
    }
    
    public static ToolExecutor.ToolExecutionResult executeSearchFilesWithSummary(String toolParams) {
        try {
            String query = ToolParameterExtractor.extractParameter(toolParams, "query");
            
            if (query == null || query.trim().isEmpty()) {
                String error = "Error: query parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            Path currentPath = Paths.get(getWorkingDirectory());
            StringBuilder results = new StringBuilder();
            int matchCount = 0;
            
            try {
                matchCount = (int) Files.walk(currentPath)
                    .filter(Files::isRegularFile)
                    .filter(path -> path.getFileName().toString().toLowerCase().contains(query.toLowerCase()))
                    .peek(path -> {
                        try {
                            long fileSize = Files.size(path);
                            results.append(String.format("%s (%s)\n", 
                                path.toString().replace("./", ""), 
                                ToolParameterExtractor.formatFileSize(fileSize)));
                        } catch (Exception e) {
                            results.append(path.toString().replace("./", "")).append("\n");
                        }
                    })
                    .mapToInt(e -> 1)
                    .sum();
            } catch (Exception e) {
                String error = "Error searching files: " + e.getMessage();
                return new ToolExecutor.ToolExecutionResult(error, error);
            }
            
            String fullResult;
            String summary;
            
            if (matchCount == 0) {
                fullResult = "No files found matching: " + query;
                summary = "No files found";
            } else {
                fullResult = String.format("Found %d file(s) matching '%s':\n\n%s", 
                    matchCount, query, results.toString());
                summary = "Found " + matchCount + " files";
            }
            
            String enhancedResult = "DISPLAY_INFO:" + matchCount + "|search results\n" + fullResult;
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);
            
        } catch (Exception e) {
            String error = "Error searching files: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
    
    public static ToolExecutor.ToolExecutionResult executeSearchContentWithSummary(String toolParams) {
        try {
            String query = ToolParameterExtractor.extractParameter(toolParams, "query");
            String filePattern = ToolParameterExtractor.extractParameter(toolParams, "file_pattern");
            String maxResultsStr = ToolParameterExtractor.extractParameter(toolParams, "max_results");
            String maxPerFileStr = ToolParameterExtractor.extractParameter(toolParams, "max_results_per_file");

            if (query == null || query.trim().isEmpty()) {
                String error = "Error: query parameter is required";
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            // Parse limits with defaults
            int maxResults = 100; // Default: show up to 100 total results
            int maxPerFile = 10;  // Default: show up to 10 matches per file

            try {
                if (maxResultsStr != null && !maxResultsStr.trim().isEmpty()) {
                    maxResults = Integer.parseInt(maxResultsStr.trim());
                }
                if (maxPerFileStr != null && !maxPerFileStr.trim().isEmpty()) {
                    maxPerFile = Integer.parseInt(maxPerFileStr.trim());
                }
            } catch (NumberFormatException e) {
                log("Invalid max_results or max_results_per_file parameter, using defaults");
            }

            Path currentPath = Paths.get(getWorkingDirectory());
            StringBuilder results = new StringBuilder();
            int totalMatches = 0;
            int filesWithMatches = 0;
            boolean truncated = false;
            final int MAX_OUTPUT_CHARS = 50000; // 50KB limit

            try {
                List<Path> filesToSearch = Files.walk(currentPath)
                    .filter(Files::isRegularFile)
                    .filter(path -> {
                        if (filePattern == null || filePattern.trim().isEmpty()) {
                            return true;
                        }
                        String fileName = path.getFileName().toString();
                        String pattern = filePattern.replace("*", ".*").replace("?", ".");
                        return fileName.matches(pattern);
                    })
                    .collect(java.util.stream.Collectors.toList());

                for (Path path : filesToSearch) {
                    if (totalMatches >= maxResults || results.length() >= MAX_OUTPUT_CHARS) {
                        truncated = true;
                        break;
                    }

                    try {
                        List<String> lines = Files.readAllLines(path);
                        int matchesInFile = 0;
                        boolean foundInFile = false;

                        for (int i = 0; i < lines.size(); i++) {
                            if (lines.get(i).toLowerCase().contains(query.toLowerCase())) {
                                if (!foundInFile) {
                                    results.append("\n=== ").append(path.toString().replace("./", "")).append(" ===\n");
                                    foundInFile = true;
                                    filesWithMatches++;
                                }

                                // Show only the matching line with line number (1-indexed)
                                results.append(String.format("  Line %d: %s\n", i + 1, lines.get(i)));
                                matchesInFile++;
                                totalMatches++;

                                // Check per-file limit
                                if (matchesInFile >= maxPerFile) {
                                    int remainingInFile = 0;
                                    for (int j = i + 1; j < lines.size(); j++) {
                                        if (lines.get(j).toLowerCase().contains(query.toLowerCase())) {
                                            remainingInFile++;
                                        }
                                    }
                                    if (remainingInFile > 0) {
                                        results.append(String.format("  ... (%d more matches in this file)\n", remainingInFile));
                                    }
                                    break;
                                }

                                // Check total limit
                                if (totalMatches >= maxResults) {
                                    truncated = true;
                                    break;
                                }

                                // Check output size limit
                                if (results.length() >= MAX_OUTPUT_CHARS) {
                                    truncated = true;
                                    break;
                                }
                            }
                        }

                        if (truncated) break;

                    } catch (Exception e) {
                        // Skip files that can't be read
                        log("Error reading file " + path + ": " + e.getMessage());
                    }
                }

            } catch (Exception e) {
                String error = "Error searching content: " + e.getMessage();
                return new ToolExecutor.ToolExecutionResult(error, error);
            }

            String fullResult;
            String summary;

            if (totalMatches == 0) {
                String patternInfo = (filePattern != null && !filePattern.trim().isEmpty())
                    ? " in " + filePattern + " files" : "";
                fullResult = "No matches found for: " + query + patternInfo;
                summary = "No matches found";
            } else {
                String patternInfo = (filePattern != null && !filePattern.trim().isEmpty())
                    ? " in " + filePattern + " files" : "";

                StringBuilder resultBuilder = new StringBuilder();
                resultBuilder.append(String.format("Found %d match(es) for '%s'%s in %d file(s):\n",
                    totalMatches, query, patternInfo, filesWithMatches));
                resultBuilder.append(results.toString());

                if (truncated) {
                    resultBuilder.append("\n⚠ Results truncated. ");
                    if (totalMatches >= maxResults) {
                        resultBuilder.append(String.format("Showing first %d matches. ", maxResults));
                    }
                    resultBuilder.append("Use file_pattern to narrow search or read_file_lines to see context.");
                }

                fullResult = resultBuilder.toString();
                summary = truncated ?
                    String.format("Found %d+ matches in %d+ files (truncated)", totalMatches, filesWithMatches) :
                    String.format("Found %d matches in %d files", totalMatches, filesWithMatches);
            }

            String enhancedResult = "DISPLAY_INFO:" + filesWithMatches + "|search results\n" + fullResult;
            return new ToolExecutor.ToolExecutionResult(enhancedResult, summary);

        } catch (Exception e) {
            String error = "Error searching content: " + e.getMessage();
            return new ToolExecutor.ToolExecutionResult(error, error);
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: SystemTrayManager.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.awt.*;
import java.awt.image.BufferedImage;

public class SystemTrayManager {
    private TrayIcon trayIcon;
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    public void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            log("System tray not supported on this platform");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create a simple green icon (16x16)
            Image image = createTrayIcon();
            
            // Create popup menu
            PopupMenu popup = new PopupMenu();
            
            MenuItem statusItem = new MenuItem("Conversation CLI - Running");
            statusItem.setEnabled(false);
            popup.add(statusItem);
            
            popup.addSeparator();
            
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> {
                log("Exit requested from system tray");
                cleanup();
                System.exit(0);
            });
            popup.add(exitItem);
            
            // Create tray icon
            trayIcon = new TrayIcon(image, "Conversation CLI", popup);
            trayIcon.setImageAutoSize(true);
            trayIcon.setToolTip("Conversation CLI - Maintaining clipboard access");
            
            // Add to system tray
            tray.add(trayIcon);
            
            log("System tray icon added successfully");
            
        } catch (Exception e) {
            log("Failed to setup system tray: " + e.getMessage());
            System.err.println("Warning: Could not setup system tray: " + e.getMessage());
        }
    }
    
    private Image createTrayIcon() {
        BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();
        
        // Enable antialiasing
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        // Draw a green circle
        g2d.setColor(new Color(76, 175, 80)); // Material Design Green
        g2d.fillOval(2, 2, 12, 12);
        
        // Add a white "C" for CLI
        g2d.setColor(Color.WHITE);
        g2d.setFont(new Font("Arial", Font.BOLD, 10));
        FontMetrics fm = g2d.getFontMetrics();
        String text = "C";
        int x = (16 - fm.stringWidth(text)) / 2;
        int y = (16 - fm.getHeight()) / 2 + fm.getAscent();
        g2d.drawString(text, x, y);
        
        g2d.dispose();
        return image;
    }
    
    public void updateTrayStatus(String status) {
        if (trayIcon != null) {
            trayIcon.setToolTip("Conversation CLI - " + status);
        }
    }
    
    public void cleanup() {
        if (trayIcon != null) {
            SystemTray.getSystemTray().remove(trayIcon);
        }
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: ToolExecutor.java
|~|~|~|~|~|~|~|~|~|~|~|
public class ToolExecutor {
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    public static String executeTool(String toolName, String toolParams) {
        try {
            switch (toolName) {
                case "read_file":
                    return FileOperations.executeReadFileWithSummary(toolParams).fullResult;
                case "create_file":
                    return FileOperations.executeCreateFileWithSummary(toolParams).fullResult;
                case "delete_file":
                    return FileOperations.executeDeleteFileWithSummary(toolParams).fullResult;
                case "move_file":
                    return FileOperations.executeMoveFileWithSummary(toolParams).fullResult;
                case "update_file":
                    return FileOperations.executeUpdateFileWithSummary(toolParams).fullResult;
                case "create_directory":
                    return DirectoryOperations.executeCreateDirectoryWithSummary(toolParams).fullResult;
                case "delete_directory_recursive":
                    return DirectoryOperations.executeDeleteDirectoryWithSummary(toolParams).fullResult;
                case "list_files":
                    return DirectoryOperations.executeListFilesWithSummary(toolParams).fullResult;
                case "list_recursive":
                    return DirectoryOperations.executeListRecursiveWithSummary(toolParams).fullResult;
                case "search_files":
                    return SearchOperations.executeSearchFilesWithSummary(toolParams).fullResult;
                case "search_content":
                    return SearchOperations.executeSearchContentWithSummary(toolParams).fullResult;
                case "manage_checklist":
                    return executeManageChecklistWithSummary(toolParams, null).fullResult;
                default:
                    log("Unknown tool: " + toolName);
                    return "Error: Unknown tool '" + toolName + "'";
            }
        } catch (Exception e) {
            log("Error executing tool " + toolName + ": " + e.getMessage());
            return "Error executing " + toolName + ": " + e.getMessage();
        }
    }
    
    public static ToolExecutionResult executeToolWithSummary(String toolName, String toolParams, ConversationManager conversationManager) {
        try {
            switch (toolName) {
                case "read_file":
                    return FileOperations.executeReadFileWithSummary(toolParams);
                case "read_file_lines":
                    return FileOperations.executeReadFileLinesWithSummary(toolParams);
                case "create_file":
                    return FileOperations.executeCreateFileWithSummary(toolParams);
                case "delete_file":
                    return FileOperations.executeDeleteFileWithSummary(toolParams);
                case "move_file":
                    return FileOperations.executeMoveFileWithSummary(toolParams);
                case "update_file":
                    return FileOperations.executeUpdateFileWithSummary(toolParams);
                case "create_directory":
                    return DirectoryOperations.executeCreateDirectoryWithSummary(toolParams);
                case "delete_directory_recursive":
                    return DirectoryOperations.executeDeleteDirectoryWithSummary(toolParams);
                case "list_files":
                    return DirectoryOperations.executeListFilesWithSummary(toolParams);
                case "list_recursive":
                    return DirectoryOperations.executeListRecursiveWithSummary(toolParams);
                case "search_files":
                    return SearchOperations.executeSearchFilesWithSummary(toolParams);
                case "search_content":
                    return SearchOperations.executeSearchContentWithSummary(toolParams);
                case "git_read":
                    return FileOperations.executeGitReadWithSummary(toolParams);
                case "manage_checklist":
                    return executeManageChecklistWithSummary(toolParams, conversationManager);
                default:
                    log("Unknown tool: " + toolName);
                    String error = "Error: Unknown tool '" + toolName + "'";
                    return new ToolExecutionResult(error, error);
            }
        } catch (Exception e) {
            log("Error executing tool " + toolName + ": " + e.getMessage());
            String error = "Error executing " + toolName + ": " + e.getMessage();
            return new ToolExecutionResult(error, error);
        }
    }
    
    // Backward compatible version
    public static ToolExecutionResult executeToolWithSummary(String toolName, String toolParams) {
        return executeToolWithSummary(toolName, toolParams, null);
    }
    
    public static class ToolExecutionResult {
        public String fullResult;
        public String summary;
        
        public ToolExecutionResult(String fullResult, String summary) {
            this.fullResult = fullResult;
            this.summary = summary;
        }
    }
    
    // Checklist tool implementation
    public static ToolExecutionResult executeManageChecklistWithSummary(String toolParams, ConversationManager conversationManager) {
        try {
            String todosParam = ToolParameterExtractor.extractParameter(toolParams, "todos");
            
            if (todosParam.isEmpty()) {
                return new ToolExecutionResult("Error: todos parameter is required", "Checklist management failed - missing todos");
            }
            
            if (conversationManager == null) {
                conversationManager = new ConversationManager();
            }
            
            // Parse todos array - simple format: [{content:"task1",status:"pending",priority:"high",id:"task1"}]
            java.util.List<ConversationManager.TodoItem> todos = parseTodosArray(todosParam);
            
            if (todos.isEmpty()) {
                return new ToolExecutionResult("Error: No valid todos provided", "No valid todos to manage");
            }
            
            // Validate todo items and state transitions
            String validationResult = validateTodos(todos);
            if (!validationResult.isEmpty()) {
                return new ToolExecutionResult("Error: " + validationResult, "Todo validation failed");
            }
            
            // Create or update checklist
            ConversationManager.TodoList todoList = new ConversationManager.TodoList(todos);
            
            // Save checklist file
            conversationManager.saveTodoList(todoList);
            
            // Check for task completions and show celebration
            String celebrationMessage = generateCelebrationMessage(todos, conversationManager);
            
            // Add checklist display to conversation
            conversationManager.addTodoListMessage(todoList);
            
            // Add celebration message if there were completions
            if (!celebrationMessage.isEmpty()) {
                conversationManager.addCelebrationMessage(celebrationMessage);
            }
            
            // Check if all items are completed
            boolean allCompleted = todos.stream().allMatch(todo -> todo.status.equals("completed"));
            if (allCompleted) {
                conversationManager.deleteTodoList();
                log("All todos completed - deleted todo list file");
            }
            
            String result = "Managed " + todos.size() + " todo items";
            log(result);
            
            // Format result with DISPLAY_INFO for proper terminal display
            String enhancedResult = "DISPLAY_INFO:" + todos.size() + "|checklist\n" + result;
            
            return new ToolExecutionResult(enhancedResult, "Managed " + todos.size() + " todos");
            
        } catch (Exception e) {
            log("Error managing checklist: " + e.getMessage());
            String error = "Error managing checklist: " + e.getMessage();
            return new ToolExecutionResult(error, error);
        }
    }
    
    private static java.util.List<ConversationManager.TodoItem> parseTodosArray(String todosParam) {
        java.util.List<ConversationManager.TodoItem> todos = new java.util.ArrayList<>();
        
        try {
            log("Parsing todos parameter: " + todosParam.substring(0, Math.min(todosParam.length(), 200)) + "...");
            
            // Clean up the parameter - remove whitespace and normalize
            todosParam = todosParam.trim().replaceAll("\\s+", " ");
            
            if (!todosParam.startsWith("[") || !todosParam.endsWith("]")) {
                log("Invalid JSON array format - must start with [ and end with ]");
                return todos;
            }
            
            // Extract content between brackets
            String content = todosParam.substring(1, todosParam.length() - 1).trim();
            if (content.isEmpty()) {
                log("Empty todos array");
                return todos;
            }
            
            // Split by },{ pattern to get individual todo objects
            String[] todoStrings = content.split("\\}\\s*,\\s*\\{");
            log("Found " + todoStrings.length + " todo entries");
            
            for (int i = 0; i < todoStrings.length; i++) {
                String todoStr = todoStrings[i].trim();
                
                // Add braces back if they were removed by splitting
                if (!todoStr.startsWith("{")) todoStr = "{" + todoStr;
                if (!todoStr.endsWith("}")) todoStr = todoStr + "}";
                
                log("Parsing todo " + (i+1) + ": " + todoStr.substring(0, Math.min(todoStr.length(), 100)) + "...");
                
                ConversationManager.TodoItem todo = parseSingleTodo(todoStr);
                if (todo != null) {
                    todos.add(todo);
                    log("Successfully parsed todo: " + todo.content);
                } else {
                    log("Failed to parse todo: " + todoStr);
                }
            }
            
        } catch (Exception e) {
            log("Error parsing todos array: " + e.getMessage());
            e.printStackTrace();
        }
        
        log("Parsed " + todos.size() + " todos successfully");
        return todos;
    }
    
    private static ConversationManager.TodoItem parseSingleTodo(String todoStr) {
        try {
            String content = "";
            String status = "pending";
            String priority = "medium";
            String id = "";
            
            // Simple field extraction using indexOf and substring
            content = extractJsonField(todoStr, "content");
            status = extractJsonField(todoStr, "status");
            priority = extractJsonField(todoStr, "priority");
            id = extractJsonField(todoStr, "id");
            
            if (!content.isEmpty() && !id.isEmpty()) {
                return new ConversationManager.TodoItem(content, status, priority, id);
            } else {
                log("Missing required fields - content: '" + content + "', id: '" + id + "'");
            }
        } catch (Exception e) {
            log("Error parsing single todo: " + e.getMessage());
        }
        return null;
    }
    
    private static String extractJsonField(String json, String fieldName) {
        try {
            String pattern = "\"" + fieldName + "\"\\s*:\\s*\"([^\"]+)\"";
            java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
            java.util.regex.Matcher m = p.matcher(json);
            if (m.find()) {
                return m.group(1);
            }
        } catch (Exception e) {
            log("Error extracting field " + fieldName + ": " + e.getMessage());
        }
        return "";
    }
    
    private static String validateTodos(java.util.List<ConversationManager.TodoItem> todos) {
        java.util.Set<String> seenIds = new java.util.HashSet<>();
        int inProgressCount = 0;
        
        for (ConversationManager.TodoItem todo : todos) {
            // Validate required fields
            if (todo.content == null || todo.content.trim().isEmpty()) {
                return "Todo content cannot be empty";
            }
            if (todo.id == null || todo.id.trim().isEmpty()) {
                return "Todo id cannot be empty";
            }
            
            // Validate unique IDs
            if (seenIds.contains(todo.id)) {
                return "Duplicate todo id: " + todo.id;
            }
            seenIds.add(todo.id);
            
            // Validate status values
            if (!isValidStatus(todo.status)) {
                return "Invalid status '" + todo.status + "' for todo: " + todo.content + 
                       ". Valid statuses: pending, in_progress, completed";
            }
            
            // Validate priority values
            if (!isValidPriority(todo.priority)) {
                return "Invalid priority '" + todo.priority + "' for todo: " + todo.content + 
                       ". Valid priorities: high, medium, low";
            }
            
            // Count in_progress items
            if ("in_progress".equals(todo.status)) {
                inProgressCount++;
            }
        }
        
        // Enforce one in_progress task at a time
        if (inProgressCount > 1) {
            return "Only one task can be in_progress at a time. Found " + inProgressCount + " in_progress tasks.";
        }
        
        return ""; // No validation errors
    }
    
    private static boolean isValidStatus(String status) {
        return "pending".equals(status) || "in_progress".equals(status) || "completed".equals(status);
    }
    
    private static boolean isValidPriority(String priority) {
        return "high".equals(priority) || "medium".equals(priority) || "low".equals(priority);
    }
    
    private static String generateCelebrationMessage(java.util.List<ConversationManager.TodoItem> todos, ConversationManager conversationManager) {
        try {
            // Load previous todo list to compare completions
            ConversationManager.TodoList previousList = conversationManager.loadTodoList();
            if (previousList == null) return "";
            
            // Find newly completed tasks
            java.util.Set<String> previouslyCompleted = new java.util.HashSet<>();
            for (ConversationManager.TodoItem item : previousList.items) {
                if ("completed".equals(item.status)) {
                    previouslyCompleted.add(item.id);
                }
            }
            
            java.util.List<String> newlyCompleted = new java.util.ArrayList<>();
            String nextTask = "";
            
            for (ConversationManager.TodoItem todo : todos) {
                if ("completed".equals(todo.status) && !previouslyCompleted.contains(todo.id)) {
                    newlyCompleted.add(todo.content);
                }
                if ("pending".equals(todo.status) && nextTask.isEmpty()) {
                    nextTask = todo.content;
                }
            }
            
            if (newlyCompleted.isEmpty()) return "";
            
            // Generate celebration message
            StringBuilder celebration = new StringBuilder();
            for (String task : newlyCompleted) {
                String shortTask = task.length() > 40 ? task.substring(0, 37) + "..." : task;
                celebration.append("✅ ").append(shortTask);
                if (!nextTask.isEmpty()) {
                    String shortNext = nextTask.length() > 40 ? nextTask.substring(0, 37) + "..." : nextTask;
                    celebration.append(" → Next: ").append(shortNext);
                }
                celebration.append("\n");
            }
            
            return celebration.toString().trim();
            
        } catch (Exception e) {
            log("Error generating celebration message: " + e.getMessage());
            return "";
        }
    }
    
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: ToolParameterExtractor.java
|~|~|~|~|~|~|~|~|~|~|~|
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class ToolParameterExtractor {
    
    private static void log(String message) {
        Logger.log(message);
    }
    
    public static String extractParameter(String toolParams, String paramName) {
        try {
            String pattern = "<parameter name=\"" + paramName + "\">(.*?)</parameter>";
            Pattern p = Pattern.compile(pattern, Pattern.DOTALL);
            Matcher m = p.matcher(toolParams);
            
            if (m.find()) {
                return m.group(1).trim();
            }
            
        } catch (Exception e) {
            log("Error extracting parameter " + paramName + ": " + e.getMessage());
        }
        
        return null;
    }
    
    public static String formatFileSize(long bytes) {
        if (bytes < 1024) return bytes + "B";
        if (bytes < 1024 * 1024) return String.format("%.1fKB", bytes / 1024.0);
        if (bytes < 1024 * 1024 * 1024) return String.format("%.1fMB", bytes / (1024.0 * 1024.0));
        return String.format("%.1fGB", bytes / (1024.0 * 1024.0 * 1024.0));
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: ToolRenderer.java
|~|~|~|~|~|~|~|~|~|~|~|
/**
 * Specialized renderer for tool execution that integrates with todo workflow.
 * Handles the progressive display of tools with current task context.
 */
public class ToolRenderer {
    private final Renderer renderer;
    private final MessageRenderer messageRenderer;
    
    public ToolRenderer(Renderer renderer) {
        this.renderer = renderer;
        this.messageRenderer = new MessageRenderer();
    }
    
    /**
     * Render tool header immediately when execution starts
     */
    public void renderToolHeader(String toolName, String formattedArgs) {
        String toolDisplay = toolName.toUpperCase();
        String paramDisplay = formattedArgs.isEmpty() ? "" : " " + formattedArgs;
        System.out.println(MessageRenderer.ANSI_GREEN + "  [" + toolDisplay + "]" + paramDisplay + MessageRenderer.ANSI_RESET);
    }
    
    /**
     * Render tool details when execution completes
     */
    public void renderToolDetails(String toolName, ToolExecutor.ToolExecutionResult result) {
        if (toolName.equals("create_file") || toolName.equals("update_file")) {
            messageRenderer.renderFileOperationDiff(result.fullResult, toolName);
        } else if (toolName.equals("manage_checklist")) {
            renderChecklistResult(result.fullResult);
        } else {
            System.out.println(MessageRenderer.ANSI_DARK_GREEN + "    " + result.summary + MessageRenderer.ANSI_RESET);
        }
    }
    
    /**
     * Render current todo task context before showing tools
     */
    public void renderCurrentTask(int currentTask, int totalTasks, String taskDescription) {
        System.out.println();
        System.out.println(MessageRenderer.ANSI_CYAN + "[" + currentTask + "/" + totalTasks + "] -> " + taskDescription + MessageRenderer.ANSI_RESET);
        System.out.println();
    }
    
    /**
     * Render todo list completion status
     */
    public void renderTodoListStatus(ConversationManager.TodoList todoList) {
        if (todoList == null || todoList.items.isEmpty()) {
            return;
        }
        
        int completed = 0;
        int inProgress = 0;
        int pending = 0;
        
        for (ConversationManager.TodoItem item : todoList.items) {
            switch (item.status) {
                case "completed":
                    completed++;
                    break;
                case "in_progress":
                    inProgress++;
                    break;
                case "pending":
                    pending++;
                    break;
            }
        }
        
        int total = todoList.items.size();
        System.out.println(MessageRenderer.ANSI_CYAN + "Todo Status: " + completed + " completed, " + inProgress + " in progress, " + pending + " pending (" + total + " total)" + MessageRenderer.ANSI_RESET);
        
        // Show current task if there's one in progress
        for (ConversationManager.TodoItem item : todoList.items) {
            if ("in_progress".equals(item.status)) {
                System.out.println(MessageRenderer.ANSI_LIGHT_GREEN + "Current: " + item.content + MessageRenderer.ANSI_RESET);
                break;
            }
        }
    }
    
    /**
     * Render checklist result from manage_checklist tool
     */
    private void renderChecklistResult(String fullResult) {
        if (fullResult.startsWith("DISPLAY_INFO:")) {
            String[] parts = fullResult.split("\\|", 2);
            if (parts.length > 0) {
                String countInfo = parts[0].substring("DISPLAY_INFO:".length());
                System.out.println(MessageRenderer.ANSI_DARK_GREEN + "    " + countInfo + " tasks" + MessageRenderer.ANSI_RESET);
            }
        } else {
            System.out.println(MessageRenderer.ANSI_DARK_GREEN + "    " + fullResult + MessageRenderer.ANSI_RESET);
        }
    }
    
    /**
     * Add spacing between tools
     */
    public void addToolSpacing() {
        System.out.println();
    }
}
|~|~|~|~|~|~|~|~|~|~|~|

FILE: bridge-button.js
|~|~|~|~|~|~|~|~|~|~|~|
// Claude Bridge Script - Button Interface with Clipboard Protocol

/* DEV_MOCK_PLACEHOLDER */

(function() {
    'use strict';
    
    console.log('[Button Bridge] Initializing...');
    
    // State management
    let currentState = 'listening'; // 'listening' or 'response'
    let isProcessing = false;
    let currentResponse = '';
    
    // Protocol constants
    const TO_BRIDGE_MARKER = '|||||TO BRIDGE|||||';
    const TO_JAVA_MARKER = '|||||TO JAVA|||||';
    
    // Remove any existing bridge UI
    const existingBridge = document.getElementById('claude-bridge-ui');
    if (existingBridge) {
        existingBridge.remove();
    }
    
    // Create main UI container
    const bridgeUI = document.createElement('div');
    bridgeUI.id = 'claude-bridge-ui';
    bridgeUI.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 999999;
        background: rgba(0, 0, 0, 0.9);
        border: 3px solid #4CAF50;
        border-radius: 20px;
        padding: 40px;
        text-align: center;
        font-family: Arial, sans-serif;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        user-select: none;
    `;
    
    // Create main button
    const mainButton = document.createElement('button');
    mainButton.id = 'bridge-main-button';
    mainButton.style.cssText = `
        width: 300px;
        height: 150px;
        background: linear-gradient(45deg, #4CAF50, #45a049);
        color: white;
        border: none;
        border-radius: 15px;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        margin-bottom: 20px;
    `;
    
    // Create status text
    const statusText = document.createElement('div');
    statusText.id = 'bridge-status';
    statusText.style.cssText = `
        color: #4CAF50;
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 15px;
    `;
    
    // Create info text
    const infoText = document.createElement('div');
    infoText.id = 'bridge-info';
    infoText.style.cssText = `
        color: #ccc;
        font-size: 14px;
        max-width: 400px;
        line-height: 1.4;
    `;
    
    // Create close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'X';
    closeButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 15px;
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
    `;
    
    closeButton.addEventListener('click', () => {
        bridgeUI.remove();
        console.log('[Button Bridge] Bridge UI closed');
    });
    
    closeButton.addEventListener('mouseenter', () => {
        closeButton.style.background = 'rgba(255, 255, 255, 0.1)';
    });
    
    closeButton.addEventListener('mouseleave', () => {
        closeButton.style.background = 'none';
    });
    
    // Add hover effects to main button
    mainButton.addEventListener('mouseenter', () => {
        if (!isProcessing) {
            mainButton.style.transform = 'scale(1.05)';
            mainButton.style.boxShadow = '0 8px 25px rgba(76, 175, 80, 0.4)';
        }
    });
    
    mainButton.addEventListener('mouseleave', () => {
        if (!isProcessing) {
            mainButton.style.transform = 'scale(1)';
            mainButton.style.boxShadow = '0 5px 15px rgba(76, 175, 80, 0.3)';
        }
    });
    
    // Main button click handler
    mainButton.addEventListener('click', async () => {
        if (isProcessing) {
            console.log('[Button Bridge] Already processing, ignoring click');
            return;
        }
        
        if (currentState === 'listening') {
            await handleListeningClick();
        } else if (currentState === 'response') {
            await handleResponseClick();
        }
    });
    
    // Handle click in listening mode
    async function handleListeningClick() {
        console.log('[Button Bridge] Listening mode click - checking clipboard...');
        
        try {
            // Read clipboard
            const clipboardText = await navigator.clipboard.readText();
            
            // Check for TO_BRIDGE marker
            if (!clipboardText.endsWith(TO_BRIDGE_MARKER)) {
                console.log('[Button Bridge] No TO_BRIDGE marker found');
                updateUI('listening', 'No valid request found in clipboard');
                return;
            }
            
            // Remove marker and parse JSON
            const jsonText = clipboardText.slice(0, -TO_BRIDGE_MARKER.length);
            let request;
            try {
                request = JSON.parse(jsonText);
                if (!request.messages || !Array.isArray(request.messages)) {
                    throw new Error('Invalid request format');
                }
            } catch (e) {
                console.error('[Button Bridge] Invalid JSON:', e);
                updateUI('listening', 'Invalid JSON in clipboard');
                return;
            }
            
            console.log('[Button Bridge] Valid request found, processing...');
            isProcessing = true;
            updateUI('processing', 'Processing request...');
            
            // Get auth token
            const token = getAuthToken();
            if (!token) {
                updateUI('listening', 'No auth token found');
                isProcessing = false;
                return;
            }
            
            // Submit to API and get response with continuation handling
            const response = await submitToInternalAPIWithContinuation(request.messages, token);

            // Check if response indicates token limit exceeded
            if (response === 'TOKEN_LIMIT_EXCEEDED') {
                currentResponse = response;
                currentState = 'response';
                isProcessing = false;
                updateUI('response', 'Token limit detected - click to copy');
            } else {
                currentResponse = response;
                currentState = 'response';
                isProcessing = false;
                updateUI('response', 'Response ready - click to copy');
            }
            
        } catch (error) {
            console.error('[Button Bridge] Error in listening click:', error);
            updateUI('listening', `Error: ${error.message}`);
            isProcessing = false;
        }
    }
    
    // Handle click in response mode
    async function handleResponseClick() {
        console.log('[Button Bridge] Response mode click - copying to clipboard...');
        
        try {
            // Copy response with TO_JAVA marker
            const responseWithMarker = currentResponse + TO_JAVA_MARKER;
            await navigator.clipboard.writeText(responseWithMarker);
            
            // Switch back to listening mode
            currentState = 'listening';
            currentResponse = '';
            updateUI('listening', 'Response copied - ready for next request');
            
        } catch (error) {
            console.error('[Button Bridge] Error copying response:', error);
            updateUI('response', `Copy failed: ${error.message}`);
        }
    }
    
    // Get auth token from localStorage
    function getAuthToken() {
        const token = localStorage.getItem('token');
        if (!token) {
            console.error('[Button Bridge] No auth token found in localStorage');
            return null;
        }
        return token;
    }
    
    // Submit to internal API with automatic continuation handling
    async function submitToInternalAPIWithContinuation(messages, token) {
        console.log('[Button Bridge] Starting API request with continuation handling...');

        let fullResponse = '';
        let conversationMessages = [...messages]; // Copy original messages
        let attemptCount = 0;
        const maxAttempts = 10; // Prevent infinite loops

        while (attemptCount < maxAttempts) {
            attemptCount++;
            console.log(`[Button Bridge] Attempt ${attemptCount} - sending request...`);

            const response = await submitToInternalAPI(conversationMessages, token);

            // Check if response is empty (token limit exceeded on backend)
            // This can happen on first attempt OR continuation if the conversation grew too large
            if (response.trim() === '') {
                console.log(`[Button Bridge] EMPTY RESPONSE on attempt ${attemptCount} - Token limit likely exceeded`);
                return 'TOKEN_LIMIT_EXCEEDED';
            }

            fullResponse += response;

            // Check if response ends with completion marker
            if (fullResponse.endsWith('|||||END|||||')) {
                console.log('[Button Bridge] Found completion marker, response is complete');
                // Strip the marker and return complete response
                return fullResponse.slice(0, -13); // Remove |||||END|||||
            }

            console.log('[Button Bridge] No completion marker found, response was truncated');

            // Get the last 30 characters for exact continuation
            const lastChars = fullResponse.slice(-30);

            // Create continuation request with exact character positioning
            const continuationContent = `Your previous response was cut off. The last 30 characters were: "${lastChars}". Start writing immediately after these exact characters. We will append your response to the previous output. End with |||||END||||| when complete.`;

            const continuationMessage = {
                role: 'user',
                content: continuationContent
            };

            // Add assistant's partial response and continuation request to conversation
            conversationMessages.push({
                role: 'assistant',
                content: response
            });
            conversationMessages.push(continuationMessage);

            console.log(`[Button Bridge] Requesting continuation... (current response length: ${fullResponse.length} chars)`);
        }

        console.log('[Button Bridge] Warning: Reached maximum continuation attempts');
        return fullResponse; // Return what we have, even if incomplete
    }
    
    // Submit to internal API (original implementation)
    async function submitToInternalAPI(messages, token) {
        console.log('[Button Bridge] Submitting to internal API...');
        
        const timestamp = Date.now();
        const userMessageId = 'msg-' + timestamp + '-user';
        const assistantMessageId = 'msg-' + timestamp + '-assistant';
        const sessionId = 'session-' + Math.random().toString(36).substr(2, 9);
        
        const apiBase = window.location.origin; // Use current page's origin
        
        // Step 1: Create new chat
        console.log('[Button Bridge] Step 1: Creating new chat...');
        const newChatResponse = await fetch(`${apiBase}/api/v1/chats/new`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                chat: {
                    id: '',
                    title: 'Chat Pending',
                    models: ['Anthropic Claude 4 Sonnet'],
                    params: {},
                    history: {
                        messages: {
                            [userMessageId]: {
                                id: userMessageId,
                                parentId: null,
                                childrenIds: [],
                                role: 'user',
                                content: messages.length > 0 ? messages[messages.length - 1].content : '',
                                timestamp: Math.floor(timestamp / 1000),
                                models: ['Anthropic Claude 4 Sonnet']
                            }
                        },
                        currentId: userMessageId
                    },
                    messages: [
                        {
                            id: userMessageId,
                            role: 'user',
                            content: messages.length > 0 ? messages[messages.length - 1].content : '',
                            timestamp: Math.floor(timestamp / 1000),
                            models: ['Anthropic Claude 4 Sonnet']
                        }
                    ],
                    files: []
                }
            })
        });
        
        if (!newChatResponse.ok) {
            throw new Error(`Chat creation failed: ${newChatResponse.status}`);
        }
        
        const chatResult = await newChatResponse.json();
        const chatId = chatResult.id;
        console.log('[Button Bridge] Chat created with ID:', chatId);
        
        // Step 2: Stream completions
        console.log('[Button Bridge] Step 2: Starting completions stream...');
        const completionsResponse = await fetch(`${apiBase}/api/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                stream: true,
                model: 'Anthropic Claude 4 Sonnet',
                messages: messages,
                params: {},
                features: {
                    web_search: false
                },
                session_id: sessionId,
                chat_id: chatId,
                id: assistantMessageId,
                background_tasks: {
                    title_generation: true,
                    tags_generation: true
                }
            })
        });
        
        if (!completionsResponse.ok) {
            throw new Error(`Completions failed: ${completionsResponse.status}`);
        }
        
        // Read the SSE stream
        const reader = completionsResponse.body.getReader();
        const decoder = new TextDecoder();
        let finalContent = '';
        
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    if (data === '[DONE]') {
                        console.log('[Button Bridge] Stream completed');
                        return finalContent;
                    }
                    
                    try {
                        const parsed = JSON.parse(data);
                        if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                            finalContent += parsed.choices[0].delta.content;
                        }
                    } catch (e) {
                        // Ignore parsing errors
                    }
                }
            }
        }
        
        return finalContent;
    }
    
    // Update UI based on state
    function updateUI(state, statusMessage) {
        if (state === 'listening') {
            mainButton.textContent = 'LISTENING';
            mainButton.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            statusText.textContent = 'READY TO RECEIVE';
            infoText.textContent = statusMessage || 'Waiting for request with |||||TO BRIDGE||||| marker';
        } else if (state === 'processing') {
            mainButton.textContent = 'PROCESSING...';
            mainButton.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';
            statusText.textContent = 'WORKING...';
            infoText.textContent = statusMessage || 'Calling /new then /completions...';
        } else if (state === 'response') {
            mainButton.textContent = 'CLICK TO COPY';
            mainButton.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
            statusText.textContent = 'RESPONSE READY';
            infoText.textContent = statusMessage || 'Click to copy response with |||||TO JAVA||||| marker';
        }
        
        // Update button colors
        if (state === 'listening') {
            statusText.style.color = '#4CAF50';
        } else if (state === 'processing') {
            statusText.style.color = '#FF9800';
        } else if (state === 'response') {
            statusText.style.color = '#2196F3';
        }
    }
    
    // Assemble UI
    bridgeUI.appendChild(closeButton);
    bridgeUI.appendChild(statusText);
    bridgeUI.appendChild(mainButton);
    bridgeUI.appendChild(infoText);
    
    // Add to page
    document.body.appendChild(bridgeUI);
    
    // Initialize UI
    updateUI('listening', 'Bridge ready - paste requests ending with |||||TO BRIDGE|||||');
    
    console.log('[Button Bridge] Button interface ready!');
    console.log('[Button Bridge] Protocol: TO_BRIDGE =', TO_BRIDGE_MARKER);
    console.log('[Button Bridge] Protocol: TO_JAVA =', TO_JAVA_MARKER);
    
    // Keepalive mechanism - send simple request every 5 minutes to keep session alive
    let keepaliveInterval = setInterval(async () => {
        try {
            console.log('[Button Bridge] Sending keepalive request...');
            
            const token = getAuthToken();
            if (!token) {
                console.log('[Button Bridge] No token for keepalive, skipping');
                return;
            }
            
            // Simple keepalive message
            const keepaliveMessages = [
                {
                    role: 'user',
                    content: 'reply "k"'
                }
            ];
            
            await submitToInternalAPI(keepaliveMessages, token);
            console.log('[Button Bridge] Keepalive request completed');
            
        } catch (error) {
            console.log('[Button Bridge] Keepalive failed:', error.message);
        }
    }, 5 * 60 * 1000); // 5 minutes
    
    console.log('[Button Bridge] Keepalive timer started (5 minute intervals)');
    
})();
|~|~|~|~|~|~|~|~|~|~|~|

FILE: build.js
|~|~|~|~|~|~|~|~|~|~|~|
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Two separate locations:
// 1. EXECUTION_DIR - where the build script was run from (for Java app working directory)
// 2. SCRIPT_DIR - where build.js and bundle.txt are located (for extraction and compilation)
const EXECUTION_DIR = process.cwd();
const SCRIPT_DIR = __dirname;
const BUNDLE_FILE = path.join(SCRIPT_DIR, 'bundle.txt');
const DELIMITER = '|~|~|~|~|~|~|~|~|~|~|~|';

// Check for run-only mode
const RUN_ONLY = process.argv.includes('r');

console.log('=== Manual Coding Agent Build Script ===');
console.log('');

console.log(`Execution directory (Java app working dir): ${EXECUTION_DIR}`);
console.log(`Script directory (extraction/compilation): ${SCRIPT_DIR}`);
console.log(`Bundle file: ${BUNDLE_FILE}`);
if (RUN_ONLY) {
    console.log('Mode: Run-only (skipping extraction and compilation)');
}
console.log('');

// Check if script directory exists
if (!fs.existsSync(SCRIPT_DIR)) {
    console.error(`ERROR: Script directory does not exist: ${SCRIPT_DIR}`);
    process.exit(1);
}

// Only check bundle file if we're not in run-only mode
if (!RUN_ONLY && !fs.existsSync(BUNDLE_FILE)) {
    console.error(`ERROR: Bundle file not found: ${BUNDLE_FILE}`);
    console.error('Please ensure bundle.txt is in the same directory as build.js');
    process.exit(1);
}

// Skip extraction and compilation if in run-only mode
if (RUN_ONLY) {
    console.log('Skipping extraction and compilation - running existing classes...');
    process.chdir(SCRIPT_DIR);
} else {
    console.log('[1/5] Unbundling Java files to script directory...');
    process.chdir(SCRIPT_DIR);

try {
    // Read bundle file
    const bundleContent = fs.readFileSync(BUNDLE_FILE, 'utf8');
    const lines = bundleContent.split('\n');
    
    let currentFile = null;
    let fileContent = [];
    let inFileContent = false;
    let extractedFiles = 0;
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Check if line starts with "FILE: "
        if (line.startsWith('FILE: ')) {
            // Save previous file if we have one
            if (currentFile && fileContent.length > 0) {
                const content = fileContent.join('\n');
                fs.writeFileSync(currentFile, content, 'utf8');
                console.log(`  [OK] Wrote ${currentFile} (${content.length} chars)`);
                extractedFiles++;
            }
            
            // Start new file
            currentFile = line.substring(6).trim(); // Remove "FILE: "
            fileContent = [];
            inFileContent = false;
            console.log(`  Extracting: ${currentFile}`);
        }
        // Check if line is delimiter
        else if (line === DELIMITER) {
            if (inFileContent) {
                // End of file content
                inFileContent = false;
            } else {
                // Start of file content
                inFileContent = true;
            }
        }
        // Regular content line
        else if (inFileContent && currentFile) {
            fileContent.push(lines[i]); // Keep original line with whitespace
        }
    }
    
    // Save last file
    if (currentFile && fileContent.length > 0) {
        const content = fileContent.join('\n');
        fs.writeFileSync(currentFile, content, 'utf8');
        console.log(`  [OK] Wrote ${currentFile} (${content.length} chars)`);
        extractedFiles++;
    }
    
    console.log(`  Extracted ${extractedFiles} Java files`);
    
    // Verify files were created
    const javaFiles = fs.readdirSync('.').filter(f => f.endsWith('.java'));
    if (javaFiles.length === 0) {
        console.error('ERROR: No Java files were extracted!');
        process.exit(1);
    }
    
} catch (error) {
    console.error(`ERROR: Failed to parse bundle file: ${error.message}`);
    process.exit(1);
}

console.log('[2/5] Cleaning previous compilation artifacts...');
// Clean up any previous .class files
try {
    const classFiles = fs.readdirSync('.').filter(f => f.endsWith('.class'));
    for (const classFile of classFiles) {
        fs.unlinkSync(classFile);
        console.log(`  Deleted ${classFile}`);
    }
} catch (error) {
    // Ignore errors if no class files exist
}

console.log('[3/5] Compiling Java files...');
try {
    // Get list of Java files explicitly
    const javaFiles = fs.readdirSync('.').filter(f => f.endsWith('.java'));
    console.log(`  Found ${javaFiles.length} Java files to compile`);
    
    const compileCommand = `javac ${javaFiles.join(' ')}`;
    execSync(compileCommand, { stdio: 'inherit' });
    console.log('  Compilation successful!');
} catch (error) {
    console.error('ERROR: Compilation failed!');
    console.error(error.message);
    process.exit(1);
}

console.log('[4/5] Verifying main class...');
if (!fs.existsSync('ConversationCLI.class')) {
    console.error('ERROR: ConversationCLI.class not found after compilation!');
    process.exit(1);
}
} // End of extraction and compilation block

console.log('[5/5] Starting ConversationCLI...');
console.log('');
console.log('=====================================');
console.log('   Manual Coding Agent Started');
console.log('=====================================');
console.log('');

try {
    execSync(`java ConversationCLI "${EXECUTION_DIR}"`, { stdio: 'inherit' });
} catch (error) {
    // Java process was terminated, this is normal
}

console.log('');
console.log('=====================================');
console.log('   Manual Coding Agent Stopped');
console.log('=====================================');
|~|~|~|~|~|~|~|~|~|~|~|

FILE: mock-api.js
|~|~|~|~|~|~|~|~|~|~|~|
// Mock API for development - intercepts internal API calls and translates to Claude API
console.log('[Mock API] Mock API script loading...');

// Set a mock token in localStorage if none exists
if (!localStorage.getItem('token')) {
    localStorage.setItem('token', 'mock-dev-token-12345');
    console.log('[Mock API] Set mock token in localStorage');
}

console.log('[Mock API] Saving original fetch and installing mock...');
const originalFetch = window.fetch;

window.fetch = async function(url, options) {
    // Parse URL to get pathname regardless of domain
    const urlObj = new URL(url);
    
    console.log('[Mock API] Intercepting fetch to:', urlObj.href);
    
    // Mock /api/v1/chats/new - just return fake chat ID (no Claude API call)
    if (urlObj.pathname === '/api/v1/chats/new') {
        console.log('[Mock API] Mocking /new call - returning fake chat ID');
        const fakeResponse = {
            id: 'mock-chat-' + Date.now(),
            title: 'Mock Chat',
            status: 'created'
        };
        return new Response(JSON.stringify(fakeResponse), {
            status: 200,
            headers: { 'Content-Type': 'application/json' }
        });
    }
    
    // Mock /api/chat/completions - translate to Claude API
    if (urlObj.pathname === '/api/chat/completions') {
        console.log('[Mock API] Intercepting /completions call');
        
        const requestBody = JSON.parse(options.body);
        const messages = requestBody.messages;
        
        // Use hardcoded API key for local development
        const apiKey = 'f5c8df700ea8f9e68ebe304c8c45f549dd2b41778cc24bf86197046513a59683';
        
        console.log('[Mock API] Calling Claude API with', messages.length, 'messages');
        
        // Call Claude API
        const claudeResponse = await originalFetch('https://philhignight.com/api/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
                model: 'claude-3-5-sonnet-20241022',
                max_tokens: 8192,
                messages: messages,
                stream: false
            })
        });
        
        if (!claudeResponse.ok) {
            throw new Error(`Claude API error: ${claudeResponse.status}`);
        }
        
        const claudeData = await claudeResponse.json();
        let content = claudeData.content[0].text;
        
        console.log('[Mock API] Got response from Claude:', content.length, 'chars');
        
        // MOCK: Simulate response truncation at 12K characters (actual limit)
        if (content.length > 12000) {
            content = content.substring(0, 12000);
            console.log('[Mock API] SIMULATING TRUNCATION - cut response to 12K chars');
        }
        
        // Transform Claude response to SSE format expected by bridge
        const sseData = [
            'data: {"id":"mock-completion","object":"chat.completion.chunk","created":' + Math.floor(Date.now()/1000) + ',"model":"claude-3-5-sonnet","choices":[{"index":0,"delta":{"content":"' + content.replace(/\n/g, '\\n').replace(/"/g, '\\"') + '"},"finish_reason":null}]}',
            'data: {"id":"mock-completion","object":"chat.completion.chunk","created":' + Math.floor(Date.now()/1000) + ',"model":"claude-3-5-sonnet","choices":[{"index":0,"delta":{},"finish_reason":"stop"}]}',
            'data: [DONE]'
        ].join('\n\n') + '\n\n';
        
        // Return as SSE stream
        return new Response(sseData, {
            status: 200,
            headers: {
                'Content-Type': 'text/plain',
                'Cache-Control': 'no-cache',
                'Connection': 'keep-alive'
            }
        });
    }
    
    // For all other requests, use original fetch
    console.log('[Mock API] Passing through to original fetch:', urlObj.href);
    return originalFetch.apply(this, arguments);
};

console.log('[Mock API] Mock fetch installed successfully!');
|~|~|~|~|~|~|~|~|~|~|~|

