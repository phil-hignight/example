-~{File: src/java-agent/ClipboardAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;

public class ClipboardAgent {
    private static Clipboard clipboard;
    private static Robot robot;
    private static String savedClipboard = "";
    private static Point savedMousePosition = new Point(0, 0);
    private static volatile boolean stopClicking = false;
    private static TrayIcon trayIcon;
    private static ExecutorService executor;
    private static Color lastClickPixelColor = null;
    
    public static void main(String[] args) {
        try {
            // Initialize components
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            robot = new Robot();
            executor = Executors.newSingleThreadExecutor();
            
            // Setup system tray
            setupSystemTray();
            
            // Process commands from stdin
            Scanner scanner = new Scanner(System.in);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                processCommand(line);
            }
            
        } catch (Exception e) {
            sendError("Initialization failed: " + e.getMessage());
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            log("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create a simple icon (16x16 green square)
            Image image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics g = image.getGraphics();
            g.setColor(Color.GREEN);
            g.fillRect(0, 0, 16, 16);
            g.dispose();
            
            // Create tray icon
            trayIcon = new TrayIcon(image, "CCC Agent");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Ready");
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            log("System tray initialized");
            
        } catch (Exception e) {
            log("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void processCommand(String jsonCommand) {
        try {
            // Parse JSON manually (avoiding external dependencies)
            Map<String, Object> cmd = parseSimpleJson(jsonCommand);
            String command = (String) cmd.get("cmd");
            
            switch (command) {
                case "SAVE_CLIPBOARD":
                    saveClipboard();
                    break;
                    
                case "RESTORE_CLIPBOARD":
                    restoreClipboard();
                    break;
                    
                case "SET_CLIPBOARD":
                    setClipboard((String) cmd.get("data"));
                    break;
                    
                case "GET_CLIPBOARD":
                    getClipboard();
                    break;
                    
                case "SAVE_MOUSE":
                    saveMousePosition();
                    break;
                    
                case "GET_MOUSE":
                    getMousePosition();
                    break;
                    
                case "RESTORE_MOUSE":
                    restoreMousePosition();
                    break;
                    
                case "CAPTURE_PIXEL_COLOR":
                    capturePixelColor(parseInt(cmd.get("x")), parseInt(cmd.get("y")));
                    break;
                    
                case "CLICK_LOOP":
                    startClickLoop(
                        parseInt(cmd.get("x")),
                        parseInt(cmd.get("y")),
                        parseInt(cmd.get("interval")),
                        parseInt(cmd.get("maxDuration"))
                    );
                    break;
                    
                case "STOP_CLICKING":
                    stopClicking();
                    break;
                    
                case "SET_STATUS":
                    setStatus((String) cmd.get("message"));
                    break;
                    
                case "PING":
                    sendResponse("pong", null);
                    break;
                    
                default:
                    sendError("Unknown command: " + command);
            }
            
        } catch (Exception e) {
            sendError("Command processing failed: " + e.getMessage());
        }
    }
    
    private static void saveClipboard() {
        try {
            Transferable contents = clipboard.getContents(null);
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                savedClipboard = (String) contents.getTransferData(DataFlavor.stringFlavor);
                sendResponse("clipboard_saved", savedClipboard.length() + " chars");
            } else {
                savedClipboard = "";
                sendResponse("clipboard_saved", "empty");
            }
        } catch (Exception e) {
            sendError("Failed to save clipboard: " + e.getMessage());
        }
    }
    
    private static void restoreClipboard() {
        try {
            StringSelection selection = new StringSelection(savedClipboard);
            clipboard.setContents(selection, null);
            sendResponse("clipboard_restored", savedClipboard.length() + " chars");
        } catch (Exception e) {
            sendError("Failed to restore clipboard: " + e.getMessage());
        }
    }
    
    private static void setClipboard(String data) {
        try {
            StringSelection selection = new StringSelection(data);
            clipboard.setContents(selection, null);
            sendResponse("clipboard_set", data.length() + " chars");
        } catch (Exception e) {
            sendError("Failed to set clipboard: " + e.getMessage());
        }
    }
    
    private static void getClipboard() {
        try {
            Transferable contents = clipboard.getContents(null);
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                String data = (String) contents.getTransferData(DataFlavor.stringFlavor);
                sendResponse("clipboard_content", data);
            } else {
                sendResponse("clipboard_content", "");
            }
        } catch (Exception e) {
            sendError("Failed to get clipboard: " + e.getMessage());
        }
    }
    
    private static void saveMousePosition() {
        savedMousePosition = MouseInfo.getPointerInfo().getLocation();
        sendResponse("mouse_saved", savedMousePosition.x + "," + savedMousePosition.y);
    }
    
    private static void getMousePosition() {
        Point currentPos = MouseInfo.getPointerInfo().getLocation();
        sendResponse("mouse_position", currentPos.x + "," + currentPos.y);
    }
    
    private static void restoreMousePosition() {
        robot.mouseMove(savedMousePosition.x, savedMousePosition.y);
        sendResponse("mouse_restored", savedMousePosition.x + "," + savedMousePosition.y);
    }
    
    private static void capturePixelColor(int x, int y) {
        try {
            lastClickPixelColor = robot.getPixelColor(x, y);
            sendResponse("pixel_color_captured", 
                "R=" + lastClickPixelColor.getRed() + 
                " G=" + lastClickPixelColor.getGreen() + 
                " B=" + lastClickPixelColor.getBlue() + 
                " at " + x + "," + y);
        } catch (Exception e) {
            sendError("Failed to capture pixel color: " + e.getMessage());
        }
    }
    
    private static void startClickLoop(int x, int y, int interval, int maxDuration) {
        stopClicking = false;
        
        executor.submit(() -> {
            try {
                long startTime = System.currentTimeMillis();
                long lastActivityTime = startTime;
                long inactivityTimeoutMs = 3 * 1000; // 3 seconds of no expected activity
                int clickCount = 0;
                int colorMismatchCount = 0;
                
                while (!stopClicking && (System.currentTimeMillis() - startTime) < maxDuration) {
                    // Check for pixel color validation before clicking (if we have a reference color)
                    if (lastClickPixelColor != null) {
                        Color currentPixelColor = robot.getPixelColor(x, y);
                        
                        // Allow some tolerance for minor color variations
                        if (!isColorSimilar(currentPixelColor, lastClickPixelColor, 30)) {
                            colorMismatchCount++;
                            sendError("WARNING: Pixel color mismatch at " + x + "," + y + 
                                    ". Expected: R=" + lastClickPixelColor.getRed() + 
                                    " G=" + lastClickPixelColor.getGreen() + 
                                    " B=" + lastClickPixelColor.getBlue() + 
                                    ", Got: R=" + currentPixelColor.getRed() + 
                                    " G=" + currentPixelColor.getGreen() + 
                                    " B=" + currentPixelColor.getBlue());
                            
                            // If we get 3 consecutive mismatches, stop clicking
                            if (colorMismatchCount >= 3) {
                                sendError("ERROR: Multiple pixel color mismatches - stopping click loop. Window may have moved or been covered.");
                                stopClicking = true;
                                break;
                            }
                        } else {
                            colorMismatchCount = 0; // Reset count on successful match
                        }
                    }
                    
                    // Move to position
                    robot.mouseMove(x, y);
                    robot.delay(50);
                    
                    // Click with hold time (like the proven test)
                    robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
                    robot.delay(80); // Hold for 80ms like the test
                    robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
                    clickCount++;
                    lastActivityTime = System.currentTimeMillis();
                    
                    // Check for inactivity timeout
                    if ((System.currentTimeMillis() - lastActivityTime) > inactivityTimeoutMs) {
                        sendError("WARNING: No expected activity for " + (inactivityTimeoutMs/1000) + " seconds");
                        lastActivityTime = System.currentTimeMillis();
                    }
                    
                    // Wait for interval (use longer interval for more deliberate clicks)
                    Thread.sleep(Math.max(interval, 500)); // At least 500ms between clicks
                }
                
                sendResponse("click_loop_complete", clickCount + " clicks");
                
            } catch (Exception e) {
                sendError("Click loop failed: " + e.getMessage());
            }
        });
        
        sendResponse("click_loop_started", x + "," + y);
    }
    
    private static void stopClicking() {
        stopClicking = true;
        sendResponse("clicking_stopped", null);
    }
    
    private static void setStatus(String message) {
        if (trayIcon != null) {
            trayIcon.setToolTip("CCC Agent: " + message);
        }
        sendResponse("status_set", message);
    }
    
    // Helper methods
    private static Map<String, Object> parseSimpleJson(String json) {
        Map<String, Object> result = new HashMap<>();
        
        // Remove braces and split by comma
        json = json.trim();
        if (json.startsWith("{")) json = json.substring(1);
        if (json.endsWith("}")) json = json.substring(0, json.length() - 1);
        
        // Parse key-value pairs
        String[] pairs = json.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)");
        for (String pair : pairs) {
            String[] kv = pair.split(":", 2);
            if (kv.length == 2) {
                String key = kv[0].trim().replaceAll("\"", "");
                String value = kv[1].trim();
                
                // Remove quotes from string values
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    value = value.substring(1, value.length() - 1);
                    // Unescape JSON string
                    value = value.replace("\\\"", "\"")
                                 .replace("\\\\", "\\")
                                 .replace("\\n", "\n")
                                 .replace("\\r", "\r")
                                 .replace("\\t", "\t");
                }
                
                result.put(key, value);
            }
        }
        
        return result;
    }
    
    private static int parseInt(Object value) {
        if (value == null) return 0;
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            return 0;
        }
    }
    
    private static void sendResponse(String type, String data) {
        // For clipboard_content, send raw data without escaping
        if ("clipboard_content".equals(type) && data != null) {
            String response = String.format("{\"type\":\"%s\",\"data\":%s,\"timestamp\":%d}",
                type, escapeJson(data), System.currentTimeMillis());
            System.out.println(response);
        } else {
            String response = String.format("{\"type\":\"%s\",\"data\":\"%s\",\"timestamp\":%d}",
                type, data != null ? data : "", System.currentTimeMillis());
            System.out.println(response);
        }
        System.out.flush();
    }
    
    private static String escapeJson(String str) {
        return "\"" + str.replace("\\", "\\\\")
                         .replace("\"", "\\\"")
                         .replace("\n", "\\n")
                         .replace("\r", "\\r")
                         .replace("\t", "\\t") + "\"";
    }
    
    private static void sendError(String error) {
        String response = String.format("{\"type\":\"error\",\"error\":\"%s\",\"timestamp\":%d}",
            error, System.currentTimeMillis());
        System.out.println(response);
        System.out.flush();
    }
    
    private static boolean isColorSimilar(Color c1, Color c2, int tolerance) {
        // Check if two colors are similar within a tolerance level
        // This accounts for minor variations due to lighting, compression, etc.
        int rDiff = Math.abs(c1.getRed() - c2.getRed());
        int gDiff = Math.abs(c1.getGreen() - c2.getGreen());
        int bDiff = Math.abs(c1.getBlue() - c2.getBlue());
        
        return (rDiff <= tolerance && gDiff <= tolerance && bDiff <= tolerance);
    }
    
    private static void log(String message) {
        System.err.println("[Agent] " + message);
    }
}
-~{END}~-

-~{File: src/java-agent/ClipboardAgentHeadless.java}~-
import java.io.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * Headless version of ClipboardAgent for testing without X11
 * This simulates clipboard and mouse operations for development/testing
 */
public class ClipboardAgentHeadless {
    private static String savedClipboard = "";
    private static String simulatedClipboard = "";
    private static int[] savedMousePosition = {0, 0};
    private static volatile boolean stopClicking = false;
    private static ExecutorService executor;
    private static boolean headlessMode = true;
    
    public static void main(String[] args) {
        try {
            // Check if we're in headless mode
            String display = System.getenv("DISPLAY");
            if (display == null || display.isEmpty()) {
                log("Running in headless mode (no X11 display)");
                log("Clipboard and mouse operations will be simulated");
                headlessMode = true;
            } else {
                log("Display found: " + display);
                headlessMode = false;
            }
            
            executor = Executors.newSingleThreadExecutor();
            
            // Process commands from stdin
            Scanner scanner = new Scanner(System.in);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                processCommand(line);
            }
            
        } catch (Exception e) {
            sendError("Initialization failed: " + e.getMessage());
            System.exit(1);
        }
    }
    
    private static void processCommand(String jsonCommand) {
        try {
            Map<String, Object> cmd = parseSimpleJson(jsonCommand);
            String command = (String) cmd.get("cmd");
            
            switch (command) {
                case "SAVE_CLIPBOARD":
                    saveClipboard();
                    break;
                    
                case "RESTORE_CLIPBOARD":
                    restoreClipboard();
                    break;
                    
                case "SET_CLIPBOARD":
                    setClipboard((String) cmd.get("data"));
                    break;
                    
                case "GET_CLIPBOARD":
                    getClipboard();
                    break;
                    
                case "SAVE_MOUSE":
                    saveMousePosition();
                    break;
                    
                case "RESTORE_MOUSE":
                    restoreMousePosition();
                    break;
                    
                case "CLICK_LOOP":
                    startClickLoop(
                        parseInt(cmd.get("x")),
                        parseInt(cmd.get("y")),
                        parseInt(cmd.get("interval")),
                        parseInt(cmd.get("maxDuration"))
                    );
                    break;
                    
                case "STOP_CLICKING":
                    stopClicking();
                    break;
                    
                case "SET_STATUS":
                    setStatus((String) cmd.get("message"));
                    break;
                    
                case "PING":
                    sendResponse("pong", null);
                    break;
                    
                default:
                    sendError("Unknown command: " + command);
            }
            
        } catch (Exception e) {
            sendError("Command processing failed: " + e.getMessage());
        }
    }
    
    private static void saveClipboard() {
        try {
            if (headlessMode) {
                // In headless mode, save the simulated clipboard
                savedClipboard = simulatedClipboard;
                sendResponse("clipboard_saved", savedClipboard.length() + " chars (simulated)");
            } else {
                // Would use real clipboard here
                sendResponse("clipboard_saved", "0 chars");
            }
        } catch (Exception e) {
            sendError("Failed to save clipboard: " + e.getMessage());
        }
    }
    
    private static void restoreClipboard() {
        try {
            if (headlessMode) {
                simulatedClipboard = savedClipboard;
                sendResponse("clipboard_restored", savedClipboard.length() + " chars (simulated)");
            } else {
                sendResponse("clipboard_restored", "0 chars");
            }
        } catch (Exception e) {
            sendError("Failed to restore clipboard: " + e.getMessage());
        }
    }
    
    private static void setClipboard(String data) {
        try {
            if (headlessMode) {
                simulatedClipboard = data;
                log("Simulated clipboard set: " + data.substring(0, Math.min(100, data.length())) + "...");
                sendResponse("clipboard_set", data.length() + " chars (simulated)");
            } else {
                sendResponse("clipboard_set", "0 chars");
            }
        } catch (Exception e) {
            sendError("Failed to set clipboard: " + e.getMessage());
        }
    }
    
    private static void getClipboard() {
        try {
            if (headlessMode) {
                sendResponse("clipboard_content", simulatedClipboard);
            } else {
                sendResponse("clipboard_content", "");
            }
        } catch (Exception e) {
            sendError("Failed to get clipboard: " + e.getMessage());
        }
    }
    
    private static void saveMousePosition() {
        if (headlessMode) {
            // Simulate saving mouse position
            savedMousePosition[0] = 100;
            savedMousePosition[1] = 100;
            sendResponse("mouse_saved", savedMousePosition[0] + "," + savedMousePosition[1] + " (simulated)");
        } else {
            sendResponse("mouse_saved", "0,0");
        }
    }
    
    private static void restoreMousePosition() {
        if (headlessMode) {
            sendResponse("mouse_restored", savedMousePosition[0] + "," + savedMousePosition[1] + " (simulated)");
        } else {
            sendResponse("mouse_restored", "0,0");
        }
    }
    
    private static void startClickLoop(int x, int y, int interval, int maxDuration) {
        stopClicking = false;
        
        executor.submit(() -> {
            try {
                long startTime = System.currentTimeMillis();
                int clickCount = 0;
                
                log("Starting simulated click loop at " + x + "," + y);
                
                while (!stopClicking && (System.currentTimeMillis() - startTime) < maxDuration) {
                    // Simulate clicking
                    clickCount++;
                    
                    if (clickCount % 10 == 0) {
                        log("Simulated clicks: " + clickCount);
                    }
                    
                    // Check clipboard for response every 5 clicks
                    if (clickCount % 5 == 0 && headlessMode) {
                        // Simulate finding a response after some clicks
                        if (clickCount == 15 && simulatedClipboard.contains("CCC_REQUEST")) {
                            // Extract request ID from the request
                            String requestId = extractRequestId(simulatedClipboard);
                            // Simulate browser response with matching ID
                            String mockResponse = String.format(
                                "{\"type\":\"BROWSER_RESPONSE\",\"id\":\"%s\",\"status\":\"success\",\"payload\":{\"content\":\"Mock response from simulated browser\"}}|||BROWSER_END|||",
                                requestId
                            );
                            simulatedClipboard = mockResponse;
                            log("Simulated browser response written to clipboard with ID: " + requestId);
                        }
                    }
                    
                    Thread.sleep(interval);
                }
                
                sendResponse("click_loop_complete", clickCount + " clicks (simulated)");
                
            } catch (Exception e) {
                sendError("Click loop failed: " + e.getMessage());
            }
        });
        
        sendResponse("click_loop_started", x + "," + y + " (simulated)");
    }
    
    private static void stopClicking() {
        stopClicking = true;
        sendResponse("clicking_stopped", null);
    }
    
    private static void setStatus(String message) {
        log("Status: " + message);
        sendResponse("status_set", message);
    }
    
    // Helper methods
    private static String extractRequestId(String clipboardContent) {
        try {
            // Extract the JSON part before |||CCC_END|||
            int endIndex = clipboardContent.indexOf("|||CCC_END|||");
            if (endIndex > 0) {
                clipboardContent = clipboardContent.substring(0, endIndex);
            }
            
            // Simple extraction of id field from JSON
            int idIndex = clipboardContent.indexOf("\"id\":");
            if (idIndex > 0) {
                int startQuote = clipboardContent.indexOf("\"", idIndex + 5);
                int endQuote = clipboardContent.indexOf("\"", startQuote + 1);
                if (startQuote > 0 && endQuote > startQuote) {
                    return clipboardContent.substring(startQuote + 1, endQuote);
                }
            }
        } catch (Exception e) {
            log("Failed to extract request ID: " + e.getMessage());
        }
        return "unknown-id";
    }
    
    private static Map<String, Object> parseSimpleJson(String json) {
        Map<String, Object> result = new HashMap<>();
        
        json = json.trim();
        if (json.startsWith("{")) json = json.substring(1);
        if (json.endsWith("}")) json = json.substring(0, json.length() - 1);
        
        String[] pairs = json.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)");
        for (String pair : pairs) {
            String[] kv = pair.split(":", 2);
            if (kv.length == 2) {
                String key = kv[0].trim().replaceAll("\"", "");
                String value = kv[1].trim();
                
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    value = value.substring(1, value.length() - 1);
                }
                
                result.put(key, value);
            }
        }
        
        return result;
    }
    
    private static int parseInt(Object value) {
        if (value == null) return 0;
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            return 0;
        }
    }
    
    private static void sendResponse(String type, String data) {
        String response = String.format("{\"type\":\"%s\",\"data\":\"%s\",\"timestamp\":%d}",
            type, data != null ? data : "", System.currentTimeMillis());
        System.out.println(response);
        System.out.flush();
    }
    
    private static void sendError(String error) {
        String response = String.format("{\"type\":\"error\",\"error\":\"%s\",\"timestamp\":%d}",
            error, System.currentTimeMillis());
        System.out.println(response);
        System.out.flush();
    }
    
    private static void log(String message) {
        System.err.println("[Headless Agent] " + message);
    }
}
-~{END}~-

-~{File: src/java-agent/compile.sh}~-
#!/bin/bash

echo "Compiling Java agents..."

# Clean up old files
rm -f agent.jar agent-headless.jar chat-server.jar *.class manifest.txt

# Check if display is available
if [ -z "$DISPLAY" ]; then
    echo "No X11 display detected, compiling headless version only"
    
    # Compile headless agent
    javac ClipboardAgentHeadless.java
    
    if [ $? -ne 0 ]; then
        echo "ERROR: Java compilation failed"
        exit 1
    fi
    
    # Create manifest for headless JAR
    echo "Main-Class: ClipboardAgentHeadless" > manifest.txt
    
    # Create headless JAR
    jar cfm agent-headless.jar manifest.txt ClipboardAgentHeadless.class
    
    # Link as main agent.jar
    cp agent-headless.jar agent.jar
    
    echo "Headless Java agent compiled successfully"
else
    echo "X11 display found, compiling both versions..."
    
    # Compile full agent
    javac ClipboardAgent.java
    
    if [ $? -ne 0 ]; then
        echo "ERROR: Java compilation failed"
        exit 1
    fi
    
    # Also compile headless for testing
    javac ClipboardAgentHeadless.java
    
    # Create manifest for full JAR
    echo "Main-Class: ClipboardAgent" > manifest.txt
    jar cfm agent.jar manifest.txt ClipboardAgent.class
    
    # Create manifest for headless JAR
    echo "Main-Class: ClipboardAgentHeadless" > manifest.txt
    jar cfm agent-headless.jar manifest.txt ClipboardAgentHeadless.class
    
    echo "Both Java agents compiled successfully"
fi

# Compile ChatServerAgent (always, regardless of display)
echo "Compiling ChatServerAgent..."
javac ChatServerAgent.java

if [ $? -ne 0 ]; then
    echo "ERROR: ChatServerAgent compilation failed"
    exit 1
fi

# Create chat server JAR
echo "Main-Class: ChatServerAgent" > manifest.txt
jar cfm chat-server.jar manifest.txt *.class

echo "ChatServerAgent compiled successfully"

# Clean up
rm -f *.class manifest.txt

echo "Done. Available JARs:"
ls -la *.jar
-~{END}~-

-~{File: src/java-agent/ChatServerAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;
import com.sun.net.httpserver.*;

public class ChatServerAgent {
    private static Clipboard clipboard;
    private static Robot robot;
    private static String savedClipboard = "";
    private static Point clickPosition = null;
    private static Color calibrationPixelColor = null;
    private static volatile boolean calibrated = false;
    private static TrayIcon trayIcon;
    private static HttpServer server;
    private static final int SERVER_PORT = 4444;
    private static final String FRONTEND_URL = "http://localhost:" + SERVER_PORT;
    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static Map<String, PendingRequest> pendingRequests = new ConcurrentHashMap<>();
    private static Map<String, Future<?>> clickingTasks = new ConcurrentHashMap<>();
    private static String lastClipboardContent = "";
    
    static class PendingRequest {
        String requestId;
        HttpExchange exchange;
        long timestamp;
        
        PendingRequest(String requestId, HttpExchange exchange) {
            this.requestId = requestId;
            this.exchange = exchange;
            this.timestamp = System.currentTimeMillis();
        }
    }
    
    public static void main(String[] args) {
        try {
            // Initialize components
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            robot = new Robot();
            
            // Setup system tray
            setupSystemTray();
            
            // Start HTTP server
            startHttpServer();
            
            // Launch Chrome
            launchChrome();
            
            // Copy bridge script to clipboard
            copyBridgeScriptToClipboard();
            
            // Start clipboard monitoring
            startClipboardMonitoring();
            
            // Keep running
            System.out.println("CCC Chat Server running. Press Ctrl+C to exit.");
            
            // Shutdown hook
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                System.out.println("Shutting down CCC Chat Server...");
                if (server != null) {
                    server.stop(0);
                }
                executor.shutdown();
            }));
            
            // Keep main thread alive
            while (true) {
                Thread.sleep(1000);
            }
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            System.out.println("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create icon (16x16 pixels)
            BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics2D g = image.createGraphics();
            g.setColor(Color.BLUE);
            g.fillOval(0, 0, 16, 16);
            g.dispose();
            
            trayIcon = new TrayIcon(image, "CCC Chat Server");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Starting...");
            MenuItem urlItem = new MenuItem("Open: " + FRONTEND_URL);
            MenuItem exitItem = new MenuItem("Exit");
            
            urlItem.addActionListener(e -> {
                try {
                    Desktop.getDesktop().browse(new URI(FRONTEND_URL));
                } catch (Exception ex) {
                    System.err.println("Could not open browser: " + ex.getMessage());
                }
            });
            
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.add(urlItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            System.out.println("System tray initialized");
            
        } catch (Exception e) {
            System.out.println("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void startHttpServer() throws Exception {
        server = HttpServer.create(new InetSocketAddress(SERVER_PORT), 0);
        
        // Serve static files
        server.createContext("/", new StaticFileHandler());
        
        // API endpoints
        server.createContext("/api/chat", new ChatHandler());
        server.createContext("/api/tools/search-files", new FileSearchHandler());
        server.createContext("/api/tool-result", new ToolResultHandler());
        
        server.setExecutor(executor);
        server.start();
        
        System.out.println("HTTP server started on port " + SERVER_PORT);
        System.out.println("Frontend available at: " + FRONTEND_URL);
        
        updateTrayStatus("HTTP server running on port " + SERVER_PORT);
    }
    
    private static void launchChrome() {
        try {
            // Try different Chrome executable locations
            String[] chromePaths = {
                "google-chrome",
                "google-chrome-stable", 
                "chromium-browser",
                "chromium",
                "/usr/bin/google-chrome",
                "/usr/bin/chromium-browser",
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"
            };
            
            for (String chromePath : chromePaths) {
                try {
                    ProcessBuilder pb = new ProcessBuilder(chromePath, "--new-window", FRONTEND_URL);
                    Process process = pb.start();
                    System.out.println("Chrome launched successfully with: " + chromePath);
                    updateTrayStatus("Chrome launched - Ready for chat");
                    return;
                } catch (Exception e) {
                    // Try next path
                }
            }
            
            // Fallback to system default browser
            if (Desktop.isDesktopSupported()) {
                Desktop.getDesktop().browse(new URI(FRONTEND_URL));
                System.out.println("Opened default browser (Chrome not found)");
                updateTrayStatus("Browser opened - Ready for chat");
            } else {
                System.out.println("Could not launch browser automatically");
                System.out.println("Please open: " + FRONTEND_URL);
                updateTrayStatus("Manual browser open required");
            }
            
        } catch (Exception e) {
            System.err.println("Could not launch browser: " + e.getMessage());
            System.out.println("Please open: " + FRONTEND_URL);
            updateTrayStatus("Manual browser open required");
        }
    }
    
    private static void startClipboardMonitoring() {
        executor.submit(() -> {
            System.out.println("Starting clipboard monitoring for responses...");
            
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Thread.sleep(100); // Check every 100ms
                    
                    String clipboardText = getClipboardContent();
                    if (clipboardText != null && !clipboardText.equals(lastClipboardContent)) {
                        lastClipboardContent = clipboardText;
                        
                        // Skip if this is just the bridge script (contains function definitions but no actual messages)
                        if (clipboardText.startsWith("// CCC Browser Bridge Script")) {
                            continue;
                        }
                        
                        // Debug: Show what we found in clipboard
                        if (clipboardText.length() < 200) {
                            System.out.println("[DEBUG] Clipboard content: " + clipboardText);
                        } else {
                            System.out.println("[DEBUG] Clipboard content (first 100 chars): " + clipboardText.substring(0, 100) + "...");
                        }
                        
                        // Handle calibration (must be a proper JSON message, not code)
                        if (clipboardText.contains("CCC_CALIBRATION") && clipboardText.contains("|||CCC_END|||") && clipboardText.startsWith("{")) {
                            handleCalibration(clipboardText);
                        }
                        // Handle progress updates
                        else if (clipboardText.contains("BROWSER_PROGRESS") && clipboardText.contains("|||BROWSER_PROGRESS|||")) {
                            handleProgressUpdate(clipboardText);
                        }
                        // Handle final responses
                        else if (clipboardText.contains("BROWSER_RESPONSE") && clipboardText.contains("|||BROWSER_END|||")) {
                            handleFinalResponse(clipboardText);
                        }
                    }
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (Exception e) {
                    // Ignore clipboard errors
                }
            }
        });
    }
    
    private static void handleCalibration(String clipboardText) {
        try {
            String jsonText = clipboardText.split("\\|\\|\\|CCC_END\\|\\|\\|")[0];
            System.out.println("Received calibration message");
            
            // Capture current mouse position (screen coordinates) when calibration message is received
            clickPosition = MouseInfo.getPointerInfo().getLocation();
            
            // Capture pixel color at calibration position for validation
            calibrationPixelColor = robot.getPixelColor(clickPosition.x, clickPosition.y);
            calibrated = true;
            
            System.out.println("✓ Calibration complete! Click position set to: " + clickPosition.x + ", " + clickPosition.y);
            System.out.println("✓ Calibration pixel color captured: R=" + calibrationPixelColor.getRed() + 
                             " G=" + calibrationPixelColor.getGreen() + " B=" + calibrationPixelColor.getBlue());
            updateTrayStatus("Calibrated - Ready for chat requests");
            
        } catch (Exception e) {
            System.err.println("Error handling calibration: " + e.getMessage());
        }
    }
    
    private static void handleProgressUpdate(String clipboardText) {
        try {
            String jsonText = clipboardText.split("\\|\\|\\|BROWSER_PROGRESS\\|\\|\\|")[0];
            System.out.println("Processing progress update: " + jsonText.substring(0, Math.min(100, jsonText.length())) + "...");
            
            // Simple JSON parsing for request ID
            String requestId = extractJsonField(jsonText, "id");
            String accumulated = extractJsonField(jsonText, "accumulated");
            
            if (requestId != null && accumulated != null) {
                PendingRequest pending = pendingRequests.get(requestId);
                if (pending != null) {
                    // Send SSE progress update to frontend
                    sendSSEUpdate(pending.exchange, "data: " + jsonText + "\n\n");
                    System.out.println("Progress update sent to frontend for request: " + requestId);
                } else {
                    System.out.println("No pending request found for: " + requestId);
                }
            } else {
                System.out.println("Could not extract request ID or accumulated content from progress update");
            }
            
        } catch (Exception e) {
            System.err.println("Error handling progress update: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static void handleFinalResponse(String clipboardText) {
        try {
            String jsonText = clipboardText.split("\\|\\|\\|BROWSER_END\\|\\|\\|")[0];
            System.out.println("Processing final response: " + jsonText.substring(0, Math.min(100, jsonText.length())) + "...");
            
            String requestId = extractJsonField(jsonText, "id");
            
            if (requestId != null) {
                // Stop continuous clicking
                stopContinuousClicking(requestId);
                
                PendingRequest pending = pendingRequests.remove(requestId);
                if (pending != null) {
                    // Send final SSE response and close
                    sendSSEUpdate(pending.exchange, "data: " + jsonText + "\n\n");
                    sendSSEUpdate(pending.exchange, "data: [DONE]\n\n");
                    
                    System.out.println("Final response sent to frontend for request: " + requestId);
                    
                    try {
                        pending.exchange.getResponseBody().close();
                    } catch (IOException e) {
                        // Ignore close errors
                    }
                    
                    System.out.println("Response completed for request: " + requestId);
                } else {
                    System.out.println("No pending request found for final response: " + requestId);
                }
            } else {
                System.out.println("Could not extract request ID from final response");
            }
            
        } catch (Exception e) {
            System.err.println("Error handling final response: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static void sendSSEUpdate(HttpExchange exchange, String data) {
        try {
            OutputStream os = exchange.getResponseBody();
            byte[] bytes = data.getBytes("UTF-8");
            os.write(bytes);
            os.flush();
            System.out.println("[SSE DEBUG] Sent " + bytes.length + " bytes: " + data.substring(0, Math.min(50, data.length())) + "...");
        } catch (Exception e) {
            System.err.println("Error sending SSE update: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static String extractJsonField(String json, String field) {
        try {
            String pattern = "\"" + field + "\":\"";
            int start = json.indexOf(pattern);
            if (start == -1) return null;
            start += pattern.length();
            
            int end = json.indexOf("\"", start);
            if (end == -1) return null;
            
            return json.substring(start, end);
        } catch (Exception e) {
            return null;
        }
    }
    
    private static String extractNestedJsonField(String json, String parentField, String field) {
        try {
            // Find the parent object
            String parentPattern = "\"" + parentField + "\":{";
            int parentStart = json.indexOf(parentPattern);
            if (parentStart == -1) return null;
            
            // Find the field within the parent object
            String pattern = "\"" + field + "\":\"";
            int start = json.indexOf(pattern, parentStart);
            if (start == -1) return null;
            start += pattern.length();
            
            int end = json.indexOf("\"", start);
            if (end == -1) return null;
            
            return json.substring(start, end);
        } catch (Exception e) {
            return null;
        }
    }
    
    private static String extractNestedJsonObject(String json, String parentField, String field) {
        try {
            // Find the parent object
            String parentPattern = "\"" + parentField + "\":{";
            int parentStart = json.indexOf(parentPattern);
            if (parentStart == -1) return null;
            
            // Find the field within the parent object
            String pattern = "\"" + field + "\":";
            int fieldStart = json.indexOf(pattern, parentStart);
            if (fieldStart == -1) return null;
            fieldStart += pattern.length();
            
            // Extract the JSON object value (could be {}, [], or simple value)
            int braceCount = 0;
            int bracketCount = 0;
            boolean inString = false;
            boolean escaped = false;
            int start = fieldStart;
            
            // Skip whitespace
            while (start < json.length() && Character.isWhitespace(json.charAt(start))) {
                start++;
            }
            
            int end = start;
            char firstChar = json.charAt(start);
            
            if (firstChar == '{') {
                braceCount = 1;
                end++;
                
                while (end < json.length() && braceCount > 0) {
                    char c = json.charAt(end);
                    
                    if (escaped) {
                        escaped = false;
                    } else if (c == '\\') {
                        escaped = true;
                    } else if (c == '"') {
                        inString = !inString;
                    } else if (!inString) {
                        if (c == '{') braceCount++;
                        else if (c == '}') braceCount--;
                    }
                    end++;
                }
            } else if (firstChar == '[') {
                bracketCount = 1;
                end++;
                
                while (end < json.length() && bracketCount > 0) {
                    char c = json.charAt(end);
                    
                    if (escaped) {
                        escaped = false;
                    } else if (c == '\\') {
                        escaped = true;
                    } else if (c == '"') {
                        inString = !inString;
                    } else if (!inString) {
                        if (c == '[') bracketCount++;
                        else if (c == ']') bracketCount--;
                    }
                    end++;
                }
            } else {
                // Simple value - find end by comma, brace, or bracket
                while (end < json.length()) {
                    char c = json.charAt(end);
                    if (!inString && (c == ',' || c == '}' || c == ']')) {
                        break;
                    }
                    if (escaped) {
                        escaped = false;
                    } else if (c == '\\') {
                        escaped = true;
                    } else if (c == '"') {
                        inString = !inString;
                    }
                    end++;
                }
            }
            
            return json.substring(start, end).trim();
        } catch (Exception e) {
            return null;
        }
    }
    
    private static void copyBridgeScriptToClipboard() {
        try {
            System.out.println("Copying bridge script to clipboard...");
            
            // Read the bridge script file
            String scriptPath = "src/browser-bridge/bridge-api.js";
            File scriptFile = new File(scriptPath);
            
            if (!scriptFile.exists()) {
                System.err.println("Bridge script not found at: " + scriptPath);
                System.out.println("Please manually copy the bridge script from the browser-bridge directory");
                return;
            }
            
            // Read file contents
            StringBuilder scriptContent = new StringBuilder();
            try (java.io.BufferedReader reader = new java.io.BufferedReader(
                    new java.io.FileReader(scriptFile))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    scriptContent.append(line).append("\n");
                }
            }
            
            // Copy to clipboard
            StringSelection selection = new StringSelection(scriptContent.toString());
            clipboard.setContents(selection, null);
            
            System.out.println("✓ Bridge script copied to clipboard (" + scriptContent.length() + " characters)");
            System.out.println();
            System.out.println("Next steps:");
            System.out.println("1. Open your internal Claude UI in a browser tab");
            System.out.println("2. Open Developer Console (F12)");
            System.out.println("3. Paste the bridge script (Ctrl+V) and press Enter");
            System.out.println("4. Click anywhere on the page to calibrate the clicking position");
            System.out.println("5. Return to http://localhost:4444 and start chatting!");
            System.out.println();
            
            updateTrayStatus("Bridge script ready - Paste in Claude UI");
            
        } catch (Exception e) {
            System.err.println("Failed to copy bridge script to clipboard: " + e.getMessage());
            System.out.println("Please manually copy the bridge script from src/browser-bridge/bridge-api.js");
        }
    }
    
    private static void updateTrayStatus(String status) {
        if (trayIcon != null) {
            PopupMenu popup = trayIcon.getPopupMenu();
            if (popup.getItemCount() > 0) {
                MenuItem statusItem = popup.getItem(0);
                statusItem.setLabel("Status: " + status);
            }
        }
    }
    
    // HTTP Handlers
    static class StaticFileHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String path = exchange.getRequestURI().getPath();
            
            if (path.equals("/") || path.equals("/index.html")) {
                sendChatInterface(exchange);
            } else if (path.startsWith("/css/") || path.startsWith("/js/")) {
                // Serve static assets (CSS/JS files)
                String filePath = "web" + path;
                serveFile(exchange, filePath);
            } else {
                send404(exchange);
            }
        }
        
        private void sendChatInterface(HttpExchange exchange) throws IOException {
            serveFile(exchange, "web/index.html");
        }
        
        private void serveFile(HttpExchange exchange, String filePath) throws IOException {
            File file = new File(filePath);
            
            // If file doesn't exist, try looking in current directory first
            if (!file.exists()) {
                // Try current working directory
                File currentDir = new File(System.getProperty("user.dir"));
                System.out.println("Current working directory: " + currentDir.getAbsolutePath());
                System.out.println("Looking for file: " + filePath);
                
                // Try different possible locations
                File[] possibleFiles = {
                    new File(filePath),                                    // Original path
                    new File("src/java-agent/" + filePath),              // From project root
                    new File("../" + filePath),                          // From java-agent directory
                    new File("./" + filePath)                            // Current directory
                };
                
                for (File possibleFile : possibleFiles) {
                    System.out.println("Trying: " + possibleFile.getAbsolutePath());
                    if (possibleFile.exists()) {
                        file = possibleFile;
                        System.out.println("Found file at: " + file.getAbsolutePath());
                        break;
                    }
                }
                
                if (!file.exists()) {
                    System.out.println("File not found in any location: " + filePath);
                    sendResponse(exchange, 404, "File not found: " + filePath);
                    return;
                }
            }
            
            byte[] bytes = readFileBytes(file);
            String contentType = getContentType(filePath);
            
            exchange.getResponseHeaders().set("Content-Type", contentType);
            exchange.sendResponseHeaders(200, bytes.length);
            try (OutputStream os = exchange.getResponseBody()) {
                os.write(bytes);
            }
        }
        
        private byte[] readFileBytes(File file) throws IOException {
            try (FileInputStream fis = new FileInputStream(file)) {
                return fis.readAllBytes();
            }
        }
        
        private String getContentType(String filePath) {
            if (filePath.endsWith(".html")) return "text/html";
            if (filePath.endsWith(".css")) return "text/css";
            if (filePath.endsWith(".js")) return "application/javascript";
            return "text/plain";
        }
        
        private void send404(HttpExchange exchange) throws IOException {
            String response = "404 Not Found";
            byte[] bytes = response.getBytes("UTF-8");
            exchange.sendResponseHeaders(404, bytes.length);
            
            OutputStream os = exchange.getResponseBody();
            os.write(bytes);
            os.close();
        }
        
        private void sendResponse(HttpExchange exchange, int statusCode, String message) throws IOException {
            byte[] bytes = message.getBytes("UTF-8");
            exchange.sendResponseHeaders(statusCode, bytes.length);
            
            OutputStream os = exchange.getResponseBody();
            os.write(bytes);
            os.close();
        }
    }
    
    static class ChatHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Received chat request: " + requestBody);
                
                // Parse request to get ID
                String requestId = extractJsonField(requestBody, "id");
                if (requestId == null) {
                    throw new Exception("No request ID found");
                }
                
                // Store pending request for response correlation
                pendingRequests.put(requestId, new PendingRequest(requestId, exchange));
                
                // Set up SSE response headers
                exchange.getResponseHeaders().set("Content-Type", "text/event-stream");
                exchange.getResponseHeaders().set("Cache-Control", "no-cache");
                exchange.getResponseHeaders().set("Connection", "keep-alive");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                exchange.sendResponseHeaders(200, 0);
                
                // Forward request via clipboard bridge
                String clipboardRequest = requestBody + "|||CCC_END|||";
                setClipboard(clipboardRequest);
                
                System.out.println("Request forwarded via clipboard bridge");
                
                // Start continuous clicking until response completes (if calibrated)
                if (calibrated && clickPosition != null) {
                    startContinuousClicking(requestId);
                }
                
            } catch (Exception e) {
                System.err.println("Chat request error: " + e.getMessage());
                
                // Send error response
                String errorResponse = "HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n" + e.getMessage();
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                OutputStream os = exchange.getResponseBody();
                os.write(bytes);
                os.close();
            }
        }
    }
    
    static class FileSearchHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("File search request: " + requestBody);
                
                // Parse query from request
                String query = extractJsonField(requestBody, "query");
                if (query == null || query.trim().isEmpty()) {
                    throw new Exception("No query provided");
                }
                
                // Execute file search using PowerShell
                java.util.List<String> files = searchFiles(query);
                
                // Create response
                String response = "{\"files\":[" + 
                    files.stream()
                        .map(file -> "\"" + file.replace("\\", "\\\\").replace("\"", "\\\"") + "\"")
                        .reduce((a, b) -> a + "," + b)
                        .orElse("") +
                    "]}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("File search error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class ToolResultHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Tool result: " + requestBody);
                
                // Parse request to get ID for response correlation first
                String requestId = extractJsonField(requestBody, "id");
                
                // Extract the messages array from the tool result request
                String messagesJson = extractNestedJsonObject(requestBody, "payload", "messages");
                
                // Create a proper chat request with the full conversation history
                String chatRequest = String.format(
                    "{\"type\":\"CCC_REQUEST\",\"id\":\"%s\",\"timestamp\":%d,\"action\":\"ai-complete\",\"payload\":{\"messages\":%s}}",
                    requestId,
                    System.currentTimeMillis(),
                    messagesJson != null ? messagesJson : "[]"
                );
                
                // Forward formatted request to AI via clipboard bridge
                String clipboardRequest = chatRequest + "|||CCC_END|||";
                setClipboard(clipboardRequest);
                if (requestId != null) {
                    // Store pending request for SSE response
                    pendingRequests.put(requestId, new PendingRequest(requestId, exchange));
                    
                    // Set up SSE response headers
                    exchange.getResponseHeaders().set("Content-Type", "text/event-stream");
                    exchange.getResponseHeaders().set("Cache-Control", "no-cache");
                    exchange.getResponseHeaders().set("Connection", "keep-alive");
                    exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                    exchange.sendResponseHeaders(200, 0);
                    
                    // Start continuous clicking if calibrated
                    System.out.println("Tool result - checking calibration: calibrated=" + calibrated + ", clickPosition=" + clickPosition);
                    if (calibrated && clickPosition != null) {
                        System.out.println("Starting continuous clicking for tool result request: " + requestId);
                        startContinuousClicking(requestId);
                    } else {
                        System.out.println("Cannot start clicking - not calibrated or no click position");
                    }
                } else {
                    // Simple acknowledgment response
                    String response = "{\"status\":\"received\"}";
                    exchange.getResponseHeaders().set("Content-Type", "application/json");
                    byte[] bytes = response.getBytes("UTF-8");
                    exchange.sendResponseHeaders(200, bytes.length);
                    
                    try (OutputStream os = exchange.getResponseBody()) {
                        os.write(bytes);
                    }
                }
                
            } catch (Exception e) {
                System.err.println("Tool result error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    private static java.util.List<String> searchFiles(String query) throws Exception {
        java.util.List<String> results = new java.util.ArrayList<>();
        
        // Use PowerShell to search for files
        String command = "powershell.exe -Command \"Get-ChildItem -Recurse -File | Where-Object { $_.Name -like '*" + 
                        query.replace("'", "''") + "*' } | Select-Object -First 20 | ForEach-Object { $_.FullName }\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    results.add(line);
                }
            }
        }
        
        process.waitFor();
        return results;
    }
    
    private static String getClipboardContent() throws Exception {
        Transferable contents = clipboard.getContents(null);
        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
            return (String) contents.getTransferData(DataFlavor.stringFlavor);
        }
        return null;
    }
    
    private static void setClipboard(String text) throws Exception {
        StringSelection selection = new StringSelection(text);
        clipboard.setContents(selection, null);
    }
    
    private static void startContinuousClicking(String requestId) {
        System.out.println("Starting continuous clicking for request: " + requestId);
        
        // Save current mouse position
        Point originalPosition = MouseInfo.getPointerInfo().getLocation();
        System.out.println("Saved original mouse position: " + originalPosition.x + ", " + originalPosition.y);
        
        Future<?> clickingTask = executor.submit(() -> {
            long startTime = System.currentTimeMillis();
            long lastActivityTime = startTime;
            long timeoutMs = 5 * 60 * 1000; // 5 minutes total timeout
            long inactivityTimeoutMs = 3 * 1000; // 3 seconds of no expected activity
            int clickCount = 0;
            int colorMismatchCount = 0;
            
            try {
                while (!Thread.currentThread().isInterrupted() && 
                       (System.currentTimeMillis() - startTime) < timeoutMs) {
                    
                    // Check for pixel color validation before clicking
                    if (calibrationPixelColor != null) {
                        Color currentPixelColor = robot.getPixelColor(clickPosition.x, clickPosition.y);
                        
                        // Allow some tolerance for minor color variations (lighting changes, etc.)
                        if (!isColorSimilar(currentPixelColor, calibrationPixelColor, 30)) {
                            colorMismatchCount++;
                            System.out.println("WARNING: Pixel color mismatch at click position. Expected: R=" + 
                                             calibrationPixelColor.getRed() + " G=" + calibrationPixelColor.getGreen() + 
                                             " B=" + calibrationPixelColor.getBlue() + ", Got: R=" + 
                                             currentPixelColor.getRed() + " G=" + currentPixelColor.getGreen() + 
                                             " B=" + currentPixelColor.getBlue());
                            
                            // If we get 3 consecutive mismatches, warn but continue clicking
                            if (colorMismatchCount >= 3) {
                                System.out.println("⚠ WARNING: Multiple pixel color mismatches detected!");
                                System.out.println("⚠ The browser window may have moved or appearance changed.");
                                System.out.println("⚠ Continuing to click but accuracy may be reduced.");
                                
                                // Don't set calibrated to false - just warn and continue
                                // This allows tool results to still trigger clicking
                                colorMismatchCount = 0; // Reset to avoid spam
                            }
                        } else {
                            colorMismatchCount = 0; // Reset count on successful match
                        }
                    }
                    
                    // Move to calibrated position
                    robot.mouseMove(clickPosition.x, clickPosition.y);
                    Thread.sleep(50);
                    
                    // Click
                    robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
                    robot.delay(50);
                    robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
                    clickCount++;
                    lastActivityTime = System.currentTimeMillis();
                    
                    // Only log every 10th click to reduce spam
                    if (clickCount % 10 == 1) {
                        System.out.println("Bridge clicking active for request: " + requestId + " (click #" + clickCount + ")");
                    }
                    
                    // Move back to original position
                    robot.mouseMove(originalPosition.x, originalPosition.y);
                    
                    // Check for inactivity timeout (if too long without expected response)
                    if ((System.currentTimeMillis() - lastActivityTime) > inactivityTimeoutMs) {
                        System.out.println("⚠ WARNING: No expected activity detected for " + (inactivityTimeoutMs/1000) + " seconds.");
                        System.out.println("⚠ This might indicate the bridge connection is not working properly.");
                        // Reset activity timer and continue (don't break immediately)
                        lastActivityTime = System.currentTimeMillis();
                    }
                    
                    // Wait 500ms before next click
                    Thread.sleep(500);
                }
                
                if (!Thread.currentThread().isInterrupted()) {
                    if (!calibrated) {
                        System.out.println("Clicking stopped for request: " + requestId + " - recalibration needed (total clicks: " + clickCount + ")");
                    } else {
                        System.out.println("Clicking timeout reached for request: " + requestId + " (5 minutes, total clicks: " + clickCount + ")");
                    }
                }
                
            } catch (InterruptedException e) {
                System.out.println("Clicking stopped for request: " + requestId + " (total clicks: " + clickCount + ")");
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                System.err.println("Error in continuous clicking: " + e.getMessage());
            } finally {
                // Always restore original mouse position
                try {
                    robot.mouseMove(originalPosition.x, originalPosition.y);
                    System.out.println("Mouse position restored to: " + originalPosition.x + ", " + originalPosition.y);
                } catch (Exception e) {
                    System.err.println("Could not restore mouse position: " + e.getMessage());
                }
            }
        });
        
        clickingTasks.put(requestId, clickingTask);
    }
    
    private static void stopContinuousClicking(String requestId) {
        Future<?> clickingTask = clickingTasks.remove(requestId);
        if (clickingTask != null) {
            clickingTask.cancel(true);
            System.out.println("Stopped continuous clicking for request: " + requestId);
        }
    }
    
    private static boolean isColorSimilar(Color c1, Color c2, int tolerance) {
        // Check if two colors are similar within a tolerance level
        // This accounts for minor variations due to lighting, compression, etc.
        int rDiff = Math.abs(c1.getRed() - c2.getRed());
        int gDiff = Math.abs(c1.getGreen() - c2.getGreen());
        int bDiff = Math.abs(c1.getBlue() - c2.getBlue());
        
        return (rDiff <= tolerance && gDiff <= tolerance && bDiff <= tolerance);
    }
    
    private static String generateUUID() {
        return UUID.randomUUID().toString();
    }
}
-~{END}~-

-~{File: src/java-agent/StandaloneAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;

public class StandaloneAgent {
    private static Clipboard clipboard;
    private static Robot robot;
    private static String savedClipboard = "";
    private static Point clickPosition = null;
    private static volatile boolean calibrated = false;
    private static TrayIcon trayIcon;
    
    public static void main(String[] args) {
        try {
            // Initialize components
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            robot = new Robot();
            
            // Setup system tray
            setupSystemTray();
            
            // Start the demo flow
            runDemo();
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            System.out.println("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create icon (16x16 pixels)
            BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics2D g = image.createGraphics();
            g.setColor(Color.GREEN);
            g.fillOval(0, 0, 16, 16);
            g.dispose();
            
            trayIcon = new TrayIcon(image, "CCC Agent - Ready");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Waiting for calibration");
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            System.out.println("System tray initialized");
            
        } catch (Exception e) {
            System.out.println("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void runDemo() throws Exception {
        System.out.println("================================");
        System.out.println("CCC Demo - Java Standalone");
        System.out.println("================================");
        System.out.println();
        
        // Wait for bridge script to be pasted
        waitForBridgePaste();
        
        // Wait for calibration
        waitForCalibration();
        
        // Send test AI request
        sendAIRequest();
        
        // Wait for response
        waitForResponse();
        
        System.out.println("Demo completed!");
    }
    
    private static void waitForBridgePaste() throws Exception {
        System.out.println("Waiting for bridge script to be pasted...");
        System.out.println("1. Bridge script should already be in your clipboard");
        System.out.println("2. Go to http://localhost:5556/ or your internal Claude UI");
        System.out.println("3. Open Developer Console (F12) and paste the script");
        System.out.println("4. The script will signal when it's loaded");
        System.out.println();
        
        // Save current clipboard content first
        String originalClipboard = "";
        try {
            originalClipboard = getClipboardContent();
            if (originalClipboard != null) {
                System.out.println("[Demo] Saved original clipboard (" + originalClipboard.length() + " chars)");
            }
        } catch (Exception e) {
            System.out.println("[Demo] Could not save original clipboard: " + e.getMessage());
        }
        
        // Poll for bridge initialization message
        System.out.println("[Demo] Waiting for bridge script initialization...");
        while (true) {
            Thread.sleep(1000);
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null) {
                    // Debug output
                    String preview = clipboardText.length() > 50 ? clipboardText.substring(0, 50) + "..." : clipboardText;
                    System.out.println("[Demo] Clipboard check: " + clipboardText.length() + " chars - " + preview);
                    
                    if (clipboardText.startsWith("CCC_BRIDGE_INITIALIZED")) {
                        System.out.println("[Demo] Bridge script initialization detected!");
                        
                        // Restore original clipboard
                        if (originalClipboard != null && !originalClipboard.isEmpty()) {
                            setClipboard(originalClipboard);
                            System.out.println("[Demo] Original clipboard restored (" + originalClipboard.length() + " chars)");
                        } else {
                            setClipboard("");
                            System.out.println("[Demo] Clipboard cleared");
                        }
                        
                        Thread.sleep(500);
                        break;
                    }
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
        }
    }
    
    private static void waitForCalibration() throws Exception {
        System.out.println("[Demo] Waiting for calibration click...");
        System.out.println("[Demo] Ready to detect calibration (not clearing clipboard)...");
        
        while (!calibrated) {
            Thread.sleep(1000);
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null && !clipboardText.trim().isEmpty()) {
                    if (clipboardText.contains("CCC_CALIBRATION") && clipboardText.contains("|||CCC_END|||")) {
                        processCalibration(clipboardText);
                    }
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
        }
    }
    
    private static void processCalibration(String content) throws Exception {
        System.out.println("[Demo] Calibration click detected!");
        
        // Get current mouse position
        Point mousePos = MouseInfo.getPointerInfo().getLocation();
        clickPosition = mousePos;
        calibrated = true;
        
        System.out.println("[Demo] Captured mouse position: " + mousePos.x + ", " + mousePos.y);
        
        // Update tray icon
        if (trayIcon != null) {
            PopupMenu popup = trayIcon.getPopupMenu();
            if (popup.getItemCount() > 0) {
                MenuItem statusItem = popup.getItem(0);
                statusItem.setLabel("Status: Calibrated - Sending AI request");
            }
        }
        
        // Clear clipboard
        setClipboard("");
        Thread.sleep(1000);
    }
    
    private static void sendAIRequest() throws Exception {
        System.out.println("[Demo] Sending AI request...");
        
        // Create test request
        String request = String.format(
            "{\"type\":\"CCC_REQUEST\",\"id\":\"%s\",\"timestamp\":%d,\"action\":\"ai-complete\",\"payload\":{\"prompt\":\"Write a haiku about clipboard bridges between programs\"}}|||CCC_END|||",
            generateUUID(),
            System.currentTimeMillis()
        );
        
        // Set clipboard
        setClipboard(request);
        Thread.sleep(2000);
        
        // Click at calibrated position
        System.out.println("[Demo] Clicking at calibrated position...");
        robot.mouseMove(clickPosition.x, clickPosition.y);
        Thread.sleep(500);
        
        // Single click
        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
        robot.delay(100);
        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
        
        System.out.println("[Demo] Request sent, waiting for response...");
    }
    
    private static void waitForResponse() throws Exception {
        int timeout = 60; // 60 seconds timeout
        int elapsed = 0;
        
        while (elapsed < timeout) {
            Thread.sleep(1000);
            elapsed++;
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null && clipboardText.contains("BROWSER_RESPONSE")) {
                    processResponse(clipboardText);
                    return;
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
            
            if (elapsed % 5 == 0) {
                System.out.println("[Demo] Still waiting... (" + elapsed + "s)");
            }
        }
        
        System.out.println("[Demo] Response timeout after " + timeout + " seconds");
    }
    
    private static void processResponse(String content) throws Exception {
        try {
            String responseText = content.split("\\|\\|\\|BROWSER_END\\|\\|\\|")[0];
            // Simple JSON parsing for the response content
            if (responseText.contains("\"content\":")) {
                String contentStart = "\"content\":\"";
                int start = responseText.indexOf(contentStart) + contentStart.length();
                int end = responseText.indexOf("\",", start);
                if (end == -1) end = responseText.indexOf("\"}", start);
                
                if (start > 0 && end > start) {
                    String aiResponse = responseText.substring(start, end);
                    System.out.println();
                    System.out.println("================================");
                    System.out.println("AI Response Received!");
                    System.out.println("================================");
                    System.out.println(aiResponse);
                    System.out.println("================================");
                    System.out.println();
                }
            }
            
            // Update tray icon
            if (trayIcon != null) {
                PopupMenu popup = trayIcon.getPopupMenu();
                if (popup.getItemCount() > 0) {
                    MenuItem statusItem = popup.getItem(0);
                    statusItem.setLabel("Status: Success! Response received");
                }
            }
            
        } catch (Exception e) {
            System.out.println("[Demo] Error parsing response: " + e.getMessage());
        }
    }
    
    private static String getClipboardContent() throws Exception {
        Transferable contents = clipboard.getContents(null);
        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
            return (String) contents.getTransferData(DataFlavor.stringFlavor);
        }
        return null;
    }
    
    private static void setClipboard(String text) throws Exception {
        StringSelection selection = new StringSelection(text);
        clipboard.setContents(selection, null);
    }
    
    private static String generateUUID() {
        return UUID.randomUUID().toString();
    }
}
-~{END}~-

-~{File: src/java-agent/web/js/coding-assistant.js}~-
class CodingAssistantUI {
    constructor() {
        this.chatArea = document.getElementById('chat-area');
        this.messageInput = document.getElementById('message-input');
        this.statusIndicator = document.getElementById('status-indicator');
        this.isProcessing = false;
        this.currentAssistantMessage = null;
        this.toolExecutions = new Map(); // Track ongoing tool executions
        this.conversationHistory = []; // Track full conversation history
        this.chatId = null; // Track conversation ID from bridge script
        
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !this.isProcessing) {
                e.preventDefault();
                this.handleUserMessage();
            }
        });
    }

    async handleUserMessage() {
        const message = this.messageInput.value.trim();
        if (!message) return;

        this.addUserMessage(message);
        this.messageInput.value = '';
        this.setProcessing(true);

        // Add user message to conversation history
        this.conversationHistory.push({
            role: 'user',
            content: message
        });

        // Add system message with tool instructions if this is the first message
        const messagesToSend = this.conversationHistory.length === 1 
            ? this.addSystemMessage(this.conversationHistory)
            : this.conversationHistory;

        try {
            const response = await this.sendMessageToBackend(messagesToSend);
            await this.processResponse(response);
        } catch (error) {
            this.addErrorMessage('Error: ' + error.message);
        } finally {
            this.setProcessing(false);
        }
    }

    async sendMessageToBackend(messages) {
        const requestId = this.generateUUID();
        
        const request = {
            type: 'CCC_REQUEST',
            id: requestId,
            timestamp: Date.now(),
            action: 'ai-complete',
            payload: { 
                messages: messages,
                chatId: this.chatId  // Include current chat ID (null for first request)
            }
        };

        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(request)
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return { response, requestId };
    }

    async processResponse({ response, requestId }) {
        // Create loading message placeholder (no dot yet)
        this.currentAssistantMessage = this.createLoadingMessage();
        this.currentAssistantContent = ''; // Track full assistant response
        
        await this.handleSSEResponse(response, requestId);
        
        // Add complete assistant message to conversation history
        if (this.currentAssistantContent) {
            this.conversationHistory.push({
                role: 'assistant',
                content: this.currentAssistantContent
            });
        }
    }

    async handleSSEResponse(response, requestId) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const dataStr = line.substring(6);
                    if (dataStr === '[DONE]') return;
                    
                    try {
                        const data = JSON.parse(dataStr);
                        await this.handleStreamData(data);
                    } catch (parseError) {
                        console.error('Parse error:', parseError.message);
                    }
                }
            }
        }
    }

    async handleStreamData(data) {
        if (data.type === 'BROWSER_PROGRESS' || data.type === 'BROWSER_RESPONSE') {
            // Extract and store chatId if present
            if (data.payload && data.payload.chatId && !this.chatId) {
                this.chatId = data.payload.chatId;
                console.log('[CodingAssistant] Received chatId:', this.chatId);
            }
            
            let content = '';
            if (data.payload && data.payload.accumulated) {
                content = data.payload.accumulated;
            } else if (data.payload && data.payload.content) {
                content = data.payload.content;
            }

            if (content) {
                // Update current assistant content for history tracking
                this.currentAssistantContent = content;
                
                // Check if this is a tool use
                if (this.isToolUse(content)) {
                    // Stop spinner and hide the loading message since we're showing tool execution instead
                    this.stopSpinnerAnimation();
                    if (this.currentAssistantMessage) {
                        this.currentAssistantMessage.style.display = 'none';
                    }
                    await this.handleToolUse(content);
                } else {
                    // Convert loading message to regular assistant message with white dot
                    this.convertToAssistantMessage(content);
                }
            }
        }
    }

    isToolUse(content) {
        return content.includes('<tool>') && content.includes('</tool>');
    }

    async handleToolUse(content) {
        // Extract tool JSON from content
        const toolMatch = content.match(/<tool>(.*?)<\/tool>/s);
        if (!toolMatch) return;

        try {
            const toolData = JSON.parse(toolMatch[1]);
            const toolId = this.generateUUID();
            
            // Add tool execution UI
            const toolExecution = this.addToolExecution(toolId, toolData);
            
            // Execute tool
            const results = await this.executeTool(toolData);
            
            // Update tool execution with results
            this.updateToolExecution(toolId, 'completed', results);
            
            // Send results back to AI
            await this.sendToolResults(toolId, toolData, results);
            
        } catch (error) {
            console.error('Tool execution error:', error);
            this.addErrorMessage('Tool execution failed: ' + error.message);
        }
    }

    async executeTool(toolData) {
        const { name, parameters } = toolData;
        
        switch (name) {
            case 'search_files':
                return await this.executeFileSearch(parameters);
            default:
                throw new Error(`Unknown tool: ${name}`);
        }
    }

    async executeFileSearch(parameters) {
        const { query } = parameters;
        
        const response = await fetch('/api/tools/search-files', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query })
        });

        if (!response.ok) {
            throw new Error(`Search failed: ${response.status}`);
        }

        return await response.json();
    }

    async sendToolResults(toolId, toolData, results) {
        // Create tool result message but don't add to conversation history yet
        const toolResultMessage = `[SYSTEM] Tool execution completed:\n\nTool: ${toolData.name}\nQuery: ${toolData.parameters?.query || 'N/A'}\nResults: ${JSON.stringify(results, null, 2)}\n\nPlease provide a response based on these results.`;
        
        // Create messages array with tool result for this request only
        const messagesWithToolResult = [...this.conversationHistory, {
            role: 'user',
            content: toolResultMessage
        }];

        const request = {
            type: 'TOOL_RESULT',
            id: this.generateUUID(),
            timestamp: Date.now(),
            payload: {
                toolId,
                toolName: toolData.name,
                results,
                messages: messagesWithToolResult,  // Send conversation + tool result
                chatId: this.chatId  // Include current chat ID
            }
        };

        const response = await fetch('/api/tool-result', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(request)
        });

        if (response.ok) {
            // Add tool result to conversation history only after sending request
            this.conversationHistory.push({
                role: 'user',
                content: toolResultMessage
            });
            
            // Process the AI's response to the tool results
            await this.processResponse({ response, requestId: request.id });
        }
    }

    addToolExecution(toolId, toolData) {
        const toolDiv = document.createElement('div');
        toolDiv.className = 'tool-execution';
        toolDiv.id = `tool-${toolId}`;
        
        toolDiv.innerHTML = `
            <div class="tool-header">
                <span class="tool-name">${toolData.name}</span>
                <span class="tool-status running" id="status-${toolId}">Running...</span>
            </div>
            <div class="tool-details">
                <div class="tool-query">Query: ${toolData.parameters.query || 'N/A'}</div>
                <div class="tool-results" id="results-${toolId}">
                    <span class="loading-dots">Searching</span>
                </div>
            </div>
        `;
        
        this.chatArea.appendChild(toolDiv);
        this.scrollToBottom();
        
        this.toolExecutions.set(toolId, toolDiv);
        return toolDiv;
    }

    updateToolExecution(toolId, status, results) {
        const toolDiv = this.toolExecutions.get(toolId);
        if (!toolDiv) return;

        const statusElement = document.getElementById(`status-${toolId}`);
        const resultsElement = document.getElementById(`results-${toolId}`);
        
        if (statusElement) {
            statusElement.textContent = status === 'completed' ? 'Completed' : 'Error';
            statusElement.className = `tool-status ${status}`;
        }

        if (resultsElement && results) {
            if (results.files && Array.isArray(results.files)) {
                resultsElement.innerHTML = results.files.map(file => 
                    `<div class="file-result">${file}</div>`
                ).join('');
            } else {
                resultsElement.textContent = JSON.stringify(results, null, 2);
            }
        }

        this.scrollToBottom();
    }

    createAssistantMessage() {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message assistant';
        this.chatArea.appendChild(messageDiv);
        this.scrollToBottom();
        return messageDiv;
    }

    createLoadingMessage() {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message loading';
        
        const spinnerSpan = document.createElement('span');
        spinnerSpan.className = 'loading-spinner';
        spinnerSpan.textContent = '~';
        
        messageDiv.appendChild(spinnerSpan);
        messageDiv.appendChild(document.createTextNode('Loading...'));
        
        this.chatArea.appendChild(messageDiv);
        this.scrollToBottom();
        
        // Start the spinner animation
        this.startSpinnerAnimation(spinnerSpan);
        
        return messageDiv;
    }

    startSpinnerAnimation(spinnerElement) {
        const chars = ['~', '-', '`', '+', '=', '*', '%', 'X', 'O'];
        // Timing for each character (in ms) - some pause longer for effect
        const timings = [100, 80, 60, 150, 80, 300, 120, 200, 150];
        let index = 0;
        
        const nextFrame = () => {
            spinnerElement.textContent = chars[index];
            const currentTiming = timings[index];
            index = (index + 1) % chars.length;
            
            this.spinnerTimeout = setTimeout(nextFrame, currentTiming);
        };
        
        nextFrame(); // Start the animation
    }

    stopSpinnerAnimation() {
        if (this.spinnerInterval) {
            clearInterval(this.spinnerInterval);
            this.spinnerInterval = null;
        }
        if (this.spinnerTimeout) {
            clearTimeout(this.spinnerTimeout);
            this.spinnerTimeout = null;
        }
    }

    convertToAssistantMessage(content) {
        if (this.currentAssistantMessage) {
            // Stop the spinner animation
            this.stopSpinnerAnimation();
            
            // Convert from loading message to assistant message
            this.currentAssistantMessage.className = 'message assistant';
            this.currentAssistantMessage.innerHTML = content.replace(/\n/g, '<br>');
            this.scrollToBottom();
        }
    }

    updateAssistantMessage(content) {
        if (this.currentAssistantMessage) {
            this.currentAssistantMessage.innerHTML = content.replace(/\n/g, '<br>');
            this.scrollToBottom();
        }
    }

    addUserMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message user';
        messageDiv.textContent = message;
        this.chatArea.appendChild(messageDiv);
        this.scrollToBottom();
    }

    addErrorMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message assistant error';
        messageDiv.textContent = message;
        this.chatArea.appendChild(messageDiv);
        this.scrollToBottom();
    }

    setProcessing(isProcessing) {
        this.isProcessing = isProcessing;
        this.messageInput.disabled = isProcessing;
        
        if (isProcessing) {
            this.statusIndicator.textContent = 'Processing...';
            this.statusIndicator.className = 'status-indicator processing';
        } else {
            this.statusIndicator.textContent = 'Ready';
            this.statusIndicator.className = 'status-indicator';
        }
    }

    scrollToBottom() {
        this.chatArea.scrollTop = this.chatArea.scrollHeight;
    }

    addSystemMessage(messages) {
        const systemMessage = {
            role: 'user',
            content: `You are a coding assistant with access to the following tools:

<tool_use>
search_files: Search for files by name pattern
- Parameters: {"query": "search_term"}
- Use this to find files matching a name pattern
- Example: {"name": "search_files", "parameters": {"query": "java"}}
</tool_use>

When a user asks you to search for files or find code, use the search_files tool. Format tool use as:
<tool>{"name": "search_files", "parameters": {"query": "search_term"}}</tool>

Always use tools when appropriate instead of asking the user to provide code manually.`
        };

        return [systemMessage, ...messages];
    }

    generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
}

// Initialize the UI when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new CodingAssistantUI();
});
-~{END}~-

-~{File: src/java-agent/web/css/terminal.css}~-
/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Fira Code', 'Consolas', 'Monaco', 'Menlo', monospace;
    background-color: #000000;
    color: #ffffff;
    height: 100vh;
    overflow: hidden;
}

/* Terminal container */
.terminal-container {
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Chat area */
.chat-area {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    padding-bottom: 10px;
}

.chat-area::-webkit-scrollbar {
    width: 8px;
}

.chat-area::-webkit-scrollbar-track {
    background: #1a1a1a;
}

.chat-area::-webkit-scrollbar-thumb {
    background: #333;
    border-radius: 4px;
}

.chat-area::-webkit-scrollbar-thumb:hover {
    background: #555;
}

/* Input area */
.input-area {
    border-top: 1px solid #333;
    padding: 15px 20px;
    display: flex;
    align-items: center;
    background-color: #111;
}

.prompt {
    color: #ffffff;
    margin-right: 10px;
    user-select: none;
}

.input-field {
    flex: 1;
    background: transparent;
    border: none;
    color: #ffffff;
    font-family: inherit;
    font-size: 14px;
    outline: none;
    caret-color: #ffffff;
}

.input-field::placeholder {
    color: #666;
}

/* Messages */
.message {
    margin-bottom: 20px;
    line-height: 1.4;
    position: relative;
}

.message.user {
    color: #888888; /* Lighter gray for user messages */
}

.message.user::before {
    content: '> ';
    color: #888888;
}

.message.assistant {
    color: #ffffff;
    padding-left: 15px; /* Space for bullet point */
}

.message.assistant:not(.tool-execution)::before {
    content: '\2022';
    color: #ffffff;
    position: absolute;
    left: 0;
    top: 0;
    font-weight: bold;
}

.message.error {
    color: #ff6b6b;
}

.message.success {
    color: #51cf66;
}

/* Tool execution styles - Claude Code style */
.tool-execution {
    margin: 15px 0;
    padding-left: 15px;
    position: relative;
    color: #ffffff;
    word-wrap: break-word;
    overflow-wrap: break-word;
}

.tool-execution::before {
    content: '\2022';
    color: #28a745;
    position: absolute;
    left: 0;
    top: 0;
    font-weight: bold;
}

.tool-header {
    display: inline-block;
    margin-bottom: 10px;
}

.tool-name {
    color: #28a745;
    font-weight: bold;
}

.tool-status {
    margin-left: 10px;
    font-size: 12px;
    color: #888;
}

.tool-status.running {
    color: #ffc107;
}

.tool-status.completed {
    color: #28a745;
}

.tool-status.error {
    color: #dc3545;
}

.tool-details {
    margin-top: 5px;
    margin-left: 5px;
}

.tool-query {
    color: #87ceeb;
    margin-bottom: 5px;
    word-wrap: break-word;
    overflow-wrap: break-word;
}

.tool-results {
    color: #ffffff;
    margin-left: 5px;
}

.file-result {
    padding: 2px 0;
    color: #87ceeb;
    word-wrap: break-word;
    overflow-wrap: break-word;
    white-space: pre-wrap;
}

.file-result:hover {
    color: #ffffff;
}

/* Status indicator */
.status-indicator {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 12px;
    background-color: #28a745;
    color: white;
    border-radius: 4px;
    font-size: 12px;
    z-index: 1000;
}

.status-indicator.processing {
    background-color: #ffc107;
    color: #000;
}

/* Loading animation */
.loading-dots::after {
    content: '';
    animation: dots 1.5s infinite;
}

@keyframes dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
}

/* Message loading state */
.message.loading {
    color: #888;
    padding-left: 15px;
}

.loading-spinner {
    margin-right: 8px;
    display: inline-block;
    min-width: 1em;
}
-~{END}~-

-~{File: src/java-agent/web/index.html}~-
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Clone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/terminal.css">
</head>
<body>
    <div class="terminal-container">
        <div class="status-indicator" id="status-indicator">Ready</div>
        <div class="chat-area" id="chat-area">
            <div class="message assistant">
                Welcome to Claude Code Clone! I'm your AI coding assistant.<br><br>
                I can help you with:<br>
                &bull; Searching for files by name<br>
                &bull; Code analysis and debugging<br>
                &bull; File editing and management<br><br>
                What would you like to work on?
            </div>
        </div>
        <div class="input-area">
            <span class="prompt">></span>
            <input type="text" class="input-field" id="message-input" placeholder="Ask me anything..." autocomplete="off">
        </div>
    </div>
    
    <script src="js/coding-assistant.js"></script>
</body>
</html>
-~{END}~-

-~{File: src/browser-bridge/bridge-api.js}~-
// CCC Browser Bridge Script - Real API Flow Version
// This follows the actual Claude API flow from SPEC.md
(function() {
  'use strict';
  
  console.log('[CCC Bridge API] Initializing with real API flow...');
  
  // Generate realistic session ID
  function generateSessionId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < 20; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  
  // Configuration
  const CONFIG = {
    apiBase: window.location.origin, // Use same origin as the page
    colors: {
      calibrating: '#1a1a2e',
      ready: '#16213e',
      processing: '#0f3460',
      streaming: '#2d5016',
      success: '#53bf9d',
      error: '#e94560'
    },
    sessionId: generateSessionId() // Generate realistic session ID
  };
  
  // State
  let bridgeState = 'calibrating';
  let lastRequest = null;
  let clickCount = 0;
  let conversationCache = new Map(); // Cache conversations by chatId
  
  // Get auth token from localStorage (mock server sets this)
  const authToken = localStorage.getItem('token') || 'mock-token-12345';
  
  // Remove any existing bridge
  const existing = document.getElementById('ccc-bridge-overlay');
  if (existing) existing.remove();
  
  // Create full-page overlay
  const overlay = document.createElement('div');
  overlay.id = 'ccc-bridge-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: ${CONFIG.colors.calibrating};
    z-index: 999999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.3s;
    font-family: 'Courier New', monospace;
    color: white;
  `;
  
  // Create status display
  const statusDisplay = document.createElement('div');
  statusDisplay.style.cssText = `
    text-align: center;
    padding: 40px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    max-width: 600px;
  `;
  
  const title = document.createElement('h1');
  title.style.cssText = `margin: 0 0 20px 0; font-size: 36px;`;
  title.textContent = 'CCC Bridge API';
  
  const status = document.createElement('div');
  status.style.cssText = `font-size: 24px; margin-bottom: 10px;`;
  status.textContent = 'Click to calibrate';
  
  const info = document.createElement('div');
  info.style.cssText = `font-size: 16px; opacity: 0.8;`;
  info.textContent = 'Ready for calibration';
  
  const streamingContent = document.createElement('div');
  streamingContent.style.cssText = `
    margin-top: 20px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
    text-align: left;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
  `;
  
  statusDisplay.appendChild(title);
  statusDisplay.appendChild(status);
  statusDisplay.appendChild(info);
  statusDisplay.appendChild(streamingContent);
  overlay.appendChild(statusDisplay);
  
  // Helper functions
  function updateDisplay(state, message = '', showStreaming = false) {
    bridgeState = state;
    overlay.style.background = CONFIG.colors[state] || CONFIG.colors.ready;
    status.textContent = state.charAt(0).toUpperCase() + state.slice(1);
    info.textContent = message;
    streamingContent.style.display = showStreaming ? 'block' : 'none';
  }
  
  function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  // Tool use detection
  function isToolUse(content) {
    return content.includes('<tool>') && content.includes('</tool>');
  }
  
  // Stream completions for existing conversations
  async function streamCompletions(chatId, messages, conversation) {
    console.log('[CCC Bridge API] ===== STREAMING COMPLETIONS FOR EXISTING CONVERSATION =====');
    console.log('[CCC Bridge API] ChatId:', chatId);
    console.log('[CCC Bridge API] Messages count:', messages.length);
    
    updateDisplay('processing', 'Updating conversation...', true);
    
    // Step 1: Update conversation with new messages
    console.log('[CCC Bridge API] Step 1: Updating conversation with new messages...');
    
    // Build the conversation structure with new messages
    const chatMessages = [];
    const historyMessages = {};
    let currentId = null;
    let parentId = null;
    
    messages.forEach((msg, index) => {
      const messageId = generateUUID();
      const chatMessage = {
        "id": messageId,
        "parentId": parentId,
        "childrenIds": [],
        "role": msg.role,
        "content": msg.content,
        "timestamp": Math.floor(Date.now() / 1000),
        "models": ["Anthropic Claude 4 Sonnet"]
      };
      
      // Update parent's children
      if (parentId && historyMessages[parentId]) {
        historyMessages[parentId].childrenIds.push(messageId);
      }
      
      chatMessages.push(chatMessage);
      historyMessages[messageId] = chatMessage;
      currentId = messageId;
      parentId = messageId;
    });
    
    // Add assistant message slot
    const assistantMessageId = generateUUID();
    const assistantMessage = {
      "parentId": currentId,
      "id": assistantMessageId,
      "childrenIds": [],
      "role": "assistant",
      "content": "",
      "model": "Anthropic Claude 4 Sonnet",
      "modelName": "Anthropic Claude 4 Sonnet",
      "modelIdx": 0,
      "userContext": null,
      "timestamp": Math.floor(Date.now() / 1000)
    };
    
    // Update last user message's children
    if (currentId && historyMessages[currentId]) {
      historyMessages[currentId].childrenIds.push(assistantMessageId);
    }
    
    chatMessages.push(assistantMessage);
    historyMessages[assistantMessageId] = assistantMessage;
    
    const updateChatResponse = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json",
        "authorization": `Bearer ${authToken}`
      },
      body: JSON.stringify({
        "chat": {
          "models": ["Anthropic Claude 4 Sonnet"],
          "history": {
            "messages": historyMessages,
            "currentId": assistantMessageId
          },
          "messages": chatMessages,
          "params": {},
          "files": []
        }
      })
    });
    
    if (!updateChatResponse.ok) {
      const errorText = await updateChatResponse.text();
      console.error('[CCC Bridge API] Chat update failed:', updateChatResponse.status, errorText);
      throw new Error(`Chat update failed: ${updateChatResponse.status}`);
    }
    
    console.log('[CCC Bridge API] ✓ Conversation updated');
    
    // Step 2: Stream completions
    updateDisplay('processing', 'Streaming response...', true);
    streamingContent.textContent = '';
    
    let finalContent = '';
    
    const completionsResponse = await fetch(`${CONFIG.apiBase}/api/chat/completions`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${authToken}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "stream": true,
        "model": "Anthropic Claude 4 Sonnet",
        "messages": messages,  // Use the full messages array
        "params": {},
        "features": {
          "web_search": false
        },
        "session_id": CONFIG.sessionId,
        "chat_id": chatId,
        "id": assistantMessageId,
        "background_tasks": {
          "title_generation": true,
          "tags_generation": true
        }
      })
    });
    
    if (!completionsResponse.ok) {
      const errorText = await completionsResponse.text();
      console.error('[CCC Bridge API] Completions failed:', completionsResponse.status, errorText);
      throw new Error(`Completions failed: ${completionsResponse.status}`);
    }
    
    // Stream the response
    const reader = completionsResponse.body.getReader();
    const decoder = new TextDecoder();
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const dataStr = line.substring(6);
          if (dataStr === '[DONE]') {
            console.log('[CCC Bridge API] ✓ Streaming completed');
            updateDisplay('success', `Completed! Final length: ${finalContent.length} chars`, false);
            
            // Update conversation cache with final content
            if (chatId) {
              conversationCache.set(chatId, {
                chatId: chatId,
                messages: messages,
                assistantMessageId: generateUUID(), // For next assistant message
                timestamp: Date.now()
              });
            }
            
            // Return response with chatId
            copyToClipboard(JSON.stringify({
              type: 'BROWSER_RESPONSE',
              id: lastRequest?.id || 'unknown',
              timestamp: Date.now(),
              status: 'completed',
              payload: {
                content: finalContent,
                accumulated: finalContent,
                chatId: chatId  // Include chatId in response
              }
            }) + '|||CCC_END|||');
            return;
          }
          
          try {
            const data = JSON.parse(dataStr);
            if (data.choices?.[0]?.delta?.content) {
              const content = data.choices[0].delta.content;
              finalContent += content;
              streamingContent.textContent = finalContent;
              
              // Send progress update
              copyToClipboard(JSON.stringify({
                type: 'BROWSER_PROGRESS',
                id: lastRequest?.id || 'unknown',
                timestamp: Date.now(),
                payload: {
                  accumulated: finalContent,
                  chatId: chatId  // Include chatId in progress updates
                }
              }) + '|||CCC_END|||');
            }
          } catch (parseError) {
            console.warn('[CCC Bridge API] Parse error:', parseError.message);
          }
        }
      }
    }
  }
  
  // API Functions following the spec
  async function createNewChat(prompt) {
    console.log('[CCC Bridge API] === CREATING NEW CHAT ===');
    console.log('[CCC Bridge API] Prompt length:', prompt.length);
    console.log('[CCC Bridge API] Prompt preview:', prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''));
    
    const userMessageId = generateUUID();
    const timestamp = Date.now();
    console.log('[CCC Bridge API] Generated user message ID:', userMessageId);
    console.log('[CCC Bridge API] Timestamp:', timestamp);
    
    const body = {
      "chat": {
        "params": {},
        "tags": [],
        "timestamp": timestamp,
        "title": "Chat Pending",
        "models": ["Anthropic Claude 4 Sonnet"],
        "messages": [
          {
            "id": userMessageId,
            "role": "user",
            "content": prompt,
            "timestamp": timestamp,
            "parentId": null,
            "children": []
          }
        ],
        "id": "",
        "history": {
          "currentId": userMessageId,
          "messages": [
            {
              "id": userMessageId,
              "role": "user",
              "content": prompt,
              "timestamp": timestamp,
              "parentId": null,
              "children": []
            }
          ]
        }
      }
    };
    
    console.log('[CCC Bridge API] Making chat creation request to:', `${CONFIG.apiBase}/api/v1/chats/new`);
    console.log('[CCC Bridge API] Chat creation body:', JSON.stringify(body, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/new`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(body)
    });
    
    console.log('[CCC Bridge API] Chat creation response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Chat creation failed:', response.status, errorText);
      throw new Error(`Chat creation failed: ${response.status} - ${errorText}`);
    }
    
    const result = await response.json();
    console.log('[CCC Bridge API] Chat creation result:', JSON.stringify(result, null, 2));
    return result;
  }
  
  async function getConversationState(chatId) {
    console.log('[CCC Bridge API] === GETTING CONVERSATION STATE ===');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Request URL:', `${CONFIG.apiBase}/api/v1/chats/${chatId}`);
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    console.log('[CCC Bridge API] Get state response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Get state failed:', response.status, errorText);
      throw new Error(`Get state failed: ${response.status} - ${errorText}`);
    }
    
    const result = await response.json();
    console.log('[CCC Bridge API] Get state result structure:');
    console.log('[CCC Bridge API] - Has result?', !!result);
    console.log('[CCC Bridge API] - Has chat?', !!result?.chat);
    console.log('[CCC Bridge API] - Has messages?', !!result?.chat?.messages);
    console.log('[CCC Bridge API] - Messages count:', result?.chat?.messages?.length || 0);
    console.log('[CCC Bridge API] Full get state result:', JSON.stringify(result, null, 2));
    
    return result;
  }
  
  async function createAssistantMessage(chatId, conversation, parentMessageId) {
    console.log('[CCC Bridge API] === CREATING ASSISTANT MESSAGE VIA POST ===');
    
    const assistantId = generateUUID();
    const timestamp = Date.now();
    
    console.log('[CCC Bridge API] Generated assistant ID:', assistantId);
    console.log('[CCC Bridge API] Parent message ID:', parentMessageId);
    console.log('[CCC Bridge API] Timestamp:', timestamp);
    
    // Debug logging
    console.log('[CCC Bridge API] Input conversation structure:', JSON.stringify(conversation, null, 2));
    
    // Clone conversation data
    const updatedConv = JSON.parse(JSON.stringify(conversation));
    
    // Create assistant message
    const assistantMessage = {
      id: assistantId,
      role: 'assistant',
      content: '',
      timestamp: timestamp,
      parentId: parentMessageId,
      children: []
    };
    
    // Ensure structure exists
    if (!updatedConv.chat) {
      console.error('[CCC Bridge API] No chat object in conversation:', updatedConv);
      throw new Error('Invalid conversation structure');
    }
    
    if (!updatedConv.chat.messages) {
      updatedConv.chat.messages = [];
    }
    
    if (!updatedConv.chat.history) {
      updatedConv.chat.history = { currentId: null, messages: [] };
    }
    
    if (!updatedConv.chat.history.messages) {
      updatedConv.chat.history.messages = [];
    }
    
    // Add to messages array
    updatedConv.chat.messages.push(assistantMessage);
    
    // Add to history.messages
    updatedConv.chat.history.messages.push(assistantMessage);
    
    // Update parent's children array
    const parentMessage = updatedConv.chat.messages.find(m => m.id === parentMessageId);
    if (parentMessage) {
      parentMessage.children.push(assistantId);
    }
    
    // Update currentId in history
    updatedConv.chat.history.currentId = assistantId;
    
    // Update updated_at timestamp
    updatedConv.updated_at = timestamp;
    
    console.log('[CCC Bridge API] Making POST request to update conversation...');
    console.log('[CCC Bridge API] URL:', `${CONFIG.apiBase}/api/v1/chats/${chatId}`);
    console.log('[CCC Bridge API] Updated conversation payload:', JSON.stringify(updatedConv, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(updatedConv)
    });
    
    console.log('[CCC Bridge API] POST response status:', response.status);
    console.log('[CCC Bridge API] POST response headers:', Object.fromEntries(response.headers.entries()));
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] POST failed:', response.status, errorText);
      throw new Error(`Update failed: ${response.status} - ${errorText}`);
    }
    
    const responseData = await response.json();
    console.log('[CCC Bridge API] POST response data:', JSON.stringify(responseData, null, 2));
    console.log('[CCC Bridge API] ✓ Successfully created assistant message via POST');
    
    return assistantId;
  }
  
  async function streamCompletion(chatId, messageId, conversation, onChunk) {
    console.log('[CCC Bridge API] === STARTING STREAM COMPLETION ===');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Message ID:', messageId);
    console.log('[CCC Bridge API] Conversation structure validation:');
    console.log('[CCC Bridge API] - Has conversation?', !!conversation);
    console.log('[CCC Bridge API] - Has conversation.chat?', !!conversation?.chat);
    console.log('[CCC Bridge API] - Has messages array?', !!conversation?.chat?.messages);
    console.log('[CCC Bridge API] - Messages count:', conversation?.chat?.messages?.length || 0);
    
    if (!conversation?.chat?.messages) {
      throw new Error('Invalid conversation structure: missing messages array');
    }
    
    // Debug logging
    console.log('[CCC Bridge API] Full conversation for completions:', JSON.stringify(conversation, null, 2));
    console.log('[CCC Bridge API] Messages structure:', conversation.chat.messages.map(m => ({
      id: m.id,
      role: m.role,
      contentLength: m.content?.length || 0,
      hasParentId: !!m.parentId,
      childrenCount: m.children?.length || 0
    })));
    
    // Build messages array for completions - only user messages for the model
    const userMessages = conversation.chat.messages.filter(m => m.role === 'user');
    console.log('[CCC Bridge API] Found user messages:', userMessages.length);
    
    const messages = userMessages.map(m => ({
      role: m.role,
      content: m.content
    }));
    
    console.log('[CCC Bridge API] Filtered messages for completion:', messages);
    
    if (messages.length === 0) {
      throw new Error('No user messages found to send to completions API');
    }
    
    const body = {
      "background_tasks": {
        "title_generation": true,
        "tags_generation": true
      },
      "chat_id": chatId,
      "features": {
        "web_search": false
      },
      "id": messageId,
      "messages": messages,
      "model": "Anthropic Claude 4 Sonnet",
      "params": {},
      "session_id": CONFIG.sessionId,
      "stream": true
    };
    
    console.log('[CCC Bridge API] Making completions request to:', `${CONFIG.apiBase}/api/chat/completions`);
    console.log('[CCC Bridge API] Full request body:', JSON.stringify(body, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(body)
    });
    
    console.log('[CCC Bridge API] Completions response status:', response.status);
    console.log('[CCC Bridge API] Completions response headers:', Object.fromEntries(response.headers.entries()));
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Completions request failed:', response.status, errorText);
      throw new Error(`Stream failed: ${response.status} - ${errorText}`);
    }
    
    console.log('[CCC Bridge API] Starting to read SSE stream...');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let accumulated = '';
    let chunkCount = 0;
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        console.log('[CCC Bridge API] Stream ended, total chunks processed:', chunkCount);
        break;
      }
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');
      
      console.log('[CCC Bridge API] Received chunk with', lines.length, 'lines');
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const dataStr = line.substring(6);
            console.log('[CCC Bridge API] Processing SSE line:', dataStr.substring(0, 100) + (dataStr.length > 100 ? '...' : ''));
            
            if (dataStr === '[DONE]') {
              console.log('[CCC Bridge API] Received [DONE] marker, ending stream');
              return accumulated;
            }
            
            const data = JSON.parse(dataStr);
            chunkCount++;
            
            if (data.choices?.[0]?.delta?.content) {
              const newContent = data.choices[0].delta.content;
              accumulated += newContent;
              console.log('[CCC Bridge API] Added content chunk:', newContent.substring(0, 50) + (newContent.length > 50 ? '...' : ''));
              console.log('[CCC Bridge API] Total accumulated length:', accumulated.length);
              onChunk(accumulated, false);
            }
            if (data.choices?.[0]?.finish_reason === 'stop') {
              console.log('[CCC Bridge API] Received finish_reason=stop, ending stream');
              onChunk(accumulated, true);
              return accumulated;
            }
          } catch (e) {
            console.error('[CCC Bridge API] Parse error on line:', line.substring(0, 100));
            console.error('[CCC Bridge API] Parse error:', e);
          }
        } else if (line.trim()) {
          console.log('[CCC Bridge API] Non-data SSE line:', line.substring(0, 100));
        }
      }
    }
    
    return accumulated;
  }
  
  // Create assistant message manually (server doesn't auto-generate)
  async function createAssistantMessageSlot(chatId, parentMessageId) {
    console.log('[CCC Bridge API] ===== CREATING ASSISTANT MESSAGE SLOT =====');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Parent message ID:', parentMessageId);
    
    try {
      // Get current conversation state
      console.log('[CCC Bridge API] Step 1: Getting current conversation state...');
      const conversation = await getConversationState(chatId);
      console.log('[CCC Bridge API] Current conversation state before creating assistant message:');
      console.log('[CCC Bridge API] Messages count:', conversation.chat.messages.length);
      console.log('[CCC Bridge API] Messages:', conversation.chat.messages.map(m => ({id: m.id, role: m.role, contentLength: m.content?.length || 0})));
      
      // Create assistant message slot
      console.log('[CCC Bridge API] Step 2: Creating assistant message via POST...');
      const assistantId = await createAssistantMessage(chatId, conversation, parentMessageId);
      console.log('[CCC Bridge API] ✓ Successfully created assistant message slot:', assistantId);
      
      // Use the conversation we already have (optimization: skip verification GET)
      console.log('[CCC Bridge API] ===== ASSISTANT MESSAGE SLOT CREATION COMPLETE =====');
      return { assistantId, conversation };
      
    } catch (error) {
      console.error('[CCC Bridge API] ❌ ERROR in createAssistantMessageSlot:', error);
      console.error('[CCC Bridge API] Error stack:', error.stack);
      throw error;
    }
  }
  
  // Test function using api_template from browser global
  async function testWithApiTemplate() {
    console.log('[CCC Bridge API] ===== TESTING WITH API_TEMPLATE =====');
    
    try {
      // Get api_template from global variable
      const apiTemplateStr = window.api_template;
      if (!apiTemplateStr) {
        throw new Error('api_template global variable not found');
      }
      
      console.log('[CCC Bridge API] Found api_template, length:', apiTemplateStr.length);
      
      // Get auth token from localStorage
      const authToken = localStorage.getItem('token');
      if (!authToken) {
        throw new Error('Auth token not found in localStorage');
      }
      
      console.log('[CCC Bridge API] Found auth token, length:', authToken.length);
      
      // Replace ${auth} with actual token
      const templatedStr = apiTemplateStr.replace(/\${auth}/g, authToken);
      
      // Parse as JSON
      const apiTemplate = JSON.parse(templatedStr);
      console.log('[CCC Bridge API] Parsed api_template, found', apiTemplate.length, 'entries');
      
      let chatId = null;
      
      // Execute each request in sequence
      for (let i = 0; i < apiTemplate.length; i++) {
        const entry = apiTemplate[i];
        console.log('[CCC Bridge API] Processing entry', i + 1, ':', entry.url);
        
        // Handle first request (/api/v1/chats/new)
        if (entry.url === '/api/v1/chats/new') {
          console.log('[CCC Bridge API] Executing chat creation request...');
          
          const response = await fetch(`${CONFIG.apiBase}${entry.url}`, entry.options);
          console.log('[CCC Bridge API] Chat creation response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[CCC Bridge API] Chat creation failed:', response.status, errorText);
            throw new Error(`Chat creation failed: ${response.status}`);
          }
          
          const result = await response.json();
          chatId = result.id;
          console.log('[CCC Bridge API] ✓ Chat created with ID:', chatId);
          continue;
        }
        
        // Handle subsequent requests - replace ${chat_id}
        if (!chatId) {
          throw new Error('Chat ID not available for subsequent requests');
        }
        
        // Stringify, replace chat_id, parse back
        let entryStr = JSON.stringify(entry);
        entryStr = entryStr.replace(/\${chat_id}/g, chatId);
        const updatedEntry = JSON.parse(entryStr);
        
        console.log('[CCC Bridge API] Updated entry URL:', updatedEntry.url);
        
        // Handle /api/chat/completions specially (SSE streaming)
        if (updatedEntry.url === '/api/chat/completions') {
          console.log('[CCC Bridge API] ===== STARTING SSE STREAM =====');
          console.log('[CCC Bridge API] Request options:', JSON.stringify(updatedEntry.options, null, 2));
          
          const response = await fetch(`${CONFIG.apiBase}${updatedEntry.url}`, updatedEntry.options);
          console.log('[CCC Bridge API] SSE response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[CCC Bridge API] SSE request failed:', response.status, errorText);
            throw new Error(`SSE request failed: ${response.status}`);
          }
          
          // Stream the SSE events
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let eventCount = 0;
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              console.log('[CCC Bridge API] SSE stream ended, total events:', eventCount);
              break;
            }
            
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                eventCount++;
                const dataStr = line.substring(6);
                console.log('[CCC Bridge API] SSE Event', eventCount + ':', dataStr);
                
                if (dataStr === '[DONE]') {
                  console.log('[CCC Bridge API] ===== SSE STREAM COMPLETE =====');
                  return;
                }
              }
            }
          }
          
          // Stop processing after completions
          break;
        }
        
        // Handle other requests normally
        console.log('[CCC Bridge API] Executing request to:', updatedEntry.url);
        
        const response = await fetch(`${CONFIG.apiBase}${updatedEntry.url}`, updatedEntry.options);
        console.log('[CCC Bridge API] Response status:', response.status);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('[CCC Bridge API] Request failed:', response.status, errorText);
          throw new Error(`Request failed: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('[CCC Bridge API] Response:', JSON.stringify(result, null, 2));
      }
      
    } catch (error) {
      console.error('[CCC Bridge API] ❌ ERROR in testWithApiTemplate:', error);
      console.error('[CCC Bridge API] Error stack:', error.stack);
    }
  }

  // Process AI request using hardcoded working API sequence
  async function processAIRequest(request) {
    try {
      updateDisplay('processing', 'Processing chat request...');
      console.log('[CCC Bridge API] ===== PROCESSING WITH HARDCODED SEQUENCE =====');
      
      // Get auth token from localStorage
      const authToken = localStorage.getItem('token');
      if (!authToken) {
        throw new Error('Auth token not found in localStorage');
      }
      
      console.log('[CCC Bridge API] Found auth token, executing API sequence...');
      
      // Handle both old prompt format and new messages format
      let messages = [];
      if (request.payload.messages) {
        messages = request.payload.messages;
        console.log('[CCC Bridge API] Using messages array format, count:', messages.length);
      } else if (request.payload.prompt) {
        // Fallback for old format
        messages = [{
          role: 'user',
          content: request.payload.prompt
        }];
        console.log('[CCC Bridge API] Using legacy prompt format, converted to messages');
      }
      
      // Handle chatId and conversation caching
      const requestChatId = request.payload.chatId;
      let chatId = null;
      let conversation = null;
      
      console.log('[CCC Bridge API] Request chatId:', requestChatId);
      console.log('[CCC Bridge API] Cache size:', conversationCache.size);
      console.log('[CCC Bridge API] Cache keys:', Array.from(conversationCache.keys()));
      
      if (requestChatId && conversationCache.has(requestChatId)) {
        // Reuse existing conversation
        conversation = conversationCache.get(requestChatId);
        chatId = requestChatId;
        console.log('[CCC Bridge API] Reusing existing conversation:', chatId);
        
        // Skip to completions - we already have the conversation set up
        return await streamCompletions(chatId, messages, conversation);
      } else {
        // Create new conversation
        console.log('[CCC Bridge API] Creating new conversation...');
        if (requestChatId) {
          console.log('[CCC Bridge API] Requested chatId not in cache:', requestChatId);
        }
      }
      
      const userMessageId = generateUUID();
      const assistantMessageId = generateUUID();
      const timestamp = Date.now();
      let finalContent = '';
      
      updateDisplay('processing', 'Creating new chat...', true);
      streamingContent.textContent = '';
      
      // Step 1: Create new chat
      console.log('[CCC Bridge API] Step 1: Creating new chat...');
      const newChatResponse = await fetch(`${CONFIG.apiBase}/api/v1/chats/new`, {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json",
          "authorization": `Bearer ${authToken}`
        },
        body: JSON.stringify({
          "chat": {
            "id": "",
            "title": "Chat Pending",
            "models": ["Anthropic Claude 4 Sonnet"],
            "params": {},
            "history": {
              "messages": {
                [userMessageId]: {
                  "id": userMessageId,
                  "parentId": null,
                  "childrenIds": [],
                  "role": "user",
                  "content": messages.length > 0 ? messages[messages.length - 1].content : "",
                  "timestamp": Math.floor(timestamp / 1000),
                  "models": ["Anthropic Claude 4 Sonnet"]
                }
              },
              "currentId": userMessageId
            },
            "messages": [
              {
                "id": userMessageId,
                "parentId": null,
                "childrenIds": [],
                "role": "user",
                "content": messages.length > 0 ? messages[messages.length - 1].content : "",
                "timestamp": Math.floor(timestamp / 1000),
                "models": ["Anthropic Claude 4 Sonnet"]
              }
            ],
            "tags": [],
            "timestamp": timestamp
          }
        })
      });
      
      if (!newChatResponse.ok) {
        const errorText = await newChatResponse.text();
        console.error('[CCC Bridge API] Chat creation failed:', newChatResponse.status, errorText);
        throw new Error(`Chat creation failed: ${newChatResponse.status}`);
      }
      
      const chatResult = await newChatResponse.json();
      chatId = chatResult.id;
      console.log('[CCC Bridge API] ✓ Chat created with ID:', chatId);
      
      // Step 2: Add assistant message to chat
      console.log('[CCC Bridge API] Step 2: Adding assistant message...');
      updateDisplay('processing', 'Setting up assistant message...', true);
      
      const updateChatResponse = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json",
          "authorization": `Bearer ${authToken}`
        },
        body: JSON.stringify({
          "chat": {
            "models": ["Anthropic Claude 4 Sonnet"],
            "history": {
              "messages": {
                [userMessageId]: {
                  "id": userMessageId,
                  "parentId": null,
                  "childrenIds": [assistantMessageId],
                  "role": "user",
                  "content": messages.length > 0 ? messages[messages.length - 1].content : "",
                  "timestamp": Math.floor(timestamp / 1000),
                  "models": ["Anthropic Claude 4 Sonnet"]
                },
                [assistantMessageId]: {
                  "parentId": userMessageId,
                  "id": assistantMessageId,
                  "childrenIds": [],
                  "role": "assistant",
                  "content": "",
                  "model": "Anthropic Claude 4 Sonnet",
                  "modelName": "Anthropic Claude 4 Sonnet",
                  "modelIdx": 0,
                  "userContext": null,
                  "timestamp": Math.floor(timestamp / 1000) + 2
                }
              },
              "currentId": assistantMessageId
            },
            "messages": [
              {
                "id": userMessageId,
                "parentId": null,
                "childrenIds": [assistantMessageId],
                "role": "user",
                "content": messages.length > 0 ? messages[messages.length - 1].content : "",
                "timestamp": Math.floor(timestamp / 1000),
                "models": ["Anthropic Claude 4 Sonnet"]
              },
              {
                "parentId": userMessageId,
                "id": assistantMessageId,
                "childrenIds": [],
                "role": "assistant",
                "content": "",
                "model": "Anthropic Claude 4 Sonnet",
                "modelName": "Anthropic Claude 4 Sonnet",
                "modelIdx": 0,
                "userContext": null,
                "timestamp": Math.floor(timestamp / 1000) + 2
              }
            ],
            "params": {},
            "files": []
          }
        })
      });
      
      if (!updateChatResponse.ok) {
        const errorText = await updateChatResponse.text();
        console.error('[CCC Bridge API] Chat update failed:', updateChatResponse.status, errorText);
        throw new Error(`Chat update failed: ${updateChatResponse.status}`);
      }
      
      console.log('[CCC Bridge API] ✓ Assistant message added to chat');
      
      // Step 3: Stream completions
      console.log('[CCC Bridge API] Step 3: Starting completions stream...');
      updateDisplay('streaming', 'Streaming response...', true);
      
      const completionsResponse = await fetch(`${CONFIG.apiBase}/api/chat/completions`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${authToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          "stream": true,
          "model": "Anthropic Claude 4 Sonnet",
          "messages": messages,
          "params": {},
          "features": {
            "web_search": false
          },
          "session_id": CONFIG.sessionId,
          "chat_id": chatId,
          "id": assistantMessageId,
          "background_tasks": {
            "title_generation": true,
            "tags_generation": true
          }
        })
      });
      
      if (!completionsResponse.ok) {
        const errorText = await completionsResponse.text();
        console.error('[CCC Bridge API] Completions request failed:', completionsResponse.status, errorText);
        throw new Error(`Completions request failed: ${completionsResponse.status}`);
      }
      
      // Stream the SSE events
      const reader = completionsResponse.body.getReader();
      const decoder = new TextDecoder();
      let eventCount = 0;
      
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          console.log('[CCC Bridge API] SSE stream ended, total events:', eventCount);
          break;
        }
        
        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            eventCount++;
            const dataStr = line.substring(6);
            console.log('[CCC Bridge API] SSE Event', eventCount + ':', dataStr);
            
            if (dataStr === '[DONE]') {
              console.log('[CCC Bridge API] ===== SSE STREAM COMPLETE =====');
              
              // Send final response via clipboard
              const finalResponse = {
                type: 'BROWSER_RESPONSE',
                id: request.id,
                timestamp: Date.now(),
                status: 'success',
                payload: {
                  content: finalContent,
                  chatId: chatId,
                  model: 'Anthropic Claude 4 Sonnet'
                }
              };
              
              const responseText = JSON.stringify(finalResponse) + '|||BROWSER_END|||';
              await navigator.clipboard.writeText(responseText);
              console.log('[CCC Bridge API] Final response written to clipboard');
              
              // Cache conversation for future reuse
              if (chatId) {
                conversationCache.set(chatId, {
                  chatId: chatId,
                  messages: messages,
                  assistantMessageId: generateUUID(), // For next assistant message
                  timestamp: Date.now()
                });
                console.log('[CCC Bridge API] Cached conversation:', chatId);
              }
              
              updateDisplay('success', 'Response sent!');
              setTimeout(() => updateDisplay('ready', 'Waiting for AI requests...'), 3000);
              
              return finalResponse;
            }
            
            // Parse and accumulate content
            try {
              const data = JSON.parse(dataStr);
              if (data.choices?.[0]?.delta?.content) {
                const newContent = data.choices[0].delta.content;
                finalContent += newContent;
                streamingContent.textContent = finalContent;
                streamingContent.scrollTop = streamingContent.scrollHeight;
                
                // Check if this content contains tool use
                if (isToolUse(finalContent)) {
                  console.log('[CCC Bridge API] Detected tool use in response');
                  
                  // Send tool use response immediately
                  const toolResponse = {
                    type: 'BROWSER_RESPONSE',
                    id: request.id,
                    timestamp: Date.now(),
                    status: 'tool_use',
                    payload: {
                      content: finalContent,
                      chatId: chatId,
                      model: 'Anthropic Claude 4 Sonnet'
                    }
                  };
                  
                  const responseText = JSON.stringify(toolResponse) + '|||BROWSER_END|||';
                  await navigator.clipboard.writeText(responseText);
                  console.log('[CCC Bridge API] Tool use response written to clipboard');
                  
                  updateDisplay('success', 'Tool use detected - response sent!');
                  setTimeout(() => updateDisplay('ready', 'Waiting for AI requests...'), 3000);
                  
                  return toolResponse;
                }
                
                // Note: Progress updates removed to avoid clipboard focus errors
                // The final response will contain the complete content
              }
            } catch (parseError) {
              console.warn('[CCC Bridge API] Could not parse SSE data:', parseError.message);
            }
          }
        }
      }
      
    } catch (error) {
      console.error('[CCC Bridge API] Error:', error);
      return {
        type: 'BROWSER_RESPONSE',
        id: request.id,
        timestamp: Date.now(),
        status: 'error',
        payload: {
          error: error.message
        }
      };
    }
  }
  
  // Handle clicks
  overlay.addEventListener('click', async (e) => {
    clickCount++;
    console.log(`[CCC Bridge API] Click #${clickCount} at ${e.clientX}, ${e.clientY}`);
    
    if (bridgeState === 'calibrating') {
      try {
        const calibrationMsg = JSON.stringify({
          type: 'CCC_CALIBRATION',
          clicked: true,
          timestamp: Date.now()
        }) + '|||CCC_END|||';
        
        await navigator.clipboard.writeText(calibrationMsg);
        console.log('[CCC Bridge API] Calibration click written to clipboard');
        updateDisplay('ready', 'Waiting for AI requests...');
        
      } catch (err) {
        console.error('[CCC Bridge API] Calibration failed:', err);
        updateDisplay('error', 'Clipboard access failed');
      }
      return;
    }
    
    if (bridgeState === 'ready') {
      try {
        const clipboardText = await navigator.clipboard.readText();
        console.log('[CCC Bridge API] Clipboard content:', clipboardText.substring(0, 100) + '...');
        
        if (clipboardText.includes('CCC_REQUEST')) {
          const requestEnd = clipboardText.indexOf('|||CCC_END|||');
          if (requestEnd > 0) {
            const requestJson = clipboardText.substring(0, requestEnd);
            lastRequest = JSON.parse(requestJson);
            console.log('[CCC Bridge API] Found request:', lastRequest.id);
            
            // Process using real API
            const response = await processAIRequest(lastRequest);
            
            // Write response to clipboard
            const responseText = JSON.stringify(response) + '|||BROWSER_END|||';
            await navigator.clipboard.writeText(responseText);
            
            console.log('[CCC Bridge API] Response written to clipboard');
            updateDisplay('success', 'Response sent!');
            
            setTimeout(() => updateDisplay('ready', 'Waiting for AI requests...'), 3000);
          }
        } else {
          console.log('[CCC Bridge API] No CCC_REQUEST found in clipboard');
        }
      } catch (err) {
        console.error('[CCC Bridge API] Error:', err);
        updateDisplay('error', err.message);
      }
    }
  });
  
  // Add to page
  document.body.appendChild(overlay);
  
  // Set mock token if needed
  if (!localStorage.getItem('token')) {
    localStorage.setItem('token', 'mock-token-12345');
  }
  
  console.log('[CCC Bridge API] Ready with real API flow');
  
  // Initialization complete - overlay click handler will handle calibration directly
  
  // Export for debugging
  window.CCCBridgeAPI = {
    getState: () => ({ state: bridgeState, clicks: clickCount, lastRequest }),
    recalibrate: () => updateDisplay('calibrating'),
    remove: () => overlay.remove(),
    testTemplate: testWithApiTemplate
  };
})();
-~{END}~-

-~{File: run-prod.bat}~-
@echo off
echo ================================
echo CCC Chat Server (Production)
echo ================================
echo.

echo Cleaning up any existing CCC processes...

REM Kill any existing Java processes running on port 4444 or CCC agents
echo Killing existing CCC processes...
powershell -Command "Get-NetTCPConnection -LocalPort 4444 -ErrorAction SilentlyContinue | ForEach-Object { $proc = Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue; if($proc) { Write-Host 'Killing process' $proc.ProcessName $proc.Id 'on port 4444'; Stop-Process -Id $proc.Id -Force } }" 2>nul

powershell -Command "Get-Process -Name java -ErrorAction SilentlyContinue | Where-Object { $_.CommandLine -like '*ChatServerAgent*' -or $_.CommandLine -like '*StandaloneAgent*' -or $_.CommandLine -like '*ClipboardAgent*' -or $_.CommandLine -like '*chat-server.jar*' } | ForEach-Object { Write-Host 'Killing Java process' $_.Id; Stop-Process -Id $_.Id -Force }" 2>nul

echo Waiting for processes to terminate...
timeout /t 2 > nul

REM Compile all Java files that are present
echo Compiling Java agents...
cd src\java-agent

echo Checking for Java source files...
dir *.java >nul 2>&1
if errorlevel 1 (
    echo No Java source files found!
    cd ..\..
    pause
    exit /b 1
)

echo Compiling all Java files in directory...
javac *.java
if errorlevel 1 (
    echo Java compilation failed!
    cd ..\..
    pause
    exit /b 1
)

REM Create manifest file for JAR
echo Main-Class: ChatServerAgent > manifest.txt
echo. >> manifest.txt
jar cvfm chat-server.jar manifest.txt *.class
if errorlevel 1 (
    echo JAR creation failed!
    cd ..\..
    pause
    exit /b 1
)
del manifest.txt
cd ..\..
echo JAR created: src\java-agent\chat-server.jar

echo.
echo ================================
echo STARTING CCC CODING AGENT
echo ================================
echo.
echo The coding agent will:
echo 1. Start HTTP server on port 4444
echo 2. Auto-launch Chrome with terminal-style coding interface
echo 3. Wait for you to paste bridge script in Claude UI
echo 4. Handle requests and tool execution via clipboard bridge
echo.
echo Coding agent interface will be available at:
echo http://localhost:4444
echo.
echo Instructions for setup:
echo 1. When Chrome opens, keep it open (coding agent UI)
echo 2. Open your internal Claude UI in another tab/window
echo 3. Open Developer Console (F12) in Claude UI
echo 4. Copy and paste the bridge script (it will be in your clipboard)
echo 5. Click the calibration overlay to set click position
echo 6. Return to the coding interface and ask for help (try "search for java files")!
echo.
echo Starting chat server...
java -jar src\java-agent\chat-server.jar

pause
-~{END}~-
