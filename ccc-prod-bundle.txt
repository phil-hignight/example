-~{File: src/java-agent/ClipboardAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;

public class ClipboardAgent {
    private static Clipboard clipboard;
    private static Robot robot;
    private static String savedClipboard = "";
    private static Point savedMousePosition = new Point(0, 0);
    private static volatile boolean stopClicking = false;
    private static TrayIcon trayIcon;
    private static ExecutorService executor;
    private static Color lastClickPixelColor = null;
    
    public static void main(String[] args) {
        try {
            // Initialize components
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            robot = new Robot();
            executor = Executors.newSingleThreadExecutor();
            
            // Setup system tray
            setupSystemTray();
            
            // Process commands from stdin
            Scanner scanner = new Scanner(System.in);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                processCommand(line);
            }
            
        } catch (Exception e) {
            sendError("Initialization failed: " + e.getMessage());
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            log("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create a simple icon (16x16 green square)
            Image image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics g = image.getGraphics();
            g.setColor(Color.GREEN);
            g.fillRect(0, 0, 16, 16);
            g.dispose();
            
            // Create tray icon
            trayIcon = new TrayIcon(image, "CCC Agent");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Ready");
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            log("System tray initialized");
            
        } catch (Exception e) {
            log("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void processCommand(String jsonCommand) {
        try {
            // Parse JSON manually (avoiding external dependencies)
            Map<String, Object> cmd = parseSimpleJson(jsonCommand);
            String command = (String) cmd.get("cmd");
            
            switch (command) {
                case "SAVE_CLIPBOARD":
                    saveClipboard();
                    break;
                    
                case "RESTORE_CLIPBOARD":
                    restoreClipboard();
                    break;
                    
                case "SET_CLIPBOARD":
                    setClipboard((String) cmd.get("data"));
                    break;
                    
                case "GET_CLIPBOARD":
                    getClipboard();
                    break;
                    
                case "SAVE_MOUSE":
                    saveMousePosition();
                    break;
                    
                case "GET_MOUSE":
                    getMousePosition();
                    break;
                    
                case "RESTORE_MOUSE":
                    restoreMousePosition();
                    break;
                    
                case "CAPTURE_PIXEL_COLOR":
                    capturePixelColor(parseInt(cmd.get("x")), parseInt(cmd.get("y")));
                    break;
                    
                case "CLICK_LOOP":
                    startClickLoop(
                        parseInt(cmd.get("x")),
                        parseInt(cmd.get("y")),
                        parseInt(cmd.get("interval")),
                        parseInt(cmd.get("maxDuration"))
                    );
                    break;
                    
                case "STOP_CLICKING":
                    stopClicking();
                    break;
                    
                case "SET_STATUS":
                    setStatus((String) cmd.get("message"));
                    break;
                    
                case "PING":
                    sendResponse("pong", null);
                    break;
                    
                default:
                    sendError("Unknown command: " + command);
            }
            
        } catch (Exception e) {
            sendError("Command processing failed: " + e.getMessage());
        }
    }
    
    private static void saveClipboard() {
        try {
            Transferable contents = clipboard.getContents(null);
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                savedClipboard = (String) contents.getTransferData(DataFlavor.stringFlavor);
                sendResponse("clipboard_saved", savedClipboard.length() + " chars");
            } else {
                savedClipboard = "";
                sendResponse("clipboard_saved", "empty");
            }
        } catch (Exception e) {
            sendError("Failed to save clipboard: " + e.getMessage());
        }
    }
    
    private static void restoreClipboard() {
        try {
            StringSelection selection = new StringSelection(savedClipboard);
            clipboard.setContents(selection, null);
            sendResponse("clipboard_restored", savedClipboard.length() + " chars");
        } catch (Exception e) {
            sendError("Failed to restore clipboard: " + e.getMessage());
        }
    }
    
    private static void setClipboard(String data) {
        try {
            StringSelection selection = new StringSelection(data);
            clipboard.setContents(selection, null);
            sendResponse("clipboard_set", data.length() + " chars");
        } catch (Exception e) {
            sendError("Failed to set clipboard: " + e.getMessage());
        }
    }
    
    private static void getClipboard() {
        try {
            Transferable contents = clipboard.getContents(null);
            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
                String data = (String) contents.getTransferData(DataFlavor.stringFlavor);
                sendResponse("clipboard_content", data);
            } else {
                sendResponse("clipboard_content", "");
            }
        } catch (Exception e) {
            sendError("Failed to get clipboard: " + e.getMessage());
        }
    }
    
    private static void saveMousePosition() {
        savedMousePosition = MouseInfo.getPointerInfo().getLocation();
        sendResponse("mouse_saved", savedMousePosition.x + "," + savedMousePosition.y);
    }
    
    private static void getMousePosition() {
        Point currentPos = MouseInfo.getPointerInfo().getLocation();
        sendResponse("mouse_position", currentPos.x + "," + currentPos.y);
    }
    
    private static void restoreMousePosition() {
        robot.mouseMove(savedMousePosition.x, savedMousePosition.y);
        sendResponse("mouse_restored", savedMousePosition.x + "," + savedMousePosition.y);
    }
    
    private static void capturePixelColor(int x, int y) {
        try {
            lastClickPixelColor = robot.getPixelColor(x, y);
            sendResponse("pixel_color_captured", 
                "R=" + lastClickPixelColor.getRed() + 
                " G=" + lastClickPixelColor.getGreen() + 
                " B=" + lastClickPixelColor.getBlue() + 
                " at " + x + "," + y);
        } catch (Exception e) {
            sendError("Failed to capture pixel color: " + e.getMessage());
        }
    }
    
    private static void startClickLoop(int x, int y, int interval, int maxDuration) {
        stopClicking = false;
        
        executor.submit(() -> {
            try {
                long startTime = System.currentTimeMillis();
                long lastActivityTime = startTime;
                long inactivityTimeoutMs = 3 * 1000; // 3 seconds of no expected activity
                int clickCount = 0;
                int colorMismatchCount = 0;
                
                while (!stopClicking && (System.currentTimeMillis() - startTime) < maxDuration) {
                    // Check for pixel color validation before clicking (if we have a reference color)
                    if (lastClickPixelColor != null) {
                        Color currentPixelColor = robot.getPixelColor(x, y);
                        
                        // Allow some tolerance for minor color variations
                        if (!isColorSimilar(currentPixelColor, lastClickPixelColor, 30)) {
                            colorMismatchCount++;
                            sendError("WARNING: Pixel color mismatch at " + x + "," + y + 
                                    ". Expected: R=" + lastClickPixelColor.getRed() + 
                                    " G=" + lastClickPixelColor.getGreen() + 
                                    " B=" + lastClickPixelColor.getBlue() + 
                                    ", Got: R=" + currentPixelColor.getRed() + 
                                    " G=" + currentPixelColor.getGreen() + 
                                    " B=" + currentPixelColor.getBlue());
                            
                            // If we get 3 consecutive mismatches, stop clicking
                            if (colorMismatchCount >= 3) {
                                sendError("ERROR: Multiple pixel color mismatches - stopping click loop. Window may have moved or been covered.");
                                stopClicking = true;
                                break;
                            }
                        } else {
                            colorMismatchCount = 0; // Reset count on successful match
                        }
                    }
                    
                    // Move to position
                    robot.mouseMove(x, y);
                    robot.delay(50);
                    
                    // Click with hold time (like the proven test)
                    robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
                    robot.delay(80); // Hold for 80ms like the test
                    robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
                    clickCount++;
                    lastActivityTime = System.currentTimeMillis();
                    
                    // Check for inactivity timeout
                    if ((System.currentTimeMillis() - lastActivityTime) > inactivityTimeoutMs) {
                        sendError("WARNING: No expected activity for " + (inactivityTimeoutMs/1000) + " seconds");
                        lastActivityTime = System.currentTimeMillis();
                    }
                    
                    // Wait for interval (use longer interval for more deliberate clicks)
                    Thread.sleep(Math.max(interval, 500)); // At least 500ms between clicks
                }
                
                sendResponse("click_loop_complete", clickCount + " clicks");
                
            } catch (Exception e) {
                sendError("Click loop failed: " + e.getMessage());
            }
        });
        
        sendResponse("click_loop_started", x + "," + y);
    }
    
    private static void stopClicking() {
        stopClicking = true;
        sendResponse("clicking_stopped", null);
    }
    
    private static void setStatus(String message) {
        if (trayIcon != null) {
            trayIcon.setToolTip("CCC Agent: " + message);
        }
        sendResponse("status_set", message);
    }
    
    // Helper methods
    private static Map<String, Object> parseSimpleJson(String json) {
        Map<String, Object> result = new HashMap<>();
        
        // Remove braces and split by comma
        json = json.trim();
        if (json.startsWith("{")) json = json.substring(1);
        if (json.endsWith("}")) json = json.substring(0, json.length() - 1);
        
        // Parse key-value pairs
        String[] pairs = json.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)");
        for (String pair : pairs) {
            String[] kv = pair.split(":", 2);
            if (kv.length == 2) {
                String key = kv[0].trim().replaceAll("\"", "");
                String value = kv[1].trim();
                
                // Remove quotes from string values
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    value = value.substring(1, value.length() - 1);
                    // Unescape JSON string
                    value = value.replace("\\\"", "\"")
                                 .replace("\\\\", "\\")
                                 .replace("\\n", "\n")
                                 .replace("\\r", "\r")
                                 .replace("\\t", "\t");
                }
                
                result.put(key, value);
            }
        }
        
        return result;
    }
    
    private static int parseInt(Object value) {
        if (value == null) return 0;
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            return 0;
        }
    }
    
    private static void sendResponse(String type, String data) {
        // For clipboard_content, send raw data without escaping
        if ("clipboard_content".equals(type) && data != null) {
            String response = String.format("{\"type\":\"%s\",\"data\":%s,\"timestamp\":%d}",
                type, escapeJson(data), System.currentTimeMillis());
            System.out.println(response);
        } else {
            String response = String.format("{\"type\":\"%s\",\"data\":\"%s\",\"timestamp\":%d}",
                type, data != null ? data : "", System.currentTimeMillis());
            System.out.println(response);
        }
        System.out.flush();
    }
    
    private static String escapeJson(String str) {
        return "\"" + str.replace("\\", "\\\\")
                         .replace("\"", "\\\"")
                         .replace("\n", "\\n")
                         .replace("\r", "\\r")
                         .replace("\t", "\\t") + "\"";
    }
    
    private static void sendError(String error) {
        String response = String.format("{\"type\":\"error\",\"error\":\"%s\",\"timestamp\":%d}",
            error, System.currentTimeMillis());
        System.out.println(response);
        System.out.flush();
    }
    
    private static boolean isColorSimilar(Color c1, Color c2, int tolerance) {
        // Check if two colors are similar within a tolerance level
        // This accounts for minor variations due to lighting, compression, etc.
        int rDiff = Math.abs(c1.getRed() - c2.getRed());
        int gDiff = Math.abs(c1.getGreen() - c2.getGreen());
        int bDiff = Math.abs(c1.getBlue() - c2.getBlue());
        
        return (rDiff <= tolerance && gDiff <= tolerance && bDiff <= tolerance);
    }
    
    private static void log(String message) {
        System.err.println("[Agent] " + message);
    }
}
-~{END}~-

-~{File: src/java-agent/SystemClipboard.java}~-
import java.awt.*;
import java.awt.datatransfer.*;

/**
 * Production implementation of ClipboardInterface using system clipboard
 */
public class SystemClipboard implements ClipboardInterface {
    private final Clipboard clipboard;
    
    public SystemClipboard() {
        this.clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
    }
    
    @Override
    public String getContent() throws Exception {
        Transferable contents = clipboard.getContents(null);
        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
            return (String) contents.getTransferData(DataFlavor.stringFlavor);
        }
        return null;
    }
    
    @Override
    public void setContent(String text) throws Exception {
        StringSelection selection = new StringSelection(text);
        clipboard.setContents(selection, null);
    }
}
-~{END}~-

-~{File: src/java-agent/SINGLE-THREAD-FIX.md}~-
# Single-Threaded Clicking Fix

## Problem
The multi-threaded approach was causing issues after 4-5 tool executions:
- Multiple clicking threads running concurrently
- Thread pool exhaustion
- Race conditions between threads
- Complex thread management and synchronization
- Potential deadlocks on clipboard access

## Solution
Converted to a single-threaded clicking approach where only one request can be actively clicking at a time.

### Key Changes

1. **Replaced concurrent map with single task tracking:**
```java
// Old: Multiple concurrent tasks
private static Map<String, Future<?>> clickingTasks = new ConcurrentHashMap<>();

// New: Single task at a time
private static Future<?> currentClickingTask = null;
private static String currentClickingRequestId = null;
```

2. **Sequential request processing in `startContinuousClicking()`:**
- Made method `synchronized`
- Cancels any existing clicking task before starting new one
- Waits for cancellation to complete before proceeding
- Only one clicking thread active at any time

3. **Simplified cleanup logic:**
- No need to iterate through multiple tasks
- Clear single task reference when done
- Much simpler state management

## Benefits

1. **No Thread Exhaustion**: Can't run out of threads since only one is active
2. **No Race Conditions**: Single thread accessing clipboard eliminates races
3. **Predictable Behavior**: Requests processed sequentially, easier to debug
4. **Simpler Code**: Less complexity, easier to maintain
5. **Better Reliability**: Eliminates whole class of concurrency bugs

## Trade-offs

- **Throughput**: Can only process one request at a time
- **Latency**: Later requests wait for earlier ones to complete

However, for a clipboard-based protocol, single-threaded is actually optimal because:
- Clipboard is inherently a single shared resource
- Can't write multiple messages to clipboard simultaneously
- The bottleneck is clipboard operations, not CPU
- Better to be reliable than fast

## Expected Behavior

1. First request starts clicking immediately
2. If second request arrives while first is clicking:
   - First request's clicking is cancelled
   - Second request takes over clicking
3. Only one auto-click operation active at any time
4. No thread accumulation or exhaustion

## Implementation Details

- `startContinuousClicking()` is now `synchronized`
- Cancellation waits up to 100ms for thread to stop
- `stopContinuousClicking()` only stops if requestId matches current
- All references properly cleared after task completion

This change should eliminate the "crashes after 5 tools" issue by preventing thread accumulation and simplifying the entire clicking mechanism.
-~{END}~-

-~{File: src/java-agent/ClipboardInterface.java}~-
/**
 * Interface for clipboard operations to enable dependency injection for testing
 */
public interface ClipboardInterface {
    /**
     * Get the current clipboard content as string
     * @return clipboard content or null if empty/unavailable
     * @throws Exception if clipboard access fails
     */
    String getContent() throws Exception;
    
    /**
     * Set clipboard content to the specified text
     * @param text content to set
     * @throws Exception if clipboard access fails
     */
    void setContent(String text) throws Exception;
}
-~{END}~-

-~{File: src/java-agent/REQUEST-ID-FIX.md}~-
# Request ID Fix for Second Message

## Problem
The second message was failing because the bridge script was sending responses with `id: "unknown"` instead of the actual request ID. This caused:
- Java couldn't match the response to the pending request
- "No pending request found for: unknown" errors
- Auto-click failure due to interrupted threads

## Root Cause
In `bridge-api.js`, the `lastRequest` variable was declared but **never assigned** the incoming request. All code that referenced `lastRequest?.id || 'unknown'` was always returning 'unknown' because `lastRequest` was always null.

## Solution
Added a single line in `processAIRequest()` to store the current request:
```javascript
async function processAIRequest(request) {
  try {
    // Store the current request for later use
    lastRequest = request;
    
    updateDisplay('processing', 'Processing chat request...');
    // ... rest of the function
```

## Expected Behavior
- Each request's ID will be properly tracked throughout its lifecycle
- All BROWSER_PROGRESS and BROWSER_RESPONSE messages will have the correct request ID
- Java will be able to match responses to pending requests
- Auto-click should work for all messages in a conversation

## Files Changed
- `/home/claude-dev/coding-agent/src/browser-bridge/bridge-api.js` - Added `lastRequest = request;` at the start of `processAIRequest()`
-~{END}~-

-~{File: src/java-agent/RESPONSE-FORMAT-UPDATE.md}~-
# Response Format Update

## Problem
The AI was violating its own instructions by mixing text and tool use in responses like:
```
I can see your project structure! Let me explore it further:

<execute>
<tool name="read_file">
<parameter name="file_path">package.json</parameter>
</tool>
</execute>
```

This caused the frontend to display the `<execute>` block as HTML text instead of executing the tool.

## Old Format Issues
The old format had two rigid types:
- TYPE 1: Tool use ONLY (must start with `<execute>`)
- TYPE 2: Response text ONLY (no tools allowed)

This was too restrictive and the AI kept mixing them, causing parsing failures.

## New Structured Format
All responses now use a structured XML format:

```xml
<response>
  <message>Your text explanation here</message>
  <execute>
    <tool name="tool_name">
      <parameter name="param_name">value</parameter>
    </tool>
  </execute>
  <message>Additional explanation</message>
</response>
```

### Benefits
1. **Clear Structure**: Root `<response>` tag makes parsing unambiguous
2. **Flexibility**: Can mix messages and tool executions in any order
3. **Better UX**: AI can explain what it's doing before/after tools
4. **Extensible**: Easy to add new section types in the future

### Examples

**Message only:**
```xml
<response>
  <message>I found your package.json file. It's a Node.js project.</message>
</response>
```

**Tool with explanation:**
```xml
<response>
  <message>Let me explore your project structure.</message>
  <execute>
    <tool name="list_files">
      <parameter name="path">.</parameter>
    </tool>
  </execute>
</response>
```

**Multiple operations:**
```xml
<response>
  <message>I'll check your project files.</message>
  <execute>
    <tool name="list_files">
      <parameter name="path">.</parameter>
    </tool>
  </execute>
  <message>Now let me read the package.json.</message>
  <execute>
    <tool name="read_file">
      <parameter name="file_path">package.json</parameter>
    </tool>
  </execute>
</response>
```

## Implementation Changes

### 1. System Prompt (`coding-assistant.js`)
Updated the instructions to require the new `<response>` format with clear examples.

### 2. Frontend Parser (`coding-assistant.js`)
- Added `handleStructuredResponse()` to parse `<response>` tags
- Processes `<message>` and `<execute>` sections in order
- Each `<message>` creates a new assistant message
- Each `<execute>` triggers tool execution

### 3. Bridge Tool Detection (`bridge-api.js`)
- Updated `isToolUse()` to detect `<execute>` tags anywhere in the response
- Still sets `status: "tool_use"` when tools are present

## Expected Behavior
1. AI wraps all responses in `<response>` tags
2. AI can freely mix `<message>` and `<execute>` sections
3. Frontend displays messages and executes tools in order
4. Better user experience with explanatory text around tool usage

## Migration
The frontend still supports the old format as a fallback, but all new responses should use the structured format.
-~{END}~-

-~{File: src/java-agent/ClipboardAgentHeadless.java}~-
import java.io.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * Headless version of ClipboardAgent for testing without X11
 * This simulates clipboard and mouse operations for development/testing
 */
public class ClipboardAgentHeadless {
    private static String savedClipboard = "";
    private static String simulatedClipboard = "";
    private static int[] savedMousePosition = {0, 0};
    private static volatile boolean stopClicking = false;
    private static ExecutorService executor;
    private static boolean headlessMode = true;
    
    public static void main(String[] args) {
        try {
            // Check if we're in headless mode
            String display = System.getenv("DISPLAY");
            if (display == null || display.isEmpty()) {
                log("Running in headless mode (no X11 display)");
                log("Clipboard and mouse operations will be simulated");
                headlessMode = true;
            } else {
                log("Display found: " + display);
                headlessMode = false;
            }
            
            executor = Executors.newSingleThreadExecutor();
            
            // Process commands from stdin
            Scanner scanner = new Scanner(System.in);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                processCommand(line);
            }
            
        } catch (Exception e) {
            sendError("Initialization failed: " + e.getMessage());
            System.exit(1);
        }
    }
    
    private static void processCommand(String jsonCommand) {
        try {
            Map<String, Object> cmd = parseSimpleJson(jsonCommand);
            String command = (String) cmd.get("cmd");
            
            switch (command) {
                case "SAVE_CLIPBOARD":
                    saveClipboard();
                    break;
                    
                case "RESTORE_CLIPBOARD":
                    restoreClipboard();
                    break;
                    
                case "SET_CLIPBOARD":
                    setClipboard((String) cmd.get("data"));
                    break;
                    
                case "GET_CLIPBOARD":
                    getClipboard();
                    break;
                    
                case "SAVE_MOUSE":
                    saveMousePosition();
                    break;
                    
                case "RESTORE_MOUSE":
                    restoreMousePosition();
                    break;
                    
                case "CLICK_LOOP":
                    startClickLoop(
                        parseInt(cmd.get("x")),
                        parseInt(cmd.get("y")),
                        parseInt(cmd.get("interval")),
                        parseInt(cmd.get("maxDuration"))
                    );
                    break;
                    
                case "STOP_CLICKING":
                    stopClicking();
                    break;
                    
                case "SET_STATUS":
                    setStatus((String) cmd.get("message"));
                    break;
                    
                case "PING":
                    sendResponse("pong", null);
                    break;
                    
                default:
                    sendError("Unknown command: " + command);
            }
            
        } catch (Exception e) {
            sendError("Command processing failed: " + e.getMessage());
        }
    }
    
    private static void saveClipboard() {
        try {
            if (headlessMode) {
                // In headless mode, save the simulated clipboard
                savedClipboard = simulatedClipboard;
                sendResponse("clipboard_saved", savedClipboard.length() + " chars (simulated)");
            } else {
                // Would use real clipboard here
                sendResponse("clipboard_saved", "0 chars");
            }
        } catch (Exception e) {
            sendError("Failed to save clipboard: " + e.getMessage());
        }
    }
    
    private static void restoreClipboard() {
        try {
            if (headlessMode) {
                simulatedClipboard = savedClipboard;
                sendResponse("clipboard_restored", savedClipboard.length() + " chars (simulated)");
            } else {
                sendResponse("clipboard_restored", "0 chars");
            }
        } catch (Exception e) {
            sendError("Failed to restore clipboard: " + e.getMessage());
        }
    }
    
    private static void setClipboard(String data) {
        try {
            if (headlessMode) {
                simulatedClipboard = data;
                log("Simulated clipboard set: " + data.substring(0, Math.min(100, data.length())) + "...");
                sendResponse("clipboard_set", data.length() + " chars (simulated)");
            } else {
                sendResponse("clipboard_set", "0 chars");
            }
        } catch (Exception e) {
            sendError("Failed to set clipboard: " + e.getMessage());
        }
    }
    
    private static void getClipboard() {
        try {
            if (headlessMode) {
                sendResponse("clipboard_content", simulatedClipboard);
            } else {
                sendResponse("clipboard_content", "");
            }
        } catch (Exception e) {
            sendError("Failed to get clipboard: " + e.getMessage());
        }
    }
    
    private static void saveMousePosition() {
        if (headlessMode) {
            // Simulate saving mouse position
            savedMousePosition[0] = 100;
            savedMousePosition[1] = 100;
            sendResponse("mouse_saved", savedMousePosition[0] + "," + savedMousePosition[1] + " (simulated)");
        } else {
            sendResponse("mouse_saved", "0,0");
        }
    }
    
    private static void restoreMousePosition() {
        if (headlessMode) {
            sendResponse("mouse_restored", savedMousePosition[0] + "," + savedMousePosition[1] + " (simulated)");
        } else {
            sendResponse("mouse_restored", "0,0");
        }
    }
    
    private static void startClickLoop(int x, int y, int interval, int maxDuration) {
        stopClicking = false;
        
        executor.submit(() -> {
            try {
                long startTime = System.currentTimeMillis();
                int clickCount = 0;
                
                log("Starting simulated click loop at " + x + "," + y);
                
                while (!stopClicking && (System.currentTimeMillis() - startTime) < maxDuration) {
                    // Simulate clicking
                    clickCount++;
                    
                    if (clickCount % 10 == 0) {
                        log("Simulated clicks: " + clickCount);
                    }
                    
                    // Check clipboard for response every 5 clicks
                    if (clickCount % 5 == 0 && headlessMode) {
                        // Simulate finding a response after some clicks
                        if (clickCount == 15 && (simulatedClipboard.startsWith("CCC_REQUEST") || simulatedClipboard.contains("{\"type\":\"CCC_REQUEST\""))) {
                            // Extract request ID from the request
                            String requestId = extractRequestId(simulatedClipboard);
                            // Simulate browser response with matching ID
                            String mockResponse = String.format(
                                "{\"type\":\"BROWSER_RESPONSE\",\"id\":\"%s\",\"status\":\"success\",\"payload\":{\"content\":\"Mock response from simulated browser\"}}|||BROWSER_END|||",
                                requestId
                            );
                            simulatedClipboard = mockResponse;
                            log("Simulated browser response written to clipboard with ID: " + requestId);
                        }
                    }
                    
                    Thread.sleep(interval);
                }
                
                sendResponse("click_loop_complete", clickCount + " clicks (simulated)");
                
            } catch (Exception e) {
                sendError("Click loop failed: " + e.getMessage());
            }
        });
        
        sendResponse("click_loop_started", x + "," + y + " (simulated)");
    }
    
    private static void stopClicking() {
        stopClicking = true;
        sendResponse("clicking_stopped", null);
    }
    
    private static void setStatus(String message) {
        log("Status: " + message);
        sendResponse("status_set", message);
    }
    
    // Helper methods
    private static String extractRequestId(String clipboardContent) {
        try {
            // Extract the JSON part before |||CCC_END|||
            int endIndex = clipboardContent.indexOf("|||CCC_END|||");
            if (endIndex > 0) {
                clipboardContent = clipboardContent.substring(0, endIndex);
            }
            
            // Simple extraction of id field from JSON
            int idIndex = clipboardContent.indexOf("\"id\":");
            if (idIndex > 0) {
                int startQuote = clipboardContent.indexOf("\"", idIndex + 5);
                int endQuote = clipboardContent.indexOf("\"", startQuote + 1);
                if (startQuote > 0 && endQuote > startQuote) {
                    return clipboardContent.substring(startQuote + 1, endQuote);
                }
            }
        } catch (Exception e) {
            log("Failed to extract request ID: " + e.getMessage());
        }
        return "unknown-id";
    }
    
    private static Map<String, Object> parseSimpleJson(String json) {
        Map<String, Object> result = new HashMap<>();
        
        json = json.trim();
        if (json.startsWith("{")) json = json.substring(1);
        if (json.endsWith("}")) json = json.substring(0, json.length() - 1);
        
        String[] pairs = json.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)");
        for (String pair : pairs) {
            String[] kv = pair.split(":", 2);
            if (kv.length == 2) {
                String key = kv[0].trim().replaceAll("\"", "");
                String value = kv[1].trim();
                
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    value = value.substring(1, value.length() - 1);
                }
                
                result.put(key, value);
            }
        }
        
        return result;
    }
    
    private static int parseInt(Object value) {
        if (value == null) return 0;
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            return 0;
        }
    }
    
    private static void sendResponse(String type, String data) {
        String response = String.format("{\"type\":\"%s\",\"data\":\"%s\",\"timestamp\":%d}",
            type, data != null ? data : "", System.currentTimeMillis());
        System.out.println(response);
        System.out.flush();
    }
    
    private static void sendError(String error) {
        String response = String.format("{\"type\":\"error\",\"error\":\"%s\",\"timestamp\":%d}",
            error, System.currentTimeMillis());
        System.out.println(response);
        System.out.flush();
    }
    
    private static void log(String message) {
        System.err.println("[Headless Agent] " + message);
    }
}
-~{END}~-

-~{File: src/java-agent/TestClipboard.java}~-
import java.io.*;

/**
 * Test implementation of ClipboardInterface that communicates with Node.js test framework
 * via stdin/stdout for clipboard operations
 */
public class TestClipboard implements ClipboardInterface {
    private final BufferedWriter output;
    private final BufferedReader input;
    
    public TestClipboard() {
        this.output = new BufferedWriter(new OutputStreamWriter(System.out));
        this.input = new BufferedReader(new InputStreamReader(System.in));
    }
    
    @Override
    public String getContent() throws Exception {
        // Send command to Node.js test framework
        output.write("CLIPBOARD_GET");
        output.newLine();
        output.flush();
        
        // Read response from Node.js test framework
        String response = input.readLine();
        if (response == null || response.equals("NULL")) {
            return null;
        }
        return response;
    }
    
    @Override
    public void setContent(String text) throws Exception {
        // Send command to Node.js test framework
        output.write("CLIPBOARD_SET:" + (text == null ? "NULL" : text));
        output.newLine();
        output.flush();
        
        // Wait for acknowledgment
        String ack = input.readLine();
        if (!"ACK".equals(ack)) {
            throw new Exception("Failed to set clipboard content");
        }
    }
}
-~{END}~-

-~{File: src/java-agent/compile.sh}~-
#!/bin/bash

echo "Compiling Java agents..."

# Clean up old files
rm -f agent.jar agent-headless.jar chat-server.jar *.class manifest.txt

# Check if display is available
if [ -z "$DISPLAY" ]; then
    echo "No X11 display detected, compiling headless version only"
    
    # Compile headless agent
    javac ClipboardAgentHeadless.java
    
    if [ $? -ne 0 ]; then
        echo "ERROR: Java compilation failed"
        exit 1
    fi
    
    # Create manifest for headless JAR
    echo "Main-Class: ClipboardAgentHeadless" > manifest.txt
    
    # Create headless JAR
    jar cfm agent-headless.jar manifest.txt ClipboardAgentHeadless.class
    
    # Link as main agent.jar
    cp agent-headless.jar agent.jar
    
    echo "Headless Java agent compiled successfully"
else
    echo "X11 display found, compiling both versions..."
    
    # Compile full agent
    javac ClipboardAgent.java
    
    if [ $? -ne 0 ]; then
        echo "ERROR: Java compilation failed"
        exit 1
    fi
    
    # Also compile headless for testing
    javac ClipboardAgentHeadless.java
    
    # Create manifest for full JAR
    echo "Main-Class: ClipboardAgent" > manifest.txt
    jar cfm agent.jar manifest.txt ClipboardAgent.class
    
    # Create manifest for headless JAR
    echo "Main-Class: ClipboardAgentHeadless" > manifest.txt
    jar cfm agent-headless.jar manifest.txt ClipboardAgentHeadless.class
    
    echo "Both Java agents compiled successfully"
fi

# Compile ChatServerAgent (always, regardless of display)
echo "Compiling ChatServerAgent..."
javac ChatServerAgent.java

if [ $? -ne 0 ]; then
    echo "ERROR: ChatServerAgent compilation failed"
    exit 1
fi

# Create chat server JAR
echo "Main-Class: ChatServerAgent" > manifest.txt
jar cfm chat-server.jar manifest.txt *.class

echo "ChatServerAgent compiled successfully"

# Clean up
rm -f *.class manifest.txt

echo "Done. Available JARs:"
ls -la *.jar
-~{END}~-

-~{File: src/java-agent/ChatServerAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.List; // Explicit import to resolve ambiguity
import java.util.concurrent.*;
import java.util.concurrent.TimeUnit;
import javax.swing.*;
import com.sun.net.httpserver.*;

public class ChatServerAgent {
    private static ClipboardInterface clipboardInterface;
    private static Clipboard clipboard; // Keep for backward compatibility
    private static Robot robot; // Keep for backward compatibility
    private static RobotInterface robotInterface;
    private static String savedClipboard = "";
    private static Point clickPosition = null;
    private static volatile boolean calibrated = false;
    private static TrayIcon trayIcon;
    private static HttpServer server;
    private static final int SERVER_PORT = 4444;
    private static final String FRONTEND_URL = "http://localhost:" + SERVER_PORT;
    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static Map<String, PendingRequest> pendingRequests = new ConcurrentHashMap<>();
    // Single-threaded clicking approach - only one request at a time
    private static Future<?> currentClickingTask = null;
    private static String currentClickingRequestId = null;
    private static String lastClipboardContent = "";
    
    // Track list_recursive calls for safety checking
    private static Map<String, Long> recentListRecursiveCalls = new ConcurrentHashMap<>();
    
    static class PendingRequest {
        String requestId;
        HttpExchange exchange;
        long timestamp;
        
        PendingRequest(String requestId, HttpExchange exchange) {
            this.requestId = requestId;
            this.exchange = exchange;
            this.timestamp = System.currentTimeMillis();
        }
    }
    
    /**
     * Initialize with system clipboard and robot (production use)
     */
    public static void initializeWithSystemClipboard() throws Exception {
        clipboardInterface = new SystemClipboard();
        clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); // For backward compatibility
        robot = new Robot(); // Keep for backward compatibility
        robotInterface = new SystemRobot();
    }
    
    /**
     * Initialize with custom clipboard interface (testing use)
     */
    public static void initializeWithClipboard(ClipboardInterface customClipboard) throws Exception {
        clipboardInterface = customClipboard;
        // Don't initialize system clipboard or robot for testing
        // robot = new Robot(); // Skip robot in headless testing environment
        robotInterface = null; // Will be set separately for testing
    }
    
    /**
     * Initialize with custom clipboard and robot interfaces (full testing use)
     */
    public static void initializeWithInterfaces(ClipboardInterface customClipboard, RobotInterface customRobot) throws Exception {
        clipboardInterface = customClipboard;
        robotInterface = customRobot;
        // Don't initialize system clipboard or robot for testing
    }

    public static void main(String[] args) {
        try {
            // Initialize components with system clipboard
            initializeWithSystemClipboard();
            
            // Setup system tray
            setupSystemTray();
            
            // Start HTTP server
            startHttpServer();
            
            // Launch Chrome
            launchChrome();
            
            // Copy bridge script to clipboard
            copyBridgeScriptToClipboard();
            
            // Start clipboard monitoring immediately to catch calibration messages
            System.out.println("[FLOW] Starting clipboard monitoring for calibration...");
            startClipboardMonitoring();
            
            // Keep running
            System.out.println("CCC Chat Server running. Press Ctrl+C to exit.");
            
            // Shutdown hook
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                System.out.println("Shutting down CCC Chat Server...");
                if (server != null) {
                    server.stop(0);
                }
                executor.shutdown();
            }));
            
            // Keep main thread alive
            while (true) {
                Thread.sleep(1000);
            }
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            System.out.println("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create icon (16x16 pixels)
            BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics2D g = image.createGraphics();
            g.setColor(Color.BLUE);
            g.fillOval(0, 0, 16, 16);
            g.dispose();
            
            trayIcon = new TrayIcon(image, "CCC Chat Server");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Starting...");
            MenuItem urlItem = new MenuItem("Open: " + FRONTEND_URL);
            MenuItem exitItem = new MenuItem("Exit");
            
            urlItem.addActionListener(e -> {
                try {
                    Desktop.getDesktop().browse(new URI(FRONTEND_URL));
                } catch (Exception ex) {
                    System.err.println("Could not open browser: " + ex.getMessage());
                }
            });
            
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.add(urlItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            System.out.println("System tray initialized");
            
        } catch (Exception e) {
            System.out.println("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void startHttpServer() throws Exception {
        server = HttpServer.create(new InetSocketAddress(SERVER_PORT), 0);
        
        // Serve static files
        server.createContext("/", new StaticFileHandler());
        
        // API endpoints
        server.createContext("/api/chat", new ChatHandler());
        server.createContext("/api/tools/search-files", new FileSearchHandler());
        server.createContext("/api/tools/search-content", new ContentSearchHandler());
        server.createContext("/api/tools/list-files", new ListFilesHandler());
        server.createContext("/api/tools/read-file", new ReadFileHandler());
        server.createContext("/api/tools/create-file", new CreateFileHandler());
        server.createContext("/api/tools/delete-file", new DeleteFileHandler());
        server.createContext("/api/tools/list-recursive", new ListRecursiveHandler());
        server.createContext("/api/tools/create-directory", new CreateDirectoryHandler());
        server.createContext("/api/tools/delete-directory", new DeleteDirectoryHandler());
        server.createContext("/api/tool-result", new ToolResultHandler());
        
        server.setExecutor(executor);
        server.start();
        
        System.out.println("HTTP server started on port " + SERVER_PORT);
        System.out.println("Frontend available at: " + FRONTEND_URL);
        
        updateTrayStatus("HTTP server running on port " + SERVER_PORT);
    }
    
    private static void launchChrome() {
        try {
            // Try different Chrome executable locations
            String[] chromePaths = {
                "google-chrome",
                "google-chrome-stable", 
                "chromium-browser",
                "chromium",
                "/usr/bin/google-chrome",
                "/usr/bin/chromium-browser",
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"
            };
            
            for (String chromePath : chromePaths) {
                try {
                    ProcessBuilder pb = new ProcessBuilder(chromePath, "--new-window", FRONTEND_URL);
                    Process process = pb.start();
                    System.out.println("Chrome launched successfully with: " + chromePath);
                    updateTrayStatus("Chrome launched - Ready for chat");
                    return;
                } catch (Exception e) {
                    // Try next path
                }
            }
            
            // Fallback to system default browser
            if (Desktop.isDesktopSupported()) {
                Desktop.getDesktop().browse(new URI(FRONTEND_URL));
                System.out.println("Opened default browser (Chrome not found)");
                updateTrayStatus("Browser opened - Ready for chat");
            } else {
                System.out.println("Could not launch browser automatically");
                System.out.println("Please open: " + FRONTEND_URL);
                updateTrayStatus("Manual browser open required");
            }
            
        } catch (Exception e) {
            System.err.println("Could not launch browser: " + e.getMessage());
            System.out.println("Please open: " + FRONTEND_URL);
            updateTrayStatus("Manual browser open required");
        }
    }
    
    private static volatile boolean clipboardMonitoringActive = false;
    private static volatile Thread clipboardMonitoringThread = null;
    
    private static void startClipboardMonitoring() {
        if (clipboardMonitoringActive) {
            return; // Already running
        }
        
        clipboardMonitoringActive = true;
        clipboardMonitoringThread = new Thread(() -> {
            System.out.println("[CLIPBOARD] Started monitoring for active conversation");
            
            while (clipboardMonitoringActive && !Thread.currentThread().isInterrupted()) {
                try {
                    // Use adaptive polling delay
                    adaptiveWait();
                    
                    // Try to read messages from bridge
                    List<Map<String, Object>> messages = readMessagesFromBridge();
                    
                    if (!messages.isEmpty()) {
                        System.out.println("[CLIPBOARD] Read " + messages.size() + " messages from bridge");
                    }
                    
                    for (Map<String, Object> message : messages) {
                        String messageType = (String) message.get("type");
                        if (messageType != null) {
                            System.out.println("[FLOW] Received: " + messageType);
                            processIncomingMessage(messageType, message);
                        }
                    }
                    
                } catch (Exception e) {
                    // Continue monitoring despite errors - suppress spam
                }
            }
            
            System.out.println("[CLIPBOARD] Monitoring stopped");
        });
        
        clipboardMonitoringThread.start();
    }
    
    private static void stopClipboardMonitoring() {
        if (!clipboardMonitoringActive) {
            return; // Not running
        }
        
        System.out.println("[CLIPBOARD] Stopping monitoring - conversation complete");
        clipboardMonitoringActive = false;
        
        if (clipboardMonitoringThread != null) {
            clipboardMonitoringThread.interrupt();
            clipboardMonitoringThread = null;
        }
    }
    
    private static void processIncomingMessage(String messageType, Map<String, Object> message) {
        try {
            switch (messageType) {
                case "CCC_CALIBRATION":
                    handleCalibration(message);
                    break;
                case "USER_CANCELLED":
                    handleUserCancellation(message);
                    break;
                case "BROWSER_PROGRESS":
                    handleProgressUpdate(message);
                    break;
                case "BROWSER_RESPONSE":
                    handleFinalResponse(message);
                    break;
                case "CLICK_CONFIRMED":
                    handleClickConfirmation(message);
                    break;
                case "BROWSER_ERROR":
                    handleBrowserError(message);
                    break;
                default:
                    System.out.println("[CLIPBOARD] Unknown message type: " + messageType);
            }
        } catch (Exception e) {
            System.out.println("[CLIPBOARD] Error processing message " + messageType + ": " + e.getMessage());
        }
    }
    
    private static void handleCalibration(Map<String, Object> message) {
        try {
            // Capture current mouse position (screen coordinates) when calibration message is received
            clickPosition = robotInterface.getMousePosition();
            calibrated = true;
            
            System.out.println("[FLOW] ✓ Calibrated at screen position: " + clickPosition.x + ", " + clickPosition.y);
            updateTrayStatus("✓ Calibrated at: " + clickPosition.x + ", " + clickPosition.y);
            
            // Send calibration confirmation back to browser
            Map<String, Object> confirmPayload = new HashMap<>();
            confirmPayload.put("calibrated", true);
            
            // Create position map manually for compatibility
            Map<String, Object> positionMap = new HashMap<>();
            positionMap.put("x", clickPosition.x);
            positionMap.put("y", clickPosition.y);
            confirmPayload.put("screenPosition", positionMap);
            
            queueMessageToBridge("CALIBRATION_CONFIRMED", confirmPayload);
            
            // Try to send immediately
            if (sendQueueToBridge()) {
                // Click to trigger browser to read the confirmation
                Thread.sleep(100); // Brief delay to ensure message is written
                robotInterface.mouseMove(clickPosition.x, clickPosition.y);
                robotInterface.mousePress(InputEvent.BUTTON1_DOWN_MASK);
                robotInterface.delay(50);
                robotInterface.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
                System.out.println("[FLOW] Clicked to deliver calibration confirmation");
            } else {
                System.out.println("[ERROR] Failed to send calibration confirmation");
            }
            
        } catch (Exception e) {
            System.err.println("[ERROR] Calibration failed: " + e.getMessage());
        }
    }
    
    private static void handleUserCancellation(Map<String, Object> message) {
        try {
            System.out.println("User cancelled operation (ESC ESC)");
            
            // Stop current clicking task if any
            if (currentClickingTask != null) {
                stopContinuousClicking(currentClickingRequestId);
            }
            
            // Cancel all pending requests with cancellation message
            for (Map.Entry<String, PendingRequest> entry : pendingRequests.entrySet()) {
                String requestId = entry.getKey();
                PendingRequest pending = entry.getValue();
                
                // Send cancellation message to frontend
                String cancelResponse = "{\"type\":\"USER_CANCELLED\",\"id\":\"" + requestId + "\",\"timestamp\":" + 
                                      System.currentTimeMillis() + ",\"payload\":{\"message\":\"Operation cancelled by user (ESC ESC)\"}}";
                
                sendSSEUpdate(pending.exchange, "data: " + cancelResponse + "\n\n");
                sendSSEUpdate(pending.exchange, "data: [DONE]\n\n");
                
                try {
                    pending.exchange.getResponseBody().close();
                } catch (IOException e) {
                    // Ignore close errors
                }
            }
            
            // Clear all pending requests
            pendingRequests.clear();
            
            updateTrayStatus("User cancelled - Ready for new requests");
            
        } catch (Exception e) {
            System.err.println("Error handling user cancellation: " + e.getMessage());
        }
    }
    
    private static void handleProgressUpdate(Map<String, Object> message) {
        try {
            String requestId = (String) message.get("id");
            Object payloadObj = message.get("payload");
            
            if (requestId != null && payloadObj instanceof Map) {
                Map<String, Object> payload = (Map<String, Object>) payloadObj;
                String accumulated = (String) payload.get("accumulated");
                
                if (accumulated != null) {
                    System.out.println("[PROGRESS] Update for request " + requestId + " (" + accumulated.length() + " chars)");
                    
                    PendingRequest pending = pendingRequests.get(requestId);
                    if (pending != null) {
                        // Convert message back to JSON for frontend
                        String messageJson = mapToJson(message);
                        sendSSEUpdate(pending.exchange, "data: " + messageJson + "\n\n");
                        // Don't log every progress update to reduce spam
                    } else {
                        System.out.println("[PROGRESS] No pending request found for: " + requestId);
                    }
                }
            } else {
                System.out.println("[PROGRESS] Could not extract request ID or payload from progress update");
            }
            
        } catch (Exception e) {
            System.err.println("Error handling progress update: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static void handleFinalResponse(Map<String, Object> message) {
        try {
            String requestId = (String) message.get("id");
            String messageType = (String) message.get("type");
            
            System.out.println("[FINAL] Processing " + messageType + " for request: " + requestId);
            
            if (requestId != null) {
                // Stop continuous clicking first
                stopContinuousClicking(requestId);
                
                // Use synchronized block to prevent race conditions
                synchronized (pendingRequests) {
                    PendingRequest pending = pendingRequests.remove(requestId);
                    if (pending != null) {
                        // Convert message back to JSON for frontend
                        String messageJson = mapToJson(message);
                        
                        // Debug: Log the full JSON being sent
                        System.out.println("[DEBUG-JSON] Full message being sent to frontend:");
                        System.out.println(messageJson);
                        
                        sendSSEUpdate(pending.exchange, "data: " + messageJson + "\n\n");
                        sendSSEUpdate(pending.exchange, "data: [DONE]\n\n");
                        
                        System.out.println("[FINAL] Response sent to frontend for request: " + requestId);
                        System.out.println("[FLOW] ✓ Response received (" + messageJson.length() + " chars)");
                        
                        try {
                            pending.exchange.getResponseBody().close();
                        } catch (IOException e) {
                            System.out.println("[FINAL] Error closing response stream: " + e.getMessage());
                        }
                        
                        System.out.println("[FINAL] Response completed for request: " + requestId);
                        
                        // Don't stop clipboard monitoring - keep it active for the session
                        // The user might send more messages
                        System.out.println("[CLIPBOARD] Keeping monitoring active for additional messages");
                    } else {
                        System.out.println("[FINAL] ERROR: No pending request found for: " + requestId);
                        System.out.println("[FINAL] Current pending requests: " + pendingRequests.keySet());
                    }
                }
            } else {
                System.out.println("[FINAL] ERROR: No request ID in final response message");
            }
            
        } catch (Exception e) {
            System.err.println("[FINAL] ERROR: Exception in handleFinalResponse: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private static void handleClickConfirmation(Map<String, Object> message) {
        // Set flag for waitForClickConfirmation method
        clickConfirmationReceived = true;
        lastClickConfirmationTime = System.currentTimeMillis();
        
        Object timestamp = message.get("timestamp");
        Object position = message.get("position");
        System.out.println("[CLICK] Confirmation received at " + timestamp + " position: " + position);
    }
    
    private static void handleBrowserError(Map<String, Object> message) {
        System.err.println("[BROWSER-ERROR] Browser reported error: " + message.get("error"));
        System.err.println("[BROWSER-ERROR] Details: " + message.get("details"));
        System.err.println("[BROWSER-ERROR] Clipboard preview: " + message.get("clipboardPreview"));
        
        // Stop current clicking task if any
        if (currentClickingTask != null) {
            stopContinuousClicking(currentClickingRequestId);
        }
        
        // Send error response to all pending requests
        for (Map.Entry<String, PendingRequest> entry : pendingRequests.entrySet()) {
            PendingRequest pending = entry.getValue();
            try {
                String errorResponse = "{\n" +
                    "  \"error\": \"Browser Error\",\n" +
                    "  \"details\": \"" + message.get("details") + "\",\n" +
                    "  \"action\": \"refresh\"\n" +
                    "}";
                
                sendSSEUpdate(pending.exchange, "data: " + errorResponse + "\n\n");
                sendSSEUpdate(pending.exchange, "data: [DONE]\n\n");
                pending.exchange.getResponseBody().close();
                
            } catch (Exception e) {
                System.err.println("[BROWSER-ERROR] Failed to send error response: " + e.getMessage());
            }
        }
        
        // Clear pending requests
        pendingRequests.clear();
    }
    
    private static void sendSSEUpdate(HttpExchange exchange, String data) {
        try {
            OutputStream os = exchange.getResponseBody();
            byte[] bytes = data.getBytes("UTF-8");
            os.write(bytes);
            os.flush();
            System.out.println("[SSE DEBUG] Sent " + bytes.length + " bytes: " + data.substring(0, Math.min(50, data.length())) + "...");
        } catch (Exception e) {
            // Check if it's a StreamClosedException - this is expected if the response was already completed
            if (e.getClass().getName().contains("StreamClosedException")) {
                System.out.println("[SSE DEBUG] Stream already closed - response was likely already sent");
            } else {
                System.err.println("Error sending SSE update: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }
    
    private static String extractJsonField(String json, String field) {
        try {
            String pattern = "\"" + field + "\":\"";
            int start = json.indexOf(pattern);
            if (start == -1) {
                System.out.println("[DEBUG-PARSE] Field '" + field + "' not found in JSON. Pattern searched: " + pattern);
                // Try to find the field name at least
                String fieldPattern = "\"" + field + "\":";
                int fieldIndex = json.indexOf(fieldPattern);
                if (fieldIndex >= 0) {
                    String contextAroundField = json.substring(Math.max(0, fieldIndex - 20), Math.min(json.length(), fieldIndex + 100));
                    System.out.println("[DEBUG-PARSE] Found field without quotes, context: [" + contextAroundField + "]");
                }
                return null;
            }
            start += pattern.length();
            
            int end = json.indexOf("\"", start);
            if (end == -1) {
                System.out.println("[DEBUG-PARSE] No closing quote found for field '" + field + "' starting at position " + start);
                return null;
            }
            
            String result = json.substring(start, end);
            System.out.println("[DEBUG-PARSE] Successfully extracted field '" + field + "': [" + result + "]");
            return result;
        } catch (Exception e) {
            System.out.println("[DEBUG-PARSE] Exception extracting field '" + field + "': " + e.getMessage());
            return null;
        }
    }
    
    private static String extractNestedJsonField(String json, String parentField, String field) {
        try {
            // Find the parent object
            String parentPattern = "\"" + parentField + "\":{";
            int parentStart = json.indexOf(parentPattern);
            if (parentStart == -1) return null;
            
            // Find the field within the parent object
            String pattern = "\"" + field + "\":\"";
            int start = json.indexOf(pattern, parentStart);
            if (start == -1) return null;
            start += pattern.length();
            
            int end = json.indexOf("\"", start);
            if (end == -1) return null;
            
            return json.substring(start, end);
        } catch (Exception e) {
            return null;
        }
    }
    
    private static String extractNestedJsonObject(String json, String parentField, String field) {
        try {
            // Find the parent object
            String parentPattern = "\"" + parentField + "\":{";
            int parentStart = json.indexOf(parentPattern);
            if (parentStart == -1) return null;
            
            // Find the field within the parent object
            String pattern = "\"" + field + "\":";
            int fieldStart = json.indexOf(pattern, parentStart);
            if (fieldStart == -1) return null;
            fieldStart += pattern.length();
            
            // Extract the JSON object value (could be {}, [], or simple value)
            int braceCount = 0;
            int bracketCount = 0;
            boolean inString = false;
            boolean escaped = false;
            int start = fieldStart;
            
            // Skip whitespace
            while (start < json.length() && Character.isWhitespace(json.charAt(start))) {
                start++;
            }
            
            int end = start;
            char firstChar = json.charAt(start);
            
            if (firstChar == '{') {
                braceCount = 1;
                end++;
                
                while (end < json.length() && braceCount > 0) {
                    char c = json.charAt(end);
                    
                    if (escaped) {
                        escaped = false;
                    } else if (c == '\\') {
                        escaped = true;
                    } else if (c == '"') {
                        inString = !inString;
                    } else if (!inString) {
                        if (c == '{') braceCount++;
                        else if (c == '}') braceCount--;
                    }
                    end++;
                }
            } else if (firstChar == '[') {
                bracketCount = 1;
                end++;
                
                while (end < json.length() && bracketCount > 0) {
                    char c = json.charAt(end);
                    
                    if (escaped) {
                        escaped = false;
                    } else if (c == '\\') {
                        escaped = true;
                    } else if (c == '"') {
                        inString = !inString;
                    } else if (!inString) {
                        if (c == '[') bracketCount++;
                        else if (c == ']') bracketCount--;
                    }
                    end++;
                }
            } else {
                // Simple value - find end by comma, brace, or bracket
                while (end < json.length()) {
                    char c = json.charAt(end);
                    if (!inString && (c == ',' || c == '}' || c == ']')) {
                        break;
                    }
                    if (escaped) {
                        escaped = false;
                    } else if (c == '\\') {
                        escaped = true;
                    } else if (c == '"') {
                        inString = !inString;
                    }
                    end++;
                }
            }
            
            return json.substring(start, end).trim();
        } catch (Exception e) {
            return null;
        }
    }
    
    private static void copyBridgeScriptToClipboard() {
        try {
            System.out.println("Copying bridge script to clipboard...");
            
            // Read the bridge script file
            String scriptPath = "src/browser-bridge/bridge-api.js";
            File scriptFile = new File(scriptPath);
            
            if (!scriptFile.exists()) {
                System.err.println("Bridge script not found at: " + scriptPath);
                System.out.println("Please manually copy the bridge script from the browser-bridge directory");
                return;
            }
            
            // Read file contents
            StringBuilder scriptContent = new StringBuilder();
            try (java.io.BufferedReader reader = new java.io.BufferedReader(
                    new java.io.FileReader(scriptFile))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    scriptContent.append(line).append("\n");
                }
            }
            
            // Copy to clipboard
            StringSelection selection = new StringSelection(scriptContent.toString());
            clipboard.setContents(selection, null);
            
            System.out.println("✓ Bridge script copied to clipboard (" + scriptContent.length() + " characters)");
            System.out.println();
            System.out.println("Next steps:");
            System.out.println("1. Open your internal Claude UI in a browser tab");
            System.out.println("2. Open Developer Console (F12)");
            System.out.println("3. Paste the bridge script (Ctrl+V) and press Enter");
            System.out.println("4. Click anywhere on the page to calibrate the clicking position");
            System.out.println("5. Return to http://localhost:4444 and start chatting!");
            System.out.println();
            
            updateTrayStatus("Bridge script ready - Paste in Claude UI");
            
        } catch (Exception e) {
            System.err.println("Failed to copy bridge script to clipboard: " + e.getMessage());
            System.out.println("Please manually copy the bridge script from src/browser-bridge/bridge-api.js");
        }
    }
    
    private static void updateTrayStatus(String status) {
        if (trayIcon != null) {
            PopupMenu popup = trayIcon.getPopupMenu();
            if (popup.getItemCount() > 0) {
                MenuItem statusItem = popup.getItem(0);
                statusItem.setLabel("Status: " + status);
            }
        }
    }
    
    // HTTP Handlers
    static class StaticFileHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String path = exchange.getRequestURI().getPath();
            
            if (path.equals("/") || path.equals("/index.html")) {
                sendChatInterface(exchange);
            } else if (path.startsWith("/css/") || path.startsWith("/js/")) {
                // Serve static assets (CSS/JS files)
                String filePath = "web" + path;
                serveFile(exchange, filePath);
            } else {
                send404(exchange);
            }
        }
        
        private void sendChatInterface(HttpExchange exchange) throws IOException {
            serveFile(exchange, "web/index.html");
        }
        
        private void serveFile(HttpExchange exchange, String filePath) throws IOException {
            File file = new File(filePath);
            
            // If file doesn't exist, try looking in current directory first
            if (!file.exists()) {
                // Try current working directory
                File currentDir = new File(System.getProperty("user.dir"));
                System.out.println("Current working directory: " + currentDir.getAbsolutePath());
                System.out.println("Looking for file: " + filePath);
                
                // Try different possible locations
                File[] possibleFiles = {
                    new File(filePath),                                    // Original path
                    new File("src/java-agent/" + filePath),              // From project root
                    new File("../" + filePath),                          // From java-agent directory
                    new File("./" + filePath)                            // Current directory
                };
                
                for (File possibleFile : possibleFiles) {
                    System.out.println("Trying: " + possibleFile.getAbsolutePath());
                    if (possibleFile.exists()) {
                        file = possibleFile;
                        System.out.println("Found file at: " + file.getAbsolutePath());
                        break;
                    }
                }
                
                if (!file.exists()) {
                    System.out.println("File not found in any location: " + filePath);
                    sendResponse(exchange, 404, "File not found: " + filePath);
                    return;
                }
            }
            
            byte[] bytes = readFileBytes(file);
            String contentType = getContentType(filePath);
            
            exchange.getResponseHeaders().set("Content-Type", contentType);
            exchange.sendResponseHeaders(200, bytes.length);
            try (OutputStream os = exchange.getResponseBody()) {
                os.write(bytes);
            }
        }
        
        private byte[] readFileBytes(File file) throws IOException {
            try (FileInputStream fis = new FileInputStream(file)) {
                return fis.readAllBytes();
            }
        }
        
        private String getContentType(String filePath) {
            if (filePath.endsWith(".html")) return "text/html; charset=UTF-8";
            if (filePath.endsWith(".css")) return "text/css; charset=UTF-8";
            if (filePath.endsWith(".js")) return "application/javascript; charset=UTF-8";
            return "text/plain; charset=UTF-8";
        }
        
        private void send404(HttpExchange exchange) throws IOException {
            String response = "404 Not Found";
            byte[] bytes = response.getBytes("UTF-8");
            exchange.sendResponseHeaders(404, bytes.length);
            
            OutputStream os = exchange.getResponseBody();
            os.write(bytes);
            os.close();
        }
        
        private void sendResponse(HttpExchange exchange, int statusCode, String message) throws IOException {
            byte[] bytes = message.getBytes("UTF-8");
            exchange.sendResponseHeaders(statusCode, bytes.length);
            
            OutputStream os = exchange.getResponseBody();
            os.write(bytes);
            os.close();
        }
    }
    
    static class ChatHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Received chat request: " + requestBody);
                
                // Parse request to get ID
                String requestId = extractJsonField(requestBody, "id");
                if (requestId == null) {
                    throw new Exception("No request ID found");
                }
                
                // Store pending request for response correlation
                pendingRequests.put(requestId, new PendingRequest(requestId, exchange));
                
                // Set up SSE response headers
                exchange.getResponseHeaders().set("Content-Type", "text/event-stream");
                exchange.getResponseHeaders().set("Cache-Control", "no-cache");
                exchange.getResponseHeaders().set("Connection", "keep-alive");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                exchange.sendResponseHeaders(200, 0);
                
                // Ensure clipboard monitoring is active
                if (!clipboardMonitoringActive) {
                    System.out.println("[CLIPBOARD] Restarting monitoring for new request");
                    startClipboardMonitoring();
                }
                
                // Queue CCC_REQUEST message for bridge
                System.out.println("[FLOW] User message received: " + requestBody.substring(0, Math.min(100, requestBody.length())) + "...");
                
                // The browser expects [{"type":"CCC_REQUEST","id":"...","timestamp":...,"action":"...","payload":{...}}]
                // But if we put requestBody as a string value, it gets double-encoded
                // For now, keep the current format since browser can handle it
                Map<String, Object> forwardMessage = new HashMap<>();
                forwardMessage.put("type", "CCC_REQUEST"); 
                forwardMessage.put("request", requestBody);
                javaMessageQueue.add(forwardMessage);
                
                // Try to send the queue immediately
                boolean clipboardWriteSuccess = sendQueueToBridge();
                if (!clipboardWriteSuccess) {
                    System.out.println("Failed to send initial request, will retry during polling");
                }
                
                // Start continuous clicking ONLY if clipboard write succeeded (if calibrated)
                if (clipboardWriteSuccess && calibrated && clickPosition != null) {
                    System.out.println("[FLOW] Starting auto-click at: " + clickPosition.x + ", " + clickPosition.y);
                    startContinuousClicking(requestId);
                } else if (!clipboardWriteSuccess) {
                    System.out.println("[ERROR] Clipboard write failed - no clicking");
                } else if (!calibrated) {
                    System.out.println("[ERROR] Bridge not calibrated - no clicking");
                }
                
            } catch (Exception e) {
                System.err.println("Chat request error: " + e.getMessage());
                
                // Send error response
                String errorResponse = "HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n" + e.getMessage();
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                OutputStream os = exchange.getResponseBody();
                os.write(bytes);
                os.close();
            }
        }
    }
    
    static class FileSearchHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("File search request: " + requestBody);
                
                // Parse query from request
                String query = extractJsonField(requestBody, "query");
                if (query == null || query.trim().isEmpty()) {
                    throw new Exception("No query provided");
                }
                
                // Execute file search using PowerShell
                java.util.List<String> files = searchFiles(query);
                
                // Create response
                String response = "{\"files\":[" + 
                    files.stream()
                        .map(file -> "\"" + file.replace("\\", "\\\\").replace("\"", "\\\"") + "\"")
                        .reduce((a, b) -> a + "," + b)
                        .orElse("") +
                    "]}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("File search error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class ContentSearchHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Content search request: " + requestBody);
                
                // Parse query and file pattern from request
                String query = extractJsonField(requestBody, "query");
                String filePattern = extractJsonField(requestBody, "file_pattern");
                
                if (query == null || query.trim().isEmpty()) {
                    throw new Exception("No query provided");
                }
                
                // Execute content search using PowerShell
                java.util.List<String> results = searchContent(query, filePattern);
                
                // Create response
                String response = "{\"results\":[" + 
                    results.stream()
                        .map(result -> "\"" + result.replace("\\", "\\\\").replace("\"", "\\\"") + "\"")
                        .reduce((a, b) -> a + "," + b)
                        .orElse("") +
                    "]}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("Content search error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class ListFilesHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("List files request: " + requestBody);
                
                // Parse path from request
                String path = extractJsonField(requestBody, "path");
                if (path == null || path.trim().isEmpty()) {
                    path = "."; // Default to current directory
                }
                
                // Execute list files using PowerShell
                java.util.List<String> files = listFiles(path);
                
                // Create response
                String response = "{\"files\":[" + 
                    files.stream()
                        .map(file -> "\"" + file.replace("\\", "\\\\").replace("\"", "\\\"") + "\"")
                        .reduce((a, b) -> a + "," + b)
                        .orElse("") +
                    "]}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("List files error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class ReadFileHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Read file request: " + requestBody);
                
                // Parse file path from request
                String filePath = extractJsonField(requestBody, "file_path");
                if (filePath == null || filePath.trim().isEmpty()) {
                    throw new Exception("No file_path provided");
                }
                
                // Parse optional start_line and end_line parameters
                String startLineStr = extractJsonField(requestBody, "start_line");
                String endLineStr = extractJsonField(requestBody, "end_line");
                
                Integer startLine = null;
                Integer endLine = null;
                
                if (startLineStr != null && !startLineStr.trim().isEmpty()) {
                    try {
                        startLine = Integer.parseInt(startLineStr.trim());
                    } catch (NumberFormatException e) {
                        throw new Exception("Invalid start_line parameter: must be a number");
                    }
                }
                
                if (endLineStr != null && !endLineStr.trim().isEmpty()) {
                    try {
                        endLine = Integer.parseInt(endLineStr.trim());
                    } catch (NumberFormatException e) {
                        throw new Exception("Invalid end_line parameter: must be a number");
                    }
                }
                
                // Read file content with optional line range
                String content = readFileContent(filePath, startLine, endLine);
                
                // Create response (escape content for JSON)
                String escapedContent = content.replace("\\", "\\\\")
                                              .replace("\"", "\\\"")
                                              .replace("\n", "\\n")
                                              .replace("\r", "\\r")
                                              .replace("\t", "\\t");
                
                String response = "{\"content\":\"" + escapedContent + "\",\"file_path\":\"" + 
                                filePath.replace("\\", "\\\\").replace("\"", "\\\"") + "\"}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("Read file error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class CreateFileHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Create file request: " + requestBody);
                
                // Parse parameters from request
                String filePath = extractJsonField(requestBody, "file_path");
                String content = extractJsonField(requestBody, "content");
                
                if (filePath == null || filePath.trim().isEmpty()) {
                    throw new Exception("No file_path provided");
                }
                
                if (content == null) {
                    content = ""; // Allow empty file creation
                }
                
                // Execute file creation
                createFile(filePath, content);
                
                // Create success response
                String response = "{\"success\":true,\"message\":\"File created successfully\",\"file_path\":\"" + 
                                filePath.replace("\\", "\\\\").replace("\"", "\\\"") + "\"}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("Create file error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class DeleteFileHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Delete file request: " + requestBody);
                
                // Parse file path from request
                String filePath = extractJsonField(requestBody, "file_path");
                
                if (filePath == null || filePath.trim().isEmpty()) {
                    throw new Exception("No file_path provided");
                }
                
                // Execute file deletion
                deleteFile(filePath);
                
                // Create success response
                String response = "{\"success\":true,\"message\":\"File deleted successfully\",\"file_path\":\"" + 
                                filePath.replace("\\", "\\\\").replace("\"", "\\\"") + "\"}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("Delete file error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class ListRecursiveHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("List recursive request: " + requestBody);
                
                // Parse path from request
                String path = extractJsonField(requestBody, "path");
                if (path == null || path.trim().isEmpty()) {
                    path = "."; // Default to current directory
                }
                
                // Execute recursive listing
                java.util.List<String> files = listRecursive(path);
                
                // Track this call for safety checking
                trackListRecursiveCall(path);
                
                // Create response
                StringBuilder jsonArray = new StringBuilder("[");
                for (int i = 0; i < files.size(); i++) {
                    jsonArray.append("\"").append(files.get(i).replace("\\", "\\\\").replace("\"", "\\\"")).append("\"");
                    if (i < files.size() - 1) {
                        jsonArray.append(",");
                    }
                }
                jsonArray.append("]");
                
                String response = "{\"files\":" + jsonArray.toString() + ",\"path\":\"" + 
                                path.replace("\\", "\\\\").replace("\"", "\\\"") + "\"}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("List recursive error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class CreateDirectoryHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Create directory request: " + requestBody);
                
                // Parse directory path from request
                String dirPath = extractJsonField(requestBody, "dir_path");
                
                if (dirPath == null || dirPath.trim().isEmpty()) {
                    throw new Exception("No dir_path provided");
                }
                
                // Execute directory creation
                createDirectory(dirPath);
                
                // Create success response
                String response = "{\"success\":true,\"message\":\"Directory created successfully\",\"dir_path\":\"" + 
                                dirPath.replace("\\", "\\\\").replace("\"", "\\\"") + "\"}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("Create directory error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class DeleteDirectoryHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Delete directory request: " + requestBody);
                
                // Parse directory path from request
                String dirPath = extractJsonField(requestBody, "dir_path");
                
                if (dirPath == null || dirPath.trim().isEmpty()) {
                    throw new Exception("No dir_path provided");
                }
                
                // Check if list_recursive was called recently for this path
                if (!hasRecentListRecursive(dirPath)) {
                    // Instead of deleting, return the recursive list as a safety measure
                    java.util.List<String> files = listRecursive(dirPath);
                    
                    StringBuilder jsonArray = new StringBuilder("[");
                    for (int i = 0; i < files.size(); i++) {
                        jsonArray.append("\"").append(files.get(i).replace("\\", "\\\\").replace("\"", "\\\"")).append("\"");
                        if (i < files.size() - 1) {
                            jsonArray.append(",");
                        }
                    }
                    jsonArray.append("]");
                    
                    String response = "{\"safety_listing\":true,\"message\":\"For safety, showing directory contents before deletion. If you still want to delete this directory, use the delete_directory_recursive command again.\",\"files\":" + 
                                    jsonArray.toString() + ",\"dir_path\":\"" + 
                                    dirPath.replace("\\", "\\\\").replace("\"", "\\\"") + "\"}";
                    
                    exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                    exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                    byte[] bytes = response.getBytes("UTF-8");
                    exchange.sendResponseHeaders(200, bytes.length);
                    
                    try (OutputStream os = exchange.getResponseBody()) {
                        os.write(bytes);
                    }
                    return;
                }
                
                // Execute directory deletion (list_recursive was called recently)
                deleteDirectoryRecursive(dirPath);
                
                // Create success response
                String response = "{\"success\":true,\"message\":\"Directory deleted successfully\",\"dir_path\":\"" + 
                                dirPath.replace("\\", "\\\\").replace("\"", "\\\"") + "\"}";
                
                // Send response
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = response.getBytes("UTF-8");
                exchange.sendResponseHeaders(200, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
                
            } catch (Exception e) {
                System.err.println("Delete directory error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    static class ToolResultHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"POST".equals(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, 0);
                exchange.getResponseBody().close();
                return;
            }
            
            try {
                // Read request body
                InputStream is = exchange.getRequestBody();
                String requestBody = new String(is.readAllBytes(), "UTF-8");
                
                System.out.println("Tool result: " + requestBody);
                
                // Parse request to get ID for response correlation first
                String requestId = extractJsonField(requestBody, "id");
                
                // Extract the messages array from the tool result request
                String messagesJson = extractNestedJsonObject(requestBody, "payload", "messages");
                
                // Create a proper chat request with the full conversation history
                String chatRequest = String.format(
                    "{\"type\":\"CCC_REQUEST\",\"id\":\"%s\",\"timestamp\":%d,\"action\":\"ai-complete\",\"payload\":{\"messages\":%s}}",
                    requestId,
                    System.currentTimeMillis(),
                    messagesJson != null ? messagesJson : "[]"
                );
                
                // Queue CCC_REQUEST message for bridge
                Map<String, Object> payload = new HashMap<>();
                payload.put("request", chatRequest);
                queueMessageToBridge("CCC_REQUEST", payload);
                
                // Try to send the queue immediately  
                if (!sendQueueToBridge()) {
                    System.out.println("Failed to send tool result request, will retry during polling");
                }
                if (requestId != null) {
                    // Store pending request for SSE response
                    pendingRequests.put(requestId, new PendingRequest(requestId, exchange));
                    
                    // Set up SSE response headers
                    exchange.getResponseHeaders().set("Content-Type", "text/event-stream");
                    exchange.getResponseHeaders().set("Cache-Control", "no-cache");
                    exchange.getResponseHeaders().set("Connection", "keep-alive");
                    exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                    exchange.sendResponseHeaders(200, 0);
                    
                    // Tool results need clicking too - start auto-click
                    System.out.println("[FLOW] Tool result queued, starting auto-click for request: " + requestId);
                    
                    // Start continuous clicking in background for tool results too
                    startContinuousClicking(requestId);
                } else {
                    // Simple acknowledgment response
                    String response = "{\"status\":\"received\"}";
                    exchange.getResponseHeaders().set("Content-Type", "application/json");
                    byte[] bytes = response.getBytes("UTF-8");
                    exchange.sendResponseHeaders(200, bytes.length);
                    
                    try (OutputStream os = exchange.getResponseBody()) {
                        os.write(bytes);
                    }
                }
                
            } catch (Exception e) {
                System.err.println("Tool result error: " + e.getMessage());
                
                String errorResponse = "{\"error\":\"" + e.getMessage().replace("\"", "\\\"") + "\"}";
                exchange.getResponseHeaders().set("Content-Type", "application/json");
                byte[] bytes = errorResponse.getBytes("UTF-8");
                exchange.sendResponseHeaders(500, bytes.length);
                
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(bytes);
                }
            }
        }
    }
    
    private static java.util.List<String> searchFiles(String query) throws Exception {
        java.util.List<String> results = new java.util.ArrayList<>();
        
        // Use PowerShell to search for files
        String command = "powershell.exe -Command \"Get-ChildItem -Recurse -File | Where-Object { $_.Name -like '*" + 
                        query.replace("'", "''") + "*' } | Select-Object -First 20 | ForEach-Object { $_.FullName }\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    results.add(line);
                }
            }
        }
        
        process.waitFor();
        return results;
    }
    
    private static java.util.List<String> searchContent(String query, String filePattern) throws Exception {
        java.util.List<String> results = new java.util.ArrayList<>();
        
        // Build PowerShell command for content search with context lines
        String command = "powershell.exe -Command \"" +
            "$matches = @(); " +
            
            // Get file list
            (filePattern != null && !filePattern.trim().isEmpty() ? 
                "Get-ChildItem -Recurse -File -Filter '" + filePattern.replace("'", "''") + "'" :
                "Get-ChildItem -Recurse -File") +
            
            " | ForEach-Object { " +
                "$file = $_; " +
                "$content = Get-Content $file.FullName; " +
                "$lineNum = 0; " +
                "$content | ForEach-Object { " +
                    "$lineNum++; " +
                    "if ($_ -match '" + query.replace("'", "''") + "') { " +
                        "$startLine = [Math]::Max(1, $lineNum - 5); " +
                        "$endLine = [Math]::Min($content.Length, $lineNum + 5); " +
                        "$contextLines = @(); " +
                        "for ($i = $startLine; $i -le $endLine; $i++) { " +
                            "$prefix = if ($i -eq $lineNum) { '> ' } else { '  ' }; " +
                            "$contextLines += \\\"$prefix$($i): $($content[$i-1])\\\"; " +
                        "} " +
                        "$matches += [PSCustomObject]@{ " +
                            "File = $file.Name; " +
                            "Path = $file.FullName; " +
                            "MatchLine = $lineNum; " +
                            "Context = ($contextLines -join \\\"`n\\\") " +
                        "}; " +
                    "} " +
                "} " +
            "} | Select-Object -First 20; " +
            
            "$matches | ForEach-Object { " +
                "\\\"=== $($_.File) (Line $($_.MatchLine)) ===`n$($_.Context)`n\\\" " +
            "}\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (!line.trim().isEmpty()) {
                    results.add(line);
                }
            }
        }
        
        process.waitFor();
        return results;
    }
    
    private static java.util.List<String> listFiles(String path) throws Exception {
        java.util.List<String> results = new java.util.ArrayList<>();
        
        // Use PowerShell to list files and directories
        String command = "powershell.exe -Command \"Get-ChildItem -Path '" + path.replace("'", "''") + "' | " +
                        "ForEach-Object { if ($_.PSIsContainer) { '[DIR] ' + $_.Name } else { '[FILE] ' + $_.Name + ' (' + $_.Length + ' bytes)' } }\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    results.add(line);
                }
            }
        }
        
        process.waitFor();
        return results;
    }
    
    private static String readFileContent(String filePath) throws Exception {
        return readFileContent(filePath, null, null);
    }
    
    private static String readFileContent(String filePath, Integer startLine, Integer endLine) throws Exception {
        // Use PowerShell to read file content with safety checks and optional line range
        String command = "powershell.exe -Command \"" +
                        "if (-not (Test-Path '" + filePath.replace("'", "''") + "')) { " +
                            "throw 'File not found: " + filePath.replace("'", "''") + "' " +
                        "} " +
                        "if ((Get-Item '" + filePath.replace("'", "''") + "').PSIsContainer) { " +
                            "throw 'Path is a directory, not a file: " + filePath.replace("'", "''") + "' " +
                        "} " +
                        "$fileSize = (Get-Item '" + filePath.replace("'", "''") + "').Length; " +
                        "if ($fileSize -gt 1048576) { " +
                            "throw 'File too large (max 1MB): " + filePath.replace("'", "''") + "' " +
                        "} ";
        
        if (startLine != null && endLine != null) {
            // Read specific line range with line numbers
            command += "$content = Get-Content '" + filePath.replace("'", "''") + "'; " +
                      "$totalLines = $content.Length; " +
                      "if (" + startLine + " -gt $totalLines) { " +
                          "throw 'Start line " + startLine + " exceeds file length (' + $totalLines + ')' " +
                      "} " +
                      "$actualStart = [Math]::Max(1, " + startLine + "); " +
                      "$actualEnd = [Math]::Min($totalLines, " + endLine + "); " +
                      "$result = @(); " +
                      "for ($i = $actualStart; $i -le $actualEnd; $i++) { " +
                          "$result += \\\"$($i): $($content[$i-1])\\\" " +
                      "} " +
                      "$result -join \\\"`n\\\"";
        } else if (startLine != null) {
            // Read from startLine to end with line numbers
            command += "$content = Get-Content '" + filePath.replace("'", "''") + "'; " +
                      "$totalLines = $content.Length; " +
                      "if (" + startLine + " -gt $totalLines) { " +
                          "throw 'Start line " + startLine + " exceeds file length (' + $totalLines + ')' " +
                      "} " +
                      "$result = @(); " +
                      "for ($i = " + startLine + "; $i -le $totalLines; $i++) { " +
                          "$result += \\\"$($i): $($content[$i-1])\\\" " +
                      "} " +
                      "$result -join \\\"`n\\\"";
        } else {
            // Read entire file without line numbers
            command += "Get-Content '" + filePath.replace("'", "''") + "' -Raw";
        }
        
        command += "\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        StringBuilder content = new StringBuilder();
        StringBuilder error = new StringBuilder();
        
        // Read both stdout and stderr
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
             BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
            
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
            
            while ((line = errorReader.readLine()) != null) {
                error.append(line).append("\n");
            }
        }
        
        int exitCode = process.waitFor();
        
        if (exitCode != 0 && error.length() > 0) {
            throw new Exception(error.toString().trim());
        }
        
        return content.toString();
    }
    
    // Track list_recursive call for safety checking
    private static void trackListRecursiveCall(String path) {
        // Normalize path for tracking
        String normalizedPath = path.replace("/", "\\").toLowerCase();
        recentListRecursiveCalls.put(normalizedPath, System.currentTimeMillis());
        
        // Clean up old entries (older than 10 minutes)
        long tenMinutesAgo = System.currentTimeMillis() - (10 * 60 * 1000);
        recentListRecursiveCalls.entrySet().removeIf(entry -> entry.getValue() < tenMinutesAgo);
    }
    
    // Check if list_recursive was called recently for a path
    private static boolean hasRecentListRecursive(String path) {
        // Normalize path for checking
        String normalizedPath = path.replace("/", "\\").toLowerCase();
        
        // Clean up old entries first
        long fiveMinutesAgo = System.currentTimeMillis() - (5 * 60 * 1000);
        recentListRecursiveCalls.entrySet().removeIf(entry -> entry.getValue() < fiveMinutesAgo);
        
        // Check if this path or a parent path was listed recently
        for (Map.Entry<String, Long> entry : recentListRecursiveCalls.entrySet()) {
            String trackedPath = entry.getKey();
            Long timestamp = entry.getValue();
            
            // Check if within 5 minutes
            if (timestamp > fiveMinutesAgo) {
                // Check if tracked path matches or is a parent of the deletion path
                if (normalizedPath.equals(trackedPath) || normalizedPath.startsWith(trackedPath + "\\")) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    private static void createFile(String filePath, String content) throws Exception {
        // Use PowerShell to create file with safety checks
        String command = "powershell.exe -Command \"" +
                        // Check if parent directory exists
                        "$parentDir = Split-Path '" + filePath.replace("'", "''") + "'; " +
                        "if ($parentDir -and -not (Test-Path $parentDir)) { " +
                            "throw 'Parent directory does not exist: ' + $parentDir " +
                        "} " +
                        // Check if file already exists
                        "if (Test-Path '" + filePath.replace("'", "''") + "') { " +
                            "throw 'File already exists: " + filePath.replace("'", "''") + "' " +
                        "} " +
                        // Create the file
                        "Set-Content -Path '" + filePath.replace("'", "''") + "' -Value '" + 
                        content.replace("'", "''").replace("\n", "`n").replace("\r", "`r") + "'\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        StringBuilder error = new StringBuilder();
        
        try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
            String line;
            while ((line = errorReader.readLine()) != null) {
                error.append(line).append("\n");
            }
        }
        
        int exitCode = process.waitFor();
        
        if (exitCode != 0) {
            throw new Exception(error.length() > 0 ? error.toString().trim() : "File creation failed");
        }
    }
    
    private static void deleteFile(String filePath) throws Exception {
        // Use PowerShell to delete file with safety checks
        String command = "powershell.exe -Command \"" +
                        // Check if file exists
                        "if (-not (Test-Path '" + filePath.replace("'", "''") + "')) { " +
                            "throw 'File not found: " + filePath.replace("'", "''") + "' " +
                        "} " +
                        // Check if it's actually a file, not a directory
                        "if ((Get-Item '" + filePath.replace("'", "''") + "').PSIsContainer) { " +
                            "throw 'Path is a directory, not a file: " + filePath.replace("'", "''") + "' " +
                        "} " +
                        // Delete the file
                        "Remove-Item '" + filePath.replace("'", "''") + "' -Force\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        StringBuilder error = new StringBuilder();
        
        try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
            String line;
            while ((line = errorReader.readLine()) != null) {
                error.append(line).append("\n");
            }
        }
        
        int exitCode = process.waitFor();
        
        if (exitCode != 0) {
            throw new Exception(error.length() > 0 ? error.toString().trim() : "File deletion failed");
        }
    }
    
    private static java.util.List<String> listRecursive(String path) throws Exception {
        java.util.List<String> results = new java.util.ArrayList<>();
        
        // Use PowerShell to recursively list all files and directories
        String command = "powershell.exe -Command \"" +
                        "if (-not (Test-Path '" + path.replace("'", "''") + "')) { " +
                            "throw 'Path not found: " + path.replace("'", "''") + "' " +
                        "} " +
                        "Get-ChildItem -Path '" + path.replace("'", "''") + "' -Recurse | " +
                        "ForEach-Object { " +
                            "if ($_.PSIsContainer) { " +
                                "\\\"[DIR] $($_.FullName)\\\" " +
                            "} else { " +
                                "$size = if ($_.Length -lt 1024) { \\\"$($_.Length)B\\\" } " +
                                        "elseif ($_.Length -lt 1048576) { \\\"$([Math]::Round($_.Length/1024, 1))KB\\\" } " +
                                        "else { \\\"$([Math]::Round($_.Length/1048576, 1))MB\\\" }; " +
                                "\\\"[FILE] $($_.FullName) ($size)\\\" " +
                            "} " +
                        "} | Sort-Object\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    results.add(line);
                }
            }
        }
        
        process.waitFor();
        return results;
    }
    
    private static void createDirectory(String dirPath) throws Exception {
        // Use PowerShell to create directory with safety checks
        String command = "powershell.exe -Command \"" +
                        "if (Test-Path '" + dirPath.replace("'", "''") + "') { " +
                            "throw 'Path already exists: " + dirPath.replace("'", "''") + "' " +
                        "} " +
                        "New-Item -Path '" + dirPath.replace("'", "''") + "' -ItemType Directory -Force\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        StringBuilder error = new StringBuilder();
        
        try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
            String line;
            while ((line = errorReader.readLine()) != null) {
                error.append(line).append("\n");
            }
        }
        
        int exitCode = process.waitFor();
        
        if (exitCode != 0) {
            throw new Exception(error.length() > 0 ? error.toString().trim() : "Directory creation failed");
        }
    }
    
    private static void deleteDirectoryRecursive(String dirPath) throws Exception {
        // Use PowerShell to delete directory recursively with safety checks
        String command = "powershell.exe -Command \"" +
                        "if (-not (Test-Path '" + dirPath.replace("'", "''") + "')) { " +
                            "throw 'Directory not found: " + dirPath.replace("'", "''") + "' " +
                        "} " +
                        "if (-not (Get-Item '" + dirPath.replace("'", "''") + "').PSIsContainer) { " +
                            "throw 'Path is a file, not a directory: " + dirPath.replace("'", "''") + "' " +
                        "} " +
                        "Remove-Item '" + dirPath.replace("'", "''") + "' -Recurse -Force\"";
        
        Process process = Runtime.getRuntime().exec(command);
        
        StringBuilder error = new StringBuilder();
        
        try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
            String line;
            while ((line = errorReader.readLine()) != null) {
                error.append(line).append("\n");
            }
        }
        
        int exitCode = process.waitFor();
        
        if (exitCode != 0) {
            throw new Exception(error.length() > 0 ? error.toString().trim() : "Directory deletion failed");
        }
    }
    
    // Lock+Queue Clipboard System
    private static final List<Map<String, Object>> javaMessageQueue = new ArrayList<>();
    private static long lastClipboardOpTime = 0; // No default - measure first
    private static int pollMultiplier = 5; // Start with x5
    
    private static String getClipboardContent() throws Exception {
        if (clipboardInterface != null) {
            return clipboardInterface.getContent();
        }
        // Fallback to system clipboard for backward compatibility
        Transferable contents = clipboard.getContents(null);
        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
            return (String) contents.getTransferData(DataFlavor.stringFlavor);
        }
        return null;
    }
    
    private static void setClipboard(String text) throws Exception {
        String preview = text.length() > 100 ? text.substring(0, 100) + "..." : text;
        System.out.println("[CLIPBOARD-TRACE] Java writing to clipboard: " + preview);
        
        if (clipboardInterface != null) {
            clipboardInterface.setContent(text);
        } else {
            // Fallback to system clipboard for backward compatibility
            StringSelection selection = new StringSelection(text);
            clipboard.setContents(selection, null);
        }
    }
    
    // Queue a message to be sent to browser
    private static synchronized void queueMessageToBridge(String messageType, Map<String, Object> payload) {
        Map<String, Object> message = new HashMap<>();
        message.put("type", messageType);
        message.put("timestamp", System.currentTimeMillis());
        if (payload != null) {
            message.putAll(payload);
        }
        
        javaMessageQueue.add(message);
    }
    
    // Try to acquire clipboard lock and send our queue to bridge
    private static boolean sendQueueToBridge() {
        long startTime = System.nanoTime();
        boolean success = false;
        
        try {
            synchronized (javaMessageQueue) {
                // Don't send empty queues
                if (javaMessageQueue.isEmpty()) {
                    return true; // Nothing to send is technically a success
                }
                
                long timestamp = System.currentTimeMillis();
                String lockToken = "|||||JAVA LOCK|||||";
                // Step 1: Try to acquire lock
                setClipboard(lockToken);
                Thread.sleep(10); // Brief delay for write to complete
                
                // Step 2: Verify we own the lock
                String verification = getClipboardContent();
                if (verification != null && verification.equals(lockToken)) {
                    // Step 3: We won the lock, now write our actual message separately
                    StringBuilder queueJson = new StringBuilder("[");
                    for (int i = 0; i < javaMessageQueue.size(); i++) {
                        if (i > 0) queueJson.append(",");
                        queueJson.append(mapToJson(javaMessageQueue.get(i)));
                    }
                    queueJson.append("]");
                    
                    String messageToken = "|||||MESSAGE->BRIDGE|||||" + timestamp + "|||||" + queueJson.toString() + "|||||END|||||";
                    setClipboard(messageToken);
                    Thread.sleep(50); // Additional delay to ensure clipboard is fully propagated
                    
                    System.out.println("[FLOW] → Sent " + javaMessageQueue.size() + " messages to bridge");
                    javaMessageQueue.clear();
                    success = true;
                } else {
                }
            }
            
        } catch (Exception e) {
            // Suppress clipboard send errors - they're usually focus issues
        }
        
        // Update adaptive timing
        long duration = (System.nanoTime() - startTime) / 1_000_000; // Convert to ms
        lastClipboardOpTime = Math.max(1, duration);
        
        if (success) {
            pollMultiplier = 5; // Reset to x5 on success
        } else {
            pollMultiplier = Math.min(10, pollMultiplier + 1); // Increment up to x10
        }
        
        return success;
    }
    
    // Read messages from bridge (if clipboard has messages for us)
    private static List<Map<String, Object>> readMessagesFromBridge() {
        long startTime = System.nanoTime();
        List<Map<String, Object>> messages = new ArrayList<>();
        
        try {
            String clipboardContent = getClipboardContent();
            
            
            if (clipboardContent == null || clipboardContent.trim().isEmpty()) {
                return messages; // Empty clipboard is fine
            }
            
            
            // Check for message token directed at us (must be at start of clipboard)
            if (clipboardContent.startsWith("|||||MESSAGE->JAVA|||||")) {
                // This is a message for us from bridge
                if (clipboardContent.contains("|||||END|||||")) {
                    long timestamp = extractTimestampFromMessage(clipboardContent);
                    long age = System.currentTimeMillis() - timestamp;
                    
                    if (age > 1000) {
                        System.out.println("[CLIPBOARD] Found expired message (age: " + age + "ms), ignoring");
                        // Don't clear - all components should recognize expired timestamps
                        return messages;
                    }
                    
                    // Extract and parse message queue
                    messages = parseMessageQueue(clipboardContent);
                    System.out.println("[CLIPBOARD] Read " + messages.size() + " messages from bridge");
                    
                    // In the new 2-step protocol, we clear the message after reading it
                    // and optionally send our response
                    clearClipboard();
                    
                    // Only send if we have messages
                    synchronized (javaMessageQueue) {
                        if (javaMessageQueue.size() > 0) {
                            sendQueueToBridge();
                        }
                    }
                }
            }
            // Check for lock tokens
            else if (clipboardContent.startsWith("|||||JAVA LOCK|||||")) {
                // Our own lock token - we already have the lock!
                System.out.println("[CLIPBOARD] Found our own lock token - we have the lock");
                // If we have messages to send, send them now
                synchronized (javaMessageQueue) {
                    if (javaMessageQueue.size() > 0) {
                        sendQueueToBridge();
                    }
                }
                return messages;
            }
            else if (clipboardContent.startsWith("|||||BRIDGE LOCK|||||")) {
                // Bridge has the lock
                System.out.println("[CLIPBOARD-TRACE] Java sees bridge lock token");
                return messages;
            }
            // For any other content (no protocol tokens), just ignore it - don't clear
            else {
                // No protocol tokens means this isn't our protocol traffic
                // Could be bridge script, user copy/paste, etc. - leave it alone
                return messages;
            }
            
        } catch (Exception e) {
            // Suppress clipboard read errors - they're usually focus issues  
        }
        
        // Update adaptive timing  
        long duration = (System.nanoTime() - startTime) / 1_000_000;
        lastClipboardOpTime = Math.max(1, duration);
        
        return messages;
    }
    
    private static void clearClipboard() {
        try {
            System.out.println("[CLIPBOARD-TRACE] Java clearing clipboard");
            setClipboard("");
        } catch (Exception e) {
            System.out.println("[CLIPBOARD] Failed to clear: " + e.getMessage());
        }
    }
    
    private static long extractTimestampFromMessage(String content) {
        try {
            // Extract timestamp from MESSAGE token format: |||||MESSAGE->RECIPIENT|||||TIMESTAMP|||||
            String[] parts = content.split("\\|\\|\\|\\|\\|");
            if (parts.length >= 3) {
                return Long.parseLong(parts[2]);
            }
        } catch (NumberFormatException e) {
            // Invalid timestamp, treat as very old
        }
        return 0;
    }
    
    private static List<Map<String, Object>> parseMessageQueue(String content) {
        List<Map<String, Object>> messages = new ArrayList<>();
        try {
            // Extract JSON between timestamp and END in MESSAGE format: |||||MESSAGE->JAVA|||||TIMESTAMP|||||JSON|||||END|||||
            int start = content.indexOf("|||||MESSAGE->JAVA|||||");
            
            if (start >= 0) {
                int timestampStart = start + "|||||MESSAGE->JAVA|||||".length();
                int timestampEnd = content.indexOf("|||||", timestampStart);
                int jsonStart = timestampEnd + 5;
                int end = content.indexOf("|||||END|||||");
                
                if (timestampEnd > timestampStart && jsonStart < end && end > 0) {
                    String jsonContent = content.substring(jsonStart, end);
                    // Parse JSON array (simple implementation)  
                    messages = parseJsonArray(jsonContent);
                } else {
                    System.out.println("[CLIPBOARD] Invalid message format - failed to find proper delimiters");
                }
            } else {
                // Silently ignore non-protocol clipboard content (normal behavior)
            }
        } catch (Exception e) {
            System.out.println("[CLIPBOARD] Failed to parse message queue: " + e.getMessage());
        }
        return messages;
    }
    
    // Simple JSON parsing for our message format
    private static List<Map<String, Object>> parseJsonArray(String jsonArray) {
        List<Map<String, Object>> messages = new ArrayList<>();
        try {
            List<Object> parsed = SimpleJsonParser.parseArray(jsonArray);
            for (Object obj : parsed) {
                if (obj instanceof Map) {
                    messages.add((Map<String, Object>) obj);
                }
            }
        } catch (Exception e) {
            System.out.println("[CLIPBOARD] JSON array parse error: " + e.getMessage());
        }
        return messages;
    }
    
    private static Map<String, Object> parseJsonObject(String jsonObject) {
        return SimpleJsonParser.parseObject(jsonObject);
    }
    
    private static String escapeJsonString(String str) {
        if (str == null) return "";
        
        StringBuilder escaped = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            switch (ch) {
                case '"':
                    escaped.append("\\\"");
                    break;
                case '\\':
                    escaped.append("\\\\");
                    break;
                case '\b':
                    escaped.append("\\b");
                    break;
                case '\f':
                    escaped.append("\\f");
                    break;
                case '\n':
                    escaped.append("\\n");
                    break;
                case '\r':
                    escaped.append("\\r");
                    break;
                case '\t':
                    escaped.append("\\t");
                    break;
                default:
                    if (ch < 0x20 || ch > 0x7e) {
                        // Escape non-printable and non-ASCII characters
                        escaped.append(String.format("\\u%04x", (int) ch));
                    } else {
                        escaped.append(ch);
                    }
                    break;
            }
        }
        return escaped.toString();
    }
    
    private static String mapToJson(Map<String, Object> map) {
        StringBuilder json = new StringBuilder("{");
        boolean first = true;
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            if (!first) json.append(",");
            json.append("\"").append(entry.getKey()).append("\":");
            Object value = entry.getValue();
            if (value instanceof String) {
                String strValue = value.toString();
                // Special handling for the "request" field that contains JSON
                if (entry.getKey().equals("request") && strValue.trim().startsWith("{") && strValue.trim().endsWith("}")) {
                    // This is already JSON, include it as-is without quotes
                    json.append(strValue);
                } else {
                    // Normal string escaping - escape all special characters
                    json.append("\"").append(escapeJsonString(strValue)).append("\"");
                }
            } else if (value instanceof Number || value instanceof Boolean) {
                json.append(value.toString());
            } else if (value instanceof Map) {
                // Recursively handle nested maps
                json.append(mapToJson((Map<String, Object>) value));
            } else {
                json.append("\"").append(escapeJsonString(value.toString())).append("\"");
            }
            first = false;
        }
        json.append("}");
        return json.toString();
    }
    
    // Adaptive polling with backoff
    private static void adaptiveWait() {
        try {
            // Only wait if we have measured an operation time
            if (lastClipboardOpTime > 0) {
                long waitTime = lastClipboardOpTime * pollMultiplier;
                Thread.sleep(waitTime);
            }
            // If no measurement yet, don't wait - start polling immediately
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private static synchronized void startContinuousClicking(String requestId) {
        // Cancel any existing clicking task first (single-threaded approach)
        if (currentClickingTask != null && !currentClickingTask.isDone()) {
            System.out.println("[SINGLE-THREAD] Cancelling previous clicking for: " + currentClickingRequestId);
            currentClickingTask.cancel(true);
            // Wait a bit for cancellation to complete
            try {
                currentClickingTask.get(100, TimeUnit.MILLISECONDS);
            } catch (Exception e) {
                // Expected - task was cancelled
            }
        }
        
        System.out.println("[FLOW] Auto-clicking bridge for request: " + requestId);
        currentClickingRequestId = requestId;
        
        // Save current mouse position
        Point originalPosition = robotInterface.getMousePosition();
        
        currentClickingTask = executor.submit(() -> {
            long startTime = System.currentTimeMillis();
            long lastActivityTime = startTime;
            long timeoutMs = 5 * 60 * 1000; // 5 minutes total timeout
            long inactivityTimeoutMs = 3 * 1000; // 3 seconds of no expected activity
            int clickCount = 0;
            
            try {
                while (!Thread.currentThread().isInterrupted() && 
                       (System.currentTimeMillis() - startTime) < timeoutMs) {
                    
                    // Move to calibrated position
                    robotInterface.mouseMove(clickPosition.x, clickPosition.y);
                    Thread.sleep(50);
                    
                    // Click
                    robotInterface.mousePress(InputEvent.BUTTON1_DOWN_MASK);
                    robotInterface.delay(50);
                    robotInterface.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
                    clickCount++;
                    
                    // Wait for click confirmation from browser (60 second timeout)
                    System.out.println("[CLICK-DEBUG] Waiting for click confirmation (attempt " + clickCount + ")");
                    boolean confirmed = waitForClickConfirmation(60000);
                    System.out.println("[CLICK-DEBUG] Click confirmation result: " + confirmed);
                    if (!confirmed) {
                        if (clickCount == 1) {
                            System.out.println("[ERROR] Bridge not responding - check browser focus");
                            System.out.println("[CLICK-DEBUG] Clipboard monitoring active: " + clipboardMonitoringActive);
                        }
                        
                        // Send click failed message to frontend
                        sendClickFailedMessage(requestId);
                        break; // Stop clicking immediately
                    }
                    
                    lastActivityTime = System.currentTimeMillis();
                    
                    // Only log every 10th click to reduce spam
                    if (clickCount % 10 == 1) {
                        System.out.println("Bridge clicking active for request: " + requestId + " (click #" + clickCount + ")");
                    }
                    
                    // Move back to original position
                    robotInterface.mouseMove(originalPosition.x, originalPosition.y);
                    
                    // Check for inactivity timeout (if too long without expected response)
                    if ((System.currentTimeMillis() - lastActivityTime) > inactivityTimeoutMs) {
                        System.out.println("⚠ WARNING: No expected activity detected for " + (inactivityTimeoutMs/1000) + " seconds.");
                        System.out.println("⚠ This might indicate the bridge connection is not working properly.");
                        // Reset activity timer and continue (don't break immediately)
                        lastActivityTime = System.currentTimeMillis();
                    }
                    
                    // Wait 500ms before next click
                    Thread.sleep(500);
                }
                
                if (!Thread.currentThread().isInterrupted()) {
                    if (!calibrated) {
                        System.out.println("Clicking stopped for request: " + requestId + " - recalibration needed (total clicks: " + clickCount + ")");
                    } else {
                        System.out.println("Clicking timeout reached for request: " + requestId + " (5 minutes, total clicks: " + clickCount + ")");
                    }
                }
                
            } catch (InterruptedException e) {
                System.out.println("Clicking stopped for request: " + requestId + " (total clicks: " + clickCount + ")");
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                System.err.println("Error in continuous clicking: " + e.getMessage());
            } finally {
                // Always restore original mouse position
                try {
                    robotInterface.mouseMove(originalPosition.x, originalPosition.y);
                    System.out.println("Mouse position restored to: " + originalPosition.x + ", " + originalPosition.y);
                } catch (Exception e) {
                    System.err.println("Could not restore mouse position: " + e.getMessage());
                }
            }
        });
        
        // Single-threaded: currentClickingTask is already set above
    }
    
    // Wait for click confirmation from browser
    // Global flag to track when click confirmation is received
    private static volatile boolean clickConfirmationReceived = false;
    private static volatile long lastClickConfirmationTime = 0;
    
    private static boolean waitForClickConfirmation(long timeoutMs) {
        long startTime = System.currentTimeMillis();
        clickConfirmationReceived = false; // Reset flag
        
        while (System.currentTimeMillis() - startTime < timeoutMs) {
            // Check for thread interruption first
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("[CLICK-DEBUG] Thread is interrupted - stopping click confirmation wait");
                System.out.println("[CLICK-DEBUG] Clipboard monitoring active: " + clipboardMonitoringActive);
                return false;
            }
            
            // Check if confirmation was received via message processing
            if (clickConfirmationReceived && (System.currentTimeMillis() - lastClickConfirmationTime) < 1000) {
                System.out.println("+ Click confirmation received via message queue");
                return true;
            }
            
            try {
                Thread.sleep(100); // Check every 100ms
            } catch (InterruptedException e) {
                // Thread was interrupted during sleep - respect the interruption
                System.out.println("[CLICK-DEBUG] Click confirmation wait interrupted during sleep");
                System.out.println("[CLICK-DEBUG] Clipboard monitoring active: " + clipboardMonitoringActive);
                Thread.currentThread().interrupt(); // Restore interrupted status
                return false;
            }
        }
        
        return false; // Timeout - no confirmation received
    }
    
    // Send click failed message to frontend with retry option
    private static void sendClickFailedMessage(String requestId) {
        try {
            // Check if request is still pending (not already completed)
            PendingRequest pendingRequest = pendingRequests.get(requestId);
            if (pendingRequest != null) {
                // Double-check the request hasn't been completed while we were waiting
                // This prevents race conditions with handleFinalResponse
                synchronized (pendingRequests) {
                    pendingRequest = pendingRequests.get(requestId);
                    if (pendingRequest == null) {
                        // Request was already completed, don't send click failed
                        return;
                    }
                }
                
                String failedResponse = "{\"type\":\"CLICK_FAILED\",\"id\":\"" + requestId + "\",\"timestamp\":" + System.currentTimeMillis() + ",\"payload\":{\"message\":\"Auto-click failed - browser not responding\",\"showRetry\":true}}";
                
                sendSSEUpdate(pendingRequest.exchange, "data: " + failedResponse + "\n\n");
                // Don't send [DONE] for click failures - keep the stream open
                // so the user can retry or manually click
                System.out.println("[CLICK-FAILED] Keeping SSE stream open for retry attempts");
                
                // Remove from pending requests
                pendingRequests.remove(requestId);
            }
        } catch (Exception e) {
            System.err.println("Error sending click failed message: " + e.getMessage());
        }
    }
    
    private static synchronized void stopContinuousClicking(String requestId) {
        // Single-threaded: only stop if it's the current task
        if (currentClickingTask != null && requestId != null && requestId.equals(currentClickingRequestId)) {
            currentClickingTask.cancel(true);
            System.out.println("Stopped continuous clicking for request: " + requestId);
            
            // Wait a bit for the task to actually stop
            try {
                currentClickingTask.get(100, TimeUnit.MILLISECONDS);
            } catch (Exception e) {
                // Task was cancelled or timed out - that's OK
            }
            
            // Clear current task references
            currentClickingTask = null;
            currentClickingRequestId = null;
        }
    }
    
    private static String generateUUID() {
        return UUID.randomUUID().toString();
    }
    
    private static Map<String, Object> parseJsonToMap(String jsonString) {
        Map<String, Object> result = new HashMap<>();
        try {
            // Simple JSON parser to convert JSON string to Map
            jsonString = jsonString.trim();
            if (jsonString.startsWith("{") && jsonString.endsWith("}")) {
                jsonString = jsonString.substring(1, jsonString.length() - 1);
                
                boolean inString = false;
                boolean escaped = false;
                int braceCount = 0;
                int bracketCount = 0;
                StringBuilder currentPair = new StringBuilder();
                
                for (int i = 0; i < jsonString.length(); i++) {
                    char c = jsonString.charAt(i);
                    
                    if (escaped) {
                        escaped = false;
                        currentPair.append(c);
                        continue;
                    }
                    
                    if (c == '\\') {
                        escaped = true;
                        currentPair.append(c);
                        continue;
                    }
                    
                    if (c == '"') {
                        inString = !inString;
                        currentPair.append(c);
                        continue;
                    }
                    
                    if (!inString) {
                        if (c == '{') braceCount++;
                        else if (c == '}') braceCount--;
                        else if (c == '[') bracketCount++;
                        else if (c == ']') bracketCount--;
                        else if (c == ',' && braceCount == 0 && bracketCount == 0) {
                            parseAndAddKeyValue(currentPair.toString().trim(), result);
                            currentPair = new StringBuilder();
                            continue;
                        }
                    }
                    
                    currentPair.append(c);
                }
                
                if (currentPair.length() > 0) {
                    parseAndAddKeyValue(currentPair.toString().trim(), result);
                }
            }
        } catch (Exception e) {
            System.out.println("[JSON] Parse error: " + e.getMessage());
        }
        return result;
    }
    
    private static void parseAndAddKeyValue(String pair, Map<String, Object> result) {
        try {
            int colonIndex = pair.indexOf(':');
            if (colonIndex > 0) {
                String key = pair.substring(0, colonIndex).trim();
                String value = pair.substring(colonIndex + 1).trim();
                
                // Remove quotes from key
                if (key.startsWith("\"") && key.endsWith("\"")) {
                    key = key.substring(1, key.length() - 1);
                }
                
                // Parse value
                Object parsedValue = parseJsonValue(value);
                result.put(key, parsedValue);
            }
        } catch (Exception e) {
            System.out.println("[JSON] Key-value parse error: " + e.getMessage());
        }
    }
    
    private static Object parseJsonValue(String value) {
        value = value.trim();
        if (value.startsWith("\"") && value.endsWith("\"")) {
            // String value
            return value.substring(1, value.length() - 1);
        } else if (value.equals("true")) {
            return true;
        } else if (value.equals("false")) {
            return false;
        } else if (value.equals("null")) {
            return null;
        } else if (value.startsWith("[") && value.endsWith("]")) {
            // Array - return as string for now (could be parsed further if needed)
            return value;
        } else if (value.startsWith("{") && value.endsWith("}")) {
            // Object - return as string for now (could be parsed further if needed)
            return value;
        } else {
            // Try to parse as number
            try {
                if (value.contains(".")) {
                    return Double.parseDouble(value);
                } else {
                    return Long.parseLong(value);
                }
            } catch (NumberFormatException e) {
                // Return as string if not a number
                return value;
            }
        }
    }
}
-~{END}~-

-~{File: src/java-agent/test-json-parser.bat}~-
@echo off
echo Compiling JSON parser...
javac SimpleJsonParser.java
if errorlevel 1 (
    echo Compilation failed!
    exit /b 1
)

echo Compiling JSON parser tests...
javac SimpleJsonParserTest.java
if errorlevel 1 (
    echo Test compilation failed!
    exit /b 1
)

echo.
echo Running tests...
echo ========================================
java SimpleJsonParserTest
-~{END}~-

-~{File: src/java-agent/AUTO-CLICK-FIX.md}~-
# Auto-Click Fix for Second Message

## Problem
The auto-click feature was consistently failing on the second message because:
1. Clipboard monitoring was stopped after the first message completed
2. When the second message arrived, there was no active clipboard monitor to receive CLICK_CONFIRMED messages
3. The click confirmation wait would timeout, triggering "Bridge not responding" error

## Root Cause
In `handleFinalResponse()`, the code was stopping clipboard monitoring when there were no pending requests:
```java
if (pendingRequests.isEmpty()) {
    stopClipboardMonitoring();
}
```

## Solution
1. **Keep clipboard monitoring active**: Removed the code that stops clipboard monitoring after each message completes. The monitoring now stays active for the entire session.

2. **Ensure monitoring is active**: Added a check in `ChatHandler.handle()` to restart clipboard monitoring if it's not active when a new request arrives.

3. **Added debug logging**: Added `[CLICK-DEBUG]` and `[CLIPBOARD]` logging to help diagnose future issues.

## Changes Made
1. In `handleFinalResponse()`: Changed to keep clipboard monitoring active
2. In `ChatHandler.handle()`: Added check to restart monitoring if needed  
3. In `continuouslyClickBridge()`: Added debug logging for click confirmation
4. In `waitForClickConfirmation()`: Added debug logging for interruption tracking

## Expected Behavior
- Clipboard monitoring remains active throughout the session
- Auto-click should work for all messages, not just the first one
- Users won't need to reload the page between messages
-~{END}~-

-~{File: src/java-agent/SimpleJsonParser.java}~-
import java.util.*;

/**
 * A simple JSON parser that can parse JSON strings into Java objects.
 * Supports: objects, arrays, strings, numbers, booleans, and null.
 */
public class SimpleJsonParser {
    
    /**
     * Parse a JSON string into a Java object.
     * @param json The JSON string to parse
     * @return The parsed object (Map, List, String, Number, Boolean, or null)
     */
    public static Object parse(String json) {
        if (json == null || json.trim().isEmpty()) {
            return null;
        }
        
        JsonTokenizer tokenizer = new JsonTokenizer(json.trim());
        return parseValue(tokenizer);
    }
    
    /**
     * Parse a JSON object string into a Map.
     * @param json The JSON object string to parse
     * @return The parsed Map, or empty Map if parsing fails
     */
    public static Map<String, Object> parseObject(String json) {
        Object result = parse(json);
        if (result instanceof Map) {
            return (Map<String, Object>) result;
        }
        return new HashMap<>();
    }
    
    /**
     * Parse a JSON array string into a List.
     * @param json The JSON array string to parse
     * @return The parsed List, or empty List if parsing fails
     */
    public static List<Object> parseArray(String json) {
        Object result = parse(json);
        if (result instanceof List) {
            return (List<Object>) result;
        }
        return new ArrayList<>();
    }
    
    private static Object parseValue(JsonTokenizer tokenizer) {
        tokenizer.skipWhitespace();
        
        if (!tokenizer.hasMore()) {
            return null;
        }
        
        char ch = tokenizer.peek();
        
        if (ch == '{') {
            return parseObjectValue(tokenizer);
        } else if (ch == '[') {
            return parseArrayValue(tokenizer);
        } else if (ch == '"') {
            return parseStringValue(tokenizer);
        } else if (ch == 't' || ch == 'f') {
            return parseBooleanValue(tokenizer);
        } else if (ch == 'n') {
            return parseNullValue(tokenizer);
        } else if (ch == '-' || (ch >= '0' && ch <= '9')) {
            return parseNumberValue(tokenizer);
        } else {
            throw new JsonParseException("Unexpected character: " + ch + " at position " + tokenizer.getPosition());
        }
    }
    
    private static Map<String, Object> parseObjectValue(JsonTokenizer tokenizer) {
        Map<String, Object> object = new LinkedHashMap<>();
        
        tokenizer.consume('{');
        tokenizer.skipWhitespace();
        
        if (tokenizer.peek() == '}') {
            tokenizer.consume('}');
            return object;
        }
        
        while (true) {
            tokenizer.skipWhitespace();
            
            // Parse key
            if (tokenizer.peek() != '"') {
                throw new JsonParseException("Expected string key at position " + tokenizer.getPosition());
            }
            String key = parseStringValue(tokenizer);
            
            // Parse colon
            tokenizer.skipWhitespace();
            if (tokenizer.peek() != ':') {
                throw new JsonParseException("Expected ':' after key at position " + tokenizer.getPosition());
            }
            tokenizer.consume(':');
            
            // Parse value
            Object value = parseValue(tokenizer);
            object.put(key, value);
            
            // Check for more pairs
            tokenizer.skipWhitespace();
            char ch = tokenizer.peek();
            if (ch == '}') {
                tokenizer.consume('}');
                break;
            } else if (ch == ',') {
                tokenizer.consume(',');
            } else {
                throw new JsonParseException("Expected ',' or '}' at position " + tokenizer.getPosition());
            }
        }
        
        return object;
    }
    
    private static List<Object> parseArrayValue(JsonTokenizer tokenizer) {
        List<Object> array = new ArrayList<>();
        
        tokenizer.consume('[');
        tokenizer.skipWhitespace();
        
        if (tokenizer.peek() == ']') {
            tokenizer.consume(']');
            return array;
        }
        
        while (true) {
            Object value = parseValue(tokenizer);
            array.add(value);
            
            tokenizer.skipWhitespace();
            char ch = tokenizer.peek();
            if (ch == ']') {
                tokenizer.consume(']');
                break;
            } else if (ch == ',') {
                tokenizer.consume(',');
            } else {
                throw new JsonParseException("Expected ',' or ']' at position " + tokenizer.getPosition());
            }
        }
        
        return array;
    }
    
    private static String parseStringValue(JsonTokenizer tokenizer) {
        tokenizer.consume('"');
        StringBuilder sb = new StringBuilder();
        
        while (tokenizer.hasMore()) {
            char ch = tokenizer.next();
            
            if (ch == '"') {
                return sb.toString();
            } else if (ch == '\\') {
                if (!tokenizer.hasMore()) {
                    throw new JsonParseException("Unterminated string escape at position " + tokenizer.getPosition());
                }
                
                char escaped = tokenizer.next();
                switch (escaped) {
                    case '"': sb.append('"'); break;
                    case '\\': sb.append('\\'); break;
                    case '/': sb.append('/'); break;
                    case 'b': sb.append('\b'); break;
                    case 'f': sb.append('\f'); break;
                    case 'n': sb.append('\n'); break;
                    case 'r': sb.append('\r'); break;
                    case 't': sb.append('\t'); break;
                    case 'u':
                        // Unicode escape
                        if (tokenizer.remaining() < 4) {
                            throw new JsonParseException("Invalid unicode escape at position " + tokenizer.getPosition());
                        }
                        String hex = tokenizer.next(4);
                        try {
                            int codePoint = Integer.parseInt(hex, 16);
                            sb.append((char) codePoint);
                        } catch (NumberFormatException e) {
                            throw new JsonParseException("Invalid unicode escape: \\u" + hex);
                        }
                        break;
                    default:
                        throw new JsonParseException("Invalid escape sequence: \\" + escaped);
                }
            } else {
                sb.append(ch);
            }
        }
        
        throw new JsonParseException("Unterminated string at position " + tokenizer.getPosition());
    }
    
    private static Boolean parseBooleanValue(JsonTokenizer tokenizer) {
        if (tokenizer.peek() == 't') {
            if (tokenizer.consume("true")) {
                return true;
            }
        } else if (tokenizer.peek() == 'f') {
            if (tokenizer.consume("false")) {
                return false;
            }
        }
        throw new JsonParseException("Invalid boolean value at position " + tokenizer.getPosition());
    }
    
    private static Object parseNullValue(JsonTokenizer tokenizer) {
        if (tokenizer.consume("null")) {
            return null;
        }
        throw new JsonParseException("Invalid null value at position " + tokenizer.getPosition());
    }
    
    private static Number parseNumberValue(JsonTokenizer tokenizer) {
        StringBuilder sb = new StringBuilder();
        
        // Optional minus
        if (tokenizer.peek() == '-') {
            sb.append(tokenizer.next());
        }
        
        // Integer part
        if (tokenizer.peek() == '0') {
            sb.append(tokenizer.next());
        } else if (tokenizer.peek() >= '1' && tokenizer.peek() <= '9') {
            while (tokenizer.hasMore() && tokenizer.peek() >= '0' && tokenizer.peek() <= '9') {
                sb.append(tokenizer.next());
            }
        } else {
            throw new JsonParseException("Invalid number at position " + tokenizer.getPosition());
        }
        
        boolean isDouble = false;
        
        // Optional decimal part
        if (tokenizer.hasMore() && tokenizer.peek() == '.') {
            isDouble = true;
            sb.append(tokenizer.next());
            
            if (!tokenizer.hasMore() || tokenizer.peek() < '0' || tokenizer.peek() > '9') {
                throw new JsonParseException("Invalid number: expected digits after decimal point");
            }
            
            while (tokenizer.hasMore() && tokenizer.peek() >= '0' && tokenizer.peek() <= '9') {
                sb.append(tokenizer.next());
            }
        }
        
        // Optional exponent part
        if (tokenizer.hasMore() && (tokenizer.peek() == 'e' || tokenizer.peek() == 'E')) {
            isDouble = true;
            sb.append(tokenizer.next());
            
            if (tokenizer.hasMore() && (tokenizer.peek() == '+' || tokenizer.peek() == '-')) {
                sb.append(tokenizer.next());
            }
            
            if (!tokenizer.hasMore() || tokenizer.peek() < '0' || tokenizer.peek() > '9') {
                throw new JsonParseException("Invalid number: expected digits in exponent");
            }
            
            while (tokenizer.hasMore() && tokenizer.peek() >= '0' && tokenizer.peek() <= '9') {
                sb.append(tokenizer.next());
            }
        }
        
        String numStr = sb.toString();
        try {
            if (isDouble) {
                return Double.parseDouble(numStr);
            } else {
                long value = Long.parseLong(numStr);
                if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {
                    return (int) value;
                }
                return value;
            }
        } catch (NumberFormatException e) {
            throw new JsonParseException("Invalid number: " + numStr);
        }
    }
    
    /**
     * Simple tokenizer for JSON parsing
     */
    private static class JsonTokenizer {
        private final String input;
        private int position;
        
        JsonTokenizer(String input) {
            this.input = input;
            this.position = 0;
        }
        
        boolean hasMore() {
            return position < input.length();
        }
        
        int remaining() {
            return input.length() - position;
        }
        
        char peek() {
            if (!hasMore()) {
                throw new JsonParseException("Unexpected end of input");
            }
            return input.charAt(position);
        }
        
        char next() {
            if (!hasMore()) {
                throw new JsonParseException("Unexpected end of input");
            }
            return input.charAt(position++);
        }
        
        String next(int count) {
            if (remaining() < count) {
                throw new JsonParseException("Unexpected end of input");
            }
            String result = input.substring(position, position + count);
            position += count;
            return result;
        }
        
        void consume(char expected) {
            if (!hasMore() || input.charAt(position) != expected) {
                throw new JsonParseException("Expected '" + expected + "' at position " + position);
            }
            position++;
        }
        
        boolean consume(String expected) {
            if (remaining() >= expected.length() && 
                input.substring(position, position + expected.length()).equals(expected)) {
                position += expected.length();
                return true;
            }
            return false;
        }
        
        void skipWhitespace() {
            while (hasMore() && Character.isWhitespace(input.charAt(position))) {
                position++;
            }
        }
        
        int getPosition() {
            return position;
        }
    }
    
    /**
     * Exception thrown when JSON parsing fails
     */
    public static class JsonParseException extends RuntimeException {
        public JsonParseException(String message) {
            super(message);
        }
    }
}
-~{END}~-

-~{File: src/java-agent/TOOL-CLICK-FIX.md}~-
# Tool Result Auto-Click Fix

## Problem
When the AI used tools (like `list_files`), the system would get stuck in a loading state because:
1. The AI response containing `<execute>` was processed correctly
2. The tool executed and returned results
3. The tool results were sent to the bridge as a new `CCC_REQUEST`
4. But auto-click was NOT started for tool results
5. The bridge was waiting for a click that never came
6. The UI stayed in "Loading..." state indefinitely

## Root Cause
In `ToolResultHandler`, the code assumed tool results were "internal communication" that didn't need clicking:
```java
// Tool results don't need continuous clicking - they're internal communication
// that happens after the main response has already been processed
System.out.println("Tool result received - no clicking needed for internal communication");
```

This was incorrect - tool results are sent as `CCC_REQUEST` messages that need to be clicked just like user messages.

## Solution
Changed the tool result handler to start auto-clicking:
```java
// Tool results need clicking too - start auto-click
System.out.println("[FLOW] Tool result queued, starting auto-click for request: " + requestId);

// Start continuous clicking in background for tool results too
startContinuousClicking(requestId);
```

## Expected Behavior
- When AI uses tools, the tool results will be automatically clicked
- The AI will receive the tool results and provide a follow-up response
- No more stuck "Loading..." states after tool execution

## Files Changed
- `/home/claude-dev/coding-agent/src/java-agent/ChatServerAgent.java` - Modified `ToolResultHandler` to start auto-clicking for tool results
-~{END}~-

-~{File: src/java-agent/test-json-parser.sh}~-
#!/bin/bash

echo "Compiling JSON parser..."
javac SimpleJsonParser.java
if [ $? -ne 0 ]; then
    echo "Compilation failed!"
    exit 1
fi

echo "Compiling JSON parser tests..."
javac SimpleJsonParserTest.java
if [ $? -ne 0 ]; then
    echo "Test compilation failed!"
    exit 1
fi

echo
echo "Running tests..."
echo "========================================"
java SimpleJsonParserTest
-~{END}~-

-~{File: src/java-agent/RobotInterface.java}~-
import java.awt.Point;

/**
 * Interface for robot operations to enable dependency injection and testing
 */
public interface RobotInterface {
    /**
     * Move the mouse to the specified coordinates
     */
    void mouseMove(int x, int y);
    
    /**
     * Press a mouse button
     */
    void mousePress(int buttons);
    
    /**
     * Release a mouse button
     */
    void mouseRelease(int buttons);
    
    /**
     * Pause execution for the specified number of milliseconds
     */
    void delay(int ms);
    
    /**
     * Get the current mouse position (for calibration purposes)
     */
    Point getMousePosition();
}
-~{END}~-

-~{File: src/java-agent/ChatServerTestDriver.java}~-
import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;

/**
 * Test driver for ChatServerAgent that exposes clipboard communication methods
 * for testing with injected clipboard interface
 */
public class ChatServerTestDriver {
    
    public static void main(String[] args) throws Exception {
        if (args.length == 0) {
            System.err.println("Usage: java ChatServerTestDriver <test-mode>");
            System.err.println("test-mode: stdin (for Node.js communication)");
            System.exit(1);
        }
        
        String testMode = args[0];
        
        if ("stdin".equals(testMode)) {
            // Initialize with test clipboard and mock robot that communicate via stdin/stdout
            TestClipboard testClipboard = new TestClipboard();
            MockRobot mockRobot = new MockRobot();
            ChatServerAgent.initializeWithInterfaces(testClipboard, mockRobot);
            
            System.err.println("ChatServer initialized with test clipboard and mock robot");
            System.err.flush();
            
            // Now we can call real ChatServerAgent methods for testing
            runInteractiveTestMode(mockRobot);
        } else {
            System.err.println("Unknown test mode: " + testMode);
            System.exit(1);
        }
    }
    
    private static void runInteractiveTestMode(MockRobot mockRobot) throws Exception {
        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));
        java.io.PrintWriter writer = new java.io.PrintWriter(System.out, true);
        
        writer.println("READY");
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(":", 2);
            String command = parts[0];
            String payload = parts.length > 1 ? parts[1] : "";
            
            try {
                switch (command) {
                    case "QUIT":
                        return;
                        
                    case "SEND_QUEUE_TO_BRIDGE":
                        // Call real ChatServerAgent method
                        boolean result = callSendQueueToBridge();
                        writer.println("RESULT:" + result);
                        break;
                        
                    case "READ_MESSAGES_FROM_BRIDGE":
                        // Call real ChatServerAgent method  
                        List<Map<String, Object>> messages = callReadMessagesFromBridge();
                        writer.println("MESSAGES:" + messages.size());
                        for (Map<String, Object> msg : messages) {
                            String json = mapToJson(msg);
                            writer.println("MSG:" + json);
                        }
                        break;
                        
                    case "QUEUE_MESSAGE":
                        // Parse the message and queue it
                        String[] msgParts = payload.split("\\|", 2);
                        if (msgParts.length == 2) {
                            callQueueMessageToBridge(msgParts[0], parseJsonToMap(msgParts[1]));
                            writer.println("QUEUED");
                        } else {
                            writer.println("ERROR:Invalid message format");
                        }
                        break;
                        
                    case "GET_ROBOT_ACTIONS":
                        // Get robot action history for verification
                        writer.println("ROBOT_ACTIONS:" + mockRobot.getActions().size());
                        for (MockRobot.RobotAction action : mockRobot.getActions()) {
                            writer.println("ACTION:" + action.toString());
                        }
                        break;
                        
                    case "CLEAR_ROBOT_ACTIONS":
                        // Clear robot action history
                        mockRobot.clearActions();
                        writer.println("ROBOT_CLEARED");
                        break;
                        
                    case "SET_MOUSE_POSITION":
                        // Set mock mouse position for calibration testing
                        String[] coords = payload.split(",");
                        if (coords.length == 2) {
                            int x = Integer.parseInt(coords[0]);
                            int y = Integer.parseInt(coords[1]);
                            mockRobot.setMousePosition(x, y);
                            writer.println("MOUSE_POSITION_SET:" + x + "," + y);
                        } else {
                            writer.println("ERROR:Invalid coordinates format");
                        }
                        break;
                        
                    case "CALIBRATE":
                        // Trigger calibration with current mock mouse position
                        callHandleCalibration();
                        writer.println("CALIBRATED");
                        break;
                        
                    case "START_CLICKING":
                        // Start continuous clicking
                        String requestId = payload.isEmpty() ? "test-click-123" : payload;
                        callStartContinuousClicking(requestId);
                        writer.println("CLICKING_STARTED:" + requestId);
                        break;
                        
                    case "STOP_CLICKING":
                        // Stop continuous clicking
                        String stopRequestId = payload.isEmpty() ? "test-click-123" : payload;
                        callStopContinuousClicking(stopRequestId);
                        writer.println("CLICKING_STOPPED:" + stopRequestId);
                        break;
                        
                    default:
                        writer.println("ERROR:Unknown command: " + command);
                }
            } catch (Exception e) {
                writer.println("ERROR:" + e.getMessage());
            }
        }
    }
    
    // Use reflection to call private methods from ChatServerAgent
    private static boolean callSendQueueToBridge() throws Exception {
        Method method = ChatServerAgent.class.getDeclaredMethod("sendQueueToBridge");
        method.setAccessible(true);
        return (Boolean) method.invoke(null);
    }
    
    private static List<Map<String, Object>> callReadMessagesFromBridge() throws Exception {
        Method method = ChatServerAgent.class.getDeclaredMethod("readMessagesFromBridge");
        method.setAccessible(true);
        return (List<Map<String, Object>>) method.invoke(null);
    }
    
    private static void callQueueMessageToBridge(String messageType, Map<String, Object> payload) throws Exception {
        Method method = ChatServerAgent.class.getDeclaredMethod("queueMessageToBridge", String.class, Map.class);
        method.setAccessible(true);
        method.invoke(null, messageType, payload);
    }
    
    private static void callHandleCalibration() throws Exception {
        // Create a calibration message
        Map<String, Object> calibrationMessage = new java.util.HashMap<>();
        calibrationMessage.put("type", "CALIBRATE");
        
        Method method = ChatServerAgent.class.getDeclaredMethod("handleCalibration", Map.class);
        method.setAccessible(true);
        method.invoke(null, calibrationMessage);
    }
    
    private static void callStartContinuousClicking(String requestId) throws Exception {
        Method method = ChatServerAgent.class.getDeclaredMethod("startContinuousClicking", String.class);
        method.setAccessible(true);
        method.invoke(null, requestId);
    }
    
    private static void callStopContinuousClicking(String requestId) throws Exception {
        Method method = ChatServerAgent.class.getDeclaredMethod("stopContinuousClicking", String.class);
        method.setAccessible(true);
        method.invoke(null, requestId);
    }
    
    // Simple JSON parsing (for testing purposes)
    private static Map<String, Object> parseJsonToMap(String json) {
        // Simplified JSON parsing - in real implementation would use proper parser
        Map<String, Object> map = new java.util.HashMap<>();
        json = json.trim();
        if (json.startsWith("{") && json.endsWith("}")) {
            json = json.substring(1, json.length() - 1);
            String[] pairs = json.split(",");
            for (String pair : pairs) {
                String[] kv = pair.split(":", 2);
                if (kv.length == 2) {
                    String key = kv[0].trim().replaceAll("\"", "");
                    String value = kv[1].trim().replaceAll("\"", "");
                    map.put(key, value);
                }
            }
        }
        return map;
    }
    
    private static String mapToJson(Map<String, Object> map) {
        StringBuilder json = new StringBuilder("{");
        boolean first = true;
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            if (!first) json.append(",");
            json.append("\"").append(entry.getKey()).append("\":");
            
            // Handle different value types properly
            Object value = entry.getValue();
            if (value instanceof Number) {
                json.append(value); // Numbers don't need quotes
            } else {
                json.append("\"").append(value).append("\""); // Strings need quotes
            }
            
            first = false;
        }
        json.append("}");
        return json.toString();
    }
}
-~{END}~-

-~{File: src/java-agent/SimpleJsonParserTest.java}~-
import java.util.*;

/**
 * Unit tests for SimpleJsonParser
 */
public class SimpleJsonParserTest {
    
    private static int testsPassed = 0;
    private static int testsFailed = 0;
    
    public static void main(String[] args) {
        System.out.println("Running SimpleJsonParser tests...\n");
        
        // Basic value tests
        testNullParsing();
        testBooleanParsing();
        testNumberParsing();
        testStringParsing();
        
        // Object tests
        testEmptyObject();
        testSimpleObject();
        testNestedObject();
        testObjectWithArrays();
        
        // Array tests
        testEmptyArray();
        testSimpleArray();
        testNestedArray();
        testMixedArray();
        
        // Complex tests
        testComplexJson();
        testRealWorldExample();
        
        // Error tests
        testInvalidJson();
        
        // Edge cases
        testEdgeCases();
        
        System.out.println("\n========================================");
        System.out.println("Tests passed: " + testsPassed);
        System.out.println("Tests failed: " + testsFailed);
        System.out.println("Total tests: " + (testsPassed + testsFailed));
        System.out.println("========================================");
        
        if (testsFailed > 0) {
            System.exit(1);
        }
    }
    
    private static void testNullParsing() {
        System.out.println("Testing null parsing...");
        
        assertParse("null", null);
        assertParse(" null ", null);
        assertParse("\n\tnull\r\n", null);
    }
    
    private static void testBooleanParsing() {
        System.out.println("Testing boolean parsing...");
        
        assertParse("true", true);
        assertParse("false", false);
        assertParse(" true ", true);
        assertParse("\nfalse\t", false);
    }
    
    private static void testNumberParsing() {
        System.out.println("Testing number parsing...");
        
        // Integers
        assertParse("0", 0);
        assertParse("42", 42);
        assertParse("-17", -17);
        assertParse("123456789", 123456789);
        
        // Longs
        assertParse("9223372036854775807", 9223372036854775807L);
        assertParse("-9223372036854775808", -9223372036854775808L);
        
        // Doubles
        assertParse("3.14", 3.14);
        assertParse("-0.001", -0.001);
        assertParse("1.23e10", 1.23e10);
        assertParse("1.23E10", 1.23E10);
        assertParse("1.23e-10", 1.23e-10);
        assertParse("1.23e+10", 1.23e+10);
    }
    
    private static void testStringParsing() {
        System.out.println("Testing string parsing...");
        
        // Simple strings
        assertParse("\"\"", "");
        assertParse("\"hello\"", "hello");
        assertParse("\"hello world\"", "hello world");
        
        // Escape sequences
        assertParse("\"\\\"quoted\\\"\"", "\"quoted\"");
        assertParse("\"line1\\nline2\"", "line1\nline2");
        assertParse("\"tab\\there\"", "tab\there");
        assertParse("\"carriage\\rreturn\"", "carriage\rreturn");
        assertParse("\"back\\bspace\"", "back\bspace");
        assertParse("\"form\\ffeed\"", "form\ffeed");
        assertParse("\"back\\\\slash\"", "back\\slash");
        assertParse("\"forward\\/slash\"", "forward/slash");
        
        // Unicode escapes
        assertParse("\"\\u0048\\u0065\\u006C\\u006C\\u006F\"", "Hello");
        assertParse("\"emoji: \\uD83D\\uDE00\"", "emoji: 😀");
        
        // Complex strings
        assertParse("\"Hello! I'm here to help with:\\n- Coding\\n- Debugging\\n- Testing\"",
                    "Hello! I'm here to help with:\n- Coding\n- Debugging\n- Testing");
    }
    
    private static void testEmptyObject() {
        System.out.println("Testing empty object...");
        
        Map<String, Object> empty = new HashMap<>();
        assertParse("{}", empty);
        assertParse(" { } ", empty);
        assertParse("{\n}", empty);
    }
    
    private static void testSimpleObject() {
        System.out.println("Testing simple object...");
        
        Map<String, Object> obj = new LinkedHashMap<>();
        obj.put("name", "John");
        obj.put("age", 30);
        obj.put("active", true);
        
        assertParse("{\"name\":\"John\",\"age\":30,\"active\":true}", obj);
        assertParse("{ \"name\" : \"John\" , \"age\" : 30 , \"active\" : true }", obj);
        assertParse("{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"active\": true\n}", obj);
    }
    
    private static void testNestedObject() {
        System.out.println("Testing nested object...");
        
        Map<String, Object> address = new LinkedHashMap<>();
        address.put("street", "123 Main St");
        address.put("city", "New York");
        
        Map<String, Object> person = new LinkedHashMap<>();
        person.put("name", "Jane");
        person.put("address", address);
        
        assertParse("{\"name\":\"Jane\",\"address\":{\"street\":\"123 Main St\",\"city\":\"New York\"}}", person);
    }
    
    private static void testObjectWithArrays() {
        System.out.println("Testing object with arrays...");
        
        List<String> hobbies = Arrays.asList("reading", "coding", "gaming");
        List<Integer> scores = Arrays.asList(95, 87, 92);
        
        Map<String, Object> obj = new LinkedHashMap<>();
        obj.put("hobbies", hobbies);
        obj.put("scores", scores);
        
        assertParse("{\"hobbies\":[\"reading\",\"coding\",\"gaming\"],\"scores\":[95,87,92]}", obj);
    }
    
    private static void testEmptyArray() {
        System.out.println("Testing empty array...");
        
        List<Object> empty = new ArrayList<>();
        assertParse("[]", empty);
        assertParse(" [ ] ", empty);
        assertParse("[\n]", empty);
    }
    
    private static void testSimpleArray() {
        System.out.println("Testing simple array...");
        
        assertParse("[1,2,3]", Arrays.asList(1, 2, 3));
        assertParse("[\"a\",\"b\",\"c\"]", Arrays.asList("a", "b", "c"));
        assertParse("[true,false,true]", Arrays.asList(true, false, true));
    }
    
    private static void testNestedArray() {
        System.out.println("Testing nested array...");
        
        List<Object> inner1 = Arrays.asList(1, 2);
        List<Object> inner2 = Arrays.asList(3, 4);
        List<Object> outer = Arrays.asList(inner1, inner2);
        
        assertParse("[[1,2],[3,4]]", outer);
    }
    
    private static void testMixedArray() {
        System.out.println("Testing mixed array...");
        
        Map<String, Object> obj = new LinkedHashMap<>();
        obj.put("key", "value");
        
        List<Object> mixed = Arrays.asList("string", 42, true, null, obj);
        
        assertParse("[\"string\",42,true,null,{\"key\":\"value\"}]", mixed);
    }
    
    private static void testComplexJson() {
        System.out.println("Testing complex JSON...");
        
        String json = "{" +
            "\"type\":\"BROWSER_RESPONSE\"," +
            "\"id\":\"3bd11a8d-9e22-42ca-81d9-84484ca9aae3\"," +
            "\"timestamp\":1757884137590," +
            "\"status\":\"success\"," +
            "\"payload\":{" +
                "\"content\":\"Hello! I'm here to help you with coding tasks.\\n\\nWhat would you like to work on today?\"," +
                "\"chatId\":\"mock-chat-1757884130330\"," +
                "\"model\":\"Anthropic Claude 4 Sonnet\"" +
            "}" +
        "}";
        
        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put("content", "Hello! I'm here to help you with coding tasks.\n\nWhat would you like to work on today?");
        payload.put("chatId", "mock-chat-1757884130330");
        payload.put("model", "Anthropic Claude 4 Sonnet");
        
        Map<String, Object> expected = new LinkedHashMap<>();
        expected.put("type", "BROWSER_RESPONSE");
        expected.put("id", "3bd11a8d-9e22-42ca-81d9-84484ca9aae3");
        expected.put("timestamp", 1757884137590L);
        expected.put("status", "success");
        expected.put("payload", payload);
        
        assertParse(json, expected);
    }
    
    private static void testRealWorldExample() {
        System.out.println("Testing real-world example...");
        
        String json = "[{" +
            "\"request\":{" +
                "\"type\":\"CCC_REQUEST\"," +
                "\"id\":\"f37cfe8f-2eab-4bc6-9dcb-9ac4b249b2ab\"," +
                "\"timestamp\":1757883890660," +
                "\"action\":\"ai-complete\"," +
                "\"payload\":{" +
                    "\"messages\":[" +
                        "{\"role\":\"user\",\"content\":\"You are a coding assistant with access to the following tools:\\n\\nsearch_files: Search for files\"}" +
                    "]," +
                    "\"chatId\":null" +
                "}" +
            "}," +
            "\"type\":\"CCC_REQUEST\"" +
        "}]";
        
        Object result = SimpleJsonParser.parse(json);
        assert result instanceof List : "Expected List";
        List<Object> list = (List<Object>) result;
        assert list.size() == 1 : "Expected 1 element";
        
        Map<String, Object> item = (Map<String, Object>) list.get(0);
        assert "CCC_REQUEST".equals(item.get("type")) : "Expected type CCC_REQUEST";
        
        Map<String, Object> request = (Map<String, Object>) item.get("request");
        assert request != null : "Expected request object";
        assert "f37cfe8f-2eab-4bc6-9dcb-9ac4b249b2ab".equals(request.get("id")) : "Expected matching ID";
        
        testsPassed++;
        System.out.println("  ✓ Real-world example parsed correctly");
    }
    
    private static void testInvalidJson() {
        System.out.println("Testing invalid JSON...");
        
        assertThrows("{", "Unexpected end");
        assertThrows("}", "Unexpected");
        assertThrows("{\"key\"}", "Expected ':'");
        assertThrows("{\"key\":}", "Unexpected");
        assertThrows("[1,]", "Unexpected");
        assertThrows("\"unterminated", "Unterminated string");
        assertThrows("tru", "Invalid boolean");
        assertThrows("nul", "Invalid null");
        assertThrows("1.", "Invalid number");
        assertThrows("1e", "Invalid number");
        assertThrows("\"\\u123\"", "Invalid unicode");
        assertThrows("\"\\x\"", "Invalid escape");
    }
    
    private static void testEdgeCases() {
        System.out.println("Testing edge cases...");
        
        // Very large numbers
        assertParse("9999999999999999999999999999999999999999.0", 9999999999999999999999999999999999999999.0);
        
        // Deep nesting
        String deepNest = "{\"a\":{\"b\":{\"c\":{\"d\":{\"e\":\"deep\"}}}}}";
        Object deepResult = SimpleJsonParser.parse(deepNest);
        Map<String, Object> a = (Map<String, Object>) deepResult;
        Map<String, Object> b = (Map<String, Object>) a.get("a");
        Map<String, Object> c = (Map<String, Object>) b.get("b");
        Map<String, Object> d = (Map<String, Object>) c.get("c");
        Map<String, Object> e = (Map<String, Object>) d.get("d");
        assert "deep".equals(e.get("e")) : "Deep nesting failed";
        testsPassed++;
        System.out.println("  ✓ Deep nesting works");
        
        // Empty string value
        assertParse("{\"empty\":\"\"}", Collections.singletonMap("empty", ""));
        
        // Special characters in strings
        assertParse("{\"special\":\"@#$%^&*()_+-=[]{}|;':<>?,.\"}", 
                    Collections.singletonMap("special", "@#$%^&*()_+-=[]{}|;':<>?,."));
    }
    
    private static void assertParse(String json, Object expected) {
        try {
            Object result = SimpleJsonParser.parse(json);
            
            if (expected == null) {
                if (result == null) {
                    testsPassed++;
                    System.out.println("  ✓ Parsed null correctly");
                } else {
                    testsFailed++;
                    System.out.println("  ✗ Expected null but got: " + result);
                }
            } else if (expected instanceof Number && result instanceof Number) {
                // Special handling for numbers due to type conversions
                double expectedVal = ((Number) expected).doubleValue();
                double resultVal = ((Number) result).doubleValue();
                if (Math.abs(expectedVal - resultVal) < 0.0000001) {
                    testsPassed++;
                    System.out.println("  ✓ Parsed number correctly: " + result);
                } else {
                    testsFailed++;
                    System.out.println("  ✗ Expected " + expected + " but got: " + result);
                }
            } else if (deepEquals(expected, result)) {
                testsPassed++;
                System.out.println("  ✓ Parsed correctly: " + 
                    (json.length() > 50 ? json.substring(0, 50) + "..." : json));
            } else {
                testsFailed++;
                System.out.println("  ✗ Parse mismatch for: " + json);
                System.out.println("    Expected: " + expected);
                System.out.println("    Got: " + result);
            }
        } catch (Exception e) {
            testsFailed++;
            System.out.println("  ✗ Parse failed for: " + json);
            System.out.println("    Error: " + e.getMessage());
        }
    }
    
    private static void assertThrows(String json, String expectedError) {
        try {
            Object result = SimpleJsonParser.parse(json);
            testsFailed++;
            System.out.println("  ✗ Expected error for: " + json + " but got: " + result);
        } catch (SimpleJsonParser.JsonParseException e) {
            if (e.getMessage().contains(expectedError)) {
                testsPassed++;
                System.out.println("  ✓ Correctly threw error for: " + json);
            } else {
                testsFailed++;
                System.out.println("  ✗ Wrong error for: " + json);
                System.out.println("    Expected error containing: " + expectedError);
                System.out.println("    Got: " + e.getMessage());
            }
        }
    }
    
    private static boolean deepEquals(Object a, Object b) {
        if (a == b) return true;
        if (a == null || b == null) return false;
        
        if (a instanceof Map && b instanceof Map) {
            Map<?, ?> mapA = (Map<?, ?>) a;
            Map<?, ?> mapB = (Map<?, ?>) b;
            if (mapA.size() != mapB.size()) return false;
            
            for (Map.Entry<?, ?> entry : mapA.entrySet()) {
                if (!mapB.containsKey(entry.getKey())) return false;
                if (!deepEquals(entry.getValue(), mapB.get(entry.getKey()))) return false;
            }
            return true;
        }
        
        if (a instanceof List && b instanceof List) {
            List<?> listA = (List<?>) a;
            List<?> listB = (List<?>) b;
            if (listA.size() != listB.size()) return false;
            
            for (int i = 0; i < listA.size(); i++) {
                if (!deepEquals(listA.get(i), listB.get(i))) return false;
            }
            return true;
        }
        
        return a.equals(b);
    }
}
-~{END}~-

-~{File: src/java-agent/StandaloneAgent.java}~-
import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;

public class StandaloneAgent {
    private static Clipboard clipboard;
    private static Robot robot;
    private static String savedClipboard = "";
    private static Point clickPosition = null;
    private static volatile boolean calibrated = false;
    private static TrayIcon trayIcon;
    
    public static void main(String[] args) {
        try {
            // Initialize components
            clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            robot = new Robot();
            
            // Setup system tray
            setupSystemTray();
            
            // Start the demo flow
            runDemo();
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    private static void setupSystemTray() {
        if (!SystemTray.isSupported()) {
            System.out.println("System tray not supported");
            return;
        }
        
        try {
            SystemTray tray = SystemTray.getSystemTray();
            
            // Create icon (16x16 pixels)
            BufferedImage image = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
            Graphics2D g = image.createGraphics();
            g.setColor(Color.GREEN);
            g.fillOval(0, 0, 16, 16);
            g.dispose();
            
            trayIcon = new TrayIcon(image, "CCC Agent - Ready");
            trayIcon.setImageAutoSize(true);
            
            // Add popup menu
            PopupMenu popup = new PopupMenu();
            MenuItem statusItem = new MenuItem("Status: Waiting for calibration");
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(e -> System.exit(0));
            
            popup.add(statusItem);
            popup.addSeparator();
            popup.add(exitItem);
            
            trayIcon.setPopupMenu(popup);
            tray.add(trayIcon);
            
            System.out.println("System tray initialized");
            
        } catch (Exception e) {
            System.out.println("Failed to setup system tray: " + e.getMessage());
        }
    }
    
    private static void runDemo() throws Exception {
        System.out.println("================================");
        System.out.println("CCC Demo - Java Standalone");
        System.out.println("================================");
        System.out.println();
        
        // Wait for bridge script to be pasted
        waitForBridgePaste();
        
        // Wait for calibration
        waitForCalibration();
        
        // Send test AI request
        sendAIRequest();
        
        // Wait for response
        waitForResponse();
        
        System.out.println("Demo completed!");
    }
    
    private static void waitForBridgePaste() throws Exception {
        System.out.println("Waiting for bridge script to be pasted...");
        System.out.println("1. Bridge script should already be in your clipboard");
        System.out.println("2. Go to http://localhost:5556/ or your internal Claude UI");
        System.out.println("3. Open Developer Console (F12) and paste the script");
        System.out.println("4. The script will signal when it's loaded");
        System.out.println();
        
        // Save current clipboard content first
        String originalClipboard = "";
        try {
            originalClipboard = getClipboardContent();
            if (originalClipboard != null) {
                System.out.println("[Demo] Saved original clipboard (" + originalClipboard.length() + " chars)");
            }
        } catch (Exception e) {
            System.out.println("[Demo] Could not save original clipboard: " + e.getMessage());
        }
        
        // Poll for bridge initialization message
        System.out.println("[Demo] Waiting for bridge script initialization...");
        while (true) {
            Thread.sleep(1000);
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null) {
                    // Debug output
                    String preview = clipboardText.length() > 50 ? clipboardText.substring(0, 50) + "..." : clipboardText;
                    System.out.println("[Demo] Clipboard check: " + clipboardText.length() + " chars - " + preview);
                    
                    if (clipboardText.startsWith("CCC_BRIDGE_INITIALIZED")) {
                        System.out.println("[Demo] Bridge script initialization detected!");
                        
                        // Restore original clipboard
                        if (originalClipboard != null && !originalClipboard.isEmpty()) {
                            setClipboard(originalClipboard);
                            System.out.println("[Demo] Original clipboard restored (" + originalClipboard.length() + " chars)");
                        } else {
                            setClipboard("");
                            System.out.println("[Demo] Clipboard cleared");
                        }
                        
                        Thread.sleep(500);
                        break;
                    }
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
        }
    }
    
    private static void waitForCalibration() throws Exception {
        System.out.println("[Demo] Waiting for calibration click...");
        System.out.println("[Demo] Ready to detect calibration (not clearing clipboard)...");
        
        while (!calibrated) {
            Thread.sleep(1000);
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null && !clipboardText.trim().isEmpty()) {
                    if (clipboardText.startsWith("CCC_CALIBRATION") || (clipboardText.contains("|||") && clipboardText.substring(clipboardText.lastIndexOf("|||") + 3).startsWith("CCC_CALIBRATION"))) {
                        processCalibration(clipboardText);
                    }
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
        }
    }
    
    private static void processCalibration(String content) throws Exception {
        System.out.println("[Demo] Calibration click detected!");
        
        // Get current mouse position
        Point mousePos = MouseInfo.getPointerInfo().getLocation();
        clickPosition = mousePos;
        calibrated = true;
        
        System.out.println("[Demo] Captured mouse position: " + mousePos.x + ", " + mousePos.y);
        
        // Update tray icon
        if (trayIcon != null) {
            PopupMenu popup = trayIcon.getPopupMenu();
            if (popup.getItemCount() > 0) {
                MenuItem statusItem = popup.getItem(0);
                statusItem.setLabel("Status: Calibrated - Sending AI request");
            }
        }
        
        // Clear clipboard
        setClipboard("");
        Thread.sleep(1000);
    }
    
    private static void sendAIRequest() throws Exception {
        System.out.println("[Demo] Sending AI request...");
        
        // Create test request
        String request = String.format(
            "{\"type\":\"CCC_REQUEST\",\"id\":\"%s\",\"timestamp\":%d,\"action\":\"ai-complete\",\"payload\":{\"prompt\":\"Write a haiku about clipboard bridges between programs\"}}|||CCC_END|||",
            generateUUID(),
            System.currentTimeMillis()
        );
        
        // Set clipboard
        setClipboard(request);
        Thread.sleep(2000);
        
        // Click at calibrated position
        System.out.println("[Demo] Clicking at calibrated position...");
        robot.mouseMove(clickPosition.x, clickPosition.y);
        Thread.sleep(500);
        
        // Single click
        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
        robot.delay(100);
        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
        
        System.out.println("[Demo] Request sent, waiting for response...");
    }
    
    private static void waitForResponse() throws Exception {
        int timeout = 60; // 60 seconds timeout
        int elapsed = 0;
        
        while (elapsed < timeout) {
            Thread.sleep(1000);
            elapsed++;
            
            try {
                String clipboardText = getClipboardContent();
                if (clipboardText != null && (clipboardText.startsWith("BROWSER_RESPONSE") || (clipboardText.contains("{\"type\":\"BROWSER_RESPONSE\"") && clipboardText.contains("|||BROWSER_END|||")))) {
                    processResponse(clipboardText);
                    return;
                }
            } catch (Exception e) {
                // Ignore clipboard errors
            }
            
            if (elapsed % 5 == 0) {
                System.out.println("[Demo] Still waiting... (" + elapsed + "s)");
            }
        }
        
        System.out.println("[Demo] Response timeout after " + timeout + " seconds");
    }
    
    private static void processResponse(String content) throws Exception {
        try {
            String responseText = content.split("\\|\\|\\|BROWSER_END\\|\\|\\|")[0];
            // Simple JSON parsing for the response content
            if (responseText.contains("\"content\":")) {
                String contentStart = "\"content\":\"";
                int start = responseText.indexOf(contentStart) + contentStart.length();
                int end = responseText.indexOf("\",", start);
                if (end == -1) end = responseText.indexOf("\"}", start);
                
                if (start > 0 && end > start) {
                    String aiResponse = responseText.substring(start, end);
                    System.out.println();
                    System.out.println("================================");
                    System.out.println("AI Response Received!");
                    System.out.println("================================");
                    System.out.println(aiResponse);
                    System.out.println("================================");
                    System.out.println();
                }
            }
            
            // Update tray icon
            if (trayIcon != null) {
                PopupMenu popup = trayIcon.getPopupMenu();
                if (popup.getItemCount() > 0) {
                    MenuItem statusItem = popup.getItem(0);
                    statusItem.setLabel("Status: Success! Response received");
                }
            }
            
        } catch (Exception e) {
            System.out.println("[Demo] Error parsing response: " + e.getMessage());
        }
    }
    
    private static String getClipboardContent() throws Exception {
        Transferable contents = clipboard.getContents(null);
        if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
            return (String) contents.getTransferData(DataFlavor.stringFlavor);
        }
        return null;
    }
    
    private static void setClipboard(String text) throws Exception {
        StringSelection selection = new StringSelection(text);
        clipboard.setContents(selection, null);
    }
    
    private static String generateUUID() {
        return UUID.randomUUID().toString();
    }
}
-~{END}~-

-~{File: src/java-agent/MockRobot.java}~-
import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

/**
 * Mock implementation of RobotInterface for testing
 * Records all robot actions for verification and provides controllable behavior
 */
public class MockRobot implements RobotInterface {
    private Point currentPosition = new Point(100, 100); // Default mock position
    private final List<RobotAction> actions = new ArrayList<>();
    private boolean shouldFailClicks = false;
    private int clickDelay = 50; // Default delay
    
    // Action types for verification
    public static class RobotAction {
        public final String type;
        public final int x, y, buttons, delay;
        public final long timestamp;
        
        public RobotAction(String type, int x, int y, int buttons, int delay) {
            this.type = type;
            this.x = x;
            this.y = y;
            this.buttons = buttons;
            this.delay = delay;
            this.timestamp = System.currentTimeMillis();
        }
        
        @Override
        public String toString() {
            return String.format("%s(x=%d, y=%d, buttons=%d, delay=%d, time=%d)", 
                type, x, y, buttons, delay, timestamp);
        }
    }
    
    @Override
    public void mouseMove(int x, int y) {
        this.currentPosition = new Point(x, y);
        actions.add(new RobotAction("MOUSE_MOVE", x, y, 0, 0));
        System.out.println("[MOCK-ROBOT] Mouse moved to (" + x + ", " + y + ")");
    }
    
    @Override
    public void mousePress(int buttons) {
        actions.add(new RobotAction("MOUSE_PRESS", currentPosition.x, currentPosition.y, buttons, 0));
        System.out.println("[MOCK-ROBOT] Mouse pressed: buttons=" + buttons + " at " + currentPosition);
    }
    
    @Override
    public void mouseRelease(int buttons) {
        actions.add(new RobotAction("MOUSE_RELEASE", currentPosition.x, currentPosition.y, buttons, 0));
        System.out.println("[MOCK-ROBOT] Mouse released: buttons=" + buttons + " at " + currentPosition);
    }
    
    @Override
    public void delay(int ms) {
        actions.add(new RobotAction("DELAY", 0, 0, 0, ms));
        System.out.println("[MOCK-ROBOT] Delayed " + ms + "ms");
        
        // Actually sleep to simulate timing (but shorter for tests)
        try {
            Thread.sleep(Math.min(ms, 10)); // Cap at 10ms for test speed
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    @Override
    public Point getMousePosition() {
        return new Point(currentPosition.x, currentPosition.y);
    }
    
    // Test control methods
    public void setMousePosition(int x, int y) {
        this.currentPosition = new Point(x, y);
    }
    
    public void setShouldFailClicks(boolean shouldFail) {
        this.shouldFailClicks = shouldFail;
    }
    
    public void setClickDelay(int delay) {
        this.clickDelay = delay;
    }
    
    public List<RobotAction> getActions() {
        return new ArrayList<>(actions);
    }
    
    public void clearActions() {
        actions.clear();
    }
    
    // Verification helpers
    public int getClickCount() {
        return (int) actions.stream().filter(a -> "MOUSE_PRESS".equals(a.type)).count();
    }
    
    public boolean wasMouseMovedTo(int x, int y) {
        return actions.stream().anyMatch(a -> 
            "MOUSE_MOVE".equals(a.type) && a.x == x && a.y == y);
    }
    
    public boolean hadMousePressAt(int x, int y, int buttons) {
        return actions.stream().anyMatch(a ->
            "MOUSE_PRESS".equals(a.type) && a.x == x && a.y == y && a.buttons == buttons);
    }
    
    public boolean hadDelayOf(int ms) {
        return actions.stream().anyMatch(a -> 
            "DELAY".equals(a.type) && a.delay == ms);
    }
    
    public void printActionHistory() {
        System.out.println("[MOCK-ROBOT] Action History (" + actions.size() + " actions):");
        for (int i = 0; i < actions.size(); i++) {
            System.out.println("  " + (i + 1) + ". " + actions.get(i));
        }
    }
}
-~{END}~-

-~{File: src/java-agent/SystemRobot.java}~-
import java.awt.*;
import java.awt.event.InputEvent;

/**
 * Production implementation of RobotInterface using Java's Robot class
 */
public class SystemRobot implements RobotInterface {
    private final Robot robot;
    
    public SystemRobot() throws AWTException {
        this.robot = new Robot();
    }
    
    @Override
    public void mouseMove(int x, int y) {
        robot.mouseMove(x, y);
    }
    
    @Override
    public void mousePress(int buttons) {
        robot.mousePress(buttons);
    }
    
    @Override
    public void mouseRelease(int buttons) {
        robot.mouseRelease(buttons);
    }
    
    @Override
    public void delay(int ms) {
        robot.delay(ms);
    }
    
    @Override
    public Point getMousePosition() {
        return MouseInfo.getPointerInfo().getLocation();
    }
}
-~{END}~-

-~{File: src/java-agent/web/js/system-prompt.js}~-
// System prompt for the coding assistant
export const SYSTEM_PROMPT = `# Windows Code Assistant System Prompt

<system-reminder>
Never start responses by saying a question, idea, or observation was good, great, fascinating, profound, excellent, or any other positive adjective. Skip flattery and respond directly.

Critically evaluate code proposals, architecture decisions, technical theories, claims, and ideas rather than automatically agreeing or praising them. When presented with dubious, incorrect, ambiguous, or unverifiable approaches, respectfully point out flaws, potential security issues, performance concerns, or lack of clarity rather than validating them. Prioritize technical accuracy and best practices over agreeability.

Provide honest and accurate technical feedback even when it might not be what the developer hopes to hear, rather than prioritizing immediate approval or agreement. While remaining helpful, maintain objectivity about code quality, point out anti-patterns, suggest improvements, and identify potential issues. A developer's long-term success is often best served by honest, constructive technical feedback.

Do not use emojis unless the person asks for it or if the person's message contains an emoji, and be judicious about emoji use even then.

Avoid emotes or actions inside asterisks unless specifically requested.
</system-reminder>

You are a Windows Code Assistant, an interactive CLI tool that helps users with software engineering tasks. Use the instructions below and the tools available to you to assist the user.

**IMPORTANT:** Assist with defensive security tasks only. Refuse to create, modify, or improve code that may be used maliciously. Allow security analysis, detection rules, vulnerability explanations, defensive tools, and security documentation.

**IMPORTANT:** You must NEVER generate or guess URLs for the user unless you are confident that the URLs are for helping the user with programming. You may use URLs provided by the user in their messages or local files.

## Core Operational Guidelines

Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.

## Tone and Style

- Be concise, direct, and to the point
- **MUST** answer concisely with fewer than 4 lines (not including tool use or code generation), unless user asks for detail
- **IMPORTANT:** Minimize output tokens as much as possible while maintaining helpfulness, quality, and accuracy
- Only address the specific query or task at hand, avoiding tangential information unless absolutely critical
- **IMPORTANT:** Should NOT answer with unnecessary preamble or postamble unless the user asks you to
- Do not add additional code explanation summary unless requested by the user
- Answer the user's question directly, without elaboration, explanation, or details. One word answers are best
- Avoid introductions, conclusions, and explanations
- **MUST** avoid text before/after your response, such as "The answer is <answer>." or "Here is the content of the file..."

### Response Examples

- User: "2 + 2" → Assistant: "4"
- User: "what is 2+2?" → Assistant: "4"
- User: "is 11 a prime number?" → Assistant: "Yes"
- User: "what command should I run to list files in the current directory?" → Assistant: "dir"

## Proactiveness

You are allowed to be proactive, but only when the user asks you to do something. Strike a balance between:
- Doing the right thing when asked, including taking actions and follow-up actions
- Not surprising the user with actions you take without asking

## Following Conventions

When making changes to files, first understand the file's code conventions:
- Mimic code style, use existing libraries and utilities, and follow existing patterns
- **NEVER** assume that a given library is available, even if it is well known
- Whenever you write code that uses a library or framework, first check that this codebase already uses the given library
- When you create a new component, first look at existing components to see how they're written
- When you edit a piece of code, first look at the code's surrounding context to understand the code's choice of frameworks and libraries
- Always follow security best practices. Never introduce code that exposes or logs secrets and keys. Never commit secrets or keys to the repository

## Code Style

- **IMPORTANT:** DO NOT ADD ***ANY*** COMMENTS unless asked

---

**Note:** This prompt is designed to be used as the first message in a conversation along with the actual user input.

## Available Tools

search_files: Search for files by name pattern
- Parameters: {"query": "search_term"}

search_content: Search for content within files (returns 5 lines above/below matches with line numbers)
- Parameters: {"query": "search_term", "file_pattern": "*.ext"} (file_pattern is optional)

list_files: List files and directories in a path
- Parameters: {"path": "directory_path"} (defaults to current directory if not specified)

read_file: Read the contents of a file
- Parameters: {"file_path": "path/to/file", "start_line": 10, "end_line": 20} (start_line and end_line are optional - when used, returns lines with line numbers)

create_file: Create a new file with content
- Parameters: {"file_path": "path/to/file", "content": "file content"} (content is optional - defaults to empty file)

delete_file: Delete an existing file
- Parameters: {"file_path": "path/to/file"}

list_recursive: List all files and directories recursively in a path
- Parameters: {"path": "directory_path"} (defaults to current directory if not specified)

create_directory: Create a new directory
- Parameters: {"dir_path": "path/to/directory"}

delete_directory_recursive: Delete a directory and all its contents (safety check: requires recent list_recursive call)
- Parameters: {"dir_path": "path/to/directory"}

## Response Format

IMPORTANT: All responses must be wrapped in a <response> tag and can contain any combination of <message> and <execute> sections:

<response>
  <message>Your text explanation here</message>
  <execute>
    <tool name="tool_name">
      <parameter name="param_name">value</parameter>
    </tool>
  </execute>
  <message>Additional explanation</message>
</response>

Rules:
- Always wrap your entire response in <response></response> tags
- Use <message> tags for any explanatory text  
- Use <execute> tags for tool calls
- You can have multiple <message> and <execute> sections in any order
- Each <execute> block can contain one or more <tool> calls
- Keep messages concise per the tone guidelines above

Examples:

Example 1 (message only):
<response>
  <message>Found 3 JavaScript files in src/</message>
</response>

Example 2 (tools with explanation):
<response>
  <message>Searching for JavaScript files.</message>
  <execute>
    <tool name="search_files">
      <parameter name="query">*.js</parameter>
    </tool>
  </execute>
</response>

Example 3 (multiple operations):
<response>
  <message>Checking project structure.</message>
  <execute>
    <tool name="list_files">
      <parameter name="path">.</parameter>
    </tool>
  </execute>
  <message>Reading package.json.</message>
  <execute>
    <tool name="read_file">
      <parameter name="file_path">package.json</parameter>
    </tool>
  </execute>
</response>`;
-~{END}~-

-~{File: src/java-agent/web/js/coding-assistant.js}~-
// Temporarily embed the prompt directly until module loading is fixed
const SYSTEM_PROMPT = `# Windows Code Assistant System Prompt

<system-reminder>
Never start responses by saying a question, idea, or observation was good, great, fascinating, profound, excellent, or any other positive adjective. Skip flattery and respond directly.

Critically evaluate code proposals, architecture decisions, technical theories, claims, and ideas rather than automatically agreeing or praising them. When presented with dubious, incorrect, ambiguous, or unverifiable approaches, respectfully point out flaws, potential security issues, performance concerns, or lack of clarity rather than validating them. Prioritize technical accuracy and best practices over agreeability.

Provide honest and accurate technical feedback even when it might not be what the developer hopes to hear, rather than prioritizing immediate approval or agreement. While remaining helpful, maintain objectivity about code quality, point out anti-patterns, suggest improvements, and identify potential issues. A developer's long-term success is often best served by honest, constructive technical feedback.

Do not use emojis unless the person asks for it or if the person's message contains an emoji, and be judicious about emoji use even then.

Avoid emotes or actions inside asterisks unless specifically requested.
</system-reminder>

You are a Windows Code Assistant, an interactive CLI tool that helps users with software engineering tasks. Use the instructions below and the tools available to you to assist the user.

## Available Tools

search_files: Search for files by name pattern
- Parameters: {"query": "search_term"}

search_content: Search for content within files (returns 5 lines above/below matches with line numbers)
- Parameters: {"query": "search_term", "file_pattern": "*.ext"} (file_pattern is optional)

list_files: List files and directories in a path
- Parameters: {"path": "directory_path"} (defaults to current directory if not specified)

read_file: Read the contents of a file
- Parameters: {"file_path": "path/to/file", "start_line": 10, "end_line": 20} (start_line and end_line are optional - when used, returns lines with line numbers)

create_file: Create a new file with content
- Parameters: {"file_path": "path/to/file", "content": "file content"} (content is optional - defaults to empty file)

delete_file: Delete an existing file
- Parameters: {"file_path": "path/to/file"}

list_recursive: List all files and directories recursively in a path
- Parameters: {"path": "directory_path"} (defaults to current directory if not specified)

create_directory: Create a new directory
- Parameters: {"dir_path": "path/to/directory"}

delete_directory_recursive: Delete a directory and all its contents (safety check: requires recent list_recursive call)
- Parameters: {"dir_path": "path/to/directory"}

## Response Format

IMPORTANT: All responses must be wrapped in a <response> tag and can contain any combination of <message> and <execute> sections:

<response>
  <message>Your text explanation here</message>
  <execute>
    <tool name="tool_name">
      <parameter name="param_name">value</parameter>
    </tool>
  </execute>
  <message>Additional explanation</message>
</response>

Rules:
- Always wrap your entire response in <response></response> tags
- Use <message> tags for any explanatory text  
- Use <execute> tags for tool calls
- You can have multiple <message> and <execute> sections in any order
- Each <execute> block can contain one or more <tool> calls
- Be concise and direct in your messages

Examples:

Example 1 (message only):
<response>
  <message>Found 3 JavaScript files in src/</message>
</response>

Example 2 (tools with explanation):
<response>
  <message>Searching for JavaScript files.</message>
  <execute>
    <tool name="search_files">
      <parameter name="query">*.js</parameter>
    </tool>
  </execute>
</response>

Example 3 (multiple operations):
<response>
  <message>Checking project structure.</message>
  <execute>
    <tool name="list_files">
      <parameter name="path">.</parameter>
    </tool>
  </execute>
  <message>Reading package.json.</message>
  <execute>
    <tool name="read_file">
      <parameter name="file_path">package.json</parameter>
    </tool>
  </execute>
</response>`;

class CodingAssistantUI {
    constructor() {
        this.chatArea = document.getElementById('chat-area');
        this.messageInput = document.getElementById('message-input');
        this.isProcessing = false;
        this.currentAssistantMessage = null;
        this.toolExecutions = new Map(); // Track ongoing tool executions
        this.conversationHistory = []; // Track full conversation history
        this.chatId = null; // Track conversation ID from bridge script
        
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !this.isProcessing) {
                e.preventDefault();
                this.handleUserMessage();
            }
        });
    }

    async handleUserMessage() {
        const message = this.messageInput.value.trim();
        if (!message) return;

        this.addUserMessage(message);
        this.messageInput.value = '';
        this.setProcessing(true);

        // Add user message to conversation history
        this.conversationHistory.push({
            role: 'user',
            content: message
        });

        // Always add system message to messages being sent (but not to saved history)
        const messagesToSend = this.addSystemMessage([...this.conversationHistory]);

        try {
            const response = await this.sendMessageToBackend(messagesToSend);
            await this.processResponse(response);
        } catch (error) {
            this.addErrorMessage('Error: ' + error.message);
        } finally {
            this.setProcessing(false);
        }
    }

    async sendMessageToBackend(messages) {
        const requestId = this.generateUUID();
        
        const request = {
            type: 'CCC_REQUEST',
            id: requestId,
            timestamp: Date.now(),
            action: 'ai-complete',
            payload: { 
                messages: messages,
                chatId: this.chatId  // Include current chat ID (null for first request)
            }
        };

        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(request)
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return { response, requestId };
    }

    async processResponse({ response, requestId }) {
        // Create loading message placeholder (no dot yet)
        this.currentAssistantMessage = this.createLoadingMessage();
        this.currentAssistantContent = ''; // Track full assistant response
        
        await this.handleSSEResponse(response, requestId);
        
        // Add complete assistant message to conversation history
        if (this.currentAssistantContent) {
            this.conversationHistory.push({
                role: 'assistant',
                content: this.currentAssistantContent
            });
        }
    }

    async handleSSEResponse(response, requestId) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const dataStr = line.substring(6);
                    if (dataStr === '[DONE]') return;
                    
                    try {
                        const data = JSON.parse(dataStr);
                        console.log('[DEBUG-SSE] Received data:', data);
                        await this.handleStreamData(data);
                    } catch (parseError) {
                        console.error('Parse error:', parseError.message);
                        console.error('Failed to parse:', dataStr);
                    }
                }
            }
        }
    }

    async handleStreamData(data) {
        console.log('[DEBUG-STREAM] handleStreamData called with:', data);
        
        if (data.type === 'CLICK_FAILED') {
            // Handle click failed message
            this.stopSpinnerAnimation();
            if (this.currentAssistantMessage) {
                this.currentAssistantMessage.remove(); // Remove the loading message completely
            }
            
            // Add click failed message with retry button
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant error';
            messageDiv.innerHTML = `X ${data.payload.message || 'Auto-click failed - browser not responding'}`;
            
            // Add retry button
            const retryButton = document.createElement('button');
            retryButton.className = 'retry-button';
            retryButton.innerHTML = '&#8635; Retry Auto-Click';
            retryButton.onclick = () => this.retryAutoClick(data.id);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'retry-container';
            buttonContainer.appendChild(retryButton);
            messageDiv.appendChild(buttonContainer);
            
            this.chatArea.appendChild(messageDiv);
            this.scrollToBottom();
            
            // Update currentAssistantMessage to point to the error message so retry can clean it up
            this.currentAssistantMessage = messageDiv;
            this.setProcessing(false);
            return;
        }
        
        if (data.type === 'USER_CANCELLED') {
            // Handle user cancellation
            this.stopSpinnerAnimation();
            if (this.currentAssistantMessage) {
                this.currentAssistantMessage.style.display = 'none';
            }
            
            // Add cancellation message
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant error';
            messageDiv.innerHTML = `&#9888; ${data.payload.message || 'Operation cancelled by user'}`;
            this.chatArea.appendChild(messageDiv);
            this.scrollToBottom();
            
            this.setProcessing(false);
            return;
        }
        
        if (data.type === 'BROWSER_PROGRESS' || data.type === 'BROWSER_RESPONSE') {
            // Extract and store chatId if present
            if (data.payload && data.payload.chatId && !this.chatId) {
                this.chatId = data.payload.chatId;
                console.log('[CodingAssistant] Received chatId:', this.chatId);
            }
            
            let content = '';
            if (data.payload && data.payload.accumulated) {
                content = data.payload.accumulated;
            } else if (data.payload && data.payload.content) {
                content = data.payload.content;
            }

            if (content) {
                // Update current assistant content for history tracking
                this.currentAssistantContent = content;
                
                // Check if this is the new <response> format
                if (content.includes('<response>') && content.includes('</response>')) {
                    await this.handleStructuredResponse(content);
                } else {
                    // Fallback for plain text responses (shouldn't happen with new prompt)
                    this.convertToAssistantMessage(content.trim());
                }
            }
        }
    }

    async handleStructuredResponse(content) {
        // Parse the <response> structure
        const responseMatch = content.match(/<response>(.*?)<\/response>/s);
        if (!responseMatch) {
            console.error('Invalid response format - missing <response> tags');
            this.convertToAssistantMessage('Error: Invalid response format');
            return;
        }
        
        const responseContent = responseMatch[1];
        
        // Find all <message> and <execute> blocks in order
        const sections = [];
        const sectionRegex = /(<message>.*?<\/message>|<execute>.*?<\/execute>)/gs;
        let match;
        
        while ((match = sectionRegex.exec(responseContent)) !== null) {
            sections.push(match[1]);
        }
        
        // Process each section in order
        for (const section of sections) {
            if (section.startsWith('<message>')) {
                // Extract and display message content
                const messageMatch = section.match(/<message>(.*?)<\/message>/s);
                if (messageMatch) {
                    const messageText = messageMatch[1].trim();
                    if (messageText) {
                        // Hide spinner if showing
                        this.stopSpinnerAnimation();
                        // Display this message
                        this.convertToAssistantMessage(messageText);
                        // Reset for next section
                        this.currentAssistantMessage = null;
                        this.currentAssistantContent = '';
                    }
                }
            } else if (section.startsWith('<execute>')) {
                // Hide any loading message
                this.stopSpinnerAnimation();
                if (this.currentAssistantMessage) {
                    this.currentAssistantMessage.style.display = 'none';
                }
                // Process tools in this execute block
                await this.handleToolOnlyResponse(section);
            }
        }
    }

    async handleToolOnlyResponse(content) {
        // Parse <execute><tool name="..."><parameter name="...">...</parameter></tool></execute> format
        const tools = [];
        
        // Extract all <tool> blocks within <execute> blocks
        const toolMatches = content.matchAll(/<tool name="([^"]+)">(.*?)<\/tool>/gs);
        
        for (const match of toolMatches) {
            const [, toolName, toolContent] = match;
            const parameters = {};
            
            // Extract parameters from within this tool block
            const paramMatches = toolContent.matchAll(/<parameter name="([^"]+)">([^<]*)<\/parameter>/g);
            
            for (const paramMatch of paramMatches) {
                const [, paramName, paramValue] = paramMatch;
                parameters[paramName] = paramValue.trim();
            }
            
            tools.push({
                name: toolName,
                parameters: parameters
            });
        }
        
        if (tools.length === 0) {
            console.error('No tools found in execute block:', content.substring(0, 200));
            return;
        }

        // Execute all tools
        const allResults = [];
        for (const toolData of tools) {
            const toolId = this.generateUUID();
            
            // Add tool execution UI
            this.addToolExecution(toolId, toolData);
            
            try {
                // Execute tool
                const results = await this.executeTool(toolData);
                
                // Update tool execution with results
                this.updateToolExecution(toolId, 'completed', results);
                
                allResults.push({
                    toolId,
                    toolData,
                    results
                });
            } catch (toolError) {
                console.error(`Tool ${toolData.name} execution error:`, toolError);
                this.updateToolExecution(toolId, 'error', { error: toolError.message });
                
                allResults.push({
                    toolId,
                    toolData,
                    results: { error: toolError.message }
                });
            }
        }
        
        // Send all results back to AI
        if (allResults.length > 0) {
            await this.sendToolResults(allResults);
        }
    }


    async executeTool(toolData) {
        const { name, parameters } = toolData;
        
        switch (name) {
            case 'search_files':
                return await this.executeFileSearch(parameters);
            case 'search_content':
                return await this.executeContentSearch(parameters);
            case 'list_files':
                return await this.executeListFiles(parameters);
            case 'read_file':
                return await this.executeReadFile(parameters);
            case 'create_file':
                return await this.executeCreateFile(parameters);
            case 'delete_file':
                return await this.executeDeleteFile(parameters);
            case 'list_recursive':
                return await this.executeListRecursive(parameters);
            case 'create_directory':
                return await this.executeCreateDirectory(parameters);
            case 'delete_directory_recursive':
                return await this.executeDeleteDirectory(parameters);
            default:
                throw new Error(`Unknown tool: ${name}`);
        }
    }

    async executeFileSearch(parameters) {
        const { query } = parameters;
        
        const response = await fetch('/api/tools/search-files', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query })
        });

        if (!response.ok) {
            throw new Error(`File search failed: ${response.status}`);
        }

        return await response.json();
    }

    async executeContentSearch(parameters) {
        const { query, file_pattern } = parameters;
        
        const response = await fetch('/api/tools/search-content', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query, file_pattern })
        });

        if (!response.ok) {
            throw new Error(`Content search failed: ${response.status}`);
        }

        return await response.json();
    }

    async executeListFiles(parameters) {
        const { path } = parameters;
        
        const response = await fetch('/api/tools/list-files', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: path || '.' })
        });

        if (!response.ok) {
            throw new Error(`List files failed: ${response.status}`);
        }

        return await response.json();
    }

    async executeReadFile(parameters) {
        const { file_path, start_line, end_line } = parameters;
        
        const requestBody = { file_path };
        if (start_line !== undefined) {
            requestBody.start_line = start_line;
        }
        if (end_line !== undefined) {
            requestBody.end_line = end_line;
        }
        
        const response = await fetch('/api/tools/read-file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`Read file failed: ${response.status}`);
        }

        return await response.json();
    }

    async executeCreateFile(parameters) {
        const { file_path, content } = parameters;
        
        const requestBody = { file_path };
        if (content !== undefined) {
            requestBody.content = content;
        }
        
        const response = await fetch('/api/tools/create-file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`Create file failed: ${response.status}`);
        }

        return await response.json();
    }

    async executeDeleteFile(parameters) {
        const { file_path } = parameters;
        
        const response = await fetch('/api/tools/delete-file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file_path })
        });

        if (!response.ok) {
            throw new Error(`Delete file failed: ${response.status}`);
        }

        return await response.json();
    }

    async executeListRecursive(parameters) {
        const { path } = parameters;
        
        const response = await fetch('/api/tools/list-recursive', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ path: path || '.' })
        });

        if (!response.ok) {
            throw new Error(`List recursive failed: ${response.status}`);
        }

        return await response.json();
    }

    async executeCreateDirectory(parameters) {
        const { dir_path } = parameters;
        
        const response = await fetch('/api/tools/create-directory', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ dir_path })
        });

        if (!response.ok) {
            throw new Error(`Create directory failed: ${response.status}`);
        }

        return await response.json();
    }

    async executeDeleteDirectory(parameters) {
        const { dir_path } = parameters;
        
        const response = await fetch('/api/tools/delete-directory', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ dir_path })
        });

        if (!response.ok) {
            throw new Error(`Delete directory failed: ${response.status}`);
        }

        return await response.json();
    }

    async sendToolResults(allResults) {
        // Handle both single tool result (legacy) and multiple tool results
        const results = Array.isArray(allResults) ? allResults : [{ toolId: allResults, toolData: arguments[1], results: arguments[2] }];
        
        // Create combined tool result message
        let toolResultMessage = '[SYSTEM] Tool execution completed:\n\n';
        
        results.forEach((result, index) => {
            const { toolData, results: toolResults } = result;
            toolResultMessage += `Tool ${index + 1}: ${toolData.name}\n`;
            
            // Add relevant parameters
            if (toolData.parameters.query) {
                toolResultMessage += `Query: ${toolData.parameters.query}\n`;
            }
            if (toolData.parameters.path) {
                toolResultMessage += `Path: ${toolData.parameters.path}\n`;
            }
            if (toolData.parameters.file_pattern) {
                toolResultMessage += `File Pattern: ${toolData.parameters.file_pattern}\n`;
            }
            if (toolData.parameters.file_path) {
                toolResultMessage += `File Path: ${toolData.parameters.file_path}\n`;
            }
            if (toolData.parameters.dir_path) {
                toolResultMessage += `Directory Path: ${toolData.parameters.dir_path}\n`;
            }
            if (toolData.parameters.content) {
                toolResultMessage += `Content: ${toolData.parameters.content.length > 100 ? toolData.parameters.content.substring(0, 100) + '...' : toolData.parameters.content}\n`;
            }
            
            toolResultMessage += `Results: ${JSON.stringify(toolResults, null, 2)}\n\n`;
        });
        
        toolResultMessage += 'Please provide a response based on these results.';
        
        // Create messages array with tool result, then add system message
        const messagesWithToolResult = [...this.conversationHistory, {
            role: 'user',
            content: toolResultMessage
        }];
        
        // Always add system message to messages being sent (but not to saved history)
        const messagesToSendWithSystem = this.addSystemMessage(messagesWithToolResult);

        const request = {
            type: 'TOOL_RESULT',
            id: this.generateUUID(),
            timestamp: Date.now(),
            payload: {
                toolResults: results,
                messages: messagesToSendWithSystem,  // Send conversation + tool result + system message
                chatId: this.chatId  // Include current chat ID
            }
        };

        const response = await fetch('/api/tool-result', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(request)
        });

        if (response.ok) {
            // Add tool result to conversation history only after sending request
            this.conversationHistory.push({
                role: 'user',
                content: toolResultMessage
            });
            
            // Process the AI's response to the tool results
            await this.processResponse({ response, requestId: request.id });
        }
    }

    addToolExecution(toolId, toolData) {
        const toolDiv = document.createElement('div');
        toolDiv.className = 'tool-execution';
        toolDiv.id = `tool-${toolId}`;
        
        // Build parameter display for first line
        let paramDisplay = '';
        if (toolData.parameters.query) {
            paramDisplay = toolData.parameters.query;
        } else if (toolData.parameters.path) {
            paramDisplay = toolData.parameters.path;
        } else if (toolData.parameters.file_path) {
            paramDisplay = toolData.parameters.file_path;
        } else if (toolData.parameters.dir_path) {
            paramDisplay = toolData.parameters.dir_path;
        }
        
        // Capitalize tool name for display
        const toolDisplayName = toolData.name.split('_').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        
        toolDiv.innerHTML = `
            <div class="tool-header">${toolDisplayName}(${paramDisplay})</div>
            <div class="tool-summary" id="summary-${toolId}">
                <span class="loading-dots">Loading...</span>
            </div>
            <div class="tool-details-expanded" id="details-${toolId}" style="display: none;">
                <div class="tool-results-full" id="results-${toolId}"></div>
            </div>
        `;
        
        // Add click handlers for expand/collapse
        const header = toolDiv.querySelector('.tool-header');
        const summary = toolDiv.querySelector('.tool-summary');
        const details = toolDiv.querySelector('.tool-details-expanded');
        
        const toggleExpand = () => {
            const isExpanded = details.style.display !== 'none';
            if (isExpanded) {
                details.style.display = 'none';
                toolDiv.classList.remove('expanded');
            } else {
                details.style.display = 'block';
                toolDiv.classList.add('expanded');
            }
        };
        
        header.addEventListener('click', toggleExpand);
        summary.addEventListener('click', toggleExpand);
        details.addEventListener('click', toggleExpand);
        
        this.chatArea.appendChild(toolDiv);
        this.scrollToBottom();
        
        this.toolExecutions.set(toolId, toolDiv);
        return toolDiv;
    }

    updateToolExecution(toolId, status, results) {
        const toolDiv = this.toolExecutions.get(toolId);
        if (!toolDiv) return;

        const summaryElement = document.getElementById(`summary-${toolId}`);
        const resultsElement = document.getElementById(`results-${toolId}`);
        
        if (status === 'completed' && results) {
            // Update summary line (second line)
            let summaryText = '';
            let resultsContent = '';
            
            if (results.files && Array.isArray(results.files)) {
                // For file lists or search results
                summaryText = `&#9151; ${results.files.length} ${results.files.length === 1 ? 'file' : 'files'}`;
                resultsContent = results.files.map(file => `${file}`).join('\n');
            } else if (results.content) {
                // For file reads
                const lines = results.content.split('\n');
                summaryText = `&#9151; ${lines.length} lines`;
                resultsContent = results.content;
            } else if (results.success && results.message) {
                // For create_file, delete_file, create_directory success responses
                summaryText = `&#9151; ${results.message}`;
                resultsContent = results.message;
            } else if (results.safety_listing && results.files) {
                // For delete_directory_recursive safety listing
                summaryText = `&#9151; Safety listing: ${results.files.length} items`;
                resultsContent = results.message + '\n\n' + results.files.join('\n');
            } else if (results.error) {
                summaryText = `&#9151; Error: ${results.error}`;
                resultsContent = results.error;
            } else {
                summaryText = `&#9151; Completed`;
                resultsContent = JSON.stringify(results, null, 2);
            }
            
            if (summaryElement) {
                summaryElement.innerHTML = summaryText;
            }
            
            if (resultsElement) {
                resultsElement.textContent = resultsContent;
            }
        } else if (status === 'error') {
            // Add error class for red bullet point
            toolDiv.classList.add('error');
            
            const errorMsg = (results && results.error) ? results.error : 'Unknown error';
            if (summaryElement) {
                summaryElement.innerHTML = `&#9151; Error: ${errorMsg}`;
            }
            if (resultsElement && results) {
                resultsElement.textContent = results.error || 'Unknown error';
            }
        }

        this.scrollToBottom();
    }

    createAssistantMessage() {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message assistant';
        this.chatArea.appendChild(messageDiv);
        this.scrollToBottom();
        return messageDiv;
    }

    createLoadingMessage() {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message loading';
        
        const spinnerSpan = document.createElement('span');
        spinnerSpan.className = 'loading-spinner';
        spinnerSpan.textContent = '~';
        
        messageDiv.appendChild(spinnerSpan);
        messageDiv.appendChild(document.createTextNode('Loading...'));
        
        this.chatArea.appendChild(messageDiv);
        this.scrollToBottom();
        
        // Start the spinner animation
        this.startSpinnerAnimation(spinnerSpan);
        
        return messageDiv;
    }

    startSpinnerAnimation(spinnerElement) {
        const chars = ['&bull;', '&middot;', '&#8728;', '&#8729;', '&#9675;', '&#9679;', '*', '&deg;', '&#10043;', '&#10045;', '&#10038;'];
        let index = 0;
        
        const nextFrame = () => {
            spinnerElement.innerHTML = chars[index];
            index = (index + 1) % chars.length;
            
            this.spinnerTimeout = setTimeout(nextFrame, 300);
        };
        
        nextFrame(); // Start the animation
    }

    stopSpinnerAnimation() {
        if (this.spinnerInterval) {
            clearInterval(this.spinnerInterval);
            this.spinnerInterval = null;
        }
        if (this.spinnerTimeout) {
            clearTimeout(this.spinnerTimeout);
            this.spinnerTimeout = null;
        }
    }

    convertToAssistantMessage(content) {
        if (this.currentAssistantMessage) {
            // Stop the spinner animation
            this.stopSpinnerAnimation();
            
            // Convert from loading message to assistant message
            this.currentAssistantMessage.className = 'message assistant';
            this.currentAssistantMessage.innerHTML = content.replace(/\n/g, '<br>');
            this.scrollToBottom();
        }
    }

    updateAssistantMessage(content) {
        if (this.currentAssistantMessage) {
            this.currentAssistantMessage.innerHTML = content.replace(/\n/g, '<br>');
            this.scrollToBottom();
        }
    }

    addUserMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message user';
        messageDiv.textContent = message;
        this.chatArea.appendChild(messageDiv);
        this.scrollToBottom();
    }

    addErrorMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message assistant error';
        messageDiv.textContent = message;
        this.chatArea.appendChild(messageDiv);
        this.scrollToBottom();
    }


    setProcessing(isProcessing) {
        this.isProcessing = isProcessing;
        this.messageInput.disabled = isProcessing;
    }

    scrollToBottom() {
        this.chatArea.scrollTop = this.chatArea.scrollHeight;
    }

    retryAutoClick(requestId) {
        console.log('Retrying auto-click for request:', requestId);
        
        // Clear any existing loading state and create fresh loading message
        this.stopSpinnerAnimation();
        
        // Remove ALL loading, error, and assistant messages to prevent accumulation
        const messagesToRemove = this.chatArea.querySelectorAll('.message.loading, .message.assistant.error, .message.assistant:not(.tool-execution)');
        console.log('Retry cleanup: Found', messagesToRemove.length, 'messages to remove');
        messagesToRemove.forEach(msg => {
            console.log('Removing message:', msg.className, msg.textContent.substring(0, 50));
            msg.remove();
        });
        
        // Also remove the specific current message if it exists
        if (this.currentAssistantMessage) {
            console.log('Removing current assistant message');
            this.currentAssistantMessage.remove();
            this.currentAssistantMessage = null;
        }
        
        // Show new loading message
        this.currentAssistantMessage = this.createLoadingMessage();
        this.currentAssistantContent = '';
        this.setProcessing(true);
        
        // Send retry request to backend (reuse the same conversation but trigger new clicking)
        const retryMessages = [...this.conversationHistory];
        const messagesToSend = this.addSystemMessage(retryMessages);
        
        this.sendMessageToBackend(messagesToSend).then(({ response, requestId: newRequestId }) => {
            return this.processResponse({ response, requestId: newRequestId });
        }).catch(error => {
            this.addErrorMessage('Retry failed: ' + error.message);
            this.setProcessing(false);
        });
    }

    addSystemMessage(messages) {
        const systemMessage = {
            role: 'user',
            content: SYSTEM_PROMPT
        };

        return [systemMessage, ...messages];
    }

    generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
}

// Initialize the UI when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new CodingAssistantUI();
});
-~{END}~-

-~{File: src/java-agent/web/css/terminal.css}~-
/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Consolas', 'Fira Code', 'Monaco', 'Menlo', monospace;
    font-size: 13px;
    background-color: #1f1f1f;
    color: #e0e0e0;
    height: 100vh;
    overflow: hidden;
}

/* Terminal container */
.terminal-container {
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Chat area */
.chat-area {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    padding-bottom: 10px;
}

.chat-area::-webkit-scrollbar {
    width: 8px;
}

.chat-area::-webkit-scrollbar-track {
    background: #1f1f1f;
}

.chat-area::-webkit-scrollbar-thumb {
    background: #333;
    border-radius: 4px;
}

.chat-area::-webkit-scrollbar-thumb:hover {
    background: #555;
}

/* Input area */
.input-area {
    border-top: 1px solid #333;
    padding: 15px 20px;
    display: flex;
    align-items: center;
    background-color: #222;
}

.prompt {
    color: #e0e0e0;
    margin-right: 10px;
    user-select: none;
}

.input-field {
    flex: 1;
    background: transparent;
    border: none;
    color: #e0e0e0;
    font-family: inherit;
    font-size: 13px;
    outline: none;
    caret-color: #e0e0e0;
}

.input-field::placeholder {
    color: #666;
}

/* Messages */
.message {
    margin-bottom: 20px;
    line-height: 1.4;
    position: relative;
}

.message.user {
    color: #888888; /* Lighter gray for user messages */
}

.message.user::before {
    content: '> ';
    color: #888888;
}

.message.assistant {
    color: #c0c0c0;
    padding-left: 15px; /* Space for bullet point */
}

.message.assistant:not(.tool-execution)::before {
    content: '\2022';
    color: #c0c0c0;
    position: absolute;
    left: 0;
    top: 0;
    font-weight: bold;
}

.message.error {
    color: #ff6b6b;
}

/* Format error styling with red dot */
.message.format-error {
    color: #e94560;
    border-left: 3px solid #e94560;
    background-color: rgba(233, 69, 96, 0.1);
    padding-left: 12px;
}

.message.format-error::before {
    content: '●';
    color: #e94560;
    margin-right: 8px;
    font-weight: bold;
}

.message.success {
    color: #51cf66;
}

/* Tool execution styles - Claude Code style */
.tool-execution {
    margin: 15px 0;
    padding-left: 15px;
    position: relative;
    color: #e0e0e0;
    cursor: pointer;
    word-wrap: break-word;
    overflow-wrap: break-word;
}

.tool-execution::before {
    content: '\2022';
    color: #28a745;
    position: absolute;
    left: 0;
    top: 0;
    font-weight: bold;
}

.tool-execution.error::before {
    color: #dc3545;
}

.tool-header {
    color: #28a745;
    font-weight: normal;
    margin-bottom: 2px;
}

.tool-summary {
    color: #87ceeb;
    margin-left: 5px;
    font-size: 13px;
}

.tool-details-expanded {
    background-color: #2f2f2f;
    border-radius: 4px;
    padding: 10px;
    margin-top: 5px;
    margin-left: 5px;
    cursor: pointer;
}

.tool-results-full {
    color: #e0e0e0;
    white-space: pre-wrap;
    font-family: inherit;
    font-size: 13px;
}

/* Remove hover effect for file results */
.file-result {
    color: #87ceeb;
}

.file-result:hover {
    color: #87ceeb;
}


/* Loading animation */
.loading-dots::after {
    content: '';
    animation: dots 1.5s infinite;
}

@keyframes dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
}

/* Message loading state */
.message.loading {
    color: #888;
    padding-left: 15px;
    position: relative;
}

.loading-spinner {
    position: absolute;
    left: 0;
    top: 0;
    display: inline-block;
    min-width: 1em;
}

/* Scratchpad thinking sections */
.message.scratchpad {
    color: #666;
    font-style: italic;
    border-left: 2px solid #333;
    background-color: rgba(255, 255, 255, 0.02);
    padding-left: 15px;
}

.message.scratchpad::before {
    content: '\2022';
    color: #e0e0e0;
    position: absolute;
    left: 0;
    top: 0;
    font-weight: bold;
    font-style: normal;
}

/* Retry button styling */
.retry-container {
    margin-top: 10px;
}

.retry-button {
    background-color: #28a745;
    color: #ffffff;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
    transition: background-color 0.2s;
}

.retry-button:hover {
    background-color: #218838;
}

.retry-button:active {
    background-color: #1e7e34;
}
-~{END}~-

-~{File: src/java-agent/web/index.html}~-
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Clone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/terminal.css">
</head>
<body>
    <div class="terminal-container">
        <div class="chat-area" id="chat-area">
            <div class="message assistant">
                Welcome to Claude Code Clone! I'm your AI coding assistant.<br><br>
                I can help you with:<br>
                &bull; Searching for files by name or content<br>
                &bull; Reading and analyzing file contents<br>
                &bull; Exploring directory structures<br>
                &bull; Code analysis and debugging<br><br>
                What would you like to work on?
            </div>
        </div>
        <div class="input-area">
            <span class="prompt">></span>
            <input type="text" class="input-field" id="message-input" placeholder="Ask me anything..." autocomplete="off">
        </div>
    </div>
    
    <script src="js/coding-assistant.js?v=2"></script>
</body>
</html>
-~{END}~-

-~{File: src/java-agent/SSE-STREAM-FIX.md}~-
# SSE Stream Fix for Tool Results

## Problem
When AI used tools and auto-click failed, the UI would get stuck in loading state because:
1. Tool executes successfully 
2. Auto-click fails (browser not responding)
3. System sends `CLICK_FAILED` message
4. System immediately sends `[DONE]` and closes the SSE stream
5. Frontend stops listening after `[DONE]`
6. When user retries or manually clicks, the response can't be sent
7. UI stays in "Loading..." state forever

## Root Cause
In `sendClickFailedMessage()`, the code was closing the SSE stream prematurely:
```java
sendSSEUpdate(pendingRequest.exchange, "data: " + failedResponse + "\n\n");
sendSSEUpdate(pendingRequest.exchange, "data: [DONE]\n\n");  // This closes the stream!

// Close the exchange
try {
    pendingRequest.exchange.getResponseBody().close();
} catch (Exception e) {
    System.err.println("Error closing exchange after click failed: " + e.getMessage());
}
```

The frontend's SSE handler stops processing when it sees `[DONE]`:
```javascript
if (dataStr === '[DONE]') return;  // Stops all further processing
```

## Solution
Don't send `[DONE]` after `CLICK_FAILED` - keep the stream open:
```java
sendSSEUpdate(pendingRequest.exchange, "data: " + failedResponse + "\n\n");
// Don't send [DONE] for click failures - keep the stream open
// so the user can retry or manually click
System.out.println("[CLICK-FAILED] Keeping SSE stream open for retry attempts");
```

The stream will be properly closed with `[DONE]` when:
- The actual response comes through (BROWSER_RESPONSE)
- The user cancels (ESC ESC)
- An error occurs (BROWSER_ERROR)

## Expected Behavior
- When auto-click fails, user sees "Auto-click failed" with retry button
- SSE stream stays open waiting for response
- User can retry auto-click or manually click
- When response comes through, it's properly sent to frontend
- UI updates correctly and loading state clears

## Files Changed
- `/home/claude-dev/coding-agent/src/java-agent/ChatServerAgent.java` - Modified `sendClickFailedMessage()` to not send `[DONE]` after click failures

## Related Fixes
This works together with the previous fixes:
1. REQUEST-ID-FIX: Ensures request IDs are properly tracked
2. TOOL-CLICK-FIX: Ensures tool results trigger auto-clicking
3. This fix: Ensures SSE stream stays open for responses after click failures
-~{END}~-

-~{File: src/browser-bridge/bridge-api.js}~-
// CCC Browser Bridge Script - Real API Flow Version
// This follows the actual Claude API flow from SPEC.md

// Export main function for testing, but also auto-initialize for production
var CCCBridgeAPI = (function() {
  'use strict';
  
  console.log('[CCC Bridge API] Initializing with real API flow...');
  
  // Generate realistic session ID
  function generateSessionId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < 20; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  
  // Configuration
  const CONFIG = {
    apiBase: window.location.origin, // Use same origin as the page
    colors: {
      calibrating: '#1a1a2e',
      ready: '#16213e',
      processing: '#0f3460',
      streaming: '#2d5016',
      success: '#53bf9d',
      error: '#e94560'
    },
    sessionId: generateSessionId() // Generate realistic session ID
  };
  
  // State
  let bridgeState = 'calibrating';
  let lastRequest = null;
  let clickCount = 0;
  let conversationCache = new Map(); // Cache conversations by chatId
  
  // Get auth token from localStorage (mock server sets this)
  const authToken = localStorage.getItem('token') || 'mock-token-12345';
  
  // Remove any existing bridge
  const existing = document.getElementById('ccc-bridge-overlay');
  if (existing) existing.remove();
  
  // Create full-page overlay
  const overlay = document.createElement('div');
  overlay.id = 'ccc-bridge-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: ${CONFIG.colors.calibrating};
    z-index: 999999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.3s;
    font-family: 'Courier New', monospace;
    color: white;
  `;
  
  // Create status display
  const statusDisplay = document.createElement('div');
  statusDisplay.style.cssText = `
    text-align: center;
    padding: 40px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    max-width: 600px;
  `;
  
  const title = document.createElement('h1');
  title.style.cssText = `margin: 0 0 20px 0; font-size: 36px;`;
  title.textContent = 'CCC Bridge API';
  
  const status = document.createElement('div');
  status.style.cssText = `font-size: 24px; margin-bottom: 10px;`;
  status.textContent = 'Click to calibrate';
  
  const info = document.createElement('div');
  info.style.cssText = `font-size: 16px; opacity: 0.8;`;
  info.textContent = 'Ready for calibration';
  
  const streamingContent = document.createElement('div');
  streamingContent.style.cssText = `
    margin-top: 20px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
    text-align: left;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
  `;
  
  statusDisplay.appendChild(title);
  statusDisplay.appendChild(status);
  statusDisplay.appendChild(info);
  statusDisplay.appendChild(streamingContent);
  overlay.appendChild(statusDisplay);
  
  // Helper functions
  function updateDisplay(state, message = '', showStreaming = false) {
    bridgeState = state;
    overlay.style.background = CONFIG.colors[state] || CONFIG.colors.ready;
    status.textContent = state.charAt(0).toUpperCase() + state.slice(1);
    info.textContent = message;
    streamingContent.style.display = showStreaming ? 'block' : 'none';
  }
  
  function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  // Lock+Queue Clipboard System
  let bridgeMessageQueue = [];
  let lastClipboardOpTime = 0; // No default - measure first
  let pollMultiplier = 5; // Start with x5
  
  // Queue a message to be sent to Java
  function queueMessageToJava(messageType, payload = {}) {
    const message = {
      type: messageType,
      timestamp: Date.now(),
      ...payload
    };
    
    bridgeMessageQueue.push(message);
    console.log('[CLIPBOARD] Queued message:', messageType, '(queue size:', bridgeMessageQueue.length + ')');
  }
  
  // Try to acquire clipboard lock and send our queue to Java
  async function sendQueueToJava() {
    const startTime = performance.now();
    let success = false;
    const maxRetries = 10;
    let retryCount = 0;
    
    while (retryCount < maxRetries && !success) {
      try {
        const timestamp = Date.now();
        const lockToken = `|||||BRIDGE LOCK|||||`;
        
        // Step 0: Check if clipboard is clear before trying to acquire lock
        const currentContent = await navigator.clipboard.readText();
        console.log('[CLIPBOARD-TRACE] Pre-lock check (attempt ' + (retryCount + 1) + ') - clipboard contains:', currentContent ? currentContent.substring(0, 100) + '...' : 'null');
        
        // Special handling for finding our own lock token
        if (currentContent === lockToken) {
          console.log('[CLIPBOARD] Found our own lock token - we already have the lock!');
          // We already have the lock, proceed directly to write message
          const queueJson = JSON.stringify(bridgeMessageQueue);
          const messageToken = `|||||MESSAGE->JAVA|||||${timestamp}|||||${queueJson}|||||END|||||`;
          await navigator.clipboard.writeText(messageToken);
          console.log('[CLIPBOARD-TRACE] Using existing lock, sent', bridgeMessageQueue.length, 'messages to Java');
          bridgeMessageQueue = []; // Clear queue
          success = true;
          break;
        }
        
        if (currentContent && (currentContent.startsWith('|||||MESSAGE->BRIDGE|||||') || 
                              currentContent.startsWith('|||||MESSAGE->JAVA|||||') ||
                              currentContent.startsWith('|||||JAVA LOCK|||||'))) {
          console.log('[CLIPBOARD] Clipboard busy with protocol message - retrying...');
          retryCount++;
          await new Promise(resolve => setTimeout(resolve, 20)); // Wait before retry
          continue;
        }
        
        // Step 1: Try to acquire lock (clipboard appears clear)
        console.log('[CLIPBOARD] Writing lock token (attempt ' + (retryCount + 1) + '):', lockToken);
        await navigator.clipboard.writeText(lockToken);
        await new Promise(resolve => setTimeout(resolve, 10)); // Brief delay for write to complete
        
        // Step 2: Verify we own the lock
        console.log('[CLIPBOARD] Reading back to verify lock...');
        const verification = await navigator.clipboard.readText();
        console.log('[CLIPBOARD] Verification result:', verification ? verification.substring(0, 100) + '...' : 'null');
        if (verification && verification === lockToken) {
        // Step 3: We won the lock, now write our actual message separately
        const queueJson = JSON.stringify(bridgeMessageQueue);
        const messageToken = `|||||MESSAGE->JAVA|||||${timestamp}|||||${queueJson}|||||END|||||`;
        await navigator.clipboard.writeText(messageToken);
        console.log('[CLIPBOARD-TRACE] Final message written to clipboard:', messageToken.substring(0, 100) + '...');
        
          console.log('[CLIPBOARD] Lock acquired, sent', bridgeMessageQueue.length, 'messages to Java');
          bridgeMessageQueue = []; // Clear queue
          success = true;
        } else {
          const clipboardPreview = verification ? verification.substring(0, 200) + '...' : 'null';
          console.log('[CLIPBOARD] Lock acquisition failed (attempt ' + (retryCount + 1) + ') - retrying...');
          console.log('[CLIPBOARD] Current clipboard content:', clipboardPreview);
          retryCount++;
          await new Promise(resolve => setTimeout(resolve, 20)); // Wait before retry
        }
        
      } catch (error) {
        console.log('[CLIPBOARD] Send failed (attempt ' + (retryCount + 1) + '):', error.message);
        
        // Handle focus issues
        if (error.message.includes('Document is not focused') || error.message.includes('not focused')) {
          console.error('[CLIPBOARD] FOCUS ISSUE: Browser tab lost focus - cannot continue retries');
          updateDisplay('error', 'Browser lost focus - click here to continue', false);
          break; // Stop retrying on focus issues
        }
        
        retryCount++;
        if (retryCount < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, 20)); // Wait before retry
        }
      }
    }
    
    // Handle final failure after all retries
    if (!success) {
      console.log('[CLIPBOARD] Failed to acquire lock after', maxRetries, 'attempts');
    }
    
    // Update adaptive timing
    const duration = performance.now() - startTime;
    lastClipboardOpTime = Math.max(1, duration);
    
    if (success) {
      pollMultiplier = 5; // Reset to x5 on success
    } else {
      pollMultiplier = Math.min(10, pollMultiplier + 1); // Increment up to x10
    }
    
    return success;
  }
  
  // Read messages from Java (if clipboard has messages for us)
  async function readMessagesFromJava() {
    const startTime = performance.now();
    let messages = [];
    
    try {
      const clipboardContent = await navigator.clipboard.readText();
      console.log('[CLIPBOARD-TRACE] readMessagesFromJava - clipboard contains:', clipboardContent ? clipboardContent.substring(0, 100) + '...' : 'null');
      if (!clipboardContent || clipboardContent.trim() === '') {
        return messages; // Empty clipboard is fine
      }
      
      // Check for message token directed at us (must be at start of clipboard)
      if (clipboardContent.startsWith('|||||MESSAGE->BRIDGE|||||')) {
        // This is a message for us from Java
        if (clipboardContent.includes('|||||END|||||')) {
          const timestamp = extractTimestampFromMessage(clipboardContent);
          const age = Date.now() - timestamp;
          
          if (age > 1000) {
            console.log('[CLIPBOARD] Found expired message (age:', age + 'ms), ignoring');
            // Don't clear - all components should recognize expired timestamps
            return messages;
          }
          
          // Extract and parse message queue
          messages = parseMessageQueue(clipboardContent);
          console.log('[CLIPBOARD] Read', messages.length, 'messages from Java');
          
          // Clear clipboard and send our queue (we own it now)
          if (bridgeMessageQueue.length > 0) {
            await sendQueueToJava();
          } else {
            await clearClipboard();
          }
        }
      }
      // Check for lock tokens
      else if (clipboardContent.startsWith('|||||BRIDGE LOCK|||||')) {
        // Our own lock token - we already have the lock!
        console.log('[CLIPBOARD] Found our own lock token - we have the lock');
        // If we have messages to send, send them now
        if (bridgeMessageQueue.length > 0) {
          await sendQueueToJava();
        }
        return messages;
      }
      else if (clipboardContent.startsWith('|||||JAVA LOCK|||||')) {
        // Java has the lock
        console.log('[CLIPBOARD-TRACE] Bridge sees Java lock token');
        return messages;
      }
      // For any other content (no protocol tokens), just ignore it - don't clear
      else {
        // No protocol tokens means this isn't our protocol traffic
        // Could be user copy/paste, other browser content, etc. - leave it alone
        return messages;
      }
      
    } catch (error) {
      console.log('[CLIPBOARD] Read failed:', error.message);
    }
    
    // Update adaptive timing
    const duration = performance.now() - startTime;
    lastClipboardOpTime = Math.max(1, duration);
    
    return messages;
  }
  
  async function clearClipboard() {
    try {
      await navigator.clipboard.writeText('');
    } catch (error) {
      console.log('[CLIPBOARD] Failed to clear:', error.message);
    }
  }
  
  function extractTimestampFromMessage(content) {
    try {
      // Extract timestamp from MESSAGE token format: |||||MESSAGE->RECIPIENT|||||TIMESTAMP|||||
      const parts = content.split('|||||');
      if (parts.length >= 3) {
        return parseInt(parts[2]);
      }
    } catch (e) {
      // Invalid timestamp, treat as very old
    }
    return 0;
  }
  
  function parseMessageQueue(content) {
    const messages = [];
    try {
      // Extract JSON between timestamp and END in MESSAGE format: |||||MESSAGE->RECIPIENT|||||TIMESTAMP|||||JSON|||||END|||||
      const start = content.indexOf('MESSAGE->');
      if (start >= 0) {
        const timestampStart = content.indexOf('|||||', start) + 5;
        const timestampEnd = content.indexOf('|||||', timestampStart);
        const jsonStart = timestampEnd + 5;
        const end = content.indexOf('|||||END|||||');
        
        if (jsonStart >= 0 && end >= 0) {
          const jsonContent = content.substring(jsonStart, end);
          console.log('[CLIPBOARD] Attempting to parse JSON:', jsonContent.substring(0, 200) + '...');
          console.log('[CLIPBOARD] JSON length:', jsonContent.length);
          
          try {
            const parsedMessages = JSON.parse(jsonContent);
            
            if (Array.isArray(parsedMessages)) {
              messages.push(...parsedMessages);
            }
          } catch (parseErr) {
            console.error('[CLIPBOARD] JSON parse failed at message level:', parseErr);
            console.error('[CLIPBOARD] Failed JSON content:', jsonContent);
            
            // Try to handle double-encoded JSON by looking for escaped quotes
            if (jsonContent.includes('\\"')) {
              console.log('[CLIPBOARD] Detected escaped quotes - attempting to handle double-encoded JSON');
              // For now, add the raw content as a special message type
              messages.push({
                type: 'RAW_MESSAGE',
                content: jsonContent,
                error: 'double-encoded'
              });
            }
            throw parseErr; // Re-throw to trigger error handling
          }
        }
      }
    } catch (error) {
      console.log('[CLIPBOARD] Failed to parse message queue:', error.message);
      console.log('[CLIPBOARD] Raw clipboard content that failed to parse:');
      console.log(clipboardContent);
      console.log('[CLIPBOARD] Full JSON parsing error:', error);
      
      // Send error response back to Java
      (async () => {
        try {
          queueMessageToJava('BROWSER_ERROR', {
            error: 'JSON parse error',
            details: error.message,
            clipboardPreview: clipboardContent ? clipboardContent.substring(0, 200) : 'null'
          });
          await sendQueueToJava();
          
          // Clear the malformed message to prevent repeated parsing attempts
          await clearClipboard();
        } catch (errorReportErr) {
          console.error('[CLIPBOARD] Failed to report error:', errorReportErr.message);
        }
      })();
    }
    return messages;
  }
  
  // Adaptive polling with backoff
  function adaptiveWait() {
    return new Promise(resolve => {
      // Only wait if we have measured an operation time
      if (lastClipboardOpTime > 0) {
        const waitTime = lastClipboardOpTime * pollMultiplier;
        setTimeout(resolve, waitTime);
      } else {
        // If no measurement yet, don't wait - start polling immediately
        resolve();
      }
    });
  }
  
  let clipboardMonitoringActive = false;
  let clipboardMonitoringPromise = null;
  
  // Start clipboard monitoring with lock+queue system
  // REMOVED: Browser cannot monitor clipboard - must be passive and only react to clicks
  // The browser is like a crank machine - Java turns the crank (clicks) to make it work
  async function startClipboardMonitoring() {
    console.log('[CLIPBOARD] Bridge is passive - waiting for Java clicks...');
    // Bridge does not monitor - it only reacts to clicks from Java
  }
  
  function stopClipboardMonitoring() {
    if (!clipboardMonitoringActive) {
      return; // Not running
    }
    
    console.log('[CLIPBOARD] Stopping monitoring - conversation complete');
    clipboardMonitoringActive = false;
    clipboardMonitoringPromise = null;
  }
  
  // Process incoming messages from Java
  async function processIncomingMessage(messageType, message) {
    try {
      switch (messageType) {
        case 'CCC_REQUEST':
          await handleCCCRequest(message);
          break;
        case 'CALIBRATION_CONFIRMED':
          // Java has confirmed calibration with screen position
          if (message.screenPosition) {
            console.log('[CCC Bridge API] Calibration confirmed at screen position:', message.screenPosition);
            updateDisplay('ready', `Calibrated! Java will click at screen position (${message.screenPosition.x}, ${message.screenPosition.y})`);
            // After a moment, show the normal ready message
            setTimeout(() => {
              updateDisplay('ready', 'Waiting for AI requests...');
            }, 2000);
          } else {
            updateDisplay('ready', 'Calibrated - waiting for AI requests...');
          }
          break;
        case 'RAW_MESSAGE':
          // Handle double-encoded messages
          if (message.error === 'double-encoded' && message.content) {
            try {
              // Parse the array
              const parsed = JSON.parse(message.content);
              if (Array.isArray(parsed)) {
                for (const msg of parsed) {
                  if (msg.type) {
                    await processIncomingMessage(msg.type, msg);
                  }
                }
              }
            } catch (e) {
              console.error('[CLIPBOARD] Failed to process RAW_MESSAGE:', e);
            }
          }
          break;
        default:
          console.log('[CLIPBOARD] Unknown message type:', messageType);
      }
    } catch (error) {
      console.log('[CLIPBOARD] Error processing message', messageType + ':', error.message);
    }
  }
  
  // Handle CCC_REQUEST messages from Java
  async function handleCCCRequest(message) {
    console.log('[CCC Bridge API] Raw message received:', JSON.stringify(message));
    
    // Extract the actual request data
    // If message has 'request' field, use that; otherwise use the message itself
    let requestData = message.request || message;
    console.log('[CCC Bridge API] Request data:', requestData);
    console.log('[CCC Bridge API] Request data type:', typeof requestData);
    
    // If requestData is a string, parse it
    if (typeof requestData === 'string') {
      try {
        requestData = JSON.parse(requestData);
        console.log('[CCC Bridge API] Parsed string to object:', requestData);
      } catch (e) {
        console.error('[CCC Bridge API] Failed to parse request string:', e);
        return;
      }
    }
    
    // Now requestData should be an object with the actual CCC_REQUEST fields
    if (requestData && requestData.type === 'CCC_REQUEST') {
      console.log('[CCC Bridge API] Processing CCC_REQUEST with id:', requestData.id);
      await processAIRequest(requestData);
    } else {
      console.error('[CCC Bridge API] Invalid request format, missing type:CCC_REQUEST');
    }
  }
  
  // Tool use detection - only detect if message starts with <execute>
  function isToolUse(content) {
    // Check if content contains <execute> tags within a <response>
    return content.includes('<execute>') && content.includes('</execute>');
  }
  
  // Stream completions for existing conversations
  async function streamCompletions(chatId, messages, conversation) {
    console.log('[CCC Bridge API] ===== STREAMING COMPLETIONS FOR EXISTING CONVERSATION =====');
    console.log('[CCC Bridge API] ChatId:', chatId);
    console.log('[CCC Bridge API] Messages count:', messages.length);
    
    updateDisplay('processing', 'Updating conversation...', true);
    
    // Step 1: Update conversation with new messages
    console.log('[CCC Bridge API] Step 1: Updating conversation with new messages...');
    
    // Build the conversation structure with new messages
    const chatMessages = [];
    const historyMessages = {};
    let currentId = null;
    let parentId = null;
    
    messages.forEach((msg, index) => {
      const messageId = generateUUID();
      const chatMessage = {
        "id": messageId,
        "parentId": parentId,
        "childrenIds": [],
        "role": msg.role,
        "content": msg.content,
        "timestamp": Math.floor(Date.now() / 1000),
        "models": ["Anthropic Claude 4 Sonnet"]
      };
      
      // Update parent's children
      if (parentId && historyMessages[parentId]) {
        historyMessages[parentId].childrenIds.push(messageId);
      }
      
      chatMessages.push(chatMessage);
      historyMessages[messageId] = chatMessage;
      currentId = messageId;
      parentId = messageId;
    });
    
    // Add assistant message slot
    const assistantMessageId = generateUUID();
    const assistantMessage = {
      "parentId": currentId,
      "id": assistantMessageId,
      "childrenIds": [],
      "role": "assistant",
      "content": "",
      "model": "Anthropic Claude 4 Sonnet",
      "modelName": "Anthropic Claude 4 Sonnet",
      "modelIdx": 0,
      "userContext": null,
      "timestamp": Math.floor(Date.now() / 1000)
    };
    
    // Update last user message's children
    if (currentId && historyMessages[currentId]) {
      historyMessages[currentId].childrenIds.push(assistantMessageId);
    }
    
    chatMessages.push(assistantMessage);
    historyMessages[assistantMessageId] = assistantMessage;
    
    const updateChatResponse = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json",
        "authorization": `Bearer ${authToken}`
      },
      body: JSON.stringify({
        "chat": {
          "models": ["Anthropic Claude 4 Sonnet"],
          "history": {
            "messages": historyMessages,
            "currentId": assistantMessageId
          },
          "messages": chatMessages,
          "params": {},
          "files": []
        }
      })
    });
    
    if (!updateChatResponse.ok) {
      const errorText = await updateChatResponse.text();
      console.error('[CCC Bridge API] Chat update failed:', updateChatResponse.status, errorText);
      throw new Error(`Chat update failed: ${updateChatResponse.status}`);
    }
    
    console.log('[CCC Bridge API] ✓ Conversation updated');
    
    // Step 2: Stream completions
    updateDisplay('processing', 'Streaming response...', true);
    streamingContent.textContent = '';
    
    let finalContent = '';
    
    const completionsResponse = await fetch(`${CONFIG.apiBase}/api/chat/completions`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${authToken}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "stream": true,
        "model": "Anthropic Claude 4 Sonnet",
        "messages": messages,  // Use the full messages array
        "params": {},
        "features": {
          "web_search": false
        },
        "session_id": CONFIG.sessionId,
        "chat_id": chatId,
        "id": assistantMessageId,
        "background_tasks": {
          "title_generation": true,
          "tags_generation": true
        }
      })
    });
    
    if (!completionsResponse.ok) {
      const errorText = await completionsResponse.text();
      console.error('[CCC Bridge API] Completions failed:', completionsResponse.status, errorText);
      throw new Error(`Completions failed: ${completionsResponse.status}`);
    }
    
    // Stream the response
    const reader = completionsResponse.body.getReader();
    const decoder = new TextDecoder();
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const dataStr = line.substring(6);
          if (dataStr === '[DONE]') {
            console.log('[CCC Bridge API] ✓ Streaming completed');
            updateDisplay('success', `Completed! Final length: ${finalContent.length} chars`, false);
            
            // Update conversation cache with final content
            if (chatId) {
              conversationCache.set(chatId, {
                chatId: chatId,
                messages: messages,
                assistantMessageId: generateUUID(), // For next assistant message
                timestamp: Date.now()
              });
            }
            
            // Return response with chatId
            const streamResponse = {
              type: 'BROWSER_RESPONSE',
              id: lastRequest?.id || 'unknown',
              timestamp: Date.now(),
              status: 'completed',
              payload: {
                content: finalContent,
                accumulated: finalContent,
                chatId: chatId  // Include chatId in response
              }
            };
            
            // Send final progress update to ensure last content is captured
            queueMessageToJava('BROWSER_PROGRESS', {
              id: lastRequest?.id || 'unknown',
              payload: {
                accumulated: finalContent,
                chatId: chatId
              }
            });
            
            // Queue final response
            queueMessageToJava('BROWSER_RESPONSE', {
              id: lastRequest?.id || 'unknown',
              status: 'completed',
              payload: {
                content: finalContent,
                accumulated: finalContent,
                chatId: chatId
              }
            });
            
            // Send final response immediately
            const success = await sendQueueToJava();
            if (!success) {
              console.error('[CCC Bridge API] Failed to send final response - communication may be broken');
              updateDisplay('error', 'Communication failed - browser focus issue');
            }
            return streamResponse;
          }
          
          try {
            const data = JSON.parse(dataStr);
            if (data.choices?.[0]?.delta?.content) {
              const content = data.choices[0].delta.content;
              finalContent += content;
              streamingContent.textContent = finalContent;
              
              // Queue progress update (less frequent to reduce clipboard contention)
              if (finalContent.length % 200 === 0 || finalContent.length < 200) { // Only send every 200 chars or less
                queueMessageToJava('BROWSER_PROGRESS', {
                  id: lastRequest?.id || 'unknown',
                  payload: {
                    accumulated: finalContent,
                    chatId: chatId
                  }
                });
                
                // Try to send immediately if queue is getting large
                if (bridgeMessageQueue.length >= 3) {
                  await sendQueueToJava();
                }
              }
            }
          } catch (parseError) {
            console.warn('[CCC Bridge API] Parse error:', parseError.message);
          }
        }
      }
    }
  }
  
  // API Functions following the spec
  async function createNewChat(prompt) {
    console.log('[CCC Bridge API] === CREATING NEW CHAT ===');
    console.log('[CCC Bridge API] Prompt length:', prompt.length);
    console.log('[CCC Bridge API] Prompt preview:', prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''));
    
    const userMessageId = generateUUID();
    const timestamp = Date.now();
    console.log('[CCC Bridge API] Generated user message ID:', userMessageId);
    console.log('[CCC Bridge API] Timestamp:', timestamp);
    
    const body = {
      "chat": {
        "params": {},
        "tags": [],
        "timestamp": timestamp,
        "title": "Chat Pending",
        "models": ["Anthropic Claude 4 Sonnet"],
        "messages": [
          {
            "id": userMessageId,
            "role": "user",
            "content": prompt,
            "timestamp": timestamp,
            "parentId": null,
            "children": []
          }
        ],
        "id": "",
        "history": {
          "currentId": userMessageId,
          "messages": [
            {
              "id": userMessageId,
              "role": "user",
              "content": prompt,
              "timestamp": timestamp,
              "parentId": null,
              "children": []
            }
          ]
        }
      }
    };
    
    console.log('[CCC Bridge API] Making chat creation request to:', `${CONFIG.apiBase}/api/v1/chats/new`);
    console.log('[CCC Bridge API] Chat creation body:', JSON.stringify(body, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/new`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(body)
    });
    
    console.log('[CCC Bridge API] Chat creation response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Chat creation failed:', response.status, errorText);
      throw new Error(`Chat creation failed: ${response.status} - ${errorText}`);
    }
    
    const result = await response.json();
    console.log('[CCC Bridge API] Chat creation result:', JSON.stringify(result, null, 2));
    return result;
  }
  
  async function getConversationState(chatId) {
    console.log('[CCC Bridge API] === GETTING CONVERSATION STATE ===');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Request URL:', `${CONFIG.apiBase}/api/v1/chats/${chatId}`);
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    console.log('[CCC Bridge API] Get state response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Get state failed:', response.status, errorText);
      throw new Error(`Get state failed: ${response.status} - ${errorText}`);
    }
    
    const result = await response.json();
    console.log('[CCC Bridge API] Get state result structure:');
    console.log('[CCC Bridge API] - Has result?', !!result);
    console.log('[CCC Bridge API] - Has chat?', !!result?.chat);
    console.log('[CCC Bridge API] - Has messages?', !!result?.chat?.messages);
    console.log('[CCC Bridge API] - Messages count:', result?.chat?.messages?.length || 0);
    console.log('[CCC Bridge API] Full get state result:', JSON.stringify(result, null, 2));
    
    return result;
  }
  
  async function createAssistantMessage(chatId, conversation, parentMessageId) {
    console.log('[CCC Bridge API] === CREATING ASSISTANT MESSAGE VIA POST ===');
    
    const assistantId = generateUUID();
    const timestamp = Date.now();
    
    console.log('[CCC Bridge API] Generated assistant ID:', assistantId);
    console.log('[CCC Bridge API] Parent message ID:', parentMessageId);
    console.log('[CCC Bridge API] Timestamp:', timestamp);
    
    // Debug logging
    console.log('[CCC Bridge API] Input conversation structure:', JSON.stringify(conversation, null, 2));
    
    // Clone conversation data
    const updatedConv = JSON.parse(JSON.stringify(conversation));
    
    // Create assistant message
    const assistantMessage = {
      id: assistantId,
      role: 'assistant',
      content: '',
      timestamp: timestamp,
      parentId: parentMessageId,
      children: []
    };
    
    // Ensure structure exists
    if (!updatedConv.chat) {
      console.error('[CCC Bridge API] No chat object in conversation:', updatedConv);
      throw new Error('Invalid conversation structure');
    }
    
    if (!updatedConv.chat.messages) {
      updatedConv.chat.messages = [];
    }
    
    if (!updatedConv.chat.history) {
      updatedConv.chat.history = { currentId: null, messages: [] };
    }
    
    if (!updatedConv.chat.history.messages) {
      updatedConv.chat.history.messages = [];
    }
    
    // Add to messages array
    updatedConv.chat.messages.push(assistantMessage);
    
    // Add to history.messages
    updatedConv.chat.history.messages.push(assistantMessage);
    
    // Update parent's children array
    const parentMessage = updatedConv.chat.messages.find(m => m.id === parentMessageId);
    if (parentMessage) {
      parentMessage.children.push(assistantId);
    }
    
    // Update currentId in history
    updatedConv.chat.history.currentId = assistantId;
    
    // Update updated_at timestamp
    updatedConv.updated_at = timestamp;
    
    console.log('[CCC Bridge API] Making POST request to update conversation...');
    console.log('[CCC Bridge API] URL:', `${CONFIG.apiBase}/api/v1/chats/${chatId}`);
    console.log('[CCC Bridge API] Updated conversation payload:', JSON.stringify(updatedConv, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(updatedConv)
    });
    
    console.log('[CCC Bridge API] POST response status:', response.status);
    console.log('[CCC Bridge API] POST response headers:', Object.fromEntries(response.headers.entries()));
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] POST failed:', response.status, errorText);
      throw new Error(`Update failed: ${response.status} - ${errorText}`);
    }
    
    const responseData = await response.json();
    console.log('[CCC Bridge API] POST response data:', JSON.stringify(responseData, null, 2));
    console.log('[CCC Bridge API] ✓ Successfully created assistant message via POST');
    
    return assistantId;
  }
  
  async function streamCompletion(chatId, messageId, conversation, onChunk) {
    console.log('[CCC Bridge API] === STARTING STREAM COMPLETION ===');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Message ID:', messageId);
    console.log('[CCC Bridge API] Conversation structure validation:');
    console.log('[CCC Bridge API] - Has conversation?', !!conversation);
    console.log('[CCC Bridge API] - Has conversation.chat?', !!conversation?.chat);
    console.log('[CCC Bridge API] - Has messages array?', !!conversation?.chat?.messages);
    console.log('[CCC Bridge API] - Messages count:', conversation?.chat?.messages?.length || 0);
    
    if (!conversation?.chat?.messages) {
      throw new Error('Invalid conversation structure: missing messages array');
    }
    
    // Debug logging
    console.log('[CCC Bridge API] Full conversation for completions:', JSON.stringify(conversation, null, 2));
    console.log('[CCC Bridge API] Messages structure:', conversation.chat.messages.map(m => ({
      id: m.id,
      role: m.role,
      contentLength: m.content?.length || 0,
      hasParentId: !!m.parentId,
      childrenCount: m.children?.length || 0
    })));
    
    // Build messages array for completions - only user messages for the model
    const userMessages = conversation.chat.messages.filter(m => m.role === 'user');
    console.log('[CCC Bridge API] Found user messages:', userMessages.length);
    
    const messages = userMessages.map(m => ({
      role: m.role,
      content: m.content
    }));
    
    console.log('[CCC Bridge API] Filtered messages for completion:', messages);
    
    if (messages.length === 0) {
      throw new Error('No user messages found to send to completions API');
    }
    
    const body = {
      "background_tasks": {
        "title_generation": true,
        "tags_generation": true
      },
      "chat_id": chatId,
      "features": {
        "web_search": false
      },
      "id": messageId,
      "messages": messages,
      "model": "Anthropic Claude 4 Sonnet",
      "params": {},
      "session_id": CONFIG.sessionId,
      "stream": true
    };
    
    console.log('[CCC Bridge API] Making completions request to:', `${CONFIG.apiBase}/api/chat/completions`);
    console.log('[CCC Bridge API] Full request body:', JSON.stringify(body, null, 2));
    
    const response = await fetch(`${CONFIG.apiBase}/api/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify(body)
    });
    
    console.log('[CCC Bridge API] Completions response status:', response.status);
    console.log('[CCC Bridge API] Completions response headers:', Object.fromEntries(response.headers.entries()));
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CCC Bridge API] Completions request failed:', response.status, errorText);
      throw new Error(`Stream failed: ${response.status} - ${errorText}`);
    }
    
    console.log('[CCC Bridge API] Starting to read SSE stream...');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let accumulated = '';
    let chunkCount = 0;
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        console.log('[CCC Bridge API] Stream ended, total chunks processed:', chunkCount);
        break;
      }
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');
      
      console.log('[CCC Bridge API] Received chunk with', lines.length, 'lines');
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const dataStr = line.substring(6);
            console.log('[CCC Bridge API] Processing SSE line:', dataStr.substring(0, 100) + (dataStr.length > 100 ? '...' : ''));
            
            if (dataStr === '[DONE]') {
              console.log('[CCC Bridge API] Received [DONE] marker, ending stream');
              return accumulated;
            }
            
            const data = JSON.parse(dataStr);
            chunkCount++;
            
            if (data.choices?.[0]?.delta?.content) {
              const newContent = data.choices[0].delta.content;
              accumulated += newContent;
              console.log('[CCC Bridge API] Added content chunk:', newContent.substring(0, 50) + (newContent.length > 50 ? '...' : ''));
              console.log('[CCC Bridge API] Total accumulated length:', accumulated.length);
              onChunk(accumulated, false);
            }
            if (data.choices?.[0]?.finish_reason === 'stop') {
              console.log('[CCC Bridge API] Received finish_reason=stop, ending stream');
              onChunk(accumulated, true);
              return accumulated;
            }
          } catch (e) {
            console.error('[CCC Bridge API] Parse error on line:', line.substring(0, 100));
            console.error('[CCC Bridge API] Parse error:', e);
          }
        } else if (line.trim()) {
          console.log('[CCC Bridge API] Non-data SSE line:', line.substring(0, 100));
        }
      }
    }
    
    return accumulated;
  }
  
  // Create assistant message manually (server doesn't auto-generate)
  async function createAssistantMessageSlot(chatId, parentMessageId) {
    console.log('[CCC Bridge API] ===== CREATING ASSISTANT MESSAGE SLOT =====');
    console.log('[CCC Bridge API] Chat ID:', chatId);
    console.log('[CCC Bridge API] Parent message ID:', parentMessageId);
    
    try {
      // Get current conversation state
      console.log('[CCC Bridge API] Step 1: Getting current conversation state...');
      const conversation = await getConversationState(chatId);
      console.log('[CCC Bridge API] Current conversation state before creating assistant message:');
      console.log('[CCC Bridge API] Messages count:', conversation.chat.messages.length);
      console.log('[CCC Bridge API] Messages:', conversation.chat.messages.map(m => ({id: m.id, role: m.role, contentLength: m.content?.length || 0})));
      
      // Create assistant message slot
      console.log('[CCC Bridge API] Step 2: Creating assistant message via POST...');
      const assistantId = await createAssistantMessage(chatId, conversation, parentMessageId);
      console.log('[CCC Bridge API] ✓ Successfully created assistant message slot:', assistantId);
      
      // Use the conversation we already have (optimization: skip verification GET)
      console.log('[CCC Bridge API] ===== ASSISTANT MESSAGE SLOT CREATION COMPLETE =====');
      return { assistantId, conversation };
      
    } catch (error) {
      console.error('[CCC Bridge API] ❌ ERROR in createAssistantMessageSlot:', error);
      console.error('[CCC Bridge API] Error stack:', error.stack);
      throw error;
    }
  }
  
  // Test function using api_template from browser global
  async function testWithApiTemplate() {
    console.log('[CCC Bridge API] ===== TESTING WITH API_TEMPLATE =====');
    
    try {
      // Get api_template from global variable
      const apiTemplateStr = window.api_template;
      if (!apiTemplateStr) {
        throw new Error('api_template global variable not found');
      }
      
      console.log('[CCC Bridge API] Found api_template, length:', apiTemplateStr.length);
      
      // Get auth token from localStorage
      const authToken = localStorage.getItem('token');
      if (!authToken) {
        throw new Error('Auth token not found in localStorage');
      }
      
      console.log('[CCC Bridge API] Found auth token, length:', authToken.length);
      
      // Replace ${auth} with actual token
      const templatedStr = apiTemplateStr.replace(/\${auth}/g, authToken);
      
      // Parse as JSON
      const apiTemplate = JSON.parse(templatedStr);
      console.log('[CCC Bridge API] Parsed api_template, found', apiTemplate.length, 'entries');
      
      let chatId = null;
      
      // Execute each request in sequence
      for (let i = 0; i < apiTemplate.length; i++) {
        const entry = apiTemplate[i];
        console.log('[CCC Bridge API] Processing entry', i + 1, ':', entry.url);
        
        // Handle first request (/api/v1/chats/new)
        if (entry.url === '/api/v1/chats/new') {
          console.log('[CCC Bridge API] Executing chat creation request...');
          
          const response = await fetch(`${CONFIG.apiBase}${entry.url}`, entry.options);
          console.log('[CCC Bridge API] Chat creation response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[CCC Bridge API] Chat creation failed:', response.status, errorText);
            throw new Error(`Chat creation failed: ${response.status}`);
          }
          
          const result = await response.json();
          chatId = result.id;
          console.log('[CCC Bridge API] ✓ Chat created with ID:', chatId);
          continue;
        }
        
        // Handle subsequent requests - replace ${chat_id}
        if (!chatId) {
          throw new Error('Chat ID not available for subsequent requests');
        }
        
        // Stringify, replace chat_id, parse back
        let entryStr = JSON.stringify(entry);
        entryStr = entryStr.replace(/\${chat_id}/g, chatId);
        const updatedEntry = JSON.parse(entryStr);
        
        console.log('[CCC Bridge API] Updated entry URL:', updatedEntry.url);
        
        // Handle /api/chat/completions specially (SSE streaming)
        if (updatedEntry.url === '/api/chat/completions') {
          console.log('[CCC Bridge API] ===== STARTING SSE STREAM =====');
          console.log('[CCC Bridge API] Request options:', JSON.stringify(updatedEntry.options, null, 2));
          
          const response = await fetch(`${CONFIG.apiBase}${updatedEntry.url}`, updatedEntry.options);
          console.log('[CCC Bridge API] SSE response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('[CCC Bridge API] SSE request failed:', response.status, errorText);
            throw new Error(`SSE request failed: ${response.status}`);
          }
          
          // Stream the SSE events
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let eventCount = 0;
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              console.log('[CCC Bridge API] SSE stream ended, total events:', eventCount);
              break;
            }
            
            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');
            
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                eventCount++;
                const dataStr = line.substring(6);
                console.log('[CCC Bridge API] SSE Event', eventCount + ':', dataStr);
                
                if (dataStr === '[DONE]') {
                  console.log('[CCC Bridge API] ===== SSE STREAM COMPLETE =====');
                  return;
                }
              }
            }
          }
          
          // Stop processing after completions
          break;
        }
        
        // Handle other requests normally
        console.log('[CCC Bridge API] Executing request to:', updatedEntry.url);
        
        const response = await fetch(`${CONFIG.apiBase}${updatedEntry.url}`, updatedEntry.options);
        console.log('[CCC Bridge API] Response status:', response.status);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('[CCC Bridge API] Request failed:', response.status, errorText);
          throw new Error(`Request failed: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('[CCC Bridge API] Response:', JSON.stringify(result, null, 2));
      }
      
    } catch (error) {
      console.error('[CCC Bridge API] ❌ ERROR in testWithApiTemplate:', error);
      console.error('[CCC Bridge API] Error stack:', error.stack);
    }
  }

  // Process AI request using hardcoded working API sequence
  async function processAIRequest(request) {
    try {
      // Store the current request for later use
      lastRequest = request;
      
      updateDisplay('processing', 'Processing chat request...');
      console.log('[CCC Bridge API] ===== PROCESSING WITH HARDCODED SEQUENCE =====');
      
      // Get auth token from localStorage
      const authToken = localStorage.getItem('token');
      if (!authToken) {
        throw new Error('Auth token not found in localStorage');
      }
      
      console.log('[CCC Bridge API] Found auth token, executing API sequence...');
      
      // Handle both old prompt format and new messages format
      let messages = [];
      if (request.payload.messages) {
        messages = request.payload.messages;
        console.log('[CCC Bridge API] Using messages array format, count:', messages.length);
      } else if (request.payload.prompt) {
        // Fallback for old format
        messages = [{
          role: 'user',
          content: request.payload.prompt
        }];
        console.log('[CCC Bridge API] Using legacy prompt format, converted to messages');
      }
      
      // Handle chatId and conversation caching
      const requestChatId = request.payload.chatId;
      let chatId = null;
      let conversation = null;
      
      console.log('[CCC Bridge API] Request chatId:', requestChatId);
      console.log('[CCC Bridge API] Cache size:', conversationCache.size);
      console.log('[CCC Bridge API] Cache keys:', Array.from(conversationCache.keys()));
      
      if (requestChatId && conversationCache.has(requestChatId)) {
        // Reuse existing conversation
        conversation = conversationCache.get(requestChatId);
        chatId = requestChatId;
        console.log('[CCC Bridge API] Reusing existing conversation:', chatId);
        
        // Skip to completions - we already have the conversation set up
        return await streamCompletions(chatId, messages, conversation);
      } else {
        // Create new conversation
        console.log('[CCC Bridge API] Creating new conversation...');
        if (requestChatId) {
          console.log('[CCC Bridge API] Requested chatId not in cache:', requestChatId);
        }
      }
      
      const userMessageId = generateUUID();
      const assistantMessageId = generateUUID();
      const timestamp = Date.now();
      let finalContent = '';
      
      updateDisplay('processing', 'Creating new chat...', true);
      streamingContent.textContent = '';
      
      // Step 1: Create new chat
      console.log('[CCC Bridge API] Step 1: Creating new chat...');
      const newChatResponse = await fetch(`${CONFIG.apiBase}/api/v1/chats/new`, {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json",
          "authorization": `Bearer ${authToken}`
        },
        body: JSON.stringify({
          "chat": {
            "id": "",
            "title": "Chat Pending",
            "models": ["Anthropic Claude 4 Sonnet"],
            "params": {},
            "history": {
              "messages": {
                [userMessageId]: {
                  "id": userMessageId,
                  "parentId": null,
                  "childrenIds": [],
                  "role": "user",
                  "content": messages.length > 0 ? messages[messages.length - 1].content : "",
                  "timestamp": Math.floor(timestamp / 1000),
                  "models": ["Anthropic Claude 4 Sonnet"]
                }
              },
              "currentId": userMessageId
            },
            "messages": [
              {
                "id": userMessageId,
                "parentId": null,
                "childrenIds": [],
                "role": "user",
                "content": messages.length > 0 ? messages[messages.length - 1].content : "",
                "timestamp": Math.floor(timestamp / 1000),
                "models": ["Anthropic Claude 4 Sonnet"]
              }
            ],
            "tags": [],
            "timestamp": timestamp
          }
        })
      });
      
      if (!newChatResponse.ok) {
        const errorText = await newChatResponse.text();
        console.error('[CCC Bridge API] Chat creation failed:', newChatResponse.status, errorText);
        throw new Error(`Chat creation failed: ${newChatResponse.status}`);
      }
      
      const chatResult = await newChatResponse.json();
      chatId = chatResult.id;
      console.log('[CCC Bridge API] ✓ Chat created with ID:', chatId);
      
      // Step 2: Add assistant message to chat
      console.log('[CCC Bridge API] Step 2: Adding assistant message...');
      updateDisplay('processing', 'Setting up assistant message...', true);
      
      const updateChatResponse = await fetch(`${CONFIG.apiBase}/api/v1/chats/${chatId}`, {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json",
          "authorization": `Bearer ${authToken}`
        },
        body: JSON.stringify({
          "chat": {
            "models": ["Anthropic Claude 4 Sonnet"],
            "history": {
              "messages": {
                [userMessageId]: {
                  "id": userMessageId,
                  "parentId": null,
                  "childrenIds": [assistantMessageId],
                  "role": "user",
                  "content": messages.length > 0 ? messages[messages.length - 1].content : "",
                  "timestamp": Math.floor(timestamp / 1000),
                  "models": ["Anthropic Claude 4 Sonnet"]
                },
                [assistantMessageId]: {
                  "parentId": userMessageId,
                  "id": assistantMessageId,
                  "childrenIds": [],
                  "role": "assistant",
                  "content": "",
                  "model": "Anthropic Claude 4 Sonnet",
                  "modelName": "Anthropic Claude 4 Sonnet",
                  "modelIdx": 0,
                  "userContext": null,
                  "timestamp": Math.floor(timestamp / 1000) + 2
                }
              },
              "currentId": assistantMessageId
            },
            "messages": [
              {
                "id": userMessageId,
                "parentId": null,
                "childrenIds": [assistantMessageId],
                "role": "user",
                "content": messages.length > 0 ? messages[messages.length - 1].content : "",
                "timestamp": Math.floor(timestamp / 1000),
                "models": ["Anthropic Claude 4 Sonnet"]
              },
              {
                "parentId": userMessageId,
                "id": assistantMessageId,
                "childrenIds": [],
                "role": "assistant",
                "content": "",
                "model": "Anthropic Claude 4 Sonnet",
                "modelName": "Anthropic Claude 4 Sonnet",
                "modelIdx": 0,
                "userContext": null,
                "timestamp": Math.floor(timestamp / 1000) + 2
              }
            ],
            "params": {},
            "files": []
          }
        })
      });
      
      if (!updateChatResponse.ok) {
        const errorText = await updateChatResponse.text();
        console.error('[CCC Bridge API] Chat update failed:', updateChatResponse.status, errorText);
        throw new Error(`Chat update failed: ${updateChatResponse.status}`);
      }
      
      console.log('[CCC Bridge API] ✓ Assistant message added to chat');
      
      // Step 3: Stream completions
      console.log('[CCC Bridge API] Step 3: Starting completions stream...');
      updateDisplay('streaming', 'Streaming response...', true);
      
      const completionsResponse = await fetch(`${CONFIG.apiBase}/api/chat/completions`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${authToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          "stream": true,
          "model": "Anthropic Claude 4 Sonnet",
          "messages": messages,
          "params": {},
          "features": {
            "web_search": false
          },
          "session_id": CONFIG.sessionId,
          "chat_id": chatId,
          "id": assistantMessageId,
          "background_tasks": {
            "title_generation": true,
            "tags_generation": true
          }
        })
      });
      
      if (!completionsResponse.ok) {
        const errorText = await completionsResponse.text();
        console.error('[CCC Bridge API] Completions request failed:', completionsResponse.status, errorText);
        throw new Error(`Completions request failed: ${completionsResponse.status}`);
      }
      
      // Stream the SSE events
      const reader = completionsResponse.body.getReader();
      const decoder = new TextDecoder();
      let eventCount = 0;
      
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          console.log('[CCC Bridge API] SSE stream ended, total events:', eventCount);
          break;
        }
        
        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            eventCount++;
            const dataStr = line.substring(6);
            console.log('[CCC Bridge API] SSE Event', eventCount + ':', dataStr);
            
            if (dataStr === '[DONE]') {
              console.log('[CCC Bridge API] ===== SSE STREAM COMPLETE =====');
              
              // Check if final complete content is tool use
              let finalResponse;
              if (isToolUse(finalContent)) {
                console.log('[CCC Bridge API] Detected tool use in final response');
                finalResponse = {
                  type: 'BROWSER_RESPONSE',
                  id: request.id,
                  timestamp: Date.now(),
                  status: 'tool_use',
                  payload: {
                    content: finalContent,
                    chatId: chatId,
                    model: 'Anthropic Claude 4 Sonnet'
                  }
                };
                updateDisplay('success', 'Tool use detected - response sent!');
              } else {
                console.log('[CCC Bridge API] Regular response (no tool use)');
                finalResponse = {
                  type: 'BROWSER_RESPONSE',
                  id: request.id,
                  timestamp: Date.now(),
                  status: 'success',
                  payload: {
                    content: finalContent,
                    chatId: chatId,
                    model: 'Anthropic Claude 4 Sonnet'
                  }
                };
                updateDisplay('success', 'Response sent!');
              }
              
              console.log('[CCC Bridge API] CLIPBOARD DEBUG - finalResponse object:', finalResponse);
              console.log('[CCC Bridge API] CLIPBOARD DEBUG - finalResponse type:', typeof finalResponse);
              console.log('[CCC Bridge API] CLIPBOARD DEBUG - finalResponse is undefined:', finalResponse === undefined);
              
              // Safety check to prevent writing undefined
              if (finalResponse === undefined || finalResponse === null) {
                console.error('[CCC Bridge API] ERROR: finalResponse is undefined/null, this should not happen!');
                finalResponse = {
                  type: 'BROWSER_RESPONSE',
                  id: request?.id || 'unknown',
                  timestamp: Date.now(),
                  status: 'error',
                  payload: {
                    error: 'Browser bridge: finalResponse was undefined',
                    chatId: chatId
                  }
                };
                console.log('[CCC Bridge API] CLIPBOARD DEBUG - Created emergency response:', finalResponse);
              }
              
              console.log('[CCC Bridge API] CLIPBOARD DEBUG - finalResponse stringified:', JSON.stringify(finalResponse));
              
              // Queue the final response to Java
              queueMessageToJava('BROWSER_RESPONSE', {
                id: finalResponse.id,
                status: finalResponse.status,
                payload: finalResponse.payload
              });
              
              // Send the response immediately
              const finalWriteSuccess = await sendQueueToJava();
              if (!finalWriteSuccess) {
                console.error('[CCC Bridge API] CRITICAL: Failed to write final response to clipboard!');
                updateDisplay('error', 'Communication failed - please click to regain focus and retry');
                return; // Don't continue processing
              }
              console.log('[CCC Bridge API] Final response written to clipboard');
              
              // Cache conversation for future reuse
              if (chatId) {
                conversationCache.set(chatId, {
                  chatId: chatId,
                  messages: messages,
                  assistantMessageId: generateUUID(), // For next assistant message
                  timestamp: Date.now()
                });
                console.log('[CCC Bridge API] Cached conversation:', chatId);
              }
              
              // Add delay to give Java time to read the response before any other clipboard operations
              setTimeout(() => {
                updateDisplay('ready', 'Waiting for AI requests...');
                console.log('[CCC Bridge API] Ready for next request after response processing delay');
              }, 2000); // Increased delay to ensure Java reads the response
              
              return finalResponse;
            }
            
            // Parse and accumulate content
            try {
              const data = JSON.parse(dataStr);
              if (data.choices?.[0]?.delta?.content) {
                const newContent = data.choices[0].delta.content;
                finalContent += newContent;
                streamingContent.textContent = finalContent;
                streamingContent.scrollTop = streamingContent.scrollHeight;
                
                // Don't check for tool use during streaming - wait for complete response
                
                // Note: Progress updates removed to avoid clipboard focus errors
                // The final response will contain the complete content
              }
            } catch (parseError) {
              console.warn('[CCC Bridge API] Could not parse SSE data:', parseError.message);
            }
          }
        }
      }
      
    } catch (error) {
      console.error('[CCC Bridge API] Error:', error);
      return {
        type: 'BROWSER_RESPONSE',
        id: request.id,
        timestamp: Date.now(),
        status: 'error',
        payload: {
          error: error.message
        }
      };
    }
  }
  
  // Handle clicks
  overlay.addEventListener('click', async (e) => {
    clickCount++;
    console.log(`[CCC Bridge API] Click #${clickCount} at ${e.clientX}, ${e.clientY}`);
    
    // ALWAYS check for pending messages first, regardless of state
    try {
      console.log('[CLIPBOARD-TRACE] Click handler - checking for messages before processing click...');
      const messages = await readMessagesFromJava();
      for (const message of messages) {
        if (message.type) {
          await processIncomingMessage(message.type, message);
        }
      }
    } catch (readErr) {
      console.log('[CLIPBOARD] Failed to read messages on click:', readErr.message);
    }
    
    // If we're in an error state due to focus issues, try to recover
    if (bridgeState === 'error' && status.textContent.includes('focus')) {
      console.log('[CCC Bridge API] Attempting to recover from focus issue...');
      try {
        window.focus();
        // Test if we can write to clipboard again
        await navigator.clipboard.writeText('test');
        updateDisplay('ready', 'Focus restored - ready for requests');
        console.log('[CCC Bridge API] Focus recovery successful');
        return;
      } catch (testError) {
        console.error('[CCC Bridge API] Focus recovery failed:', testError);
        updateDisplay('error', 'Still no clipboard access - ensure browser tab is focused');
        return;
      }
    }
    
    // For ready state, send click confirmation
    if (bridgeState === 'ready') {
      try {
        // Send click confirmation (messages already read at top of handler)
        try {
          queueMessageToJava('CLICK_CONFIRMED', {
            position: { x: e.clientX, y: e.clientY },
            clickCount: clickCount
          });
          
          // Send click confirmation immediately (high priority)
          await sendQueueToJava();
        } catch (confirmErr) {
          console.error('[CCC Bridge API] Failed to send click confirmation:', confirmErr);
        }
      } catch (err) {
        console.error('[CCC Bridge API] Error:', err);
        updateDisplay('error', err.message);
      }
      return;
    }
    
    if (bridgeState === 'calibrating') {
      // Send calibration message
      try {
        queueMessageToJava('CCC_CALIBRATION', {
          clicked: true,
          position: { x: e.clientX, y: e.clientY },
          clickCount: clickCount
        });
        
        // Send calibration immediately (high priority)
        await sendQueueToJava();
        
        // Update display to show we're waiting for Java
        updateDisplay('calibrating', 'Hold mouse position - Java is capturing screen coordinates...');
        
        // Don't change to ready state yet - wait for CALIBRATION_CONFIRMED from Java
        
      } catch (err) {
        console.error('[CCC Bridge API] Calibration failed:', err);
        updateDisplay('error', 'Clipboard access failed');
      }
      return;
    }
  });
  
  // Add to page
  document.body.appendChild(overlay);
  
  // Set mock token if needed
  if (!localStorage.getItem('token')) {
    localStorage.setItem('token', 'mock-token-12345');
  }
  
  // Add ESC ESC cancellation handler
  let lastEscTime = 0;
  document.addEventListener('keydown', async (e) => {
    if (e.key === 'Escape') {
      const now = Date.now();
      if (now - lastEscTime < 500) { // Double ESC within 500ms
        console.log('[CCC Bridge API] Double ESC detected - sending cancellation');
        try {
          queueMessageToJava('USER_CANCELLED', {
            reason: 'User pressed ESC ESC'
          });
          
          await sendQueueToJava();
          updateDisplay('error', 'Cancelled by user (ESC ESC)');
          setTimeout(() => updateDisplay('ready', 'Waiting for AI requests...'), 2000);
        } catch (err) {
          console.error('[CCC Bridge API] Failed to send cancellation:', err);
        }
      }
      lastEscTime = now;
    }
  });
  
  console.log('[CCC Bridge API] Ready with real API flow (ESC ESC to cancel)');
  
  // Initialization complete - overlay click handler will handle calibration directly
  
  // Return API object with internal functions exposed for testing
  return {
    // Debugging functions
    getState: () => ({ state: bridgeState, clicks: clickCount, lastRequest }),
    recalibrate: () => updateDisplay('calibrating'),
    remove: () => overlay.remove(),
    testTemplate: testWithApiTemplate,
    
    // Core functions exposed for testing
    readMessagesFromJava,
    sendQueueToJava,
    queueMessageToJava,
    clearClipboard,
    adaptiveWait,
    
    // State access for testing
    getBridgeState: () => bridgeState,
    getMessageQueue: () => [...bridgeMessageQueue]
  };
})();

// Auto-initialize and also export for testing
if (typeof window !== 'undefined') {
  window.CCCBridgeAPI = CCCBridgeAPI;
}

// Export for Node.js testing
if (typeof module !== 'undefined' && module.exports) {
  module.exports = CCCBridgeAPI;
}
-~{END}~-

-~{File: run-prod.bat}~-
@echo off
echo ================================
echo CCC Chat Server (Production)
echo ================================
echo.

echo Cleaning up any existing CCC processes...

REM Kill any existing Java processes running on port 4444 or CCC agents
echo Killing existing CCC processes...
powershell -Command "Get-NetTCPConnection -LocalPort 4444 -ErrorAction SilentlyContinue | ForEach-Object { $proc = Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue; if($proc) { Write-Host 'Killing process' $proc.ProcessName $proc.Id 'on port 4444'; Stop-Process -Id $proc.Id -Force } }" 2>nul

powershell -Command "Get-Process -Name java -ErrorAction SilentlyContinue | Where-Object { $_.CommandLine -like '*ChatServerAgent*' -or $_.CommandLine -like '*StandaloneAgent*' -or $_.CommandLine -like '*ClipboardAgent*' -or $_.CommandLine -like '*chat-server.jar*' } | ForEach-Object { Write-Host 'Killing Java process' $_.Id; Stop-Process -Id $_.Id -Force }" 2>nul

echo Waiting for processes to terminate...
timeout /t 2 > nul

REM Compile all Java files that are present
echo Compiling Java agents...
cd src\java-agent

echo Checking for Java source files...
dir *.java >nul 2>&1
if errorlevel 1 (
    echo No Java source files found!
    cd ..\..
    pause
    exit /b 1
)

echo Compiling all Java files in directory...
javac *.java
if errorlevel 1 (
    echo Java compilation failed!
    cd ..\..
    pause
    exit /b 1
)

REM Create manifest file for JAR
echo Main-Class: ChatServerAgent > manifest.txt
echo. >> manifest.txt
jar cvfm chat-server.jar manifest.txt *.class
if errorlevel 1 (
    echo JAR creation failed!
    cd ..\..
    pause
    exit /b 1
)
del manifest.txt
cd ..\..
echo JAR created: src\java-agent\chat-server.jar

echo.
echo ================================
echo STARTING CCC CODING AGENT
echo ================================
echo.
echo The coding agent will:
echo 1. Start HTTP server on port 4444
echo 2. Auto-launch Chrome with terminal-style coding interface
echo 3. Wait for you to paste bridge script in Claude UI
echo 4. Handle requests and tool execution via clipboard bridge
echo.
echo Coding agent interface will be available at:
echo http://localhost:4444
echo.
echo Instructions for setup:
echo 1. When Chrome opens, keep it open (coding agent UI)
echo 2. Open your internal Claude UI in another tab/window
echo 3. Open Developer Console (F12) in Claude UI
echo 4. Copy and paste the bridge script (it will be in your clipboard)
echo 5. Click the calibration overlay to set click position
echo 6. Return to the coding interface and ask for help (try "search for java files")!
echo.
echo Starting chat server...
java -jar src\java-agent\chat-server.jar

pause
-~{END}~-
