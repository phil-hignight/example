/**
 * Clipboard Chat - Bundled Browser Version
 * Copy this entire file and paste into browser devtools console
 *
 * Generated: 2025-12-10T17:00:02.578Z
 */

(() => {
  // packages/ai/src/browser-clipboard.js
  function generateUUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  function generateSessionId() {
    return Date.now().toString();
  }
  var BrowserClipboardAI = class {
    constructor(options = {}) {
      this.apiBase = options.apiBase || "https://chat.niprgpt.mil/api";
      this.model = options.model || "Anthropic Claude 4 Sonnet";
      this.sessionId = generateSessionId();
      this.chatId = null;
      this.messageHistory = [];
    }
    /**
     * Create a new chat
     */
    async createNewChat(firstMessage) {
      const messageId = generateUUID();
      const response = await fetch(`${this.apiBase}/v1/chats/new`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session_id: this.sessionId,
          message: {
            id: messageId,
            author: { role: "user" },
            content: {
              content_type: "text",
              parts: [firstMessage.content]
            },
            metadata: {},
            create_time: Date.now() / 1e3
          }
        })
      });
      if (!response.ok) {
        throw new Error(`Failed to create chat: ${response.statusText}`);
      }
      const data = await response.json();
      return {
        chatId: data.chat_id,
        messageId
      };
    }
    /**
     * Update chat with new messages
     */
    async updateChat(messages) {
      const response = await fetch(`${this.apiBase}/v1/chats/${this.chatId}`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session_id: this.sessionId,
          messages,
          enable_title_generation: true,
          enable_tag_generation: true
        })
      });
      if (!response.ok) {
        throw new Error(`Failed to update chat: ${response.statusText}`);
      }
      return await response.json();
    }
    /**
     * Convert simple messages to clipboard format
     */
    convertMessagesToClipboardFormat(messages) {
      const clipboardMessages = [];
      let parentId = null;
      for (const msg of messages) {
        const existing = this.messageHistory.find(
          (h) => h.author.role === msg.role && h.content.parts[0] === msg.content
        );
        if (existing) {
          parentId = existing.id;
          continue;
        }
        const messageId = generateUUID();
        const clipboardMsg = {
          id: messageId,
          author: { role: msg.role },
          content: {
            content_type: "text",
            parts: [msg.content]
          },
          metadata: {},
          create_time: Date.now() / 1e3
        };
        if (parentId) {
          clipboardMsg.metadata.parent_id = parentId;
        }
        clipboardMessages.push(clipboardMsg);
        this.messageHistory.push(clipboardMsg);
        parentId = messageId;
      }
      return clipboardMessages;
    }
    /**
     * Stream message from AI
     * @param {Array} messages - Message history
     */
    async *streamMessage(messages) {
      const clipboardMessages = this.convertMessagesToClipboardFormat(messages);
      if (!this.chatId) {
        const firstMessage = messages[0];
        const { chatId } = await this.createNewChat(firstMessage);
        this.chatId = chatId;
      }
      if (clipboardMessages.length > 0) {
        await this.updateChat(clipboardMessages);
      }
      const lastUserMessage = messages.filter((m) => m.role === "user").pop();
      if (!lastUserMessage) {
        throw new Error("No user message found");
      }
      const response = await fetch(`${this.apiBase}/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.model,
          messages: this.messageHistory,
          stream: true,
          session_id: this.sessionId,
          chat_id: this.chatId,
          timeout: 30,
          max_retries: 5
        })
      });
      if (!response.ok) {
        throw new Error(`Failed to get completion: ${response.statusText}`);
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6);
            if (data === "[DONE]") continue;
            try {
              const parsed = JSON.parse(data);
              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                yield content;
              }
            } catch (e) {
            }
          }
        }
      }
    }
  };

  // packages/datastore/src/browser-filesystem.js
  var BrowserFileSystemDatastore = class {
    /**
     * Create a Browser FileSystem datastore
     * @param {Object} options
     * @param {FileSystemDirectoryHandle} options.directoryHandle - Handle to selected directory
     */
    constructor(options = {}) {
      const { directoryHandle } = options;
      if (!directoryHandle) {
        throw new Error("directoryHandle is required for BrowserFileSystemDatastore");
      }
      this.rootHandle = directoryHandle;
      this.agentHandle = null;
    }
    /**
     * Initialize the .agent directory
     * @returns {Promise<void>}
     */
    async init() {
      this.agentHandle = await this.rootHandle.getDirectoryHandle(".agent", { create: true });
    }
    /**
     * Ensure initialized
     * @private
     */
    async _ensureInit() {
      if (!this.agentHandle) {
        await this.init();
      }
    }
    async read(filename) {
      await this._ensureInit();
      try {
        const fileHandle = await this.agentHandle.getFileHandle(filename);
        const file = await fileHandle.getFile();
        return await file.text();
      } catch (err) {
        throw new Error(`File not found: ${filename}`);
      }
    }
    async write(filename, content) {
      await this._ensureInit();
      const fileHandle = await this.agentHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(content);
      await writable.close();
    }
    async exists(filename) {
      await this._ensureInit();
      try {
        await this.agentHandle.getFileHandle(filename);
        return true;
      } catch (err) {
        return false;
      }
    }
    async list() {
      await this._ensureInit();
      const files = [];
      for await (const entry of this.agentHandle.values()) {
        if (entry.kind === "file") {
          files.push(entry.name);
        }
      }
      return files;
    }
    async delete(filename) {
      await this._ensureInit();
      try {
        await this.agentHandle.removeEntry(filename);
      } catch (err) {
      }
    }
  };

  // apps/clipboard/src/clipboard-chat.js
  function escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  function renderMessage(message) {
    const isUser = message.role === "user";
    const bgColor = isUser ? "#667eea" : "#f3f4f6";
    const textColor = isUser ? "white" : "#1f2937";
    const align = isUser ? "flex-end" : "flex-start";
    return `
    <div style="display: flex; justify-content: ${align}; margin-bottom: 16px;">
      <div style="
        max-width: 70%;
        padding: 12px 16px;
        border-radius: 12px;
        background: ${bgColor};
        color: ${textColor};
        word-wrap: break-word;
      ">
        <div style="font-size: 12px; opacity: 0.7; margin-bottom: 4px;">
          ${isUser ? "You" : "Assistant"}
        </div>
        <div style="white-space: pre-wrap;">${escapeHtml(message.content)}</div>
      </div>
    </div>
  `;
  }
  function renderChatMessages(state) {
    const messagesHtml = state.messages.map((msg) => renderMessage(msg)).join("");
    return `
    <div id="messages-container" style="
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: white;
    ">
      ${messagesHtml}
      ${state.isLoading && state.streamingContent ? `
        <div style="display: flex; justify-content: flex-start; margin-bottom: 16px;">
          <div style="
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 12px;
            background: #f3f4f6;
            color: #1f2937;
            word-wrap: break-word;
          ">
            <div style="font-size: 12px; opacity: 0.7; margin-bottom: 4px;">Assistant</div>
            <div style="white-space: pre-wrap;">${escapeHtml(state.streamingContent)}<span style="animation: blink 1s infinite;">\u258A</span></div>
          </div>
        </div>
      ` : state.isLoading ? `
        <div style="display: flex; justify-content: flex-start; margin-bottom: 16px;">
          <div style="
            padding: 12px 16px;
            border-radius: 12px;
            background: #f3f4f6;
            color: #1f2937;
          ">
            <div style="font-size: 12px; opacity: 0.7; margin-bottom: 4px;">Assistant</div>
            <div>Thinking...</div>
          </div>
        </div>
      ` : ""}
      ${state.messages.length === 0 && !state.isLoading ? `
        <div style="
          text-align: center;
          color: #9ca3af;
          padding: 40px 20px;
        ">
          <p style="font-size: 18px; margin-bottom: 8px;">Welcome to AI Chat</p>
          <p>Send a message to start the conversation</p>
        </div>
      ` : ""}
      <style>
        @keyframes blink {
          0%, 50% { opacity: 1; }
          51%, 100% { opacity: 0; }
        }
      </style>
    </div>
  `;
  }
  function renderChatInput(state) {
    return `
    <div style="
      padding: 20px;
      background: white;
      border-top: 1px solid #e5e7eb;
    ">
      ${state.error ? `
        <div style="
          background: #fee2e2;
          color: #991b1b;
          padding: 12px;
          border-radius: 8px;
          margin-bottom: 12px;
          font-size: 14px;
        ">
          ${state.error}
        </div>
      ` : ""}
      <div style="display: flex; gap: 12px;">
        <input
          id="clipboard-chat-input"
          type="text"
          placeholder="Type your message..."
          ${state.isLoading ? "disabled" : ""}
          style="
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            ${state.isLoading ? "opacity: 0.5; cursor: not-allowed;" : ""}
          "
        />
        <button
          id="clipboard-send-btn"
          ${state.isLoading ? "disabled" : ""}
          style="
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            ${state.isLoading ? "opacity: 0.5; cursor: not-allowed;" : ""}
          "
        >
          Send
        </button>
      </div>
    </div>
  `;
  }
  function renderApp(state) {
    return `
    <div style="display: flex; flex-direction: column; height: 100vh; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: #f9fafb;">
      <header style="color: white; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
        <h1 style="margin: 0; font-size: 24px; font-weight: 600;">AI Chat</h1>
        <p style="font-size: 14px; margin: 4px 0 0 0; opacity: 0.9;">Powered by Claude</p>
      </header>
      ${renderChatMessages(state)}
      ${renderChatInput(state)}
    </div>
  `;
  }
  var appState = {
    messages: [],
    isLoading: false,
    streamingContent: "",
    error: null
  };
  var stateListeners = [];
  function setState(updates) {
    appState = { ...appState, ...updates };
    stateListeners.forEach((fn) => fn(appState));
  }
  function onStateChange(fn) {
    stateListeners.push(fn);
  }
  var clipboardAI = null;
  var datastore = null;
  async function initDatastore() {
    try {
      const dirHandle = await window.showDirectoryPicker({
        mode: "readwrite"
      });
      datastore = new BrowserFileSystemDatastore({ directoryHandle: dirHandle });
      await datastore.init();
      await loadConversation();
    } catch (err) {
      console.error("Failed to initialize datastore:", err);
      setState({ error: "Failed to access directory. Please refresh and try again." });
    }
  }
  async function saveConversation() {
    if (!datastore) return;
    try {
      const data = {
        messages: appState.messages,
        timestamp: Date.now()
      };
      await datastore.write("conversation.json", JSON.stringify(data, null, 2));
    } catch (err) {
      console.error("Failed to save conversation:", err);
    }
  }
  async function loadConversation() {
    if (!datastore) return;
    try {
      const exists = await datastore.exists("conversation.json");
      if (exists) {
        const content = await datastore.read("conversation.json");
        const data = JSON.parse(content);
        if (data.messages && Array.isArray(data.messages)) {
          setState({ messages: data.messages });
        }
      }
    } catch (err) {
      console.error("Failed to load conversation:", err);
    }
  }
  async function handleSendMessage() {
    const input = document.getElementById("clipboard-chat-input");
    if (!input || !input.value.trim()) return;
    const userMessage = input.value.trim();
    input.value = "";
    const newMessages = [...appState.messages, { role: "user", content: userMessage }];
    setState({
      messages: newMessages,
      isLoading: true,
      streamingContent: "",
      error: null
    });
    try {
      if (!clipboardAI) {
        clipboardAI = new BrowserClipboardAI({
          apiBase: "https://chat.niprgpt.mil/api",
          model: "Anthropic Claude 4 Sonnet"
        });
      }
      let fullResponse = "";
      for await (const chunk of clipboardAI.streamMessage(newMessages)) {
        fullResponse += chunk;
        setState({ streamingContent: fullResponse });
      }
      setState({
        messages: [...newMessages, { role: "assistant", content: fullResponse }],
        isLoading: false,
        streamingContent: ""
      });
      await saveConversation();
    } catch (err) {
      console.error("Failed to send message:", err);
      setState({
        isLoading: false,
        streamingContent: "",
        error: `Failed to send message: ${err.message}`
      });
    }
  }
  async function initClipboardChat() {
    console.log("[Clipboard Chat] Initializing...");
    const container = document.createElement("div");
    container.id = "clipboard-chat-app";
    container.style.cssText = "position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 999999;";
    document.body.appendChild(container);
    let isScrollAnchored = true;
    let previousMessageCount = 0;
    let previousIsLoading = false;
    function render() {
      const currentState = appState;
      const messageJustStarted = !previousIsLoading && currentState.isLoading;
      const messageCountChanged = currentState.messages.length !== previousMessageCount;
      const messagesContainer = container.querySelector("#messages-container");
      const isNearBottom = !messagesContainer || messagesContainer.scrollHeight - messagesContainer.scrollTop <= messagesContainer.clientHeight + 100;
      if ((messageJustStarted || messageCountChanged) && isNearBottom) {
        isScrollAnchored = true;
      }
      container.innerHTML = renderApp(currentState);
      const newMessagesContainer = container.querySelector("#messages-container");
      if (isScrollAnchored && newMessagesContainer) {
        newMessagesContainer.scrollTop = newMessagesContainer.scrollHeight;
      }
      const input = document.getElementById("clipboard-chat-input");
      const sendBtn = document.getElementById("clipboard-send-btn");
      if (input) {
        input.onkeydown = (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            handleSendMessage();
          }
        };
        if (!currentState.isLoading) {
          input.focus();
        }
      }
      if (sendBtn) {
        sendBtn.onclick = handleSendMessage;
      }
      if (newMessagesContainer) {
        let lastScrollTop = newMessagesContainer.scrollTop;
        newMessagesContainer.addEventListener("scroll", () => {
          const currentScrollTop = newMessagesContainer.scrollTop;
          const userScrolledUp = currentScrollTop < lastScrollTop - 5;
          const userScrolledDown = currentScrollTop > lastScrollTop + 5;
          const isNearBottomNow = newMessagesContainer.scrollHeight - currentScrollTop <= newMessagesContainer.clientHeight + 100;
          if (currentState.isLoading && userScrolledUp) {
            isScrollAnchored = false;
          } else if (isNearBottomNow && userScrolledDown) {
            isScrollAnchored = true;
          }
          lastScrollTop = currentScrollTop;
        });
      }
      previousMessageCount = currentState.messages.length;
      previousIsLoading = currentState.isLoading;
    }
    onStateChange(render);
    render();
    await initDatastore();
    console.log("[Clipboard Chat] Ready!");
  }
  if (typeof window !== "undefined") {
    initClipboardChat().catch(console.error);
  }
})();
