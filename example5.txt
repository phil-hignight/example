#!/usr/bin/env node
/**
 * Clipboard Chat - Single File Executable (CommonJS)
 *
 * This is a self-contained bundle with no external dependencies.
 * Copy to production and run with: node clipboard-chat.js
 */
"use strict";

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const cwd = process.cwd();

// FileSystem Transport for backend
class FileSystemTransport {
  constructor(dirPath) {
    this.dirPath = dirPath;
    this.frontendMessagePath = path.join(dirPath, 'frontend-message.json');
    this.backendMessagePath = path.join(dirPath, 'backend-message.json');
    this.lastCheck = 0;
    this.startWatching();
  }
  onReceive(callback) {
    this.callback = callback;
  }
  send(event, data) {
    fs.writeFileSync(this.backendMessagePath, JSON.stringify({
      event,
      payload: data,
      timestamp: Date.now()
    }));
  }
  startWatching() {
    setInterval(() => {
      try {
        if (fs.existsSync(this.frontendMessagePath)) {
          const stats = fs.statSync(this.frontendMessagePath);
          if (stats.mtimeMs > this.lastCheck) {
            this.lastCheck = stats.mtimeMs;
            const content = fs.readFileSync(this.frontendMessagePath, 'utf8');
            const data = JSON.parse(content);
            if (this.callback) {
              this.callback(data.event, data.payload);
            }
          }
        }
      } catch (e) {
        // Ignore errors
      }
    }, 500);
  }
}

// ClipboardAI implementation
class ClipboardAI {
  constructor(options = {}) {
    this.apiBase = options.apiBase || 'https://chat.niprgpt.mil/api';
    this.model = options.model || 'Anthropic Claude 4 Sonnet';
    this.maxTokens = options.maxTokens || 4096;
    this.sessionId = this.generateSessionId();
    this.chatId = null;
    this.messageHistory = [];
  }
  generateSessionId() {
    return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }
  getTimestamp() {
    return Date.now();
  }
  async createNewChat(firstMessage) {
    const messageId = this.generateUUID();
    const timestamp = this.getTimestamp();
    const payload = {
      chat: {
        id: '',
        title: 'Chat Pending',
        models: [this.model],
        params: {},
        history: {
          messages: {
            [messageId]: {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: 'user',
              content: firstMessage.content,
              timestamp: timestamp,
              models: [this.model]
            }
          },
          currentId: messageId
        },
        messages: [{
          id: messageId,
          parentId: null,
          childrenIds: [],
          role: 'user',
          content: firstMessage.content,
          timestamp: timestamp,
          models: [this.model]
        }],
        tags: [],
        timestamp: Date.now()
      }
    };
    const response = await fetch(`${this.apiBase}/v1/chats/new`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      throw new Error(`Failed to create chat: ${response.status}`);
    }
    const data = await response.json();
    return {
      chatId: data.id,
      messageId
    };
  }
  async updateChat(messages) {
    const historyMessages = {};
    messages.forEach(msg => {
      historyMessages[msg.id] = {
        id: msg.id,
        parentId: msg.parentId,
        childrenIds: msg.childrenIds,
        content: msg.content,
        role: msg.role,
        timestamp: msg.timestamp,
        ...(msg.role === 'user' ? {
          models: [this.model]
        } : {
          model: this.model,
          modelIdx: 0,
          modelName: this.model,
          userContext: null
        })
      };
    });
    const currentId = messages[messages.length - 1].id;
    const payload = {
      chat: {
        models: [this.model],
        files: [],
        params: {},
        history: {
          messages: historyMessages,
          currentId: currentId
        },
        messages: messages.map(msg => ({
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp,
          ...(msg.role === 'user' ? {
            models: [this.model]
          } : {
            model: this.model,
            modelIdx: 0,
            modelName: this.model,
            userContext: null
          })
        }))
      }
    };
    const response = await fetch(`${this.apiBase}/v1/chats/${this.chatId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      throw new Error(`Failed to update chat: ${response.status}`);
    }
    return await response.json();
  }
  convertMessagesToClipboardFormat(simpleMessages) {
    const messages = [];
    let previousId = null;
    for (let i = 0; i < simpleMessages.length; i++) {
      const msg = simpleMessages[i];
      let messageId;
      if (i < this.messageHistory.length) {
        messageId = this.messageHistory[i].id;
      } else {
        messageId = this.generateUUID();
      }
      let childrenIds = [];
      if (i < simpleMessages.length - 1) {
        if (i + 1 < this.messageHistory.length) {
          childrenIds = [this.messageHistory[i + 1].id];
        } else {
          childrenIds = [this.generateUUID()];
        }
      }
      const clipboardMsg = {
        id: messageId,
        parentId: previousId,
        childrenIds: childrenIds,
        role: msg.role,
        content: msg.content,
        timestamp: this.getTimestamp()
      };
      messages.push(clipboardMsg);
      previousId = messageId;
    }
    return messages;
  }
  async *streamMessage(messages) {
    const clipboardMessages = this.convertMessagesToClipboardFormat(messages);
    this.messageHistory = clipboardMessages;
    if (!this.chatId) {
      const {
        chatId
      } = await this.createNewChat(messages[0]);
      this.chatId = chatId;
    }
    await this.updateChat(clipboardMessages);
    const assistantMessageId = this.generateUUID();
    const apiMessages = messages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
    const payload = {
      stream: true,
      model: this.model,
      messages: apiMessages,
      max_tokens: this.maxTokens,
      params: {},
      features: {
        web_search: false
      },
      session_id: this.sessionId,
      chat_id: this.chatId,
      id: assistantMessageId,
      background_tasks: {
        title_generation: true,
        tags_generation: true
      }
    };
    const response = await fetch(`${this.apiBase}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      throw new Error(`Failed to get completion: ${response.status}`);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    while (true) {
      const {
        done,
        value
      } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, {
        stream: true
      });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;
          try {
            var _parsed$choices;
            const parsed = JSON.parse(data);
            const delta = (_parsed$choices = parsed.choices) === null || _parsed$choices === void 0 || (_parsed$choices = _parsed$choices[0]) === null || _parsed$choices === void 0 || (_parsed$choices = _parsed$choices.delta) === null || _parsed$choices === void 0 ? void 0 : _parsed$choices.content;
            if (delta) {
              yield delta;
            }
          } catch (e) {
            // Skip invalid JSON
          }
        }
      }
    }
    const assistantMsg = {
      id: assistantMessageId,
      parentId: clipboardMessages[clipboardMessages.length - 1].id,
      childrenIds: [],
      role: 'assistant',
      content: '',
      timestamp: this.getTimestamp()
    };
    this.messageHistory.push(assistantMsg);
  }
}

// Backend core
function createBackend(transport, ai) {
  const state = {
    messages: [],
    isLoading: false
  };
  function syncState() {
    transport.send('state-update', state);
  }
  transport.onReceive(async (event, data) => {
    console.log('[BACKEND] Received:', event, data);
    if (event === 'send-message') {
      const userMessage = data.message;
      state.messages.push({
        role: 'user',
        content: userMessage
      });
      state.isLoading = true;
      syncState();
      let assistantMessage = '';
      try {
        for await (const chunk of ai.streamMessage(state.messages)) {
          assistantMessage += chunk;
          transport.send('stream-chunk', chunk);
        }
        state.messages.push({
          role: 'assistant',
          content: assistantMessage
        });
        state.isLoading = false;
        transport.send('stream-end', null);
        syncState();
      } catch (error) {
        console.error('[BACKEND] Error streaming message:', error);
        state.isLoading = false;
        transport.send('stream-error', error.message);
        syncState();
      }
    }
  });
  syncState();
  return {
    getState: () => state,
    syncState
  };
}

// UI Bundle Template
const UI_BUNDLE_TEMPLATE = `
(async function() {
  'use strict';

  console.log('üéØ Clipboard Chat - Initializing...');
  console.log('üìÅ Working Directory: {{CWD}}');

  // Clear existing UI
  document.body.innerHTML = '';
  document.head.innerHTML = '<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Clipboard Chat</title>';

  // Request directory access
  let dirHandle;
  try {
    dirHandle = await window.showDirectoryPicker({
      mode: 'readwrite',
      startIn: 'desktop'
    });
    console.log('‚úÖ Directory access granted:', dirHandle.name);
  } catch (e) {
    alert('Directory access required for File System transport. Please grant permission.');
    return;
  }

  // FileSystem Transport for frontend
  class FileSystemTransport {
    constructor(dirHandle) {
      this.dirHandle = dirHandle;
      this.pollInterval = 500;
      this.listeners = [];
      this.lastTimestamp = 0;
    }

    async send(event, data) {
      const fileHandle = await this.dirHandle.getFileHandle('frontend-message.json', { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify({ event, payload: data, timestamp: Date.now() }));
      await writable.close();
      console.log('[FRONTEND] Sent:', event, data);
    }

    onReceive(callback) {
      this.listeners.push(callback);
      if (this.listeners.length === 1) {
        this.startPolling();
      }
    }

    async startPolling() {
      while (true) {
        await new Promise(resolve => setTimeout(resolve, this.pollInterval));

        try {
          const fileHandle = await this.dirHandle.getFileHandle('backend-message.json');
          const file = await fileHandle.getFile();
          const content = await file.text();
          const data = JSON.parse(content);

          if (data.timestamp > this.lastTimestamp) {
            this.lastTimestamp = data.timestamp;
            console.log('[FRONTEND] Received:', data.event, data.payload);
            this.listeners.forEach(fn => fn(data.event, data.payload));
          }
        } catch (e) {
          // File doesn't exist yet
        }
      }
    }
  }

  // Frontend state
  let state = {
    messages: [],
    isLoading: false,
    streamingContent: '',
    error: null
  };

  const app = document.createElement('div');
  app.id = 'app';
  document.body.appendChild(app);

  // Render function
  function render() {
    const messagesHtml = state.messages.map(function(msg) {
      const isUser = msg.role === 'user';
      const justify = isUser ? 'flex-end' : 'flex-start';
      const bg = isUser ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : '#fff';
      const color = isUser ? 'white' : '#333';
      const content = msg.content.replace(/\\n/g, '<br>');

      return '<div style="display: flex; justify-content: ' + justify + '; margin-bottom: 12px;">' +
        '<div style="max-width: 70%; padding: 12px 16px; border-radius: 12px; background: ' + bg + '; color: ' + color + '; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">' +
        content +
        '</div>' +
        '</div>';
    }).join('');

    const streamingHtml = state.streamingContent ?
      '<div style="display: flex; justify-content: flex-start; margin-bottom: 12px;">' +
        '<div style="max-width: 70%; padding: 12px 16px; border-radius: 12px; background: #fff; color: #333; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">' +
        state.streamingContent.replace(/\\n/g, '<br>') +
        '<span style="animation: blink 1s infinite;">‚ñä</span>' +
        '</div>' +
        '</div>'
      : '';

    const errorHtml = state.error ?
      '<div style="padding: 12px; background: #fee; color: #c00; border-radius: 8px; margin-bottom: 12px;">' +
        'Error: ' + state.error +
        '</div>'
      : '';

    app.innerHTML =
      '<style>' +
        '@keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }' +
        '* { margin: 0; padding: 0; box-sizing: border-box; }' +
        'body { font-family: -apple-system, sans-serif; height: 100vh; overflow: hidden; }' +
      '</style>' +
      '<div style="display: flex; flex-direction: column; height: 100vh;">' +
        '<header style="color: white; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">' +
          '<h1 style="font-size: 24px; font-weight: 600; margin: 0;">Clipboard Chat</h1>' +
          '<p style="font-size: 14px; margin-top: 4px; opacity: 0.9;">üìÅ {{CWD}}</p>' +
          '<p style="font-size: 12px; margin-top: 2px; opacity: 0.8;">üìÇ Connected to: ' + dirHandle.name + '</p>' +
        '</header>' +
        '<div id="messages" style="flex: 1; overflow-y: auto; padding: 20px; background: #f9fafb;">' +
          messagesHtml +
          streamingHtml +
          errorHtml +
        '</div>' +
        '<div style="padding: 20px; background: white; border-top: 1px solid #e5e7eb;">' +
          '<div style="display: flex; gap: 12px;">' +
            '<input id="messageInput" type="text" placeholder="Type your message..." ' +
              'style="flex: 1; padding: 12px 16px; border: 1px solid #d1d5db; border-radius: 8px; outline: none;" ' +
              (state.isLoading ? 'disabled' : '') + ' />' +
            '<button id="sendButton" ' +
              'style="padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer;" ' +
              (state.isLoading ? 'disabled' : '') + '>' +
              (state.isLoading ? 'Sending...' : 'Send') +
            '</button>' +
          '</div>' +
        '</div>' +
      '</div>';

    const input = document.getElementById('messageInput');
    const button = document.getElementById('sendButton');
    const messagesDiv = document.getElementById('messages');

    if (input && button) {
      const handleSend = () => {
        const message = input.value.trim();
        if (message && !state.isLoading) {
          transport.send('send-message', { message });
          state.messages.push({ role: 'user', content: message });
          state.isLoading = true;
          state.streamingContent = '';
          input.value = '';
          render();
        }
      };

      button.onclick = handleSend;
      input.onkeypress = (e) => {
        if (e.key === 'Enter') handleSend();
      };

      if (!state.isLoading) input.focus();
    }

    if (messagesDiv) {
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
  }

  // Create transport
  const transport = new FileSystemTransport(dirHandle);

  // Listen for backend messages
  transport.onReceive((event, data) => {
    if (event === 'state-update') {
      state = data;
      render();
    }
    if (event === 'stream-chunk') {
      state.streamingContent += data;
      render();
    }
    if (event === 'stream-end') {
      state.messages.push({ role: 'assistant', content: state.streamingContent });
      state.streamingContent = '';
      state.isLoading = false;
      render();
    }
    if (event === 'stream-error') {
      state.error = data;
      state.isLoading = false;
      render();
    }
  });

  // Initial render
  render();

  console.log('‚úÖ Chat UI initialized!');
  console.log('üí¨ Type a message to start chatting');
})();
`;

// Main
async function main() {
  // Check if running in build mode
  const buildMode = process.argv.includes('--build');
  if (buildMode) {
    console.log('‚ùå This is already a built file. Run without --build flag.');
    return;
  }
  console.log('üöÄ Clipboard Chat Server');
  console.log('========================\n');
  console.log(`üìÅ Working Directory: ${cwd}\n`);

  // Initialize backend
  const transport = new FileSystemTransport(cwd);
  const ai = new ClipboardAI();
  const backend = createBackend(transport, ai);
  console.log('‚úÖ Backend server running');
  console.log(`üìÇ Watching: ${cwd}`);
  console.log(`üìù Files: frontend-message.json, backend-message.json\n`);

  // Wait for user to press Enter
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  rl.question('Press Enter to generate UI JavaScript file... ', () => {
    rl.close();

    // Inject CWD into UI bundle
    const injectedUI = UI_BUNDLE_TEMPLATE.replace(/{{CWD}}/g, cwd);

    // Save to file
    const outputFile = path.join(cwd, 'clipboard-ui.js');
    fs.writeFileSync(outputFile, injectedUI);
    console.log('\n‚úÖ UI JavaScript generated!');
    console.log(`üìÑ File: ${outputFile}`);
    console.log(`üì¶ Size: ${(injectedUI.length / 1024).toFixed(1)}KB\n`);
    console.log('üìã Next steps:');
    console.log('1. Copy the contents of clipboard-ui.js');
    console.log('2. Go to your employer\'s AI UI (or any website)');
    console.log('3. Open browser console (F12)');
    console.log('4. Paste and press Enter');
    console.log('5. Grant directory access when prompted');
    console.log('   (Select this directory: ' + cwd + ')');
    console.log('6. Start chatting!\n');
    console.log('üí° The browser and this server communicate via JSON files\n');
  });
}
main().catch(console.error);
