/**
 * Clipboard Chat - Bundled Browser Version
 * Copy this entire file and paste into browser devtools console
 *
 * Generated: 2025-12-10T17:34:52.695Z
 */

(() => {
  // packages/backend/src/ai/clipboard.js
  var ClipboardAI = class {
    /**
     * @param {Object} options - Optional configuration
     */
    constructor(options = {}) {
      this.apiBase = options.apiBase || "https://chat.niprgpt.mil/api";
      this.model = options.model || "Anthropic Claude 4 Sonnet";
      this.maxTokens = options.maxTokens || 4096;
      this.timeout = options.timeout || 3e4;
      this.maxRetries = options.maxRetries || 5;
      this.sessionId = this.generateSessionId();
      this.chatId = null;
      this.messageHistory = [];
    }
    /**
     * Generate unique session ID
     */
    generateSessionId() {
      return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    /**
     * Generate UUID for messages
     */
    generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    /**
     * Get current timestamp
     */
    getTimestamp() {
      return Date.now();
    }
    /**
     * Create new chat with first message
     * @param {Object} firstMessage - First user message
     * @returns {Promise<string>} Chat ID
     */
    async createNewChat(firstMessage) {
      const messageId = this.generateUUID();
      const timestamp = this.getTimestamp();
      const payload = {
        chat: {
          id: "",
          title: "Chat Pending",
          models: [this.model],
          params: {},
          history: {
            messages: {
              [messageId]: {
                id: messageId,
                parentId: null,
                childrenIds: [],
                role: "user",
                content: firstMessage.content,
                timestamp,
                models: [this.model]
              }
            },
            currentId: messageId
          },
          messages: [
            {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: "user",
              content: firstMessage.content,
              timestamp,
              models: [this.model]
            }
          ],
          tags: [],
          timestamp: Date.now()
        }
      };
      const response = await fetch(`${this.apiBase}/v1/chats/new`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        throw new Error(`Failed to create chat: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      return { chatId: data.id, messageId };
    }
    /**
     * Update chat with message history
     * @param {Array} messages - Array of message objects with IDs
     */
    async updateChat(messages) {
      const historyMessages = {};
      messages.forEach((msg) => {
        historyMessages[msg.id] = {
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp,
          ...msg.role === "user" ? { models: [this.model] } : {
            model: this.model,
            modelIdx: 0,
            modelName: this.model,
            userContext: null
          }
        };
      });
      const currentId = messages[messages.length - 1].id;
      const payload = {
        chat: {
          models: [this.model],
          files: [],
          params: {},
          history: {
            messages: historyMessages,
            currentId
          },
          messages: messages.map((msg) => ({
            id: msg.id,
            parentId: msg.parentId,
            childrenIds: msg.childrenIds,
            content: msg.content,
            role: msg.role,
            timestamp: msg.timestamp,
            ...msg.role === "user" ? { models: [this.model] } : {
              model: this.model,
              modelIdx: 0,
              modelName: this.model,
              userContext: null
            }
          }))
        }
      };
      const response = await fetch(`${this.apiBase}/v1/chats/${this.chatId}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        throw new Error(`Failed to update chat: ${response.status} ${response.statusText}`);
      }
      return await response.json();
    }
    /**
     * Convert simple messages to clipboard format with IDs
     * @param {Array} simpleMessages - Simple [{role, content}] format
     * @returns {Array} Messages with IDs and relationships
     */
    convertMessagesToClipboardFormat(simpleMessages) {
      const messages = [];
      let previousId = null;
      for (let i = 0; i < simpleMessages.length; i++) {
        const msg = simpleMessages[i];
        let messageId;
        if (i < this.messageHistory.length) {
          messageId = this.messageHistory[i].id;
        } else {
          messageId = this.generateUUID();
        }
        let childrenIds = [];
        if (i < simpleMessages.length - 1) {
          if (i + 1 < this.messageHistory.length) {
            childrenIds = [this.messageHistory[i + 1].id];
          } else {
            const nextId = this.generateUUID();
            childrenIds = [nextId];
          }
        }
        const clipboardMsg = {
          id: messageId,
          parentId: previousId,
          childrenIds,
          role: msg.role,
          content: msg.content,
          timestamp: this.getTimestamp()
        };
        messages.push(clipboardMsg);
        previousId = messageId;
      }
      return messages;
    }
    /**
     * Stream a message using clipboard API
     * @param {Array} messages - Array of message objects with role and content
     * @yields {string} Text chunks as they arrive
     */
    async *streamMessage(messages) {
      const clipboardMessages = this.convertMessagesToClipboardFormat(messages);
      this.messageHistory = clipboardMessages;
      if (!this.chatId) {
        const { chatId } = await this.createNewChat(messages[0]);
        this.chatId = chatId;
      }
      await this.updateChat(clipboardMessages);
      const assistantMessageId = this.generateUUID();
      const apiMessages = messages.map((msg) => ({
        role: msg.role,
        content: msg.content
      }));
      const payload = {
        stream: true,
        model: this.model,
        messages: apiMessages,
        max_tokens: this.maxTokens,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: true,
          tags_generation: true
        }
      };
      const response = await fetch(`${this.apiBase}/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        throw new Error(`Failed to get completion: ${response.status} ${response.statusText}`);
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6);
            if (data === "[DONE]") continue;
            try {
              const parsed = JSON.parse(data);
              const delta = parsed.choices?.[0]?.delta?.content;
              if (delta) {
                yield delta;
              }
            } catch (e) {
            }
          }
        }
      }
      const assistantMsg = {
        id: assistantMessageId,
        parentId: clipboardMessages[clipboardMessages.length - 1].id,
        childrenIds: [],
        role: "assistant",
        content: "",
        // Will be filled by backend/core/app.js
        timestamp: this.getTimestamp()
      };
      this.messageHistory.push(assistantMsg);
    }
  };

  // packages/datastore/src/browser-filesystem.js
  var BrowserFileSystemDatastore = class {
    /**
     * Create a Browser FileSystem datastore
     * @param {Object} options
     * @param {FileSystemDirectoryHandle} options.directoryHandle - Handle to selected directory
     */
    constructor(options = {}) {
      const { directoryHandle } = options;
      if (!directoryHandle) {
        throw new Error("directoryHandle is required for BrowserFileSystemDatastore");
      }
      this.rootHandle = directoryHandle;
      this.agentHandle = null;
    }
    /**
     * Initialize the .agent directory
     * @returns {Promise<void>}
     */
    async init() {
      this.agentHandle = await this.rootHandle.getDirectoryHandle(".agent", { create: true });
    }
    /**
     * Ensure initialized
     * @private
     */
    async _ensureInit() {
      if (!this.agentHandle) {
        await this.init();
      }
    }
    async read(filename) {
      await this._ensureInit();
      try {
        const fileHandle = await this.agentHandle.getFileHandle(filename);
        const file = await fileHandle.getFile();
        return await file.text();
      } catch (err) {
        throw new Error(`File not found: ${filename}`);
      }
    }
    async write(filename, content) {
      await this._ensureInit();
      const fileHandle = await this.agentHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(content);
      await writable.close();
    }
    async exists(filename) {
      await this._ensureInit();
      try {
        await this.agentHandle.getFileHandle(filename);
        return true;
      } catch (err) {
        return false;
      }
    }
    async list() {
      await this._ensureInit();
      const files = [];
      for await (const entry of this.agentHandle.values()) {
        if (entry.kind === "file") {
          files.push(entry.name);
        }
      }
      return files;
    }
    async delete(filename) {
      await this._ensureInit();
      try {
        await this.agentHandle.removeEntry(filename);
      } catch (err) {
      }
    }
  };

  // apps/clipboard/src/clipboard-chat.js
  function escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  function renderMessage(message) {
    const isUser = message.role === "user";
    const bgColor = isUser ? "#667eea" : "#f3f4f6";
    const textColor = isUser ? "white" : "#1f2937";
    const align = isUser ? "flex-end" : "flex-start";
    return `
    <div style="display: flex; justify-content: ${align}; margin-bottom: 16px;">
      <div style="
        max-width: 70%;
        padding: 12px 16px;
        border-radius: 12px;
        background: ${bgColor};
        color: ${textColor};
        word-wrap: break-word;
      ">
        <div style="font-size: 12px; opacity: 0.7; margin-bottom: 4px;">
          ${isUser ? "You" : "Assistant"}
        </div>
        <div style="white-space: pre-wrap;">${escapeHtml(message.content)}</div>
      </div>
    </div>
  `;
  }
  function renderChatMessages(state) {
    const messagesHtml = state.messages.map((msg) => renderMessage(msg)).join("");
    return `
    <div id="messages-container" style="
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: white;
    ">
      ${messagesHtml}
      ${state.isLoading && state.streamingContent ? `
        <div style="display: flex; justify-content: flex-start; margin-bottom: 16px;">
          <div style="
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 12px;
            background: #f3f4f6;
            color: #1f2937;
            word-wrap: break-word;
          ">
            <div style="font-size: 12px; opacity: 0.7; margin-bottom: 4px;">Assistant</div>
            <div style="white-space: pre-wrap;">${escapeHtml(state.streamingContent)}<span style="animation: blink 1s infinite;">\u258A</span></div>
          </div>
        </div>
      ` : state.isLoading ? `
        <div style="display: flex; justify-content: flex-start; margin-bottom: 16px;">
          <div style="
            padding: 12px 16px;
            border-radius: 12px;
            background: #f3f4f6;
            color: #1f2937;
          ">
            <div style="font-size: 12px; opacity: 0.7; margin-bottom: 4px;">Assistant</div>
            <div>Thinking...</div>
          </div>
        </div>
      ` : ""}
      ${state.messages.length === 0 && !state.isLoading ? `
        <div style="
          text-align: center;
          color: #9ca3af;
          padding: 40px 20px;
        ">
          <p style="font-size: 18px; margin-bottom: 8px;">Welcome to AI Chat</p>
          <p>Send a message to start the conversation</p>
        </div>
      ` : ""}
      <style>
        @keyframes blink {
          0%, 50% { opacity: 1; }
          51%, 100% { opacity: 0; }
        }
      </style>
    </div>
  `;
  }
  function renderChatInput(state) {
    return `
    <div style="
      padding: 20px;
      background: white;
      border-top: 1px solid #e5e7eb;
    ">
      ${state.error ? `
        <div style="
          background: #fee2e2;
          color: #991b1b;
          padding: 12px;
          border-radius: 8px;
          margin-bottom: 12px;
          font-size: 14px;
        ">
          ${state.error}
        </div>
      ` : ""}
      <div style="display: flex; gap: 12px;">
        <input
          id="clipboard-chat-input"
          type="text"
          placeholder="Type your message..."
          ${state.isLoading ? "disabled" : ""}
          style="
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            ${state.isLoading ? "opacity: 0.5; cursor: not-allowed;" : ""}
          "
        />
        <button
          id="clipboard-send-btn"
          ${state.isLoading ? "disabled" : ""}
          style="
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            ${state.isLoading ? "opacity: 0.5; cursor: not-allowed;" : ""}
          "
        >
          Send
        </button>
      </div>
    </div>
  `;
  }
  function renderApp(state) {
    return `
    <div style="display: flex; flex-direction: column; height: 100vh; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: #f9fafb;">
      <header style="color: white; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
        <h1 style="margin: 0; font-size: 24px; font-weight: 600;">AI Chat</h1>
        <p style="font-size: 14px; margin: 4px 0 0 0; opacity: 0.9;">Powered by Claude</p>
      </header>
      ${renderChatMessages(state)}
      ${renderChatInput(state)}
    </div>
  `;
  }
  var appState = {
    messages: [],
    isLoading: false,
    streamingContent: "",
    error: null,
    datastoreReady: false
  };
  var stateListeners = [];
  function setState(updates) {
    appState = { ...appState, ...updates };
    stateListeners.forEach((fn) => fn(appState));
  }
  function onStateChange(fn) {
    stateListeners.push(fn);
  }
  var clipboardAI = null;
  var datastore = null;
  async function initDatastore() {
    try {
      const dirHandle = await window.showDirectoryPicker({
        mode: "readwrite"
      });
      datastore = new BrowserFileSystemDatastore({ directoryHandle: dirHandle });
      await datastore.init();
      setState({ datastoreReady: true, error: null });
      await loadConversation();
    } catch (err) {
      console.error("Failed to initialize datastore:", err);
      setState({
        datastoreReady: false,
        error: "Failed to access directory. Please refresh and try again."
      });
    }
  }
  async function saveConversation() {
    if (!datastore) return;
    try {
      const data = {
        messages: appState.messages,
        timestamp: Date.now()
      };
      await datastore.write("conversation.json", JSON.stringify(data, null, 2));
    } catch (err) {
      console.error("Failed to save conversation:", err);
    }
  }
  async function loadConversation() {
    if (!datastore) return;
    try {
      const exists = await datastore.exists("conversation.json");
      if (exists) {
        const content = await datastore.read("conversation.json");
        const data = JSON.parse(content);
        if (data.messages && Array.isArray(data.messages)) {
          setState({ messages: data.messages });
        }
      }
    } catch (err) {
      console.error("Failed to load conversation:", err);
    }
  }
  async function handleSendMessage() {
    const input = document.getElementById("clipboard-chat-input");
    if (!input || !input.value.trim()) return;
    const userMessage = input.value.trim();
    input.value = "";
    const newMessages = [...appState.messages, { role: "user", content: userMessage }];
    setState({
      messages: newMessages,
      isLoading: true,
      streamingContent: "",
      error: null
    });
    try {
      if (!clipboardAI) {
        clipboardAI = new ClipboardAI({
          apiBase: "https://chat.niprgpt.mil/api",
          model: "Anthropic Claude 4 Sonnet"
        });
      }
      let fullResponse = "";
      for await (const chunk of clipboardAI.streamMessage(newMessages)) {
        fullResponse += chunk;
        setState({ streamingContent: fullResponse });
      }
      setState({
        messages: [...newMessages, { role: "assistant", content: fullResponse }],
        isLoading: false,
        streamingContent: ""
      });
      await saveConversation();
    } catch (err) {
      console.error("Failed to send message:", err);
      setState({
        isLoading: false,
        streamingContent: "",
        error: `Failed to send message: ${err.message}`
      });
    }
  }
  async function initClipboardChat() {
    console.log("[Clipboard Chat] Initializing...");
    const container = document.createElement("div");
    container.id = "clipboard-chat-app";
    container.style.cssText = "position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 999999;";
    document.body.appendChild(container);
    let isScrollAnchored = true;
    let previousMessageCount = 0;
    let previousIsLoading = false;
    function render() {
      const currentState = appState;
      const messageJustStarted = !previousIsLoading && currentState.isLoading;
      const messageCountChanged = currentState.messages.length !== previousMessageCount;
      const messagesContainer = container.querySelector("#messages-container");
      const isNearBottom = !messagesContainer || messagesContainer.scrollHeight - messagesContainer.scrollTop <= messagesContainer.clientHeight + 100;
      if ((messageJustStarted || messageCountChanged) && isNearBottom) {
        isScrollAnchored = true;
      }
      container.innerHTML = renderApp(currentState);
      const newMessagesContainer = container.querySelector("#messages-container");
      if (isScrollAnchored && newMessagesContainer) {
        newMessagesContainer.scrollTop = newMessagesContainer.scrollHeight;
      }
      const input = document.getElementById("clipboard-chat-input");
      const sendBtn = document.getElementById("clipboard-send-btn");
      if (input) {
        input.onkeydown = (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            handleSendMessage();
          }
        };
        if (!currentState.isLoading) {
          input.focus();
        }
      }
      if (sendBtn) {
        sendBtn.onclick = handleSendMessage;
      }
      if (newMessagesContainer) {
        let lastScrollTop = newMessagesContainer.scrollTop;
        newMessagesContainer.addEventListener("scroll", () => {
          const currentScrollTop = newMessagesContainer.scrollTop;
          const userScrolledUp = currentScrollTop < lastScrollTop - 5;
          const userScrolledDown = currentScrollTop > lastScrollTop + 5;
          const isNearBottomNow = newMessagesContainer.scrollHeight - currentScrollTop <= newMessagesContainer.clientHeight + 100;
          if (currentState.isLoading && userScrolledUp) {
            isScrollAnchored = false;
          } else if (isNearBottomNow && userScrolledDown) {
            isScrollAnchored = true;
          }
          lastScrollTop = currentScrollTop;
        });
      }
      previousMessageCount = currentState.messages.length;
      previousIsLoading = currentState.isLoading;
    }
    onStateChange(render);
    render();
    await initDatastore();
    render();
    console.log("[Clipboard Chat] Ready!");
  }
  if (typeof window !== "undefined") {
    initClipboardChat().catch(console.error);
  }
})();
