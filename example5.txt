/**
 * Clipboard Chat v3 - Pure Browser Implementation
 * No backend required - everything runs in browser
 * Uses File System Access API for .agent/ folder persistence
 */

// This file generates a single JavaScript bundle that runs entirely in the browser
// Just paste it into console on any website

const BROWSER_BUNDLE = `
// ============================================================================
// Browser-only Clipboard Chat with Datastore
// ============================================================================

(function() {
  'use strict';

  const API_BASE = 'https://chat.niprgpt.mil/api';
  const MODEL = 'Anthropic Claude 4 Sonnet';

  // ==========================================================================
  // Utility: UUID Generation
  // ==========================================================================

  function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function generateSessionId() {
    return Date.now().toString();
  }

  // ==========================================================================
  // Browser FileSystem Datastore
  // ==========================================================================

  class BrowserFileSystemDatastore {
    constructor(options) {
      const directoryHandle = options.directoryHandle;
      if (!directoryHandle) {
        throw new Error('directoryHandle is required');
      }
      this.rootHandle = directoryHandle;
      this.agentHandle = null;
    }

    async init() {
      this.agentHandle = await this.rootHandle.getDirectoryHandle('.agent', { create: true });
    }

    async _ensureInit() {
      if (!this.agentHandle) {
        await this.init();
      }
    }

    async read(filename) {
      await this._ensureInit();
      try {
        const fileHandle = await this.agentHandle.getFileHandle(filename);
        const file = await fileHandle.getFile();
        return await file.text();
      } catch (err) {
        throw new Error('File not found: ' + filename);
      }
    }

    async write(filename, content) {
      await this._ensureInit();
      const fileHandle = await this.agentHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(content);
      await writable.close();
    }

    async exists(filename) {
      await this._ensureInit();
      try {
        await this.agentHandle.getFileHandle(filename);
        return true;
      } catch (err) {
        return false;
      }
    }
  }

  // ==========================================================================
  // Browser ClipboardAI Implementation
  // ==========================================================================

  function getTimestamp() {
    return Date.now();
  }

  class BrowserClipboardAI {
    constructor() {
      this.apiBase = API_BASE;
      this.model = MODEL;
      this.sessionId = generateSessionId();
      this.chatId = null;
      this.messageHistory = [];
    }

    async createNewChat(firstMessage) {
      const messageId = generateUUID();
      const timestamp = getTimestamp();

      const payload = {
        chat: {
          id: '',
          title: 'Chat Pending',
          models: [this.model],
          params: {},
          history: {
            messages: {
              [messageId]: {
                id: messageId,
                parentId: null,
                childrenIds: [],
                role: 'user',
                content: firstMessage,
                timestamp: timestamp,
                models: [this.model]
              }
            },
            currentId: messageId
          },
          messages: [
            {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: 'user',
              content: firstMessage,
              timestamp: timestamp,
              models: [this.model]
            }
          ],
          tags: [],
          timestamp: Date.now()
        }
      };

      const response = await fetch(this.apiBase + '/v1/chats/new', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        throw new Error('Failed to create chat: ' + response.status + ' ' + response.statusText);
      }

      const data = await response.json();
      this.chatId = data.id;

      return { chatId: data.id, messageId: messageId };
    }

    async updateChat(messages) {
      const historyMessages = {};
      messages.forEach(function(msg) {
        historyMessages[msg.id] = {
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp
        };
        if (msg.role === 'user') {
          historyMessages[msg.id].models = [this.model];
        } else {
          historyMessages[msg.id].model = this.model;
          historyMessages[msg.id].modelIdx = 0;
          historyMessages[msg.id].modelName = this.model;
          historyMessages[msg.id].userContext = null;
        }
      }.bind(this));

      const currentId = messages[messages.length - 1].id;

      const payload = {
        chat: {
          models: [this.model],
          files: [],
          params: {},
          history: {
            messages: historyMessages,
            currentId: currentId
          },
          messages: messages.map(function(msg) {
            const result = {
              id: msg.id,
              parentId: msg.parentId,
              childrenIds: msg.childrenIds,
              content: msg.content,
              role: msg.role,
              timestamp: msg.timestamp
            };
            if (msg.role === 'user') {
              result.models = [this.model];
            } else {
              result.model = this.model;
              result.modelIdx = 0;
              result.modelName = this.model;
              result.userContext = null;
            }
            return result;
          }.bind(this))
        }
      };

      const response = await fetch(this.apiBase + '/v1/chats/' + this.chatId, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        throw new Error('Failed to update chat: ' + response.status + ' ' + response.statusText);
      }

      return await response.json();
    }

    async *streamMessage(messages) {
      // On first message, create the chat
      if (!this.chatId) {
        const firstMessage = messages[0].content;
        const result = await this.createNewChat(firstMessage);
        const messageId = result.messageId;

        // Store in history
        this.messageHistory.push({
          id: messageId,
          parentId: null,
          childrenIds: [],
          role: 'user',
          content: firstMessage,
          timestamp: getTimestamp()
        });
      } else {
        // Not the first message - need to add new user messages to history
        // Find which messages are new
        for (let i = 0; i < messages.length; i++) {
          const msg = messages[i];

          // Check if this message is already in history
          let found = false;
          for (let j = 0; j < this.messageHistory.length; j++) {
            const h = this.messageHistory[j];
            if (h.role === msg.role && h.content === msg.content) {
              found = true;
              break;
            }
          }

          // Add new message
          if (!found) {
            const messageId = generateUUID();
            const lastMsg = this.messageHistory[this.messageHistory.length - 1];
            const newMsg = {
              id: messageId,
              parentId: lastMsg.id,
              childrenIds: [],
              role: msg.role,
              content: msg.content,
              timestamp: getTimestamp()
            };

            // Update parent's childrenIds
            lastMsg.childrenIds.push(messageId);
            this.messageHistory.push(newMsg);
          }
        }

        // Update chat with full history
        await this.updateChat(this.messageHistory);
      }

      // Convert to API format for completion
      const apiMessages = messages.map(function(m) {
        return {
          role: m.role,
          content: m.content
        };
      });

      // Generate assistant message ID
      const assistantMessageId = generateUUID();

      // Get completion
      const payload = {
        stream: true,
        model: this.model,
        messages: apiMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: true,
          tags_generation: true
        }
      };

      const response = await fetch(this.apiBase + '/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        throw new Error('Failed to get completion: ' + response.status + ' ' + response.statusText);
      }

      // Parse SSE stream
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let fullAssistantMessage = '';

      while (true) {
        const result = await reader.read();
        if (result.done) break;

        buffer = buffer + decoder.decode(result.value, { stream: true });
        const lines = buffer.split('\\n');
        buffer = lines.pop() || '';

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.indexOf('data: ') === 0) {
            const data = line.slice(6);
            if (data === '[DONE]') continue;

            try {
              const parsed = JSON.parse(data);
              const content = parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content;
              if (content) {
                fullAssistantMessage = fullAssistantMessage + content;
                yield content;
              }
            } catch (e) {
              // Ignore parse errors
            }
          }
        }
      }

      // After streaming completes, add assistant message to history
      if (fullAssistantMessage) {
        const lastUserMsg = this.messageHistory[this.messageHistory.length - 1];
        const assistantMsg = {
          id: assistantMessageId,
          parentId: lastUserMsg.id,
          childrenIds: [],
          role: 'assistant',
          content: fullAssistantMessage,
          timestamp: getTimestamp()
        };

        // Update parent's childrenIds
        lastUserMsg.childrenIds.push(assistantMessageId);
        this.messageHistory.push(assistantMsg);
      }
    }
  }

  // ==========================================================================
  // State Manager
  // ==========================================================================

  function createStateManager(options) {
    const onStateChange = options.onStateChange || function() {};
    const state = {
      messages: [],
      isLoading: false,
      streamingContent: '',
      error: null
    };

    function notifyStateChange() {
      onStateChange(Object.assign({}, state));
    }

    function addMessage(message) {
      state.messages.push(message);
      notifyStateChange();
    }

    function setLoading(isLoading) {
      state.isLoading = isLoading;
      notifyStateChange();
    }

    function setError(error) {
      state.error = error;
      notifyStateChange();
    }

    function clearError() {
      state.error = null;
      notifyStateChange();
    }

    function setStreamingContent(content) {
      state.streamingContent = content;
      notifyStateChange();
    }

    function getState() {
      return Object.assign({}, state);
    }

    function getMessagesForAI() {
      return state.messages.map(function(m) {
        return { role: m.role, content: m.content };
      });
    }

    return {
      addMessage: addMessage,
      setLoading: setLoading,
      setError: setError,
      clearError: clearError,
      setStreamingContent: setStreamingContent,
      getState: getState,
      getMessagesForAI: getMessagesForAI,
      notifyStateChange: notifyStateChange
    };
  }

  // ==========================================================================
  // Orchestrator
  // ==========================================================================

  function createOrchestrator(options) {
    const stateManager = options.stateManager;
    const aiCaller = options.aiCaller;
    const datastore = options.datastore;

    async function handleSendMessage(message) {
      stateManager.addMessage({ role: 'user', content: message });
      stateManager.setLoading(true);
      stateManager.setStreamingContent('');
      stateManager.clearError();

      try {
        const messages = stateManager.getMessagesForAI();
        let assistantMessage = '';
        const stream = aiCaller.streamMessage(messages);

        while (true) {
          const result = await stream.next();
          if (result.done) break;
          const chunk = result.value;
          assistantMessage = assistantMessage + chunk;
          stateManager.setStreamingContent(assistantMessage);
        }

        stateManager.addMessage({ role: 'assistant', content: assistantMessage });
        stateManager.setLoading(false);
        stateManager.setStreamingContent('');

        if (datastore) await saveConversation();
      } catch (error) {
        console.error('[ORCHESTRATOR] Error:', error);
        stateManager.setLoading(false);
        stateManager.setError(error.message);
      }
    }

    async function saveConversation() {
      if (!datastore) return;
      try {
        const state = stateManager.getState();
        const data = {
          messages: state.messages,
          timestamp: Date.now()
        };
        await datastore.write('conversation.json', JSON.stringify(data, null, 2));
      } catch (error) {
        console.error('[ORCHESTRATOR] Failed to save:', error);
      }
    }

    async function loadConversation() {
      if (!datastore) return;
      try {
        const exists = await datastore.exists('conversation.json');
        if (exists) {
          const content = await datastore.read('conversation.json');
          const data = JSON.parse(content);
          if (data.messages && Array.isArray(data.messages)) {
            data.messages.forEach(function(msg) {
              stateManager.addMessage(msg);
            });
          }
        }
      } catch (error) {
        console.error('[ORCHESTRATOR] Failed to load:', error);
      }
    }

    return {
      handleSendMessage: handleSendMessage,
      loadConversation: loadConversation
    };
  }

  // ==========================================================================
  // UI Rendering
  // ==========================================================================

  let app = null;
  let stateManager = null;
  let orchestrator = null;

  function render() {
    if (!app || !stateManager) return;
    const state = stateManager.getState();

    const messagesHtml = state.messages.map(function(msg) {
      const isUser = msg.role === 'user';
      const justify = isUser ? 'flex-end' : 'flex-start';
      const bg = isUser ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : '#fff';
      const color = isUser ? 'white' : '#333';
      const content = msg.content.replace(/\\n/g, '<br>');
      return '<div style="display: flex; justify-content: ' + justify + '; margin-bottom: 12px;">' +
        '<div style="max-width: 70%; padding: 12px 16px; border-radius: 12px; background: ' + bg + '; color: ' + color + '; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">' +
        content + '</div></div>';
    }).join('');

    const streamingHtml = state.streamingContent ?
      '<div style="display: flex; justify-content: flex-start; margin-bottom: 12px;">' +
      '<div style="max-width: 70%; padding: 12px 16px; border-radius: 12px; background: #fff; color: #333; box-shadow: 0 2px 8px rgba(0,0,0,0.1); opacity: 0.7;">' +
      state.streamingContent.replace(/\\n/g, '<br>') + '</div></div>' : '';

    const errorHtml = state.error ?
      '<div style="background: #fee; color: #c33; padding: 12px; border-radius: 8px; margin-bottom: 12px;">Error: ' + state.error + '</div>' : '';

    app.innerHTML = '<style>* { box-sizing: border-box; margin: 0; padding: 0; } body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }</style>' +
      '<div style="display: flex; flex-direction: column; height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">' +
      '<div style="flex: 1; overflow-y: auto; padding: 20px;">' + messagesHtml + streamingHtml + errorHtml + '</div>' +
      '<div style="padding: 20px; background: white; box-shadow: 0 -2px 10px rgba(0,0,0,0.1);">' +
      '<div style="display: flex; gap: 12px;">' +
      '<input id="message-input" type="text" placeholder="Type your message..." ' +
      'style="flex: 1; padding: 12px 16px; border: 2px solid #e0e0e0; border-radius: 24px; font-size: 14px; outline: none;" ' +
      (state.isLoading ? 'disabled' : '') + '>' +
      '<button id="send-button" style="padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 24px; font-size: 14px; cursor: pointer; font-weight: 600;" ' +
      (state.isLoading ? 'disabled' : '') + '>' + (state.isLoading ? 'Sending...' : 'Send') + '</button>' +
      '</div></div></div>';

    const input = document.getElementById('message-input');
    const button = document.getElementById('send-button');

    if (input && button) {
      const handleSend = async function() {
        const message = input.value.trim();
        if (message && !state.isLoading) {
          input.value = '';
          await orchestrator.handleSendMessage(message);
        }
      };
      button.onclick = handleSend;
      input.onkeypress = function(e) {
        if (e.key === 'Enter') handleSend();
      };
      if (!state.isLoading) input.focus();
    }

    const messagesContainer = app.querySelector('div > div');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }

  // ==========================================================================
  // Initialization
  // ==========================================================================

  async function init() {
    console.log('[CLIPBOARD CHAT] Initializing...');

    // Remove existing page content
    document.body.innerHTML = '';
    document.body.style.margin = '0';
    document.body.style.padding = '0';

    // Create app container
    app = document.createElement('div');
    app.id = 'clipboard-chat-app';
    document.body.appendChild(app);

    // Request directory access
    let directoryHandle;
    try {
      directoryHandle = await window.showDirectoryPicker();
    } catch (err) {
      app.innerHTML = '<div style="padding: 20px; background: #fee; color: #c33;">Failed to get directory access</div>';
      return;
    }

    // Initialize components
    const datastore = new BrowserFileSystemDatastore({ directoryHandle: directoryHandle });
    await datastore.init();

    const ai = new BrowserClipboardAI();
    stateManager = createStateManager({ onStateChange: render });
    orchestrator = createOrchestrator({
      stateManager: stateManager,
      aiCaller: ai,
      datastore: datastore
    });

    // Load conversation history
    await orchestrator.loadConversation();

    // Initial render
    render();

    console.log('[CLIPBOARD CHAT] Ready!');
  }

  init();
})();
`.trim();

// Export the bundle
console.log(BROWSER_BUNDLE);
