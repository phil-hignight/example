/**
 * Code Boss - Browser-Only Version
 *
 * AI-powered development assistant running entirely in your browser.
 * Uses File System Access API for file operations.
 *
 * @version 1.0.0-browser
 * @generated 2025-11-13T22:38:23.002Z
 * @license MIT
 *
 * Usage:
 *   1. Open internal AI tool in browser
 *   2. Open DevTools console (F12)
 *   3. Paste this entire script
 *   4. Follow prompts to select working directory
 *
 * Files bundled: 47
 * Total size: [calculated at build time]
 */

(function() {
  'use strict';

  console.log('Code Boss initializing...');
  console.log('Version: 1.0.0-browser');

  // Initialize module namespace
  window.module = window.module || {};

  // ============================================================================
  // src/utils.js
  // ============================================================================

  /**
   * utils.js
   *
   * Common utility functions:
   * - String manipulation
   * - Object/array utilities
   * - Date/time formatting
   * - Async helpers
   * - DOM utilities
   * - Debounce/throttle
   */
  
  (function() {
    'use strict';
  
    /**
     * Utils class
     * Collection of common utility functions
     */
    class Utils {
      /**
       * Generate slugified string from name
       * @param {string} name - Name to slugify
       * @returns {string} Slug
       */
      static slugify(name) {
        return name
          .toLowerCase()
          .replace(/\s+/g, '-')
          .replace(/[^a-z0-9-]/g, '')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '');
      }
  
      /**
       * Capitalize first letter
       * @param {string} str - String to capitalize
       * @returns {string} Capitalized string
       */
      static capitalize(str) {
        if (!str) return '';
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
  
      /**
       * Truncate string with ellipsis
       * @param {string} str - String to truncate
       * @param {number} maxLength - Maximum length
       * @returns {string} Truncated string
       */
      static truncate(str, maxLength) {
        if (str.length <= maxLength) return str;
        return str.slice(0, maxLength - 3) + '...';
      }
  
      /**
       * Format bytes as human-readable size
       * @param {number} bytes - Bytes
       * @returns {string} Formatted size
       */
      static formatBytes(bytes) {
        // TODO: Convert to KB, MB, GB as appropriate
        // TODO: Return formatted string
        throw new Error('Not implemented: Utils.formatBytes()');
      }
  
      /**
       * Format timestamp as relative time
       * @param {number} timestamp - Timestamp in ms
       * @returns {string} Relative time (e.g., "2 hours ago")
       */
      static formatRelativeTime(timestamp) {
        // TODO: Calculate difference from now
        // TODO: Format as "X seconds/minutes/hours/days ago"
        throw new Error('Not implemented: Utils.formatRelativeTime()');
      }
  
      /**
       * Format date as ISO string
       * @param {Date} date - Date object
       * @returns {string} ISO date string
       */
      static formatDate(date) {
        return date.toISOString();
      }
  
      /**
       * Parse ISO date string
       * @param {string} dateStr - ISO date string
       * @returns {Date} Date object
       */
      static parseDate(dateStr) {
        return new Date(dateStr);
      }
  
      /**
       * Deep clone object
       * @param {*} obj - Object to clone
       * @returns {*} Cloned object
       */
      static deepClone(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof Array) return obj.map(item => Utils.deepClone(item));
        if (obj instanceof Object) {
          const cloned = {};
          for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
              cloned[key] = Utils.deepClone(obj[key]);
            }
          }
          return cloned;
        }
        return obj;
      }
  
      /**
       * Deep merge objects
       * @param {Object} target - Target object
       * @param {...Object} sources - Source objects
       * @returns {Object} Merged object
       */
      static deepMerge(target, ...sources) {
        // TODO: Iterate through sources
        // TODO: Recursively merge properties
        // TODO: Return merged object
        throw new Error('Not implemented: Utils.deepMerge()');
      }
  
      /**
       * Get nested property value
       * @param {Object} obj - Object
       * @param {string} path - Property path (e.g., "a.b.c")
       * @param {*} defaultValue - Default if not found
       * @returns {*} Property value or default
       */
      static get(obj, path, defaultValue = null) {
        // TODO: Split path by dots
        // TODO: Navigate through object
        // TODO: Return value or default
        throw new Error('Not implemented: Utils.get()');
      }
  
      /**
       * Set nested property value
       * @param {Object} obj - Object
       * @param {string} path - Property path
       * @param {*} value - Value to set
       * @returns {void}
       */
      static set(obj, path, value) {
        // TODO: Split path by dots
        // TODO: Navigate and create missing objects
        // TODO: Set final value
        throw new Error('Not implemented: Utils.set()');
      }
  
      /**
       * Debounce function
       * @param {Function} func - Function to debounce
       * @param {number} wait - Wait time in ms
       * @returns {Function} Debounced function
       */
      static debounce(func, wait) {
        // TODO: Return function that delays execution
        // TODO: Cancel previous timeout on each call
        // TODO: Execute after wait time
        throw new Error('Not implemented: Utils.debounce()');
      }
  
      /**
       * Throttle function
       * @param {Function} func - Function to throttle
       * @param {number} limit - Limit time in ms
       * @returns {Function} Throttled function
       */
      static throttle(func, limit) {
        // TODO: Return function that limits execution rate
        // TODO: Execute at most once per limit interval
        throw new Error('Not implemented: Utils.throttle()');
      }
  
      /**
       * Sleep for specified time
       * @param {number} ms - Milliseconds to sleep
       * @returns {Promise<void>} Promise that resolves after delay
       */
      static sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }
  
      /**
       * Retry async function
       * @param {Function} fn - Async function to retry
       * @param {number} maxRetries - Maximum retry attempts
       * @param {number} delay - Delay between retries in ms
       * @returns {Promise<*>} Function result
       */
      static async retry(fn, maxRetries = 3, delay = 1000) {
        // TODO: Try to execute function
        // TODO: If fails, wait and retry
        // TODO: Throw if max retries exceeded
        throw new Error('Not implemented: Utils.retry()');
      }
  
      /**
       * Create promise with timeout
       * @param {Promise} promise - Promise to wrap
       * @param {number} timeout - Timeout in ms
       * @returns {Promise<*>} Promise that rejects on timeout
       */
      static withTimeout(promise, timeout) {
        // TODO: Race promise against timeout
        // TODO: Reject with timeout error if timeout wins
        throw new Error('Not implemented: Utils.withTimeout()');
      }
  
      /**
       * Generate UUID v4
       * @returns {string} UUID string
       */
      static generateUUID() {
        if (crypto.randomUUID) {
          return crypto.randomUUID();
        }
        // Fallback implementation
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
          const r = Math.random() * 16 | 0;
          const v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      }
  
      /**
       * Generate random ID
       * @param {number} length - ID length
       * @returns {string} Random ID
       */
      static generateID(length = 8) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }
  
      /**
       * Escape regex special characters
       * @param {string} str - String to escape
       * @returns {string} Escaped string
       */
      static escapeRegex(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }
  
      /**
       * Parse query string
       * @param {string} queryString - Query string
       * @returns {Object} Parsed parameters
       */
      static parseQueryString(queryString) {
        // TODO: Parse query string into object
        // TODO: Decode URI components
        // TODO: Return object
        throw new Error('Not implemented: Utils.parseQueryString()');
      }
  
      /**
       * Build query string from object
       * @param {Object} params - Parameters object
       * @returns {string} Query string
       */
      static buildQueryString(params) {
        // TODO: Build query string from object
        // TODO: Encode URI components
        // TODO: Return query string
        throw new Error('Not implemented: Utils.buildQueryString()');
      }
  
      /**
       * Check if value is empty
       * @param {*} value - Value to check
       * @returns {boolean} True if empty
       */
      static isEmpty(value) {
        if (value === null || value === undefined) return true;
        if (typeof value === 'string' && value.trim() === '') return true;
        if (Array.isArray(value) && value.length === 0) return true;
        if (typeof value === 'object' && Object.keys(value).length === 0) return true;
        return false;
      }
  
      /**
       * Array unique
       * @param {Array} arr - Array
       * @returns {Array} Array with unique values
       */
      static unique(arr) {
        return [...new Set(arr)];
      }
  
      /**
       * Array flatten
       * @param {Array} arr - Array to flatten
       * @param {number} depth - Flatten depth (default: 1)
       * @returns {Array} Flattened array
       */
      static flatten(arr, depth = 1) {
        return arr.flat(depth);
      }
  
      /**
       * Group array by key
       * @param {Array} arr - Array to group
       * @param {string|Function} key - Key or key extractor function
       * @returns {Object} Grouped object
       */
      static groupBy(arr, key) {
        // TODO: Group array items by key
        // TODO: Return object with groups
        throw new Error('Not implemented: Utils.groupBy()');
      }
  
      /**
       * Sort array by key
       * @param {Array} arr - Array to sort
       * @param {string|Function} key - Key or comparator function
       * @param {string} order - 'asc' or 'desc'
       * @returns {Array} Sorted array
       */
      static sortBy(arr, key, order = 'asc') {
        // TODO: Sort array by key
        // TODO: Handle ascending/descending
        throw new Error('Not implemented: Utils.sortBy()');
      }
  
      /**
       * Chunk array
       * @param {Array} arr - Array to chunk
       * @param {number} size - Chunk size
       * @returns {Array<Array>} Array of chunks
       */
      static chunk(arr, size) {
        // TODO: Split array into chunks of specified size
        throw new Error('Not implemented: Utils.chunk()');
      }
  
      /**
       * Pick properties from object
       * @param {Object} obj - Source object
       * @param {Array<string>} keys - Keys to pick
       * @returns {Object} New object with picked keys
       */
      static pick(obj, keys) {
        // TODO: Create new object with only specified keys
        throw new Error('Not implemented: Utils.pick()');
      }
  
      /**
       * Omit properties from object
       * @param {Object} obj - Source object
       * @param {Array<string>} keys - Keys to omit
       * @returns {Object} New object without omitted keys
       */
      static omit(obj, keys) {
        // TODO: Create new object without specified keys
        throw new Error('Not implemented: Utils.omit()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.Utils = Utils;
  
  })();

  // ============================================================================
  // src/logger.js
  // ============================================================================

  /**
   * logger.js
   *
   * Logging system with:
   * - Multiple log levels (debug, info, warn, error)
   * - Namespaced loggers
   * - Console and storage logging
   * - Performance timing
   * - Error tracking
   */
  
  (function() {
    'use strict';
  
    /**
     * Log levels
     */
    const LogLevel = {
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3,
      NONE: 4
    };
  
    /**
     * Logger class
     * Provides structured logging with levels and namespaces
     */
    class Logger {
      constructor(namespace = 'CodeBoss', level = LogLevel.INFO) {
        this.namespace = namespace;
        this.level = level;
        this.logs = [];
        this.maxLogs = 1000; // Keep last 1000 logs
        this.timers = new Map(); // Performance timers
      }
  
      /**
       * Log debug message
       * @param {string} message - Log message
       * @param {...*} args - Additional arguments
       * @returns {void}
       */
      debug(message, ...args) {
        this.log(LogLevel.DEBUG, message, ...args);
      }
  
      /**
       * Log info message
       * @param {string} message - Log message
       * @param {...*} args - Additional arguments
       * @returns {void}
       */
      info(message, ...args) {
        this.log(LogLevel.INFO, message, ...args);
      }
  
      /**
       * Log warning message
       * @param {string} message - Log message
       * @param {...*} args - Additional arguments
       * @returns {void}
       */
      warn(message, ...args) {
        this.log(LogLevel.WARN, message, ...args);
      }
  
      /**
       * Log error message
       * @param {string} message - Log message
       * @param {...*} args - Additional arguments
       * @returns {void}
       */
      error(message, ...args) {
        this.log(LogLevel.ERROR, message, ...args);
      }
  
      /**
       * Log message at specific level
       * @param {number} level - Log level
       * @param {string} message - Log message
       * @param {...*} args - Additional arguments
       * @returns {void}
       * @private
       */
      log(level, message, ...args) {
        if (level < this.level) return;
  
        const formatted = this.formatMessage(level, message);
        const logEntry = {
          timestamp: Date.now(),
          level: this.getLevelName(level),
          namespace: this.namespace,
          message: message,
          args: args
        };
  
        // Console output
        const consoleFn = level === LogLevel.ERROR ? console.error :
                         level === LogLevel.WARN ? console.warn :
                         level === LogLevel.DEBUG ? console.debug :
                         console.log;
        consoleFn(formatted, ...args);
  
        // Store in logs
        this.logs.push(logEntry);
        if (this.logs.length > this.maxLogs) {
          this.logs.shift();
        }
      }
  
      /**
       * Format log message
       * @param {number} level - Log level
       * @param {string} message - Message
       * @returns {string} Formatted message
       * @private
       */
      formatMessage(level, message) {
        const timestamp = new Date().toISOString();
        const levelName = this.getLevelName(level);
        return `[${timestamp}] [${levelName}] [${this.namespace}] ${message}`;
      }
  
      /**
       * Get level name
       * @param {number} level - Log level
       * @returns {string} Level name
       * @private
       */
      getLevelName(level) {
        const names = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE'];
        return names[level] || 'UNKNOWN';
      }
  
      /**
       * Start performance timer
       * @param {string} label - Timer label
       * @returns {void}
       */
      time(label) {
        this.timers.set(label, Date.now());
      }
  
      /**
       * End performance timer and log duration
       * @param {string} label - Timer label
       * @returns {number} Duration in ms
       */
      timeEnd(label) {
        const startTime = this.timers.get(label);
        if (!startTime) {
          this.warn(`Timer '${label}' does not exist`);
          return 0;
        }
        const duration = Date.now() - startTime;
        this.info(`${label}: ${duration}ms`);
        this.timers.delete(label);
        return duration;
      }
  
      /**
       * Log timer checkpoint without ending
       * @param {string} label - Timer label
       * @returns {number} Duration so far
       */
      timeLog(label) {
        // TODO: Get start time
        // TODO: Calculate duration so far
        // TODO: Log duration
        // TODO: Return duration
        throw new Error('Not implemented: Logger.timeLog()');
      }
  
      /**
       * Group logs together
       * @param {string} label - Group label
       * @returns {void}
       */
      group(label) {
        // TODO: Start console group
        throw new Error('Not implemented: Logger.group()');
      }
  
      /**
       * End log group
       * @returns {void}
       */
      groupEnd() {
        // TODO: End console group
        throw new Error('Not implemented: Logger.groupEnd()');
      }
  
      /**
       * Set log level
       * @param {number} level - New log level
       * @returns {void}
       */
      setLevel(level) {
        this.level = level;
      }
  
      /**
       * Get log level
       * @returns {number} Current log level
       */
      getLevel() {
        return this.level;
      }
  
      /**
       * Get stored logs
       * @param {number} count - Number of recent logs to return
       * @returns {Array} Recent logs
       */
      getLogs(count = 100) {
        // TODO: Return last N logs
        throw new Error('Not implemented: Logger.getLogs()');
      }
  
      /**
       * Clear stored logs
       * @returns {void}
       */
      clearLogs() {
        this.logs = [];
      }
  
      /**
       * Export logs as JSON
       * @returns {string} JSON string of logs
       */
      exportLogs() {
        // TODO: Serialize logs to JSON
        // TODO: Return JSON string
        throw new Error('Not implemented: Logger.exportLogs()');
      }
  
      /**
       * Create child logger with sub-namespace
       * @param {string} subNamespace - Sub-namespace
       * @returns {Logger} Child logger
       */
      child(subNamespace) {
        const fullNamespace = `${this.namespace}:${subNamespace}`;
        return new Logger(fullNamespace, this.level);
      }
  
      /**
       * Log object in table format
       * @param {Object} obj - Object to log
       * @returns {void}
       */
      table(obj) {
        // TODO: Use console.table if available
        // TODO: Otherwise format as JSON
        throw new Error('Not implemented: Logger.table()');
      }
  
      /**
       * Assert condition and log if false
       * @param {boolean} condition - Condition to check
       * @param {string} message - Error message if false
       * @returns {void}
       */
      assert(condition, message) {
        // TODO: Check condition
        // TODO: If false, log error
        throw new Error('Not implemented: Logger.assert()');
      }
  
      /**
       * Count occurrences of log with label
       * @param {string} label - Counter label
       * @returns {void}
       */
      count(label) {
        // TODO: Increment counter for label
        // TODO: Log count
        throw new Error('Not implemented: Logger.count()');
      }
  
      /**
       * Reset counter
       * @param {string} label - Counter label
       * @returns {void}
       */
      countReset(label) {
        // TODO: Reset counter for label
        throw new Error('Not implemented: Logger.countReset()');
      }
    }
  
    /**
     * Global logger instance
     */
    let globalLogger = null;
  
    /**
     * Get or create global logger
     * @returns {Logger} Global logger instance
     */
    function getLogger() {
      if (!globalLogger) {
        globalLogger = new Logger('CodeBoss', LogLevel.INFO);
      }
      return globalLogger;
    }
  
    /**
     * Create namespaced logger
     * @param {string} namespace - Logger namespace
     * @returns {Logger} Namespaced logger
     */
    function createLogger(namespace) {
      return new Logger(namespace, LogLevel.INFO);
    }
  
    /**
     * Set global log level
     * @param {number} level - Log level
     * @returns {void}
     */
    function setGlobalLogLevel(level) {
      getLogger().setLevel(level);
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.Logger = Logger;
    window.module.LogLevel = LogLevel;
    window.module.getLogger = getLogger;
    window.module.createLogger = createLogger;
    window.module.setGlobalLogLevel = setGlobalLogLevel;
  
  })();

  // ============================================================================
  // src/validators.js
  // ============================================================================

  /**
   * validators.js
   *
   * Input validation utilities:
   * - File path validation
   * - Parameter validation
   * - Type checking
   * - Format validation
   * - Security checks
   */
  
  (function() {
    'use strict';
  
    /**
     * Validators class
     * Provides validation functions for inputs and parameters
     */
    class Validators {
      /**
       * Validate file path
       * @param {string} path - File path to validate
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static validateFilePath(path) {
        // TODO: Check path is string
        // TODO: Check path is not empty
        // TODO: Check no absolute paths
        // TODO: Check no parent directory traversal outside root
        // TODO: Check no invalid characters
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.validateFilePath()');
      }
  
      /**
       * Validate directory path
       * @param {string} path - Directory path to validate
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static validateDirectoryPath(path) {
        // TODO: Use validateFilePath
        // TODO: Additional directory-specific checks
        throw new Error('Not implemented: Validators.validateDirectoryPath()');
      }
  
      /**
       * Check if path is absolute
       * @param {string} path - Path to check
       * @returns {boolean} True if absolute
       */
      static isAbsolutePath(path) {
        // TODO: Check for leading /
        // TODO: Check for Windows drive letter (C:)
        // TODO: Return true if absolute
        throw new Error('Not implemented: Validators.isAbsolutePath()');
      }
  
      /**
       * Check if path has parent directory traversal
       * @param {string} path - Path to check
       * @returns {boolean} True if has traversal
       */
      static hasParentTraversal(path) {
        // TODO: Check for ../ patterns
        // TODO: Normalize path and check if goes outside root
        throw new Error('Not implemented: Validators.hasParentTraversal()');
      }
  
      /**
       * Validate project name
       * @param {string} name - Project name
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static validateProjectName(name) {
        // TODO: Check name is string
        // TODO: Check length (1-100 chars)
        // TODO: Check valid characters (alphanumeric, spaces, hyphens)
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.validateProjectName()');
      }
  
      /**
       * Validate task description
       * @param {string} description - Task description
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static validateTaskDescription(description) {
        // TODO: Check description is string
        // TODO: Check length (5-200 chars)
        // TODO: Check not empty
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.validateTaskDescription()');
      }
  
      /**
       * Validate checklist item
       * @param {Object} item - Checklist item
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static validateChecklistItem(item) {
        // TODO: Check item has required fields
        // TODO: Validate short_desc (1-100 chars)
        // TODO: Validate detailed_desc (1-500 chars)
        // TODO: Validate item_type (coding/git/testing/research)
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.validateChecklistItem()');
      }
  
      /**
       * Validate mental model updates
       * @param {Object} updates - Mental model updates map
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static validateMentalModelUpdates(updates) {
        // TODO: Check updates is object
        // TODO: Check each key is string
        // TODO: Check each value is string (or empty for deletion)
        // TODO: Check value length (0-200 chars)
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.validateMentalModelUpdates()');
      }
  
      /**
       * Validate email format
       * @param {string} email - Email address
       * @returns {boolean} True if valid email
       */
      static isValidEmail(email) {
        // TODO: Use regex to validate email format
        throw new Error('Not implemented: Validators.isValidEmail()');
      }
  
      /**
       * Validate URL format
       * @param {string} url - URL string
       * @returns {boolean} True if valid URL
       */
      static isValidURL(url) {
        // TODO: Use URL constructor to validate
        // TODO: Catch and return false if invalid
        throw new Error('Not implemented: Validators.isValidURL()');
      }
  
      /**
       * Validate JSON string
       * @param {string} jsonStr - JSON string
       * @returns {boolean} True if valid JSON
       */
      static isValidJSON(jsonStr) {
        // TODO: Try to parse JSON
        // TODO: Return true if successful, false otherwise
        throw new Error('Not implemented: Validators.isValidJSON()');
      }
  
      /**
       * Sanitize file path
       * @param {string} path - Path to sanitize
       * @returns {string} Sanitized path
       */
      static sanitizeFilePath(path) {
        // TODO: Normalize path separators
        // TODO: Remove leading/trailing slashes
        // TODO: Collapse multiple slashes
        // TODO: Remove invalid characters
        // TODO: Return sanitized path
        throw new Error('Not implemented: Validators.sanitizeFilePath()');
      }
  
      /**
       * Sanitize HTML string
       * @param {string} html - HTML string
       * @returns {string} Sanitized HTML
       */
      static sanitizeHTML(html) {
        // TODO: Escape HTML special characters
        // TODO: Return safe string
        throw new Error('Not implemented: Validators.sanitizeHTML()');
      }
  
      /**
       * Check if string contains only safe characters
       * @param {string} str - String to check
       * @param {string} pattern - Allowed pattern (regex)
       * @returns {boolean} True if safe
       */
      static isSafeString(str, pattern = /^[a-zA-Z0-9_-]+$/) {
        // TODO: Test string against pattern
        throw new Error('Not implemented: Validators.isSafeString()');
      }
  
      /**
       * Validate required field
       * @param {*} value - Value to check
       * @param {string} fieldName - Field name for error message
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static required(value, fieldName) {
        // TODO: Check value is not null/undefined/empty
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.required()');
      }
  
      /**
       * Validate string length
       * @param {string} str - String to check
       * @param {number} min - Minimum length
       * @param {number} max - Maximum length
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static lengthBetween(str, min, max) {
        // TODO: Check string length is within range
        // TODO: Return validation result with descriptive error
        throw new Error('Not implemented: Validators.lengthBetween()');
      }
  
      /**
       * Validate number range
       * @param {number} num - Number to check
       * @param {number} min - Minimum value
       * @param {number} max - Maximum value
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static between(num, min, max) {
        // TODO: Check number is within range
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.between()');
      }
  
      /**
       * Validate enum value
       * @param {*} value - Value to check
       * @param {Array} validValues - Array of valid values
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static oneOf(value, validValues) {
        // TODO: Check value is in validValues array
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.oneOf()');
      }
  
      /**
       * Validate type
       * @param {*} value - Value to check
       * @param {string} expectedType - Expected type name
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static isType(value, expectedType) {
        // TODO: Check typeof value === expectedType
        // TODO: Handle special cases (array, null)
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.isType()');
      }
  
      /**
       * Validate array
       * @param {*} value - Value to check
       * @param {Function} itemValidator - Validator for each item
       * @returns {Object} {valid: boolean, error: string|null}
       */
      static isArray(value, itemValidator = null) {
        // TODO: Check Array.isArray
        // TODO: If itemValidator provided, validate each item
        // TODO: Return validation result
        throw new Error('Not implemented: Validators.isArray()');
      }
  
      /**
       * Validate object shape
       * @param {Object} obj - Object to validate
       * @param {Object} schema - Schema with field validators
       * @returns {Object} {valid: boolean, errors: Object}
       */
      static validateObject(obj, schema) {
        // TODO: Check each field in schema
        // TODO: Run validator for each field
        // TODO: Collect all errors
        // TODO: Return validation result with all field errors
        throw new Error('Not implemented: Validators.validateObject()');
      }
  
      /**
       * Create custom validator
       * @param {Function} validatorFn - Validator function
       * @param {string} errorMessage - Error message
       * @returns {Function} Validator function
       */
      static custom(validatorFn, errorMessage) {
        // TODO: Return function that runs validatorFn
        // TODO: Return {valid, error} based on result
        throw new Error('Not implemented: Validators.custom()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.Validators = Validators;
  
  })();

  // ============================================================================
  // src/event-emitter.js
  // ============================================================================

  /**
   * event-emitter.js
   *
   * Simple event emitter for component communication:
   * - Event subscription and emission
   * - Async event handling
   * - Event namespacing
   * - Once-only listeners
   * - Error handling
   */
  
  (function() {
    'use strict';
  
    /**
     * EventEmitter class
     * Provides pub/sub event system for components
     */
    class EventEmitter {
      constructor() {
        this.events = new Map(); // eventName -> array of listeners
        this.onceEvents = new Set(); // listener functions that should only fire once
      }
  
      /**
       * Add event listener
       * @param {string} event - Event name
       * @param {Function} listener - Listener function
       * @returns {void}
       */
      on(event, listener) {
        if (typeof event !== 'string' || !event) {
          throw new Error('Event name must be a non-empty string');
        }
        if (typeof listener !== 'function') {
          throw new Error('Listener must be a function');
        }
  
        if (!this.events.has(event)) {
          this.events.set(event, []);
        }
        this.events.get(event).push(listener);
      }
  
      /**
       * Add one-time event listener
       * @param {string} event - Event name
       * @param {Function} listener - Listener function
       * @returns {void}
       */
      once(event, listener) {
        const wrapper = (...args) => {
          this.off(event, wrapper);
          return listener(...args);
        };
        wrapper.originalListener = listener;
        this.on(event, wrapper);
      }
  
      /**
       * Remove event listener
       * @param {string} event - Event name
       * @param {Function} listener - Listener function
       * @returns {void}
       */
      off(event, listener) {
        const listeners = this.events.get(event);
        if (!listeners) return;
  
        const index = listeners.findIndex(l => l === listener || l.originalListener === listener);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
  
        if (listeners.length === 0) {
          this.events.delete(event);
        }
      }
  
      /**
       * Remove all listeners for an event
       * @param {string} event - Event name (optional, if not provided removes all)
       * @returns {void}
       */
      removeAllListeners(event = null) {
        if (event) {
          this.events.delete(event);
        } else {
          this.events.clear();
        }
      }
  
      /**
       * Emit event synchronously
       * @param {string} event - Event name
       * @param {...*} args - Arguments to pass to listeners
       * @returns {boolean} True if event had listeners
       */
      emit(event, ...args) {
        const listeners = this.events.get(event);
        if (!listeners || listeners.length === 0) {
          return false;
        }
  
        // Copy array to avoid issues if listener modifies the list
        const listenersCopy = [...listeners];
  
        for (const listener of listenersCopy) {
          try {
            listener(...args);
          } catch (error) {
            console.error(`Error in event listener for '${event}':`, error);
          }
        }
  
        return true;
      }
  
      /**
       * Emit event asynchronously
       * @param {string} event - Event name
       * @param {...*} args - Arguments to pass to listeners
       * @returns {Promise<boolean>} True if event had listeners
       */
      async emitAsync(event, ...args) {
        const listeners = this.events.get(event);
        if (!listeners || listeners.length === 0) {
          return false;
        }
  
        // Copy array to avoid issues if listener modifies the list
        const listenersCopy = [...listeners];
  
        for (const listener of listenersCopy) {
          try {
            await listener(...args);
          } catch (error) {
            console.error(`Error in async event listener for '${event}':`, error);
          }
        }
  
        return true;
      }
  
      /**
       * Get listener count for event
       * @param {string} event - Event name
       * @returns {number} Number of listeners
       */
      listenerCount(event) {
        const listeners = this.events.get(event);
        return listeners ? listeners.length : 0;
      }
  
      /**
       * Get all listeners for event
       * @param {string} event - Event name
       * @returns {Array<Function>} Array of listeners
       */
      listeners(event) {
        const listeners = this.events.get(event);
        return listeners ? [...listeners] : [];
      }
  
      /**
       * Get all event names
       * @returns {Array<string>} Array of event names
       */
      eventNames() {
        return Array.from(this.events.keys());
      }
  
      /**
       * Check if event has listeners
       * @param {string} event - Event name
       * @returns {boolean} True if has listeners
       */
      hasListeners(event) {
        const listeners = this.events.get(event);
        return listeners && listeners.length > 0;
      }
  
      /**
       * Create namespaced event name
       * @param {string} namespace - Namespace
       * @param {string} event - Event name
       * @returns {string} Namespaced event name
       */
      static namespacedEvent(namespace, event) {
        return `${namespace}:${event}`;
      }
  
      /**
       * Parse namespaced event
       * @param {string} namespacedEvent - Namespaced event string
       * @returns {Object} {namespace, event}
       */
      static parseNamespacedEvent(namespacedEvent) {
        const parts = namespacedEvent.split(':');
        return {
          namespace: parts[0],
          event: parts.slice(1).join(':')
        };
      }
  
      /**
       * Wait for event (returns promise)
       * @param {string} event - Event name
       * @param {number} timeout - Timeout in ms (optional)
       * @returns {Promise<*>} Promise that resolves with event data
       */
      waitFor(event, timeout = null) {
        return new Promise((resolve, reject) => {
          let timeoutId = null;
  
          const listener = (data) => {
            if (timeoutId) clearTimeout(timeoutId);
            resolve(data);
          };
  
          this.once(event, listener);
  
          if (timeout) {
            timeoutId = setTimeout(() => {
              this.off(event, listener);
              reject(new Error(`Timeout waiting for event '${event}' after ${timeout}ms`));
            }, timeout);
          }
        });
      }
  
      /**
       * Emit event with error handling
       * @param {string} event - Event name
       * @param {...*} args - Arguments
       * @returns {boolean} True if all listeners succeeded
       */
      emitSafe(event, ...args) {
        const listeners = this.events.get(event);
        if (!listeners || listeners.length === 0) {
          return true;
        }
  
        const listenersCopy = [...listeners];
        let allSucceeded = true;
  
        for (const listener of listenersCopy) {
          try {
            listener(...args);
          } catch (error) {
            allSucceeded = false;
            console.error(`Error in event listener for '${event}':`, error);
          }
        }
  
        return allSucceeded;
      }
    }
  
    /**
     * Global event bus singleton
     */
    class EventBus extends EventEmitter {
      constructor() {
        super();
        if (EventBus.instance) {
          return EventBus.instance;
        }
        EventBus.instance = this;
      }
  
      /**
       * Get singleton instance
       * @returns {EventBus} Singleton instance
       */
      static getInstance() {
        if (!EventBus.instance) {
          EventBus.instance = new EventBus();
        }
        return EventBus.instance;
      }
    }
  
    // Common event names
    const Events = {
      // App lifecycle
      APP_INITIALIZED: 'app:initialized',
      APP_READY: 'app:ready',
      APP_ERROR: 'app:error',
  
      // Directory
      DIRECTORY_SELECTED: 'directory:selected',
      DIRECTORY_CHANGED: 'directory:changed',
  
      // Project/Task
      PROJECT_SELECTED: 'project:selected',
      PROJECT_CREATED: 'project:created',
      TASK_CREATED: 'task:created',
      TASK_COMPLETED: 'task:completed',
  
      // Phase
      PHASE_CHANGED: 'phase:changed',
  
      // Messages
      USER_MESSAGE: 'message:user',
      ASSISTANT_MESSAGE: 'message:assistant',
      TOOL_USE: 'message:tool_use',
      TOOL_RESULT: 'message:tool_result',
  
      // Processing
      PROCESSING_START: 'processing:start',
      PROCESSING_END: 'processing:end',
      PROCESSING_ERROR: 'processing:error',
  
      // Checklist
      CHECKLIST_CREATED: 'checklist:created',
      CHECKLIST_APPROVED: 'checklist:approved',
      CHECKLIST_REJECTED: 'checklist:rejected',
      ITEM_CHANGED: 'checklist:item_changed',
  
      // UI
      UI_INITIALIZED: 'ui:initialized',
      UI_ERROR: 'ui:error',
  
      // State
      STATE_CHANGED: 'state:changed',
      STATE_SAVED: 'state:saved',
      STATE_LOADED: 'state:loaded'
    };
  
    // Export to window.module
    window.module = window.module || {};
    window.module.EventEmitter = EventEmitter;
    window.module.EventBus = EventBus;
    window.module.Events = Events;
  
  })();

  // ============================================================================
  // src/storage-manager.js
  // ============================================================================

  /**
   * storage-manager.js
   *
   * Wrapper for localStorage with:
   * - Type-safe storage operations
   * - JSON serialization/deserialization
   * - Storage quota management
   * - Key namespacing
   * - Error handling
   */
  
  (function() {
    'use strict';
  
    /**
     * StorageManager class
     * Manages localStorage with type safety and error handling
     */
    class StorageManager {
      constructor(namespace = 'code_boss') {
        this.namespace = namespace;
        this.prefix = `${namespace}:`;
      }
  
      /**
       * Get prefixed key
       * @param {string} key - Key name
       * @returns {string} Prefixed key
       * @private
       */
      getKey(key) {
        return this.prefix + key;
      }
  
      /**
       * Set item in storage
       * @param {string} key - Key name
       * @param {*} value - Value to store (will be JSON serialized)
       * @returns {boolean} True if successful
       */
      set(key, value) {
        try {
          const prefixedKey = this.getKey(key);
          const serialized = JSON.stringify(value);
          localStorage.setItem(prefixedKey, serialized);
          return true;
        } catch (error) {
          if (error.name === 'QuotaExceededError') {
            console.error('[StorageManager] Storage quota exceeded:', error);
          } else {
            console.error('[StorageManager] Failed to set item:', error);
          }
          return false;
        }
      }
  
      /**
       * Get item from storage
       * @param {string} key - Key name
       * @param {*} defaultValue - Default value if not found
       * @returns {*} Stored value or default
       */
      get(key, defaultValue = null) {
        try {
          const prefixedKey = this.getKey(key);
          const serialized = localStorage.getItem(prefixedKey);
  
          if (serialized === null) {
            return defaultValue;
          }
  
          return JSON.parse(serialized);
        } catch (error) {
          console.error('[StorageManager] Failed to get item:', error);
          return defaultValue;
        }
      }
  
      /**
       * Remove item from storage
       * @param {string} key - Key name
       * @returns {void}
       */
      remove(key) {
        try {
          const prefixedKey = this.getKey(key);
          localStorage.removeItem(prefixedKey);
        } catch (error) {
          console.error('[StorageManager] Failed to remove item:', error);
        }
      }
  
      /**
       * Check if key exists
       * @param {string} key - Key name
       * @returns {boolean} True if exists
       */
      has(key) {
        const prefixedKey = this.getKey(key);
        return localStorage.getItem(prefixedKey) !== null;
      }
  
      /**
       * Clear all items in namespace
       * @returns {void}
       */
      clear() {
        try {
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.prefix)) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));
        } catch (error) {
          console.error('[StorageManager] Failed to clear storage:', error);
        }
      }
  
      /**
       * Get all keys in namespace
       * @returns {Array<string>} Array of keys (without prefix)
       */
      keys() {
        const keys = [];
        try {
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.prefix)) {
              keys.push(key.substring(this.prefix.length));
            }
          }
        } catch (error) {
          console.error('[StorageManager] Failed to get keys:', error);
        }
        return keys;
      }
  
      /**
       * Get storage size used by namespace
       * @returns {number} Size in bytes
       */
      getSize() {
        let totalSize = 0;
        try {
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.prefix)) {
              const value = localStorage.getItem(key);
              totalSize += key.length + (value ? value.length : 0);
            }
          }
        } catch (error) {
          console.error('[StorageManager] Failed to get size:', error);
        }
        return totalSize;
      }
  
      /**
       * Get remaining storage quota
       * @returns {number} Remaining bytes (estimate)
       */
      getRemainingQuota() {
        const estimatedQuota = 5 * 1024 * 1024; // 5MB estimate
        const usedSize = this.getSize();
        return Math.max(0, estimatedQuota - usedSize);
      }
  
      /**
       * Check if storage is available
       * @returns {boolean} True if localStorage is available
       */
      isAvailable() {
        try {
          const testKey = this.prefix + '__test__';
          localStorage.setItem(testKey, 'test');
          localStorage.removeItem(testKey);
          return true;
        } catch (error) {
          return false;
        }
      }
  
      /**
       * Export all data in namespace
       * @returns {Object} All key-value pairs
       */
      exportAll() {
        const data = {};
        const keys = this.keys();
        keys.forEach(key => {
          data[key] = this.get(key);
        });
        return data;
      }
  
      /**
       * Import data into namespace
       * @param {Object} data - Data to import
       * @param {boolean} overwrite - Overwrite existing keys
       * @returns {number} Number of items imported
       */
      importAll(data, overwrite = false) {
        let count = 0;
        for (const key in data) {
          if (data.hasOwnProperty(key)) {
            if (overwrite || !this.has(key)) {
              this.set(key, data[key]);
              count++;
            }
          }
        }
        return count;
      }
  
      /**
       * Set string value (no JSON serialization)
       * @param {string} key - Key name
       * @param {string} value - String value
       * @returns {boolean} True if successful
       */
      setString(key, value) {
        try {
          const prefixedKey = this.getKey(key);
          localStorage.setItem(prefixedKey, value);
          return true;
        } catch (error) {
          console.error('[StorageManager] Failed to set string:', error);
          return false;
        }
      }
  
      /**
       * Get string value (no JSON parsing)
       * @param {string} key - Key name
       * @param {string} defaultValue - Default value
       * @returns {string} Stored string or default
       */
      getString(key, defaultValue = '') {
        try {
          const prefixedKey = this.getKey(key);
          const value = localStorage.getItem(prefixedKey);
          return value !== null ? value : defaultValue;
        } catch (error) {
          console.error('[StorageManager] Failed to get string:', error);
          return defaultValue;
        }
      }
  
      /**
       * Set number value
       * @param {string} key - Key name
       * @param {number} value - Number value
       * @returns {boolean} True if successful
       */
      setNumber(key, value) {
        if (typeof value !== 'number' || isNaN(value)) {
          console.error('[StorageManager] Invalid number value:', value);
          return false;
        }
        return this.setString(key, value.toString());
      }
  
      /**
       * Get number value
       * @param {string} key - Key name
       * @param {number} defaultValue - Default value
       * @returns {number} Stored number or default
       */
      getNumber(key, defaultValue = 0) {
        const value = this.getString(key, null);
        if (value === null) {
          return defaultValue;
        }
        const parsed = parseFloat(value);
        return isNaN(parsed) ? defaultValue : parsed;
      }
  
      /**
       * Set boolean value
       * @param {string} key - Key name
       * @param {boolean} value - Boolean value
       * @returns {boolean} True if successful
       */
      setBoolean(key, value) {
        return this.setString(key, value ? 'true' : 'false');
      }
  
      /**
       * Get boolean value
       * @param {string} key - Key name
       * @param {boolean} defaultValue - Default value
       * @returns {boolean} Stored boolean or default
       */
      getBoolean(key, defaultValue = false) {
        const value = this.getString(key, null);
        if (value === null) {
          return defaultValue;
        }
        return value === 'true';
      }
  
      /**
       * Get namespace
       * @returns {string} Namespace
       */
      getNamespace() {
        return this.namespace;
      }
  
      /**
       * Create sub-namespace manager
       * @param {string} subNamespace - Sub-namespace name
       * @returns {StorageManager} New storage manager with sub-namespace
       */
      subNamespace(subNamespace) {
        const fullNamespace = `${this.namespace}.${subNamespace}`;
        return new StorageManager(fullNamespace);
      }
    }
  
    /**
     * Storage keys used by Code Boss
     */
    const StorageKeys = {
      // Directory
      DIRECTORY_PATH: 'directory_path',
      LAST_DIRECTORY_HANDLE: 'last_directory_handle',
  
      // UI State
      TERMINAL_HISTORY: 'terminal_history',
      COMMAND_HISTORY: 'command_history',
      WINDOW_SIZE: 'window_size',
  
      // User Preferences
      THEME: 'theme',
      FONT_SIZE: 'font_size',
      AUTO_SCROLL: 'auto_scroll',
  
      // Session
      LAST_PROJECT: 'last_project',
      LAST_TASK: 'last_task',
  
      // Debug
      DEBUG_MODE: 'debug_mode',
      LOG_LEVEL: 'log_level'
    };
  
    // Export to window.module
    window.module = window.module || {};
    window.module.StorageManager = StorageManager;
    window.module.StorageKeys = StorageKeys;
  
  })();

  // ============================================================================
  // src/conversation-state.js
  // ============================================================================

  /**
   * conversation-state.js
   *
   * Defines the core ConversationState data structure and related types.
   * This is the central state object that tracks:
   * - Current project, task, and phase
   * - Mental models (project and task level)
   * - Ephemeral content (cleared after each AI message)
   * - Recent changes (last 10 operations)
   * - Checklist items
   * - Message history
   *
   * Based on: specs/DATA-STRUCTURES.md, specs/ARCHITECTURE.md
   */
  
  (function() {
    'use strict';
  
    /**
     * Message types that can exist in conversation history
     */
    const MessageType = {
      USER_MSG: 'user_msg',
      ASSISTANT_MSG: 'assistant_msg',
      TOOL_USE: 'tool_use',
      TOOL_RESULT: 'tool_result',
      PHASE_TRANSITION: 'phase_transition',
      MENTAL_MODEL_UPDATE: 'mental_model_update',
      CHECKLIST_APPROVED: 'checklist_approved',
      SYSTEM_MSG: 'system_msg',  // System messages (phase transitions, etc.)
      GREETING: 'greeting',      // Initial greeting messages (not sent to API)
      TASK_COMPLETE: 'task_complete', // Task completion with continuation prompt (not sent to API)
      LOADING: 'loading'  // In-memory only, not persisted
    };
  
    /**
     * Phase names
     */
    const Phase = {
      PLANNING: 'planning',
      EXECUTION: 'execution',
      REVIEW: 'review'
    };
  
    /**
     * Item types for checklist items
     */
    const ItemType = {
      CODING: 'coding',       // File operations only
      GIT: 'git',            // Git write operations
      TESTING: 'testing',     // Command execution
      RESEARCH: 'research'    // Read-only investigation
    };
  
    /**
     * Item status values
     */
    const ItemStatus = {
      PENDING: 'pending',
      IN_PROGRESS: 'in_progress',
      COMPLETE: 'complete',
      FAILED: 'failed'
    };
  
    /**
     * Change types for recent changes
     */
    const ChangeType = {
      CREATE: 'create',
      UPDATE: 'update',
      DELETE: 'delete',
      MOVE: 'move',
      GIT_COMMIT: 'git_commit'
    };
  
    /**
     * Processing status values
     */
    const ProcessingStatus = {
      PROCESSING: 'processing',
      COMPLETE: 'complete',
      ERROR: 'error'
    };
  
    /**
     * Creates a new message object
     * @param {string} type - Message type from MessageType
     * @param {Object} data - Type-specific message data
     * @returns {Object} Message object with id and timestamp
     */
    function createMessage(type, data) {
      return {
        id: generateMessageId(),
        type: type,
        timestamp: Date.now(),
        ...data
      };
    }
  
    /**
     * Creates a user message
     * @param {string} content - User's message content
     * @returns {Object} User message object
     */
    function createUserMessage(content) {
      return createMessage(MessageType.USER_MSG, { content });
    }
  
    /**
     * Creates an assistant message
     * @param {string} content - Assistant's message content
     * @returns {Object} Assistant message object
     */
    function createAssistantMessage(content) {
      return createMessage(MessageType.ASSISTANT_MSG, { content });
    }
  
    /**
     * Creates a tool use message
     * @param {string} toolName - Name of the tool being called
     * @param {Object} parameters - Tool parameters
     * @returns {Object} Tool use message object
     */
    function createToolUseMessage(toolName, parameters) {
      return createMessage(MessageType.TOOL_USE, { toolName, parameters });
    }
  
    /**
     * Creates a tool result message
     * @param {string} toolName - Name of the tool that was executed
     * @param {*} result - Tool execution result
     * @returns {Object} Tool result message object
     */
    function createToolResultMessage(toolName, result) {
      return createMessage(MessageType.TOOL_RESULT, { toolName, result });
    }
  
    /**
     * Creates a phase transition message
     * @param {string} from - Previous phase
     * @param {string} to - New phase
     * @param {string} trigger - What triggered the transition
     * @returns {Object} Phase transition message object
     */
    function createPhaseTransitionMessage(from, to, trigger) {
      return createMessage(MessageType.PHASE_TRANSITION, { from, to, trigger });
    }
  
    /**
     * Creates a mental model update message
     * @param {Object} updates - Map of file/key to note string
     * @returns {Object} Mental model update message object
     */
    function createMentalModelUpdateMessage(updates) {
      return createMessage(MessageType.MENTAL_MODEL_UPDATE, { updates });
    }
  
    /**
     * Creates a checklist approved message
     * @param {string} taskDescription - Description of the task
     * @param {Array} items - Checklist items
     * @returns {Object} Checklist approved message object
     */
    function createChecklistApprovedMessage(taskDescription, items) {
      return createMessage(MessageType.CHECKLIST_APPROVED, { task_description: taskDescription, items });
    }
  
    /**
     * Creates a system message
     * @param {string} content - System message content
     * @returns {Object} System message object
     */
    function createSystemMessage(content) {
      return createMessage(MessageType.SYSTEM_MSG, { content });
    }
  
    /**
     * Creates a greeting message (display only, not sent to API)
     * @param {string} content - Greeting message content
     * @returns {Object} Greeting message object
     */
    function createGreetingMessage(content) {
      return createMessage(MessageType.GREETING, { content });
    }
  
    /**
     * Creates a loading message (in-memory only)
     * @returns {Object} Loading message object
     */
    function createLoadingMessage() {
      return createMessage(MessageType.LOADING, { content: '' });
    }
  
    /**
     * Creates a task completion message (display only, not sent to API)
     * @param {string} completionMessage - Message to display at end of task
     * @param {string} continuationPrompt - Prompt to show when starting new task
     * @returns {Object} Task completion message object
     */
    function createTaskCompleteMessage(completionMessage, continuationPrompt) {
      return createMessage(MessageType.TASK_COMPLETE, {
        completionMessage,
        continuationPrompt
      });
    }
  
    /**
     * Creates a checklist item
     * @param {string} shortDesc - Short description for UI
     * @param {string} detailedDesc - Detailed description for AI
     * @param {string} itemType - Item type from ItemType
     * @returns {Object} Checklist item object
     */
    function createChecklistItem(shortDesc, detailedDesc, itemType) {
      return {
        id: generateItemId(),
        short_desc: shortDesc,
        detailed_desc: detailedDesc,
        item_type: itemType,
        status: ItemStatus.PENDING
      };
    }
  
    /**
     * Creates a change entry for recent changes
     * @param {string} type - Change type from ChangeType
     * @param {string} file - File path (null for git_commit)
     * @param {string} description - Description of the change
     * @param {number} linesChanged - Number of lines changed
     * @param {string} diff - Short diff (null if >10 lines)
     * @returns {Object} Change entry object
     */
    function createChangeEntry(type, file, description, linesChanged, diff) {
      return {
        id: generateChangeId(),
        type,
        file,
        description,
        timestamp: new Date().toISOString(),
        linesChanged,
        diff
      };
    }
  
    /**
     * Creates a new ConversationState object
     * @returns {Object} Fresh conversation state
     */
    function createConversationState() {
      return {
        // Processing state
        busy: false,
        status: ProcessingStatus.COMPLETE,
  
        // Project/Task/Phase
        currentProject: null,
        currentTask: null,
        currentPhase: Phase.PLANNING,
        currentItemIndex: -1,  // -1 means not in execution, >= 0 is current item index
  
        // Mental models (simple string maps)
        projectMentalModel: {},  // file/key -> note string
        taskMentalModel: {},     // file/key -> note string
  
        // Ephemeral content (cleared after each AI message)
        ephemeralFiles: [],           // Array of file paths
        ephemeralContent: {},         // Other ephemeral data (git_read, searches, etc.)
  
        // Recent changes (last 10 operations)
        recentChanges: [],
  
        // Checklist
        checklist: [],
  
        // Conversation history (current task only)
        history: [],
        messageCount: 0
      };
    }
  
    /**
     * Generates a unique message ID
     * @returns {string} Message ID
     */
    function generateMessageId() {
      return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
  
    /**
     * Generates a unique item ID
     * @returns {string} Item ID
     */
    function generateItemId() {
      return 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
  
    /**
     * Generates a unique change ID
     * @returns {string} Change ID
     */
    function generateChangeId() {
      return 'ch_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
  
    /**
     * Checks if a message type is persisted to disk
     * @param {string} type - Message type
     * @returns {boolean} True if message should be persisted
     */
    function isPersistedMessageType(type) {
      // All types except LOADING are persisted
      return type !== MessageType.LOADING;
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ConversationState = {
      // Constants
      MessageType,
      Phase,
      ItemType,
      ItemStatus,
      ChangeType,
      ProcessingStatus,
  
      // Factory functions
      createConversationState,
      createMessage,
      createUserMessage,
      createAssistantMessage,
      createToolUseMessage,
      createToolResultMessage,
      createPhaseTransitionMessage,
      createMentalModelUpdateMessage,
      createChecklistApprovedMessage,
      createSystemMessage,
      createGreetingMessage,
      createLoadingMessage,
      createTaskCompleteMessage,
      createChecklistItem,
      createChangeEntry,
  
      // Utilities
      isPersistedMessageType,
      generateMessageId,
      generateItemId,
      generateChangeId
    };
  
  })();

  // ============================================================================
  // src/file-node.js
  // ============================================================================

  /**
   * File node for file structure cache
   * Represents a file or directory with metadata
   */
  
  (function() {
    'use strict';
  
    /**
     * File node class
     */
    class FileNode {
      constructor(path, type, metadata = {}) {
        this.path = path;
        this.type = type; // 'file' or 'directory'
        this.name = path.split('/').pop();
        this.parent = null;
        this.children = []; // For directories
  
        // File metadata
        this.size = metadata.size || 0;
        this.lines = metadata.lines || 0;
        this.hash = metadata.hash || null;
        this.lastModified = metadata.lastModified || null;
  
        // Token information
        this.estimatedTokens = metadata.estimatedTokens || 0;
  
        // Method signatures (optional)
        this.methodSignatures = metadata.methodSignatures || [];
  
        // Language/type
        this.language = metadata.language || this.detectLanguage();
      }
  
      /**
       * Detect language from file extension
       * @returns {string} Language name
       */
      detectLanguage() {
        throw new Error('Not implemented: detectLanguage()');
  
        // TODO: Implementation
        // 1. Get file extension
        // 2. Map to language:
        //    - .js  javascript
        //    - .java  java
        //    - .py  python
        //    - .ts  typescript
        //    - etc.
        // 3. Return language name
      }
  
      /**
       * Add child node
       * @param {FileNode} child - Child node to add
       */
      addChild(child) {
        throw new Error('Not implemented: addChild()');
  
        // TODO: Implementation
        // 1. Add to children array
        // 2. Set child.parent = this
        // 3. Sort children (directories first, then alphabetical)
      }
  
      /**
       * Remove child node
       * @param {FileNode} child - Child node to remove
       */
      removeChild(child) {
        throw new Error('Not implemented: removeChild()');
  
        // TODO: Implementation
        // 1. Remove from children array
        // 2. Set child.parent = null
      }
  
      /**
       * Get child by name
       * @param {string} name - Child name
       * @returns {FileNode|null} Child node or null
       */
      getChild(name) {
        throw new Error('Not implemented: getChild()');
  
        // TODO: Implementation
        // 1. Find child with matching name
        // 2. Return child or null
      }
  
      /**
       * Get all descendants (recursive)
       * @returns {Array<FileNode>} All descendant nodes
       */
      getDescendants() {
        throw new Error('Not implemented: getDescendants()');
  
        // TODO: Implementation
        // 1. Collect this node
        // 2. Recursively collect children's descendants
        // 3. Return flattened array
      }
  
      /**
       * Get depth in tree (0 = root)
       * @returns {number} Depth
       */
      getDepth() {
        throw new Error('Not implemented: getDepth()');
  
        // TODO: Implementation
        // 1. Count parents up to root
        // 2. Return count
      }
  
      /**
       * Check if node is ancestor of another node
       * @param {FileNode} node - Potential descendant
       * @returns {boolean} True if ancestor
       */
      isAncestorOf(node) {
        throw new Error('Not implemented: isAncestorOf()');
  
        // TODO: Implementation
        // 1. Walk up from node to root
        // 2. Check if this node is encountered
        // 3. Return boolean
      }
  
      /**
       * Format as tree string
       * @param {number} indent - Indentation level
       * @param {boolean} showTokens - Whether to show token estimates
       * @returns {string} Formatted tree string
       */
      toTreeString(indent = 0, showTokens = true) {
        throw new Error('Not implemented: toTreeString()');
  
        // TODO: Implementation
        // 1. Format this node with indentation
        // 2. If showTokens, include token estimate
        // 3. If directory, recursively format children
        // 4. Return formatted string
  
        // Example format:
        // src/ (500 tokens)
        //   Calculator.java (150 tokens)
        //   User.java (200 tokens)
        //   utils/
        //     ValidationUtils.java (150 tokens)
      }
  
      /**
       * Serialize to JSON
       * @returns {Object} JSON representation
       */
      toJSON() {
        throw new Error('Not implemented: toJSON()');
  
        // TODO: Implementation
        // 1. Create object with all properties
        // 2. Serialize children recursively
        // 3. Omit parent reference (avoid circular)
        // 4. Return object
      }
  
      /**
       * Deserialize from JSON
       * @param {Object} json - JSON object
       * @returns {FileNode} Reconstructed node
       */
      static fromJSON(json) {
        throw new Error('Not implemented: fromJSON()');
  
        // TODO: Implementation
        // 1. Create FileNode from json properties
        // 2. Recursively deserialize children
        // 3. Rebuild parent references
        // 4. Return root node
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.FileNode = FileNode;
  
  })();

  // ============================================================================
  // src/tokenizer.js
  // ============================================================================

  /**
   * Generic tokenizer for character-by-character parsing
   * Base class for XML and JSON tokenizers
   */
  
  (function() {
    'use strict';
  
    /**
     * Token types
     */
    const TokenType = {
      TEXT: 'text',
      TAG_OPEN: 'tag_open',
      TAG_CLOSE: 'tag_close',
      ATTRIBUTE: 'attribute',
      STRING: 'string',
      NUMBER: 'number',
      BOOLEAN: 'boolean',
      NULL: 'null',
      ARRAY_START: 'array_start',
      ARRAY_END: 'array_end',
      OBJECT_START: 'object_start',
      OBJECT_END: 'object_end',
      COMMA: 'comma',
      COLON: 'colon',
      WHITESPACE: 'whitespace',
      EOF: 'eof'
    };
  
    /**
     * Token class
     */
    class Token {
      constructor(type, value, position) {
        this.type = type;
        this.value = value;
        this.position = position;
      }
    }
  
    /**
     * Base tokenizer class
     */
    class Tokenizer {
      constructor(input) {
        this.input = input;
        this.position = 0;
        this.line = 1;
        this.column = 1;
        this.tokens = [];
      }
  
      /**
       * Check if at end of input
       */
      isEOF() {
        return this.position >= this.input.length;
      }
  
      /**
       * Peek at current character without consuming
       */
      peek(offset = 0) {
        const pos = this.position + offset;
        if (pos >= this.input.length) {
          return null;
        }
        return this.input[pos];
      }
  
      /**
       * Consume and return current character
       */
      consume() {
        if (this.isEOF()) {
          return null;
        }
  
        const char = this.input[this.position];
        this.position++;
  
        if (char === '\n') {
          this.line++;
          this.column = 1;
        } else {
          this.column++;
        }
  
        return char;
      }
  
      /**
       * Consume while predicate is true
       */
      consumeWhile(predicate) {
        let result = '';
        while (!this.isEOF() && predicate(this.peek())) {
          result += this.consume();
        }
        return result;
      }
  
      /**
       * Skip whitespace
       */
      skipWhitespace() {
        this.consumeWhile(char => /\s/.test(char));
      }
  
      /**
       * Check if character is whitespace
       */
      isWhitespace(char) {
        return /\s/.test(char);
      }
  
      /**
       * Check if character is digit
       */
      isDigit(char) {
        return /[0-9]/.test(char);
      }
  
      /**
       * Check if character is letter
       */
      isLetter(char) {
        return /[a-zA-Z]/.test(char);
      }
  
      /**
       * Check if character is alphanumeric
       */
      isAlphanumeric(char) {
        return /[a-zA-Z0-9]/.test(char);
      }
  
      /**
       * Get current position info
       */
      getPosition() {
        return {
          offset: this.position,
          line: this.line,
          column: this.column
        };
      }
  
      /**
       * Create token at current position
       */
      createToken(type, value) {
        return new Token(type, value, this.getPosition());
      }
  
      /**
       * Add token to tokens list
       */
      addToken(type, value) {
        const token = this.createToken(type, value);
        this.tokens.push(token);
        return token;
      }
  
      /**
       * Tokenize input (to be implemented by subclasses)
       */
      tokenize() {
        throw new Error('Not implemented: tokenize() must be implemented by subclass');
      }
  
      /**
       * Get all tokens
       */
      getTokens() {
        if (this.tokens.length === 0) {
          this.tokenize();
        }
        return this.tokens;
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.Tokenizer = Tokenizer;
    window.module.Token = Token;
    window.module.TokenType = TokenType;
  
  })();

  // ============================================================================
  // src/xml-tokenizer.js
  // ============================================================================

  /**
   * XML tokenizer for parsing XML character by character
   * Used by LenientXMLParser for more robust parsing
   */
  
  (function() {
    'use strict';
  
    const { Tokenizer, TokenType } = window.module;
  
    /**
     * XML-specific token types
     */
    const XMLTokenType = {
      ...TokenType,
      TAG_START: 'tag_start',           // <
      TAG_END: 'tag_end',               // >
      TAG_SELF_CLOSE: 'tag_self_close', // />
      TAG_NAME: 'tag_name',             // element name
      ATTR_NAME: 'attr_name',           // attribute name
      ATTR_VALUE: 'attr_value',         // attribute value
      TEXT_CONTENT: 'text_content',     // text between tags
      CDATA_START: 'cdata_start',       // <![CDATA[
      CDATA_END: 'cdata_end',           // ]]>
      CDATA_CONTENT: 'cdata_content',   // CDATA content
      COMMENT_START: 'comment_start',   // <!--
      COMMENT_END: 'comment_end',       // -->
      COMMENT_CONTENT: 'comment_content' // Comment content
    };
  
    /**
     * XML tokenizer
     */
    class XMLTokenizer extends Tokenizer {
      constructor(input) {
        super(input);
      }
  
      /**
       * Tokenize XML input
       */
      tokenize() {
        throw new Error('Not implemented: XML tokenization logic');
  
        // TODO: Implement XML tokenization
        // 1. Scan for < to find tag starts
        // 2. Parse tag name and attributes
        // 3. Handle self-closing tags />
        // 4. Handle closing tags </name>
        // 5. Extract text content between tags
        // 6. Handle CDATA sections <![CDATA[...]]>
        // 7. Handle comments <!-- ... -->
        // 8. Track nesting level for validation
  
        // Example skeleton:
        /*
        while (!this.isEOF()) {
          this.skipWhitespace();
  
          if (this.peek() === '<') {
            if (this.peek(1) === '!') {
              if (this.peek(2) === '[' && this.peek(3) === 'C') {
                // CDATA section
                this.parseCDATA();
              } else if (this.peek(2) === '-' && this.peek(3) === '-') {
                // Comment
                this.parseComment();
              }
            } else if (this.peek(1) === '/') {
              // Closing tag
              this.parseClosingTag();
            } else {
              // Opening tag
              this.parseOpeningTag();
            }
          } else {
            // Text content
            this.parseTextContent();
          }
        }
  
        this.addToken(XMLTokenType.EOF, null);
        */
      }
  
      /**
       * Parse opening tag: <name attr="value">
       */
      parseOpeningTag() {
        throw new Error('Not implemented: parseOpeningTag()');
  
        // TODO: Implementation
        // 1. Consume '<'
        // 2. Parse tag name
        // 3. Parse attributes (key="value" or key='value')
        // 4. Check for self-closing '/>'
        // 5. Consume '>'
      }
  
      /**
       * Parse closing tag: </name>
       */
      parseClosingTag() {
        throw new Error('Not implemented: parseClosingTag()');
  
        // TODO: Implementation
        // 1. Consume '</'
        // 2. Parse tag name
        // 3. Consume '>'
      }
  
      /**
       * Parse text content between tags
       */
      parseTextContent() {
        throw new Error('Not implemented: parseTextContent()');
  
        // TODO: Implementation
        // Consume all characters until '<'
      }
  
      /**
       * Parse CDATA section: <![CDATA[...]]>
       */
      parseCDATA() {
        throw new Error('Not implemented: parseCDATA()');
  
        // TODO: Implementation
        // 1. Consume '<![CDATA['
        // 2. Read content until ']]>'
        // 3. Handle incomplete CDATA (AI might forget closing)
      }
  
      /**
       * Parse comment: <!-- ... -->
       */
      parseComment() {
        throw new Error('Not implemented: parseComment()');
  
        // TODO: Implementation
        // 1. Consume '<!--'
        // 2. Read content until '-->'
        // 3. Handle incomplete comments
      }
  
      /**
       * Parse attribute: name="value" or name='value'
       */
      parseAttribute() {
        throw new Error('Not implemented: parseAttribute()');
  
        // TODO: Implementation
        // 1. Parse attribute name (alphanumeric + _-)
        // 2. Consume '='
        // 3. Parse quoted value (handle both " and ')
        // 4. Handle unquoted values (lenient parsing)
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.XMLTokenizer = XMLTokenizer;
    window.module.XMLTokenType = XMLTokenType;
  
  })();

  // ============================================================================
  // src/json-tokenizer.js
  // ============================================================================

  /**
   * JSON tokenizer for parsing JSON character by character
   * Used by LenientJsonParser for more robust parsing
   */
  
  (function() {
    'use strict';
  
    const { Tokenizer, TokenType } = window.module;
  
    /**
     * JSON tokenizer
     */
    class JSONTokenizer extends Tokenizer {
      constructor(input) {
        super(input);
      }
  
      /**
       * Tokenize JSON input
       */
      tokenize() {
        throw new Error('Not implemented: JSON tokenization logic');
  
        // TODO: Implement JSON tokenization
        // 1. Parse strings (handle escape sequences)
        // 2. Parse numbers (int, float, scientific notation)
        // 3. Parse booleans (true/false)
        // 4. Parse null
        // 5. Parse arrays [...]
        // 6. Parse objects {...}
        // 7. Parse commas and colons
        // 8. Handle whitespace
        // 9. Handle incomplete/malformed structures (lenient)
  
        // Example skeleton:
        /*
        while (!this.isEOF()) {
          this.skipWhitespace();
  
          const char = this.peek();
  
          if (char === '"' || char === "'") {
            this.parseString();
          } else if (this.isDigit(char) || char === '-') {
            this.parseNumber();
          } else if (char === '{') {
            this.addToken(TokenType.OBJECT_START, char);
            this.consume();
          } else if (char === '}') {
            this.addToken(TokenType.OBJECT_END, char);
            this.consume();
          } else if (char === '[') {
            this.addToken(TokenType.ARRAY_START, char);
            this.consume();
          } else if (char === ']') {
            this.addToken(TokenType.ARRAY_END, char);
            this.consume();
          } else if (char === ',') {
            this.addToken(TokenType.COMMA, char);
            this.consume();
          } else if (char === ':') {
            this.addToken(TokenType.COLON, char);
            this.consume();
          } else if (this.peek(0) === 't' && this.peek(1) === 'r' &&
                     this.peek(2) === 'u' && this.peek(3) === 'e') {
            this.parseBoolean();
          } else if (this.peek(0) === 'f' && this.peek(1) === 'a' &&
                     this.peek(2) === 'l' && this.peek(3) === 's' &&
                     this.peek(4) === 'e') {
            this.parseBoolean();
          } else if (this.peek(0) === 'n' && this.peek(1) === 'u' &&
                     this.peek(2) === 'l' && this.peek(3) === 'l') {
            this.parseNull();
          } else {
            // Unknown character, skip or error
            this.consume();
          }
        }
  
        this.addToken(TokenType.EOF, null);
        */
      }
  
      /**
       * Parse string: "value" or 'value'
       */
      parseString() {
        throw new Error('Not implemented: parseString()');
  
        // TODO: Implementation
        // 1. Track opening quote (" or ')
        // 2. Consume characters until closing quote
        // 3. Handle escape sequences (\n, \t, \\, \", etc.)
        // 4. Handle incomplete strings (missing closing quote)
        // 5. Handle unicode escapes (\uXXXX)
      }
  
      /**
       * Parse number: integer, float, scientific notation
       */
      parseNumber() {
        throw new Error('Not implemented: parseNumber()');
  
        // TODO: Implementation
        // 1. Handle negative sign
        // 2. Parse integer part
        // 3. Parse decimal part (.123)
        // 4. Parse exponent part (e+10, E-5)
        // 5. Convert to JavaScript number
      }
  
      /**
       * Parse boolean: true or false
       */
      parseBoolean() {
        throw new Error('Not implemented: parseBoolean()');
  
        // TODO: Implementation
        // 1. Check for 'true' or 'false' keyword
        // 2. Consume characters
        // 3. Return boolean token
      }
  
      /**
       * Parse null: null
       */
      parseNull() {
        throw new Error('Not implemented: parseNull()');
  
        // TODO: Implementation
        // 1. Check for 'null' keyword
        // 2. Consume characters
        // 3. Return null token
      }
  
      /**
       * Parse object key (may be unquoted in lenient mode)
       */
      parseObjectKey() {
        throw new Error('Not implemented: parseObjectKey()');
  
        // TODO: Implementation
        // 1. Try to parse as quoted string
        // 2. If not quoted, parse as identifier (lenient)
        // 3. Allow alphanumeric + _ + - characters
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.JSONTokenizer = JSONTokenizer;
  
  })();

  // ============================================================================
  // src/xml-parser.js
  // ============================================================================

  /**
   * xml-parser.js
   *
   * Lenient XML parser for AI-generated XML
   * Parses XML into a tree structure of elements with text content and attributes
   *
   * Ported from: src_old/com/codeboss/javalayer/aiprocessor/LenientXMLParser.java
   */
  
  (function() {
    'use strict';
  
    /**
     * XML Element class
     */
    class Element {
      constructor(name, attributes, textContent, children, trimText = true) {
        this.name = name;
        this.attributes = attributes || {};
        this.textContent = textContent ? (trimText ? textContent.trim() : textContent) : '';
        this.children = children || [];
      }
  
      /**
       * Get first child element with the given name
       * @param {string} name - Child element name
       * @returns {Element|null} First matching child or null
       */
      getChild(name) {
        return this.children.find(child => child.name === name) || null;
      }
  
      /**
       * Get all child elements with the given name
       * @param {string} name - Child element name
       * @returns {Array<Element>} Matching children
       */
      getChildren(name) {
        return this.children.filter(child => child.name === name);
      }
  
      /**
       * Get attribute value by name
       * @param {string} name - Attribute name
       * @returns {string|undefined} Attribute value
       */
      getAttribute(name) {
        return this.attributes[name];
      }
  
      /**
       * Check if element has attribute
       * @param {string} name - Attribute name
       * @returns {boolean} True if attribute exists
       */
      hasAttribute(name) {
        return name in this.attributes;
      }
    }
  
    /**
     * Parse XML string into root element
     * @param {string} xml - XML string to parse
     * @param {Array<Array<string>>} rawContentPaths - Paths where content should be treated as raw text
     * @returns {Element} Root element
     */
    function parse(xml, rawContentPaths = []) {
      if (!xml || xml.trim().length === 0) {
        throw new Error('XML cannot be null or empty');
      }
  
      xml = xml.trim();
  
      // Find root element
      const rootPattern = /^<([a-zA-Z_][a-zA-Z0-9_-]*)([^>]*)>(.*)<\/\1>$/s;
      const rootMatch = xml.match(rootPattern);
  
      if (!rootMatch) {
        throw new Error('Invalid XML: no root element found');
      }
  
      const rootName = rootMatch[1];
      const rootAttributesStr = rootMatch[2];
      const rootContent = rootMatch[3];
  
      const rootAttributes = parseAttributes(rootAttributesStr);
  
      // Start parsing with path [rootName]
      const currentPath = [rootName];
  
      // Parse content (children or text)
      const contentResult = parseContent(rootContent, currentPath, rawContentPaths);
  
      return new Element(rootName, rootAttributes, contentResult.textContent, contentResult.children, !contentResult.preserveWhitespace);
    }
  
    /**
     * Parse content - determine if it's text or child elements
     * @param {string} content - Content to parse
     * @param {Array<string>} currentPath - Current element path
     * @param {Array<Array<string>>} rawContentPaths - Paths for raw text treatment
     * @returns {Object} ContentResult with textContent, children, preserveWhitespace
     */
    function parseContent(content, currentPath, rawContentPaths) {
      let children = [];
      let textContent = '';
      let preserveWhitespace = false;
  
      // Check if current path matches any raw content path
      if (matchesAnyPath(currentPath, rawContentPaths)) {
        // Treat all content as raw text, don't parse children
        textContent = content;
  
        // Strip ALL CDATA markers from raw content
        if (textContent.includes('<![CDATA[') || textContent.includes(']]>')) {
          // First try to match complete CDATA sections
          textContent = textContent.replace(/<!\[CDATA\[(.*?)\]\]>/gs, '$1');
  
          // Also handle incomplete CDATA tags
          textContent = textContent.replace(/<!\[CDATA\[/g, '');
          textContent = textContent.replace(/\]\]>/g, '');
        }
  
        // Normalize AI formatting issues
        textContent = normalizeAIFormatting(textContent);
        preserveWhitespace = true;
        return { textContent, children, preserveWhitespace };
      }
  
      // First, try to parse as child elements
      if (content.trim().startsWith('<') && !content.trim().startsWith('<![CDATA[')) {
        // Starts with a tag, likely has child elements
        try {
          children = parseChildren(content, currentPath, rawContentPaths);
          // If parseChildren succeeded but returned empty list, treat as text content
          if (children.length === 0) {
            textContent = content;
          }
        } catch (e) {
          // Failed to parse as children, treat as text
          textContent = content;
        }
      } else {
        // Doesn't start with tag (or starts with CDATA), treat as text content
        textContent = content;
  
        // Strip ALL CDATA markers from text content
        if (textContent.includes('<![CDATA[') || textContent.includes(']]>')) {
          // First try to match complete CDATA sections
          textContent = textContent.replace(/<!\[CDATA\[(.*?)\]\]>/gs, '$1');
  
          // Also handle incomplete CDATA tags
          textContent = textContent.replace(/<!\[CDATA\[/g, '');
          textContent = textContent.replace(/\]\]>/g, '');
  
          // Normalize AI formatting issues
          textContent = normalizeAIFormatting(textContent);
          preserveWhitespace = true;
          return { textContent, children, preserveWhitespace };
        }
      }
  
      return { textContent, children, preserveWhitespace };
    }
  
    /**
     * Check if current path matches any of the raw content paths
     * @param {Array<string>} currentPath - Current path
     * @param {Array<Array<string>>} rawContentPaths - Raw content paths
     * @returns {boolean} True if matches
     */
    function matchesAnyPath(currentPath, rawContentPaths) {
      return rawContentPaths.some(rawPath => pathsMatch(currentPath, rawPath));
    }
  
    /**
     * Check if two paths match
     * @param {Array<string>} path1 - First path
     * @param {Array<string>} path2 - Second path
     * @returns {boolean} True if paths match
     */
    function pathsMatch(path1, path2) {
      if (path1.length !== path2.length) {
        return false;
      }
      return path1.every((element, index) => element === path2[index]);
    }
  
    /**
     * Parse attributes from attribute string
     * @param {string} attributeStr - Attribute string
     * @returns {Object} Attributes map
     */
    function parseAttributes(attributeStr) {
      const attributes = {};
  
      if (!attributeStr || attributeStr.trim().length === 0) {
        return attributes;
      }
  
      // Match name="value" or name='value'
      const attrPattern = /([a-zA-Z_][a-zA-Z0-9_-]*)=["']([^"']*)["']/g;
      let match;
  
      while ((match = attrPattern.exec(attributeStr)) !== null) {
        const name = match[1];
        const value = match[2];
        attributes[name] = value;
      }
  
      return attributes;
    }
  
    /**
     * Parse child elements from content
     * @param {string} content - Content to parse
     * @param {Array<string>} currentPath - Current element path
     * @param {Array<Array<string>>} rawContentPaths - Raw content paths
     * @returns {Array<Element>} Child elements
     */
    function parseChildren(content, currentPath, rawContentPaths) {
      const children = [];
  
      // Match both regular and self-closing child elements
      const combinedPattern = /(<([a-zA-Z_][a-zA-Z0-9_-]*)([^>]*?)\/>)|(<([a-zA-Z_][a-zA-Z0-9_-]*)([^>]*)>(.*?)<\/\5>)/gs;
      let match;
  
      while ((match = combinedPattern.exec(content)) !== null) {
        if (match[1]) {
          // Self-closing tag: <tag ... />
          const childName = match[2];
          const childAttributesStr = match[3];
          const childAttributes = parseAttributes(childAttributesStr);
  
          // Self-closing tags have no content
          children.push(new Element(childName, childAttributes, '', []));
        } else {
          // Regular tag: <tag ...>...</tag>
          const childName = match[5];
          const childAttributesStr = match[6];
          const childContent = match[7];
  
          const childAttributes = parseAttributes(childAttributesStr);
  
          // Build child path
          const childPath = [...currentPath, childName];
  
          // Parse content (children or text)
          const contentResult = parseContent(childContent, childPath, rawContentPaths);
  
          children.push(new Element(childName, childAttributes, contentResult.textContent, contentResult.children, !contentResult.preserveWhitespace));
        }
      }
  
      return children;
    }
  
    /**
     * Normalize AI formatting issues in CDATA content
     * @param {string} content - Content to normalize
     * @returns {string} Normalized content
     */
    function normalizeAIFormatting(content) {
      if (!content) {
        return content;
      }
  
      // Fix line continuations: backslash followed by newline
      // Handle all line ending variations
      content = content.replace(/\\\r\n/g, '');  // Windows
      content = content.replace(/\\\n/g, '');     // Unix
      content = content.replace(/\\\r/g, '');     // Old Mac
  
      return content;
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.XMLParser = {
      Element,
      parse,
      parseAttributes,
      normalizeAIFormatting
    };
  
  })();

  // ============================================================================
  // src/json-parser.js
  // ============================================================================

  /**
   * json-parser.js
   *
   * Lenient JSON parser for AI-generated JSON:
   * - Parse incomplete/malformed JSON
   * - Extract valid objects from partial JSON
   * - Handle common AI JSON errors
   *
   * Based on: src_old/com/codeboss/javalayer/shared/LenientJsonParser.java
   */
  
  (function() {
    'use strict';
  
    /**
     * LenientJsonParser class
     * Parses potentially malformed JSON from AI responses
     */
    class LenientJsonParser {
      constructor() {
        this.strictMode = false;
      }
  
      /**
       * Parse JSON with lenient error handling
       * @param {string} jsonStr - JSON string to parse
       * @returns {*} Parsed JSON object/array or null
       */
      parse(jsonStr) {
        // TODO: Try standard JSON.parse first
        // TODO: If fails, attempt fixes:
        //   - Remove trailing commas
        //   - Fix unquoted keys
        //   - Handle incomplete strings
        //   - Handle incomplete arrays/objects
        // TODO: Return parsed result or null
        throw new Error('Not implemented: LenientJsonParser.parse()');
      }
  
      /**
       * Try to parse JSON strictly first
       * @param {string} jsonStr - JSON string
       * @returns {*} Parsed object or null
       * @private
       */
      tryStrictParse(jsonStr) {
        // TODO: Try JSON.parse
        // TODO: Catch and return null on error
        throw new Error('Not implemented: LenientJsonParser.tryStrictParse()');
      }
  
      /**
       * Remove trailing commas
       * @param {string} jsonStr - JSON string
       * @returns {string} Cleaned JSON
       * @private
       */
      removeTrailingCommas(jsonStr) {
        // TODO: Replace patterns like ,} and ,] with } and ]
        // TODO: Handle multiple occurrences
        throw new Error('Not implemented: LenientJsonParser.removeTrailingCommas()');
      }
  
      /**
       * Fix unquoted object keys
       * @param {string} jsonStr - JSON string
       * @returns {string} Fixed JSON
       * @private
       */
      fixUnquotedKeys(jsonStr) {
        // TODO: Find unquoted keys (e.g., {foo: "bar"})
        // TODO: Add quotes around keys
        // TODO: Return fixed JSON
        throw new Error('Not implemented: LenientJsonParser.fixUnquotedKeys()');
      }
  
      /**
       * Handle incomplete strings
       * @param {string} jsonStr - JSON string
       * @returns {string} Fixed JSON
       * @private
       */
      fixIncompleteStrings(jsonStr) {
        // TODO: Find unclosed string literals
        // TODO: Close them properly
        // TODO: Return fixed JSON
        throw new Error('Not implemented: LenientJsonParser.fixIncompleteStrings()');
      }
  
      /**
       * Handle incomplete objects/arrays
       * @param {string} jsonStr - JSON string
       * @returns {string} Fixed JSON
       * @private
       */
      fixIncompleteStructures(jsonStr) {
        // TODO: Count opening/closing braces and brackets
        // TODO: Add missing closing delimiters
        // TODO: Return fixed JSON
        throw new Error('Not implemented: LenientJsonParser.fixIncompleteStructures()');
      }
  
      /**
       * Extract first valid JSON object/array from text
       * @param {string} text - Text containing JSON
       * @returns {*} Parsed JSON or null
       */
      extractFirst(text) {
        // TODO: Find first { or [ character
        // TODO: Extract matching structure
        // TODO: Parse extracted JSON
        // TODO: Return parsed result or null
        throw new Error('Not implemented: LenientJsonParser.extractFirst()');
      }
  
      /**
       * Extract all valid JSON objects/arrays from text
       * @param {string} text - Text containing JSON
       * @returns {Array} Array of parsed JSON objects
       */
      extractAll(text) {
        // TODO: Find all { and [ characters
        // TODO: Extract matching structures
        // TODO: Parse each structure
        // TODO: Return array of valid parsed objects
        throw new Error('Not implemented: LenientJsonParser.extractAll()');
      }
  
      /**
       * Find matching closing delimiter
       * @param {string} text - Text to search
       * @param {number} startIndex - Starting index
       * @param {string} openChar - Opening character ({ or [)
       * @param {string} closeChar - Closing character (} or ])
       * @returns {number} Index of matching close or -1
       * @private
       */
      findMatchingClose(text, startIndex, openChar, closeChar) {
        // TODO: Track nesting depth
        // TODO: Find matching closing delimiter
        // TODO: Handle strings (ignore delimiters in strings)
        // TODO: Return index or -1 if not found
        throw new Error('Not implemented: LenientJsonParser.findMatchingClose()');
      }
  
      /**
       * Validate parsed JSON structure
       * @param {*} obj - Parsed object to validate
       * @returns {boolean} True if valid
       */
      validate(obj) {
        // TODO: Check if obj is object or array
        // TODO: Recursively validate structure
        // TODO: Return validation result
        throw new Error('Not implemented: LenientJsonParser.validate()');
      }
  
      /**
       * Parse JSON with custom error handling
       * @param {string} jsonStr - JSON string
       * @param {Function} errorHandler - Error handler function
       * @returns {*} Parsed object or error result
       */
      parseWithErrorHandler(jsonStr, errorHandler) {
        // TODO: Try to parse
        // TODO: If error, call errorHandler with error
        // TODO: Return parsed result or error handler result
        throw new Error('Not implemented: LenientJsonParser.parseWithErrorHandler()');
      }
  
      /**
       * Set strict mode
       * @param {boolean} strict - Enable strict mode
       */
      setStrictMode(strict) {
        this.strictMode = strict;
      }
  
      /**
       * Check if in strict mode
       * @returns {boolean} True if strict
       */
      isStrictMode() {
        return this.strictMode;
      }
  
      /**
       * Normalize line endings in JSON
       * @param {string} jsonStr - JSON string
       * @returns {string} Normalized JSON
       * @private
       */
      normalizeLineEndings(jsonStr) {
        // TODO: Convert all line endings to \n
        // TODO: Handle \r\n, \r
        throw new Error('Not implemented: LenientJsonParser.normalizeLineEndings()');
      }
  
      /**
       * Remove comments from JSON (non-standard but common)
       * @param {string} jsonStr - JSON string
       * @returns {string} JSON without comments
       * @private
       */
      removeComments(jsonStr) {
        // TODO: Remove // single-line comments
        // TODO: Remove /* multi-line comments */
        // TODO: Be careful not to remove from strings
        throw new Error('Not implemented: LenientJsonParser.removeComments()');
      }
  
      /**
       * Parse JSONL (JSON Lines) format
       * @param {string} jsonlStr - JSONL string (one JSON per line)
       * @returns {Array} Array of parsed objects
       */
      parseJSONL(jsonlStr) {
        // TODO: Split into lines
        // TODO: Parse each line as JSON
        // TODO: Skip empty lines
        // TODO: Collect valid objects
        // TODO: Return array
        throw new Error('Not implemented: LenientJsonParser.parseJSONL()');
      }
  
      /**
       * Stringify with pretty formatting
       * @param {*} obj - Object to stringify
       * @param {number} indent - Indent spaces (default 2)
       * @returns {string} Formatted JSON string
       */
      stringify(obj, indent = 2) {
        return JSON.stringify(obj, null, indent);
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.LenientJsonParser = LenientJsonParser;
  
  })();

  // ============================================================================
  // src/fs-manager.js
  // ============================================================================

  /**
   * fs-manager.js
   *
   * File System Manager using File System Access API
   * Handles all file operations for the browser-only version:
   * - Directory handle management
   * - File read/write operations
   * - Directory operations
   * - .agent/ persistence
   *
   * Based on: specs/BROWSER_ARCHITECTURE.md, MIGRATION_CHECKLIST.md
   */
  
  (function() {
    'use strict';
  
    /**
     * FileSystemManager class
     * Wraps File System Access API for all file operations
     */
    class FileSystemManager {
      constructor() {
        this.rootDirHandle = null;
        this.dirPath = null;
      }
  
      /**
       * Request directory access from user
       * Shows directory picker dialog
       * @returns {Promise<void>}
       */
      async requestDirectoryAccess() {
        console.log('[FSManager] requestDirectoryAccess: Starting...');
  
        if (!('showDirectoryPicker' in window)) {
          console.error('[FSManager] requestDirectoryAccess: File System Access API not supported');
          throw new Error('File System Access API not supported in this browser');
        }
  
        try {
          console.log('[FSManager] requestDirectoryAccess: Showing directory picker...');
          this.rootDirHandle = await window.showDirectoryPicker();
          console.log('[FSManager] requestDirectoryAccess: Got directory handle:', this.rootDirHandle.name);
  
          this.dirPath = this.rootDirHandle.name;
          console.log('[FSManager] requestDirectoryAccess: Set dirPath to:', this.dirPath);
  
          this.saveDirPathToStorage();
          console.log('[FSManager] requestDirectoryAccess: Saved path to storage');
  
          console.log('[FSManager] requestDirectoryAccess: Complete!');
        } catch (error) {
          console.error('[FSManager] requestDirectoryAccess: Error:', error.name, error.message);
          if (error.name === 'AbortError') {
            throw new Error('Directory selection cancelled');
          }
          throw error;
        }
      }
  
      /**
       * Check if we have directory access
       * @returns {boolean} True if we have access
       */
      hasDirectoryAccess() {
        return this.rootDirHandle !== null;
      }
  
      /**
       * Get the current directory path
       * @returns {string|null} Directory path or null
       */
      getDirectoryPath() {
        return this.dirPath;
      }
  
      /**
       * Read a file
       * @param {string} path - File path relative to root
       * @returns {Promise<string>} File contents
       */
      async readFile(path) {
        console.log('[FSManager] readFile called for:', path);
  
        // Try up to 3 times with a small delay between attempts
        // FileReader can fail intermittently with NotReadableError
        const maxAttempts = 3;
        let lastError = null;
  
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
          try {
            const fileHandle = await this.getFileHandle(path);
            console.log(`[FSManager] Attempt ${attempt}: Got file handle:`, fileHandle.name);
  
            const file = await fileHandle.getFile();
            console.log(`[FSManager] Attempt ${attempt}: Got file object, size:`, file.size, 'type:', file.type);
  
            // Try using FileReader as an alternative to file.text()
            // This sometimes works better with browser security restrictions
            const text = await new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = () => reject(reader.error);
              reader.readAsText(file);
            });
  
            console.log(`[FSManager] Attempt ${attempt}: Read`, text.length, 'characters - SUCCESS');
            return text;
  
          } catch (error) {
            lastError = error;
            console.warn(`[FSManager] Attempt ${attempt} failed:`, error.name, error.message);
  
            // If this isn't the last attempt and it's a NotReadableError, wait and retry
            if (attempt < maxAttempts && error.name === 'NotReadableError') {
              const delay = attempt * 100; // 100ms, then 200ms
              console.log(`[FSManager] Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            }
  
            // For other errors or last attempt, throw immediately
            console.error('[FSManager] Error reading file (giving up):', error.name, error.message);
            throw error;
          }
        }
  
        // Should never reach here, but just in case
        throw lastError;
      }
  
      /**
       * Write a file (create or overwrite)
       * @param {string} path - File path relative to root
       * @param {string} content - File content
       * @returns {Promise<void>}
       */
      async writeFile(path, content) {
        const fileHandle = await this.getFileHandle(path, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
      }
  
      /**
       * Append to a file
       * @param {string} path - File path relative to root
       * @param {string} content - Content to append
       * @returns {Promise<void>}
       */
      async appendFile(path, content) {
        let existingContent = '';
        try {
          existingContent = await this.readFile(path);
        } catch (error) {
          // File doesn't exist, will be created
        }
        await this.writeFile(path, existingContent + content);
      }
  
      /**
       * Read JSON file
       * @param {string} path - File path relative to root
       * @returns {Promise<Object>} Parsed JSON object
       */
      async readJSON(path) {
        const content = await this.readFile(path);
        return JSON.parse(content);
      }
  
      /**
       * Write JSON file
       * @param {string} path - File path relative to root
       * @param {Object} data - Data to write as JSON
       * @returns {Promise<void>}
       */
      async writeJSON(path, data) {
        const content = JSON.stringify(data, null, 2);
        await this.writeFile(path, content);
      }
  
      /**
       * Delete a file
       * @param {string} path - File path relative to root
       * @returns {Promise<void>}
       */
      async deleteFile(path) {
        const lastSlash = path.lastIndexOf('/');
        const dirPath = lastSlash >= 0 ? path.substring(0, lastSlash) : '.';
        const fileName = lastSlash >= 0 ? path.substring(lastSlash + 1) : path;
  
        const dirHandle = await this.getDirectoryHandle(dirPath);
        await dirHandle.removeEntry(fileName);
      }
  
      /**
       * Move/rename a file
       * @param {string} fromPath - Source path
       * @param {string} toPath - Destination path
       * @returns {Promise<void>}
       */
      async moveFile(fromPath, toPath) {
        const content = await this.readFile(fromPath);
        await this.writeFile(toPath, content);
        await this.deleteFile(fromPath);
      }
  
      /**
       * Check if a file exists
       * @param {string} path - File path relative to root
       * @returns {Promise<boolean>} True if file exists
       */
      async fileExists(path) {
        try {
          await this.getFileHandle(path);
          return true;
        } catch (error) {
          return false;
        }
      }
  
      /**
       * Create a directory
       * @param {string} path - Directory path relative to root
       * @returns {Promise<void>}
       */
      async createDirectory(path) {
        await this.getDirectoryHandle(path, { create: true });
      }
  
      /**
       * Delete a directory recursively
       * @param {string} path - Directory path relative to root
       * @returns {Promise<void>}
       */
      async deleteDirectory(path) {
        const lastSlash = path.lastIndexOf('/');
        const parentPath = lastSlash >= 0 ? path.substring(0, lastSlash) : '.';
        const dirName = lastSlash >= 0 ? path.substring(lastSlash + 1) : path;
  
        const parentHandle = await this.getDirectoryHandle(parentPath);
        await parentHandle.removeEntry(dirName, { recursive: true });
      }
  
      /**
       * Check if a directory exists
       * @param {string} path - Directory path relative to root
       * @returns {Promise<boolean>} True if directory exists
       */
      async directoryExists(path) {
        try {
          await this.getDirectoryHandle(path);
          return true;
        } catch (error) {
          return false;
        }
      }
  
      /**
       * List files in a directory
       * @param {string} path - Directory path relative to root
       * @param {boolean} recursive - List recursively
       * @returns {Promise<Array<string>>} Array of file paths
       */
      async listFiles(path, recursive = false) {
        const dirHandle = await this.getDirectoryHandle(path);
        const files = [];
  
        async function collectEntries(handle, basePath) {
          for await (const entry of handle.values()) {
            const entryPath = basePath ? `${basePath}/${entry.name}` : entry.name;
  
            if (entry.kind === 'file') {
              files.push(entryPath);
            } else if (entry.kind === 'directory' && recursive) {
              await collectEntries(entry, entryPath);
            }
          }
        }
  
        await collectEntries(dirHandle, path === '.' || !path ? '' : path);
        return files;
      }
  
      /**
       * Ensure we have permission to access the root directory
       * NOTE: We can only CHECK permission here, not request it.
       * requestPermission() requires a user gesture and will throw SecurityError otherwise.
       * @returns {Promise<void>}
       * @private
       */
      async ensurePermission() {
        if (!this.rootDirHandle) {
          console.error('[FSManager] ensurePermission: No root directory handle');
          throw new Error('No directory access. Call requestDirectoryAccess() first.');
        }
  
        console.log('[FSManager] ensurePermission: Checking permission on directory:', this.rootDirHandle.name);
  
        try {
          // Only check permission - we cannot request it without user gesture
          const permission = await this.rootDirHandle.queryPermission({ mode: 'readwrite' });
          console.log('[FSManager] ensurePermission: Permission status:', permission);
  
          // Accept both 'granted' and 'prompt' states
          // 'prompt' means we can still access but might be prompted again
          // 'denied' is the only state we should reject
          if (permission === 'denied') {
            console.error('[FSManager] ensurePermission: Permission explicitly denied');
            throw new Error('File system permission was denied. Please refresh the page and re-select the directory.');
          }
  
          console.log('[FSManager] ensurePermission: Permission OK (status:', permission + ')');
        } catch (error) {
          console.error('[FSManager] ensurePermission: Error checking permission:', error);
          throw error;
        }
      }
  
      /**
       * Get directory handle for a path
       * @param {string} path - Directory path relative to root
       * @param {Object} options - Options like { create: true }
       * @returns {Promise<FileSystemDirectoryHandle>} Directory handle
       * @private
       */
      async getDirectoryHandle(path, options = {}) {
        await this.ensurePermission();
  
        // Handle root directory
        if (!path || path === '.' || path === '/') {
          return this.rootDirHandle;
        }
  
        // Split path and filter empty segments
        const segments = path.split('/').filter(seg => seg && seg !== '.');
  
        let currentHandle = this.rootDirHandle;
        for (const segment of segments) {
          currentHandle = await currentHandle.getDirectoryHandle(segment, options);
        }
  
        return currentHandle;
      }
  
      /**
       * Get file handle for a path
       * @param {string} path - File path relative to root
       * @param {Object} options - Options like { create: true }
       * @returns {Promise<FileSystemFileHandle>} File handle
       * @private
       */
      async getFileHandle(path, options = {}) {
        const lastSlash = path.lastIndexOf('/');
        const dirPath = lastSlash >= 0 ? path.substring(0, lastSlash) : '.';
        const fileName = lastSlash >= 0 ? path.substring(lastSlash + 1) : path;
  
        const dirHandle = await this.getDirectoryHandle(dirPath, options);
        return await dirHandle.getFileHandle(fileName, options);
      }
  
      // .agent/ Specific Operations
  
      /**
       * Initialize .agent directory structure
       * @returns {Promise<void>}
       */
      async initializeAgentDirectory() {
        console.log('[FSManager] initializeAgentDirectory: Starting...');
  
        try {
          console.log('[FSManager] initializeAgentDirectory: Creating .agent directory...');
          await this.createDirectory('.agent');
          console.log('[FSManager] initializeAgentDirectory: Created .agent directory');
        } catch (error) {
          console.error('[FSManager] initializeAgentDirectory: Failed to create .agent directory:', error);
          throw error;
        }
  
        try {
          console.log('[FSManager] initializeAgentDirectory: Creating .agent/projects directory...');
          await this.createDirectory('.agent/projects');
          console.log('[FSManager] initializeAgentDirectory: Created .agent/projects directory');
        } catch (error) {
          console.error('[FSManager] initializeAgentDirectory: Failed to create .agent/projects directory:', error);
          throw error;
        }
  
        try {
          console.log('[FSManager] initializeAgentDirectory: Creating .agent/command-results directory...');
          await this.createDirectory('.agent/command-results');
          console.log('[FSManager] initializeAgentDirectory: Created .agent/command-results directory');
        } catch (error) {
          console.error('[FSManager] initializeAgentDirectory: Failed to create .agent/command-results directory:', error);
          throw error;
        }
  
        // Initialize command queue as idle
        try {
          console.log('[FSManager] initializeAgentDirectory: Writing .agent/command-queue.json...');
          await this.writeJSON('.agent/command-queue.json', {
            status: 'idle',
            timestamp: Date.now()
          });
          console.log('[FSManager] initializeAgentDirectory: Wrote .agent/command-queue.json');
        } catch (e) {
          console.log('[FSManager] initializeAgentDirectory: command-queue.json may already exist, ignoring error');
        }
  
        console.log('[FSManager] initializeAgentDirectory: Complete!');
      }
  
      /**
       * Read state.json
       * @returns {Promise<Object|null>} State object or null if doesn't exist
       */
      async readState() {
        try {
          const content = await this.readFile('.agent/state.json');
          return JSON.parse(content);
        } catch (error) {
          return null;
        }
      }
  
      /**
       * Write state.json
       * @param {Object} state - State object to save
       * @returns {Promise<void>}
       */
      async writeState(state) {
        const content = JSON.stringify(state, null, 2);
        await this.writeFile('.agent/state.json', content);
      }
  
      /**
       * Read project metadata
       * @param {string} projectSlug - Project slug (directory name)
       * @returns {Promise<Object|null>} Project metadata or null
       */
      async readProjectMetadata(projectSlug) {
        try {
          const content = await this.readFile(`.agent/projects/${projectSlug}/metadata.json`);
          return JSON.parse(content);
        } catch (error) {
          return null;
        }
      }
  
      /**
       * Write project metadata
       * @param {string} projectSlug - Project slug
       * @param {Object} metadata - Project metadata object
       * @returns {Promise<void>}
       */
      async writeProjectMetadata(projectSlug, metadata) {
        await this.createDirectory(`.agent/projects/${projectSlug}`);
        const content = JSON.stringify(metadata, null, 2);
        await this.writeFile(`.agent/projects/${projectSlug}/metadata.json`, content);
      }
  
      /**
       * Read task messages from JSONL file
       * @param {string} projectSlug - Project slug
       * @param {string} taskSlug - Task slug
       * @returns {Promise<Array<Object>>} Array of message objects
       */
      async readTaskMessages(projectSlug, taskSlug) {
        try {
          const content = await this.readFile(`.agent/projects/${projectSlug}/${taskSlug}.jsonl`);
          const lines = content.split('\n').filter(line => line.trim());
          return lines.map(line => JSON.parse(line));
        } catch (error) {
          return [];
        }
      }
  
      /**
       * Append message to task JSONL file
       * @param {string} projectSlug - Project slug
       * @param {string} taskSlug - Task slug
       * @param {Object} message - Message object to append
       * @returns {Promise<void>}
       */
      async appendTaskMessage(projectSlug, taskSlug, message) {
        const jsonLine = JSON.stringify(message) + '\n';
        await this.appendFile(`.agent/projects/${projectSlug}/${taskSlug}.jsonl`, jsonLine);
      }
  
      /**
       * List all projects
       * @returns {Promise<Array<string>>} Array of project slugs
       */
      async listProjects() {
        try {
          const dirHandle = await this.getDirectoryHandle('.agent/projects');
          const projects = [];
  
          for await (const entry of dirHandle.values()) {
            if (entry.kind === 'directory') {
              projects.push(entry.name);
            }
          }
  
          return projects;
        } catch (error) {
          return [];
        }
      }
  
      /**
       * List all tasks for a project
       * @param {string} projectSlug - Project slug
       * @returns {Promise<Array<string>>} Array of task slugs
       */
      async listTasks(projectSlug) {
        try {
          const dirHandle = await this.getDirectoryHandle(`.agent/projects/${projectSlug}`);
          const tasks = [];
  
          for await (const entry of dirHandle.values()) {
            if (entry.kind === 'file' && entry.name.endsWith('.jsonl')) {
              tasks.push(entry.name.replace('.jsonl', ''));
            }
          }
  
          return tasks;
        } catch (error) {
          return [];
        }
      }
  
      /**
       * Save directory path to localStorage
       * @private
       */
      saveDirPathToStorage() {
        if (this.dirPath && window.module && window.module.StorageManager) {
          const storage = new window.module.StorageManager();
          storage.setString('directory_path', this.dirPath);
        }
      }
  
      /**
       * Load directory path from localStorage
       * @returns {string|null} Saved path or null
       * @private
       */
      loadDirPathFromStorage() {
        if (window.module && window.module.StorageManager) {
          const storage = new window.module.StorageManager();
          return storage.getString('directory_path', null);
        }
        return null;
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.FileSystemManager = FileSystemManager;
  
  })();

  // ============================================================================
  // src/token-estimator.js
  // ============================================================================

  /**
   * token-estimator.js
   *
   * Estimates token counts for text:
   * - Heuristic-based token estimation (chars / 4)
   * - Token counting for prompts, messages, files
   * - Budget management helpers
   *
   * Based on: src_old/com/codeboss/javalayer/filecache/TokenEstimator.java
   */
  
  (function() {
    'use strict';
  
    /**
     * TokenEstimator class
     * Provides token count estimation using simple heuristics
     */
    class TokenEstimator {
      constructor() {
        // Simple heuristic: ~4 characters per token for English text
        this.charsPerToken = 4;
  
        // Claude 3.5 Sonnet limits
        this.maxInputTokens = 200000;
        this.maxOutputTokens = 8192;
      }
  
      /**
       * Estimate token count for text
       * @param {string} text - Text to estimate
       * @returns {number} Estimated token count
       */
      estimate(text) {
        if (!text) {
          return 0;
        }
        return Math.ceil(text.length / this.charsPerToken);
      }
  
      /**
       * Estimate tokens for multiple text segments
       * @param {Array<string>} segments - Text segments
       * @returns {number} Total estimated tokens
       */
      estimateMultiple(segments) {
        // TODO: Sum token estimates for all segments
        throw new Error('Not implemented: TokenEstimator.estimateMultiple()');
      }
  
      /**
       * Estimate tokens for a message
       * @param {Object} message - Message object
       * @returns {number} Estimated token count
       */
      estimateMessage(message) {
        // TODO: Extract content from message
        // TODO: Estimate tokens for content
        // TODO: Add overhead for message structure (~10 tokens)
        throw new Error('Not implemented: TokenEstimator.estimateMessage()');
      }
  
      /**
       * Estimate tokens for conversation history
       * @param {Array} messages - Array of message objects
       * @returns {number} Estimated token count
       */
      estimateConversation(messages) {
        // TODO: Sum token estimates for all messages
        // TODO: Add overhead for conversation structure
        throw new Error('Not implemented: TokenEstimator.estimateConversation()');
      }
  
      /**
       * Estimate tokens for a file
       * @param {string} content - File content
       * @param {boolean} withLineNumbers - Include line numbers
       * @returns {number} Estimated token count
       */
      estimateFile(content, withLineNumbers = true) {
        // TODO: Estimate base content tokens
        // TODO: If withLineNumbers, add overhead for line number formatting
        throw new Error('Not implemented: TokenEstimator.estimateFile()');
      }
  
      /**
       * Estimate tokens for mental model
       * @param {Object} mentalModel - Mental model map
       * @returns {number} Estimated token count
       */
      estimateMentalModel(mentalModel) {
        // TODO: Iterate through mental model entries
        // TODO: Estimate tokens for each key-value pair
        // TODO: Add overhead for formatting
        throw new Error('Not implemented: TokenEstimator.estimateMentalModel()');
      }
  
      /**
       * Estimate tokens for recent changes
       * @param {Array} changes - Array of ChangeEntry objects
       * @returns {number} Estimated token count
       */
      estimateRecentChanges(changes) {
        // TODO: Estimate tokens for each change entry
        // TODO: Include description, diff, metadata
        throw new Error('Not implemented: TokenEstimator.estimateRecentChanges()');
      }
  
      /**
       * Check if content fits within token budget
       * @param {string} content - Content to check
       * @param {number} budget - Token budget
       * @returns {boolean} True if fits
       */
      fitsInBudget(content, budget) {
        const tokens = this.estimate(content);
        return tokens <= budget;
      }
  
      /**
       * Truncate text to fit token budget
       * @param {string} text - Text to truncate
       * @param {number} maxTokens - Maximum tokens
       * @returns {string} Truncated text
       */
      truncateToTokens(text, maxTokens) {
        // TODO: Estimate current tokens
        // TODO: If over budget, calculate max chars
        // TODO: Truncate text to max chars
        // TODO: Add truncation indicator
        throw new Error('Not implemented: TokenEstimator.truncateToTokens()');
      }
  
      /**
       * Get remaining budget
       * @param {number} used - Tokens used
       * @param {number} total - Total budget
       * @returns {number} Remaining tokens
       */
      getRemainingBudget(used, total) {
        return Math.max(0, total - used);
      }
  
      /**
       * Calculate percentage of budget used
       * @param {number} used - Tokens used
       * @param {number} total - Total budget
       * @returns {number} Percentage (0-100)
       */
      getBudgetPercentage(used, total) {
        if (total === 0) {
          return 0;
        }
        return Math.min(100, (used / total) * 100);
      }
  
      /**
       * Check if nearing token limit
       * @param {number} used - Tokens used
       * @param {number} total - Total budget
       * @param {number} threshold - Warning threshold percentage (default 80)
       * @returns {boolean} True if nearing limit
       */
      isNearingLimit(used, total, threshold = 80) {
        const percentage = this.getBudgetPercentage(used, total);
        return percentage >= threshold;
      }
  
      /**
       * Estimate overhead for formatting
       * @param {string} formatType - Format type (json, xml, markdown, etc.)
       * @returns {number} Estimated overhead tokens
       */
      estimateFormatOverhead(formatType) {
        // TODO: Return estimated overhead based on format type
        // TODO: JSON: ~5% overhead
        // TODO: XML: ~10% overhead
        // TODO: Markdown: ~3% overhead
        throw new Error('Not implemented: TokenEstimator.estimateFormatOverhead()');
      }
  
      /**
       * Get max input tokens
       * @returns {number} Max input tokens
       */
      getMaxInputTokens() {
        return this.maxInputTokens;
      }
  
      /**
       * Get max output tokens
       * @returns {number} Max output tokens
       */
      getMaxOutputTokens() {
        return this.maxOutputTokens;
      }
  
      /**
       * Set characters per token ratio
       * @param {number} ratio - Characters per token
       */
      setCharsPerToken(ratio) {
        this.charsPerToken = ratio;
      }
  
      /**
       * Get characters per token ratio
       * @returns {number} Characters per token
       */
      getCharsPerToken() {
        return this.charsPerToken;
      }
  
      /**
       * Estimate tokens with more accurate counting for code
       * @param {string} text - Text to estimate
       * @param {boolean} isCode - True if text is code
       * @returns {number} Estimated token count
       */
      estimateWithType(text, isCode = false) {
        // TODO: If code, use different ratio (code tokens are denser)
        // TODO: Code: ~3 chars per token
        // TODO: Regular text: ~4 chars per token
        throw new Error('Not implemented: TokenEstimator.estimateWithType()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.TokenEstimator = TokenEstimator;
  
  })();

  // ============================================================================
  // src/budget-manager.js
  // ============================================================================

  /**
   * Budget manager for token allocation (optional optimization)
   * Manages token budgets across different prompt sections
   */
  
  (function() {
    'use strict';
  
    const { TokenEstimator } = window.module;
    const { Logger } = window.module;
    const logger = window.module.createLogger('BudgetManager');
  
    /**
     * Budget manager
     */
    class BudgetManager {
      constructor(maxInputTokens = 200000, maxOutputTokens = 8000) {
        this.maxInputTokens = maxInputTokens;
        this.maxOutputTokens = maxOutputTokens;
  
        // Budget allocation percentages
        this.budgets = {
          baseInstructions: 0.10,  // 10% - System prompt, base instructions
          phaseInstructions: 0.05, // 5% - Phase-specific instructions
          mentalModels: 0.15,      // 15% - Project + task mental models
          ephemeralContent: 0.40,  // 40% - Files, git output, searches
          recentChanges: 0.05,     // 5% - Recent changes
          checklist: 0.05,         // 5% - Current checklist
          tools: 0.05,             // 5% - Tool definitions
          history: 0.15            // 15% - Conversation history
        };
  
        // Current usage tracking
        this.usage = {};
        this.resetUsage();
      }
  
      /**
       * Reset usage tracking
       */
      resetUsage() {
        throw new Error('Not implemented: resetUsage()');
  
        // TODO: Implementation
        // 1. Initialize usage object with 0 for each section
        // 2. Calculate max tokens per section based on budgets
      }
  
      /**
       * Get max tokens for section
       * @param {string} section - Section name
       * @returns {number} Max tokens for section
       */
      getMaxTokens(section) {
        throw new Error('Not implemented: getMaxTokens()');
  
        // TODO: Implementation
        // 1. Get budget percentage for section
        // 2. Calculate: maxInputTokens * percentage
        // 3. Return token count
      }
  
      /**
       * Track token usage for section
       * @param {string} section - Section name
       * @param {number} tokens - Token count
       */
      trackUsage(section, tokens) {
        throw new Error('Not implemented: trackUsage()');
  
        // TODO: Implementation
        // 1. Add tokens to usage[section]
        // 2. Log if over budget
        // 3. Update total usage
      }
  
      /**
       * Get remaining budget for section
       * @param {string} section - Section name
       * @returns {number} Remaining tokens
       */
      getRemainingBudget(section) {
        throw new Error('Not implemented: getRemainingBudget()');
  
        // TODO: Implementation
        // 1. Get max tokens for section
        // 2. Subtract current usage
        // 3. Return remaining (or 0 if over budget)
      }
  
      /**
       * Check if section is over budget
       * @param {string} section - Section name
       * @returns {boolean} True if over budget
       */
      isOverBudget(section) {
        throw new Error('Not implemented: isOverBudget()');
  
        // TODO: Implementation
        // 1. Compare usage[section] to max
        // 2. Return boolean
      }
  
      /**
       * Get total usage
       * @returns {number} Total tokens used
       */
      getTotalUsage() {
        throw new Error('Not implemented: getTotalUsage()');
  
        // TODO: Implementation
        // 1. Sum all usage values
        // 2. Return total
      }
  
      /**
       * Check if total usage is near limit
       * @param {number} threshold - Threshold percentage (default 0.8)
       * @returns {boolean} True if near limit
       */
      isNearLimit(threshold = 0.8) {
        throw new Error('Not implemented: isNearLimit()');
  
        // TODO: Implementation
        // 1. Get total usage
        // 2. Compare to maxInputTokens * threshold
        // 3. Return boolean
      }
  
      /**
       * Generate budget report
       * @returns {string} Formatted budget report
       */
      generateReport() {
        throw new Error('Not implemented: generateReport()');
  
        // TODO: Implementation
        // 1. Format each section with:
        //    - Section name
        //    - Usage / Max
        //    - Percentage used
        // 2. Show total usage
        // 3. Return formatted string
  
        // Example format:
        // Budget Report:
        // - Base Instructions: 15,000 / 20,000 (75%)
        // - Ephemeral Content: 65,000 / 80,000 (81%)
        // - History: 25,000 / 30,000 (83%)
        // Total: 180,000 / 200,000 (90%)
      }
  
      /**
       * Suggest budget adjustments
       * @returns {Object} Suggested adjustments
       */
      suggestAdjustments() {
        throw new Error('Not implemented: suggestAdjustments()');
  
        // TODO: Implementation
        // 1. Find sections that are over budget
        // 2. Find sections that are under budget
        // 3. Suggest reallocations
        // 4. Return object with suggestions
      }
  
      /**
       * Update budget allocation
       * @param {string} section - Section name
       * @param {number} percentage - New percentage (0-1)
       */
      updateBudget(section, percentage) {
        throw new Error('Not implemented: updateBudget()');
  
        // TODO: Implementation
        // 1. Validate percentage
        // 2. Update budgets[section]
        // 3. Ensure total percentages = 1.0
        // 4. Warn if total != 1.0
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.BudgetManager = BudgetManager;
  
  })();

  // ============================================================================
  // src/context-manager.js
  // ============================================================================

  /**
   * context-manager.js
   *
   * Manages context size and compaction:
   * - Context size management
   * - Token budget tracking
   * - Message history truncation
   * - Compaction triggers (optional)
   *
   * Based on: src_old/com/codeboss/javalayer/aiprocessor/ContextManager.java
   *
   * NOTE: With ephemeral content system, compaction may not be needed.
   * This manager primarily tracks token usage and triggers truncation.
   */
  
  (function() {
    'use strict';
  
    /**
     * ContextManager class
     * Manages conversation context size and token budgets
     */
    class ContextManager {
      constructor(tokenEstimator) {
        this.tokenEstimator = tokenEstimator;
        this.maxTokens = 200000; // Claude 3.5 Sonnet limit
        this.reservedOutputTokens = 8192; // Reserve for AI response
        this.warningThreshold = 0.8; // Warn at 80% usage
      }
  
      /**
       * Estimate total context size
       * @param {Object} state - Conversation state
       * @param {string} systemPrompt - System prompt
       * @returns {number} Estimated total tokens
       */
      estimateContextSize(state, systemPrompt) {
        // TODO: Estimate system prompt tokens
        // TODO: Estimate conversation history tokens
        // TODO: Estimate mental model tokens
        // TODO: Estimate ephemeral content tokens
        // TODO: Estimate recent changes tokens
        // TODO: Sum all components
        throw new Error('Not implemented: ContextManager.estimateContextSize()');
      }
  
      /**
       * Check if context is nearing limit
       * @param {Object} state - Conversation state
       * @param {string} systemPrompt - System prompt
       * @returns {boolean} True if nearing limit
       */
      isNearingLimit(state, systemPrompt) {
        // TODO: Estimate current context size
        // TODO: Calculate available budget (maxTokens - reservedOutputTokens)
        // TODO: Check if over warning threshold
        throw new Error('Not implemented: ContextManager.isNearingLimit()');
      }
  
      /**
       * Check if context exceeds limit
       * @param {Object} state - Conversation state
       * @param {string} systemPrompt - System prompt
       * @returns {boolean} True if exceeds limit
       */
      exceedsLimit(state, systemPrompt) {
        // TODO: Estimate current context size
        // TODO: Calculate available budget
        // TODO: Check if over limit
        throw new Error('Not implemented: ContextManager.exceedsLimit()');
      }
  
      /**
       * Get available token budget
       * @returns {number} Available tokens for input
       */
      getAvailableBudget() {
        return this.maxTokens - this.reservedOutputTokens;
      }
  
      /**
       * Calculate context breakdown
       * @param {Object} state - Conversation state
       * @param {string} systemPrompt - System prompt
       * @returns {Object} Token breakdown by component
       */
      getContextBreakdown(state, systemPrompt) {
        // TODO: Estimate tokens for each component:
        //   - systemPrompt
        //   - conversationHistory
        //   - projectMentalModel
        //   - taskMentalModel
        //   - ephemeralFiles
        //   - ephemeralContent
        //   - recentChanges
        //   - checklist
        //   - toolDefinitions
        // TODO: Return breakdown object
        throw new Error('Not implemented: ContextManager.getContextBreakdown()');
      }
  
      /**
       * Suggest truncation to fit budget
       * @param {Object} state - Conversation state
       * @param {string} systemPrompt - System prompt
       * @returns {Object} Truncation suggestions
       */
      suggestTruncation(state, systemPrompt) {
        // TODO: Calculate current size
        // TODO: Calculate needed reduction
        // TODO: Suggest which components to truncate:
        //   - Oldest conversation messages
        //   - Ephemeral files (oldest first)
        //   - Recent changes (oldest first)
        // TODO: Return suggestions
        throw new Error('Not implemented: ContextManager.suggestTruncation()');
      }
  
      /**
       * Truncate conversation history to fit budget
       * @param {Array} messages - Conversation messages
       * @param {number} targetTokens - Target token count
       * @returns {Array} Truncated messages
       */
      truncateHistory(messages, targetTokens) {
        // TODO: Estimate tokens for each message
        // TODO: Keep most recent messages that fit in budget
        // TODO: Always keep at least last 5 messages
        // TODO: Return truncated array
        throw new Error('Not implemented: ContextManager.truncateHistory()');
      }
  
      /**
       * Truncate ephemeral files to fit budget
       * @param {Array} ephemeralFiles - File paths
       * @param {number} targetTokens - Target token count
       * @param {Object} fsManager - File system manager
       * @returns {Promise<Array>} Truncated file list
       */
      async truncateEphemeralFiles(ephemeralFiles, targetTokens, fsManager) {
        // TODO: Estimate tokens for each file
        // TODO: Keep most recent files that fit in budget
        // TODO: Return truncated array
        throw new Error('Not implemented: ContextManager.truncateEphemeralFiles()');
      }
  
      /**
       * Optimize context for token efficiency
       * @param {Object} state - Conversation state
       * @returns {Object} Optimized state
       */
      optimizeContext(state) {
        // TODO: Remove duplicate information
        // TODO: Summarize long messages
        // TODO: Truncate large file content
        // TODO: Return optimized state
        throw new Error('Not implemented: ContextManager.optimizeContext()');
      }
  
      /**
       * Get context statistics
       * @param {Object} state - Conversation state
       * @param {string} systemPrompt - System prompt
       * @returns {Object} Context statistics
       */
      getStatistics(state, systemPrompt) {
        // TODO: Calculate total tokens
        // TODO: Calculate percentage used
        // TODO: Calculate remaining budget
        // TODO: Get component breakdown
        // TODO: Return statistics object
        throw new Error('Not implemented: ContextManager.getStatistics()');
      }
  
      /**
       * Set max token limit
       * @param {number} maxTokens - Maximum tokens
       */
      setMaxTokens(maxTokens) {
        this.maxTokens = maxTokens;
      }
  
      /**
       * Set reserved output tokens
       * @param {number} tokens - Reserved tokens
       */
      setReservedOutputTokens(tokens) {
        this.reservedOutputTokens = tokens;
      }
  
      /**
       * Set warning threshold
       * @param {number} threshold - Threshold percentage (0-1)
       */
      setWarningThreshold(threshold) {
        this.warningThreshold = threshold;
      }
  
      /**
       * Get warning threshold
       * @returns {number} Warning threshold (0-1)
       */
      getWarningThreshold() {
        return this.warningThreshold;
      }
  
      /**
       * Format statistics for display
       * @param {Object} stats - Statistics object
       * @returns {string} Formatted statistics
       */
      formatStatistics(stats) {
        // TODO: Format statistics as human-readable string
        // TODO: Include total, used, available, percentage
        // TODO: Include breakdown by component
        throw new Error('Not implemented: ContextManager.formatStatistics()');
      }
  
      /**
       * Check if compaction is needed
       * NOTE: With ephemeral content, this may not be necessary
       * @param {Object} state - Conversation state
       * @param {string} systemPrompt - System prompt
       * @returns {boolean} True if compaction recommended
       */
      needsCompaction(state, systemPrompt) {
        // TODO: Check if approaching token limit
        // TODO: Check if context can be optimized
        // TODO: Return true if compaction would help
        throw new Error('Not implemented: ContextManager.needsCompaction()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ContextManager = ContextManager;
  
  })();

  // ============================================================================
  // src/diff-generator.js
  // ============================================================================

  /**
   * diff-generator.js
   *
   * Generates unified diffs between file versions:
   * - Create unified diff format
   * - Line-by-line comparison
   * - Context lines around changes
   * - Used by undo stack and recent changes
   *
   * Simple implementation without external dependencies
   */
  
  (function() {
    'use strict';
  
    /**
     * DiffGenerator class
     * Generates unified diffs between text strings
     */
    class DiffGenerator {
      constructor() {
        this.contextLines = 3; // Lines of context around changes
      }
  
      /**
       * Generate unified diff between two strings
       * @param {string} oldContent - Original content
       * @param {string} newContent - New content
       * @param {string} oldPath - Old file path (for header)
       * @param {string} newPath - New file path (for header)
       * @returns {string} Unified diff
       */
      generate(oldContent, newContent, oldPath = 'a/file', newPath = 'b/file') {
        // TODO: Split content into lines
        // TODO: Compute line differences
        // TODO: Generate unified diff format
        // TODO: Include file headers
        // TODO: Include hunks with context
        // TODO: Return diff string
        throw new Error('Not implemented: DiffGenerator.generate()');
      }
  
      /**
       * Generate short diff (for recent changes)
       * Only includes changed lines without context
       * @param {string} oldContent - Original content
       * @param {string} newContent - New content
       * @returns {string} Short diff
       */
      generateShort(oldContent, newContent) {
        // TODO: Split content into lines
        // TODO: Find changed lines
        // TODO: Format as simple +/- diff
        // TODO: Return diff string
        throw new Error('Not implemented: DiffGenerator.generateShort()');
      }
  
      /**
       * Compute line differences using simple LCS algorithm
       * @param {Array<string>} oldLines - Old lines
       * @param {Array<string>} newLines - New lines
       * @returns {Array} Array of diff operations
       * @private
       */
      computeDiff(oldLines, newLines) {
        // TODO: Implement simple diff algorithm:
        //   - Use Longest Common Subsequence (LCS)
        //   - Or simpler line-by-line comparison
        // TODO: Return array of operations: {type: 'add'|'delete'|'equal', line: ...}
        throw new Error('Not implemented: DiffGenerator.computeDiff()');
      }
  
      /**
       * Format diff operations as unified diff
       * @param {Array} operations - Diff operations
       * @param {Array<string>} oldLines - Old lines
       * @param {Array<string>} newLines - New lines
       * @returns {string} Formatted diff
       * @private
       */
      formatUnified(operations, oldLines, newLines) {
        // TODO: Group operations into hunks
        // TODO: Add context lines
        // TODO: Format as unified diff with @@ headers
        // TODO: Prefix lines with +, -, or space
        throw new Error('Not implemented: DiffGenerator.formatUnified()');
      }
  
      /**
       * Create hunk header
       * @param {number} oldStart - Old start line
       * @param {number} oldCount - Old line count
       * @param {number} newStart - New start line
       * @param {number} newCount - New line count
       * @returns {string} Hunk header
       * @private
       */
      createHunkHeader(oldStart, oldCount, newStart, newCount) {
        return `@@ -${oldStart},${oldCount} +${newStart},${newCount} @@`;
      }
  
      /**
       * Split content into lines
       * @param {string} content - Content to split
       * @returns {Array<string>} Lines
       * @private
       */
      splitLines(content) {
        if (!content) {
          return [];
        }
        return content.split(/\r?\n/);
      }
  
      /**
       * Count changed lines in diff
       * @param {string} diff - Diff string
       * @returns {number} Number of changed lines
       */
      countChangedLines(diff) {
        // TODO: Count lines starting with + or -
        // TODO: Exclude file headers and hunk headers
        throw new Error('Not implemented: DiffGenerator.countChangedLines()');
      }
  
      /**
       * Check if diff is small (can be shown inline)
       * @param {string} diff - Diff string
       * @param {number} maxLines - Maximum lines (default 10)
       * @returns {boolean} True if small
       */
      isSmallDiff(diff, maxLines = 10) {
        const changedLines = this.countChangedLines(diff);
        return changedLines <= maxLines;
      }
  
      /**
       * Truncate diff if too long
       * @param {string} diff - Diff string
       * @param {number} maxLines - Maximum lines
       * @returns {string} Truncated diff
       */
      truncate(diff, maxLines = 10) {
        // TODO: If diff has more than maxLines changes
        // TODO: Keep first N lines and add truncation marker
        throw new Error('Not implemented: DiffGenerator.truncate()');
      }
  
      /**
       * Generate diff statistics
       * @param {string} diff - Diff string
       * @returns {Object} {additions, deletions, changes}
       */
      getStatistics(diff) {
        // TODO: Count lines starting with +
        // TODO: Count lines starting with -
        // TODO: Return statistics object
        throw new Error('Not implemented: DiffGenerator.getStatistics()');
      }
  
      /**
       * Apply diff to content (reverse operation)
       * @param {string} content - Original content
       * @param {string} diff - Diff to apply
       * @returns {string} Modified content
       */
      apply(content, diff) {
        // TODO: Parse diff
        // TODO: Apply changes to content
        // TODO: Return modified content
        // TODO: This is complex - may skip for MVP
        throw new Error('Not implemented: DiffGenerator.apply()');
      }
  
      /**
       * Reverse a diff (swap old and new)
       * @param {string} diff - Diff to reverse
       * @returns {string} Reversed diff
       */
      reverse(diff) {
        // TODO: Swap + and - prefixes
        // TODO: Swap old and new in headers
        // TODO: Return reversed diff
        throw new Error('Not implemented: DiffGenerator.reverse()');
      }
  
      /**
       * Set context lines
       * @param {number} lines - Number of context lines
       */
      setContextLines(lines) {
        this.contextLines = lines;
      }
  
      /**
       * Get context lines
       * @returns {number} Context lines
       */
      getContextLines() {
        return this.contextLines;
      }
  
      /**
       * Simple LCS implementation for line comparison
       * @param {Array<string>} a - First array
       * @param {Array<string>} b - Second array
       * @returns {Array<Array<number>>} LCS matrix
       * @private
       */
      computeLCS(a, b) {
        // TODO: Implement Longest Common Subsequence
        // TODO: Return LCS matrix for backtracking
        throw new Error('Not implemented: DiffGenerator.computeLCS()');
      }
  
      /**
       * Backtrack LCS to find diff operations
       * @param {Array<Array<number>>} lcs - LCS matrix
       * @param {Array<string>} a - First array
       * @param {Array<string>} b - Second array
       * @returns {Array} Diff operations
       * @private
       */
      backtrackLCS(lcs, a, b) {
        // TODO: Backtrack through LCS matrix
        // TODO: Generate diff operations
        throw new Error('Not implemented: DiffGenerator.backtrackLCS()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.DiffGenerator = DiffGenerator;
  
  })();

  // ============================================================================
  // src/tool-definitions.js
  // ============================================================================

  /**
   * tool-definitions.js
   *
   * Defines all Code Boss tools with schemas and metadata:
   * - Tool schemas for AI API
   * - Tool categories and permissions
   * - Tool descriptions and parameters
   *
   * Based on: specs/TOOLS.md, specs/PHASES.md
   */
  
  (function() {
    'use strict';
  
    /**
     * Tool definitions for Claude API
     * Each tool has: name, description, input_schema
     */
    const TOOLS = {
      // File Operations
      read_file: {
        name: 'read_file',
        description: 'Read file contents (ephemeral - cleared after AI response). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            file_path: {
              type: 'string',
              description: 'Path to file relative to working directory'
            },
            looking_for: {
              type: 'string',
              description: 'What you are looking for in this file (5-15 words)'
            },
            why: {
              type: 'string',
              description: 'Why you need this information (5-15 words)'
            },
            start_line: {
              type: 'integer',
              description: 'Starting line number (1-indexed, optional)'
            },
            end_line: {
              type: 'integer',
              description: 'Ending line number (1-indexed, optional)'
            }
          },
          required: ['file_path', 'looking_for', 'why']
        }
      },
  
      create_file: {
        name: 'create_file',
        description: 'Create new file with content',
        input_schema: {
          type: 'object',
          properties: {
            file_path: {
              type: 'string',
              description: 'Path for new file relative to working directory'
            },
            content: {
              type: 'string',
              description: 'Full content of the file'
            }
          },
          required: ['file_path', 'content']
        }
      },
  
      update_file: {
        name: 'update_file',
        description: 'Update existing file with exact content matching',
        input_schema: {
          type: 'object',
          properties: {
            file_path: {
              type: 'string',
              description: 'Path to existing file'
            },
            old_content: {
              type: 'string',
              description: 'Exact text to find and replace'
            },
            new_content: {
              type: 'string',
              description: 'Text to replace with'
            }
          },
          required: ['file_path', 'old_content', 'new_content']
        }
      },
  
      delete_file: {
        name: 'delete_file',
        description: 'Remove a file',
        input_schema: {
          type: 'object',
          properties: {
            file_path: {
              type: 'string',
              description: 'Path to file to delete'
            }
          },
          required: ['file_path']
        }
      },
  
      move_file: {
        name: 'move_file',
        description: 'Move or rename a file',
        input_schema: {
          type: 'object',
          properties: {
            source_path: {
              type: 'string',
              description: 'Current path of file'
            },
            dest_path: {
              type: 'string',
              description: 'New path for file'
            }
          },
          required: ['source_path', 'dest_path']
        }
      },
  
      // Directory Operations
      create_directory: {
        name: 'create_directory',
        description: 'Create a directory',
        input_schema: {
          type: 'object',
          properties: {
            directory_path: {
              type: 'string',
              description: 'Path for new directory'
            }
          },
          required: ['directory_path']
        }
      },
  
      delete_directory_recursive: {
        name: 'delete_directory_recursive',
        description: 'Remove directory and all contents',
        input_schema: {
          type: 'object',
          properties: {
            directory_path: {
              type: 'string',
              description: 'Path to directory to delete'
            }
          },
          required: ['directory_path']
        }
      },
  
      list_files: {
        name: 'list_files',
        description: 'List files in directory (ephemeral). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            directory_path: {
              type: 'string',
              description: 'Directory to list (default: current directory)'
            },
            pattern: {
              type: 'string',
              description: 'Optional glob pattern to filter files'
            },
            looking_for: {
              type: 'string',
              description: 'What you are looking for in the listing'
            },
            why: {
              type: 'string',
              description: 'Why you need this listing'
            }
          },
          required: ['looking_for', 'why']
        }
      },
  
      // Search Operations
      search_files_by_name: {
        name: 'search_files_by_name',
        description: 'Find files by name pattern (ephemeral). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            directory_path: {
              type: 'string',
              description: 'Directory to search (default: current directory)'
            },
            pattern: {
              type: 'string',
              description: 'Glob pattern for file names'
            },
            looking_for: {
              type: 'string',
              description: 'What files you are trying to find'
            },
            why: {
              type: 'string',
              description: 'Why you need to find these files'
            }
          },
          required: ['pattern', 'looking_for', 'why']
        }
      },
  
      search_files_by_content: {
        name: 'search_files_by_content',
        description: 'Search file contents with regex (ephemeral). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            directory_path: {
              type: 'string',
              description: 'Directory to search (default: current directory)'
            },
            pattern: {
              type: 'string',
              description: 'Regex pattern to search for'
            },
            file_pattern: {
              type: 'string',
              description: 'Optional glob pattern to filter files'
            },
            looking_for: {
              type: 'string',
              description: 'What you are searching for'
            },
            why: {
              type: 'string',
              description: 'Why you need this search'
            }
          },
          required: ['pattern', 'looking_for', 'why']
        }
      },
  
      // Git Operations
      git_read: {
        name: 'git_read',
        description: 'Execute read-only git commands (ephemeral). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            project_path: {
              type: 'string',
              description: 'Path to git repository'
            },
            git_args: {
              type: 'string',
              description: 'Git command arguments (e.g., "status", "log --oneline")'
            },
            looking_for: {
              type: 'string',
              description: 'What you are looking for in git output'
            },
            why: {
              type: 'string',
              description: 'Why you need this git information'
            },
            offset: {
              type: 'integer',
              description: 'Skip first N lines of output'
            },
            limit: {
              type: 'integer',
              description: 'Show only N lines of output'
            }
          },
          required: ['project_path', 'git_args', 'looking_for', 'why']
        }
      },
  
      git_write: {
        name: 'git_write',
        description: 'Execute git write operations (add, commit, push, etc.)',
        input_schema: {
          type: 'object',
          properties: {
            project_path: {
              type: 'string',
              description: 'Path to git repository'
            },
            git_args: {
              type: 'string',
              description: 'Git command arguments'
            }
          },
          required: ['project_path', 'git_args']
        }
      },
  
      // Command Execution
      run_command: {
        name: 'run_command',
        description: 'Execute shell command',
        input_schema: {
          type: 'object',
          properties: {
            command: {
              type: 'string',
              description: 'Shell command to execute'
            },
            working_directory: {
              type: 'string',
              description: 'Directory to run command in (default: current directory)'
            },
            background: {
              type: 'boolean',
              description: 'Run in background (default: false)'
            }
          },
          required: ['command']
        }
      },
  
      list_processes: {
        name: 'list_processes',
        description: 'List running background processes',
        input_schema: {
          type: 'object',
          properties: {}
        }
      },
  
      stop_command: {
        name: 'stop_command',
        description: 'Stop a running background process',
        input_schema: {
          type: 'object',
          properties: {
            pid: {
              type: 'integer',
              description: 'Process ID to stop'
            }
          },
          required: ['pid']
        }
      },
  
      // Project/Task Management
      list_projects: {
        name: 'list_projects',
        description: 'List all projects (ephemeral). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            looking_for: {
              type: 'string',
              description: 'What you are looking for in project list'
            },
            why: {
              type: 'string',
              description: 'Why you need to see all projects'
            }
          },
          required: ['looking_for', 'why']
        }
      },
  
      list_tasks_for_project: {
        name: 'list_tasks_for_project',
        description: 'List tasks in a project (ephemeral). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            project_name: {
              type: 'string',
              description: 'Name of project'
            },
            looking_for: {
              type: 'string',
              description: 'What you are looking for in task history'
            },
            why: {
              type: 'string',
              description: 'Why you need to see task history'
            }
          },
          required: ['project_name', 'looking_for', 'why']
        }
      },
  
      read_task_messages: {
        name: 'read_task_messages',
        description: 'View task message history (ephemeral). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            task_name: {
              type: 'string',
              description: 'Name of task to view'
            },
            looking_for: {
              type: 'string',
              description: 'What you are looking for in task messages'
            },
            why: {
              type: 'string',
              description: 'Why you need to see this task history'
            }
          },
          required: ['task_name', 'looking_for', 'why']
        }
      },
  
      // Mental Model Operations
      update_mental_model: {
        name: 'update_mental_model',
        description: 'Update task mental model with concise notes (MANDATORY after any read operation)',
        input_schema: {
          type: 'object',
          properties: {
            updates: {
              type: 'object',
              description: 'Map of file/key to note string (empty string removes entry)'
            }
          },
          required: ['updates']
        }
      },
  
      read_change: {
        name: 'read_change',
        description: 'Read full diff for a recent change (ephemeral). REQUIRES update_mental_model in same response.',
        input_schema: {
          type: 'object',
          properties: {
            change_id: {
              type: 'string',
              description: 'Change ID to read'
            },
            looking_for: {
              type: 'string',
              description: 'What you are looking for in the diff'
            },
            why: {
              type: 'string',
              description: 'Why you need to see this change'
            }
          },
          required: ['change_id', 'looking_for', 'why']
        }
      },
  
      // Planning/Execution Control
      begin_execution: {
        name: 'begin_execution',
        description: 'Create checklist and transition to execution phase (planning only)',
        input_schema: {
          type: 'object',
          properties: {
            task_description: {
              type: 'string',
              description: 'Description of the task'
            },
            items: {
              type: 'array',
              description: 'Checklist items',
              items: {
                type: 'object',
                properties: {
                  short_desc: {
                    type: 'string',
                    description: 'Short description for UI display'
                  },
                  detailed_desc: {
                    type: 'string',
                    description: 'Detailed description for AI execution context'
                  },
                  item_type: {
                    type: 'string',
                    enum: ['coding', 'git', 'testing', 'research'],
                    description: 'Item type determines available tools'
                  }
                },
                required: ['short_desc', 'detailed_desc', 'item_type']
              }
            }
          },
          required: ['task_description', 'items']
        }
      },
  
      mark_complete: {
        name: 'mark_complete',
        description: 'Mark current checklist item as complete (execution only)',
        input_schema: {
          type: 'object',
          properties: {}
        }
      },
  
      mark_failed: {
        name: 'mark_failed',
        description: 'Mark current item as failed, return to planning (execution only)',
        input_schema: {
          type: 'object',
          properties: {
            message: {
              type: 'string',
              description: 'Error message explaining why item failed'
            }
          },
          required: ['message']
        }
      }
    };
  
    /**
     * Get tool definition by name
     * @param {string} toolName - Tool name
     * @returns {Object|null} Tool definition or null
     */
    function getToolDefinition(toolName) {
      return TOOLS[toolName] || null;
    }
  
    /**
     * Get all tool definitions as array (for Claude API)
     * @returns {Array} Array of tool definitions
     */
    function getAllTools() {
      return Object.values(TOOLS);
    }
  
    /**
     * Get tools available for phase/item type
     * MVP: Returns all tools (no phase filtering)
     * @param {string} phase - Current phase (unused in MVP)
     * @param {string} itemType - Current item type (unused in MVP)
     * @returns {Array} Array of available tool definitions
     */
    function getAvailableTools(phase, itemType = null) {
      // MVP: Return all tools, no filtering
      // For full version: filter based on phase and item type
      return getAllTools();
    }
  
    /**
     * Check if tool is a read operation (ephemeral)
     * @param {string} toolName - Tool name
     * @returns {boolean} True if read operation
     */
    function isReadOperation(toolName) {
      const readTools = [
        'read_file',
        'git_read',
        'list_files',
        'search_files_by_name',
        'search_files_by_content',
        'list_projects',
        'list_tasks_for_project',
        'read_task_messages',
        'read_change'
      ];
      return readTools.includes(toolName);
    }
  
    /**
     * Check if tool requires mental model update
     * @param {string} toolName - Tool name
     * @returns {boolean} True if requires update_mental_model
     */
    function requiresMentalModelUpdate(toolName) {
      return isReadOperation(toolName);
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ToolDefinitions = {
      TOOLS,
      getToolDefinition,
      getAllTools,
      getAvailableTools,
      isReadOperation,
      requiresMentalModelUpdate
    };
  
  })();

  // ============================================================================
  // src/tool-executor.js
  // ============================================================================

  /**
   * tool-executor.js
   *
   * Executes all Code Boss tools via File System Access API:
   * - File operations (read, create, update, delete, move, list)
   * - Directory operations (create, delete)
   * - Search operations (by name, by content)
   * - Git operations (read, write)
   * - Command execution (run_command, kill_process)
   * - Mental model operations (update, read_change)
   * - Planning/execution operations (begin_execution, mark_complete, mark_failed)
   * - Project/task operations (list, read)
   *
   * Based on: src_old/com/codeboss/javalayer/toolexecutor/ToolExecutor.java
   *           specs/TOOLS.md
   */
  
  (function() {
    'use strict';
  
    /**
     * ToolExecutor class (MVP version)
     * Executes tools and returns results
     */
    class ToolExecutor {
      constructor(fsManager, commandExecutor) {
        this.fsManager = fsManager;
        this.commandExecutor = commandExecutor;  // CommandExecutor for run_command
      }
  
      /**
       * Execute a tool
       * @param {string} toolName - Tool name
       * @param {Object} parameters - Tool parameters
       * @returns {Promise<Object>} Tool result
       */
      async execute(toolName, parameters) {
        try {
          // Dispatch to appropriate handler
          switch (toolName) {
            // File operations
            case 'read_file':
              return await this.executeReadFile(parameters);
            case 'write_file':
            case 'create_file':
              return await this.executeCreateFile(parameters);
            case 'update_file':
              return await this.executeUpdateFile(parameters);
            case 'delete_file':
              return await this.executeDeleteFile(parameters);
            case 'move_file':
              return await this.executeMoveFile(parameters);
            case 'list_files':
              return await this.executeListFiles(parameters);
  
            // Directory operations
            case 'create_directory':
              return await this.executeCreateDirectory(parameters);
            case 'delete_directory_recursive':
              return await this.executeDeleteDirectoryRecursive(parameters);
  
            // Command execution
            case 'run_command':
              return await this.executeRunCommand(parameters);
            case 'git_read':
              return await this.executeGitRead(parameters);
            case 'git_write':
              return await this.executeGitWrite(parameters);
  
            // Control tools (handled by AIProcessor, not executed here)
            case 'begin_execution':
            case 'mark_complete':
            case 'mark_failed':
            case 'update_mental_model':
              return { success: true }; // These are handled by AIProcessor.handleControlTool()
  
            default:
              return { error: `Unknown tool: ${toolName}` };
          }
        } catch (error) {
          return {
            error: error.message || 'Tool execution failed',
            stack: error.stack
          };
        }
      }
  
      // File Operations
  
      /**
       * Read a file
       * @param {Object} params - {file_path, start_line, end_line}
       * @returns {Promise<Object>} File content result
       */
      async executeReadFile(params) {
        const { file_path, start_line, end_line } = params;
  
        const content = await this.fsManager.readFile(file_path);
  
        // Apply line range if specified
        let finalContent = content;
        if (start_line || end_line) {
          const lines = content.split('\n');
          const start = (start_line || 1) - 1; // Convert to 0-indexed
          const end = end_line || lines.length;
          finalContent = lines.slice(start, end).join('\n');
        }
  
        return {
          file_path,
          content: finalContent,
          lines: finalContent.split('\n').length,
          size: finalContent.length
        };
      }
  
      /**
       * Create a file
       * @param {Object} params - {file_path, content}
       * @returns {Promise<Object>} Creation result
       */
      async executeCreateFile(params) {
        const { file_path, content } = params;
  
        // For MVP, just write the file (overwrite if exists)
        await this.fsManager.writeFile(file_path, content);
  
        return {
          success: true,
          file_path,
          lines: content.split('\n').length,
          size: content.length
        };
      }
  
      /**
       * Update a file
       * @param {Object} params - {file_path, old_content, new_content}
       * @returns {Promise<Object>} Update result
       */
      async executeUpdateFile(params) {
        const { file_path, old_content, new_content } = params;
  
        // Read current file
        const currentContent = await this.fsManager.readFile(file_path);
  
        // Check if old_content exists in file
        const matchIndex = currentContent.indexOf(old_content);
        if (matchIndex === -1) {
          return {
            error: `Could not find exact match for old_content in ${file_path}`,
            hint: 'Make sure old_content exactly matches the text to replace'
          };
        }
  
        // Calculate the line number where the match starts
        const beforeMatch = currentContent.substring(0, matchIndex);
        const start_line = beforeMatch.split('\n').length;
  
        // Replace old with new
        const updatedContent = currentContent.replace(old_content, new_content);
  
        // Write updated file
        await this.fsManager.writeFile(file_path, updatedContent);
  
        return {
          success: true,
          file_path,
          start_line,  // Line number where the edit starts (1-indexed)
          lines_changed: new_content.split('\n').length - old_content.split('\n').length
        };
      }
  
      /**
       * Delete a file
       * @param {Object} params - {file_path}
       * @returns {Promise<Object>} Deletion result
       */
      async executeDeleteFile(params) {
        const { file_path } = params;
  
        await this.fsManager.deleteFile(file_path);
  
        return {
          success: true,
          file_path
        };
      }
  
      /**
       * Move/rename a file
       * @param {Object} params - {source_path, dest_path}
       * @returns {Promise<Object>} Move result
       */
      async executeMoveFile(params) {
        const { source_path, dest_path } = params;
  
        await this.fsManager.moveFile(source_path, dest_path);
  
        return {
          success: true,
          from: source_path,
          to: dest_path
        };
      }
  
      /**
       * List files in a directory
       * @param {Object} params - {directory_path, recursive}
       * @returns {Promise<Object>} List of files
       */
      async executeListFiles(params) {
        const { directory_path, recursive } = params;
        const path = directory_path || '.';
  
        const files = await this.fsManager.listFiles(path, recursive || false);
  
        return {
          directory: path,
          files,
          count: files.length
        };
      }
  
      // Directory Operations
  
      /**
       * Create a directory
       * @param {Object} params - {directory_path}
       * @returns {Promise<Object>} Creation result
       */
      async executeCreateDirectory(params) {
        const { directory_path } = params;
  
        await this.fsManager.createDirectory(directory_path);
  
        return {
          success: true,
          directory_path
        };
      }
  
      /**
       * Delete a directory recursively
       * @param {Object} params - {directory_path}
       * @returns {Promise<Object>} Deletion result
       */
      async executeDeleteDirectoryRecursive(params) {
        const { directory_path } = params;
  
        await this.fsManager.deleteDirectory(directory_path);
  
        return {
          success: true,
          directory_path
        };
      }
  
      // Search Operations
  
      /**
       * Search files by name pattern
       * @param {Object} params - {pattern, directory}
       * @returns {Promise<Object>} Search results
       */
      async executeSearchFilesByName(params) {
        // TODO: List all files in directory (recursive)
        // TODO: Filter by pattern (glob or regex)
        // TODO: Return matching files
        throw new Error('Not implemented: ToolExecutor.executeSearchFilesByName()');
      }
  
      /**
       * Search files by content
       * @param {Object} params - {pattern, directory}
       * @returns {Promise<Object>} Search results
       */
      async executeSearchFilesByContent(params) {
        // TODO: List all files in directory (recursive)
        // TODO: Read each file and search for pattern
        // TODO: Return matching files with line numbers and context
        throw new Error('Not implemented: ToolExecutor.executeSearchFilesByContent()');
      }
  
      // Git Operations
  
      /**
       * Read git information
       * @param {Object} params - {project_path, git_args, looking_for, why, offset, limit}
       * @returns {Promise<Object>} Git output
       */
      async executeGitRead(params) {
        const { project_path, git_args, offset, limit } = params;
  
        // Execute git command via command queue
        const result = await this.commandExecutor.executeCommand(
          `git ${git_args}`,
          project_path
        );
  
        if (result.exitCode !== 0) {
          return {
            error: `Git command failed: ${result.stderr}`,
            exitCode: result.exitCode
          };
        }
  
        // Apply offset/limit if provided
        let output = result.stdout;
        if (offset || limit) {
          const lines = output.split('\n');
          const start = offset || 0;
          const end = limit ? start + limit : undefined;
          output = lines.slice(start, end).join('\n');
        }
  
        return {
          output: output,
          exitCode: 0
        };
      }
  
      /**
       * Write git operations
       * @param {Object} params - {project_path, git_args}
       * @returns {Promise<Object>} Git result
       */
      async executeGitWrite(params) {
        const { project_path, git_args } = params;
  
        // Execute git command via command queue
        const result = await this.commandExecutor.executeCommand(
          `git ${git_args}`,
          project_path
        );
  
        if (result.exitCode !== 0) {
          return {
            error: `Git command failed: ${result.stderr}`,
            stdout: result.stdout,
            exitCode: result.exitCode
          };
        }
  
        // Create recent change entry if commit
        if (git_args.includes('commit')) {
          const changeEntry = {
            type: ChangeType.GIT_COMMIT,
            file: null,
            description: `Git commit: ${git_args}`,
            timestamp: new Date().toISOString(),
            linesChanged: null,
            diff: null
          };
          this.conversationManager.addRecentChange(changeEntry);
        }
  
        return {
          output: result.stdout,
          exitCode: 0
        };
      }
  
      // Command Execution
  
      /**
       * Run a command
       * @param {Object} params - {command, working_directory, background}
       * @returns {Promise<Object>} Command output
       */
      async executeRunCommand(params) {
        const { command, working_directory, background } = params;
  
        if (background) {
          // TODO: Background processes not yet implemented
          // Would need process tracking in daemon
          throw new Error('Background processes not yet implemented');
        }
  
        // Execute command via command queue
        const result = await this.commandExecutor.executeCommand(
          command,
          working_directory || '.'
        );
  
        return {
          stdout: result.stdout,
          stderr: result.stderr,
          exitCode: result.exitCode,
          error: result.error
        };
      }
  
      /**
       * List running processes
       * @param {Object} params - {}
       * @returns {Promise<Object>} List of processes
       */
      async executeListProcesses(params) {
        // Background processes not yet implemented
        return {
          processes: [],
          message: 'Background processes not yet implemented. All commands run synchronously.'
        };
      }
  
      /**
       * Stop a running command
       * @param {Object} params - {pid}
       * @returns {Promise<Object>} Stop result
       */
      async executeStopCommand(params) {
        // Background processes not yet implemented
        return {
          success: false,
          error: 'Background processes not yet implemented. All commands run synchronously.'
        };
      }
  
      // Mental Model Operations
  
      /**
       * Update mental model
       * @param {Object} params - {updates}
       * @returns {Promise<Object>} Update result
       */
      async executeUpdateMentalModel(params) {
        // TODO: Apply updates to task mental model via conversationManager
        // TODO: Add mental model update message
        // TODO: Return success result
        throw new Error('Not implemented: ToolExecutor.executeUpdateMentalModel()');
      }
  
      /**
       * Read full diff for a change
       * @param {Object} params - {change_id}
       * @returns {Promise<Object>} Full diff
       */
      async executeReadChange(params) {
        // TODO: Find change in recent changes
        // TODO: If diff was truncated, read full diff from file history
        // TODO: Return full diff
        throw new Error('Not implemented: ToolExecutor.executeReadChange()');
      }
  
      // Planning/Execution Control
  
      /**
       * Begin execution with checklist
       * @param {Object} params - {task_description, items}
       * @returns {Promise<Object>} User approval result
       */
      async executeBeginExecution(params) {
        // TODO: Show checklist to user for approval (via UI event)
        // TODO: Wait for user approval
        // TODO: If approved, create task via conversationManager
        // TODO: Transition to execution phase
        // TODO: Return approval result
        throw new Error('Not implemented: ToolExecutor.executeBeginExecution()');
      }
  
      /**
       * Mark current item as complete
       * @param {Object} params - {}
       * @returns {Promise<Object>} Completion result
       */
      async executeMarkComplete(params) {
        // TODO: Mark current item complete via conversationManager
        // TODO: If more items, advance to next
        // TODO: If last item, transition to review phase
        // TODO: Return result
        throw new Error('Not implemented: ToolExecutor.executeMarkComplete()');
      }
  
      /**
       * Mark current item as failed
       * @param {Object} params - {message}
       * @returns {Promise<Object>} Failure result
       */
      async executeMarkFailed(params) {
        // TODO: Mark current item failed via conversationManager
        // TODO: Transition back to planning phase
        // TODO: Return result
        throw new Error('Not implemented: ToolExecutor.executeMarkFailed()');
      }
  
      // Project/Task Operations
  
      /**
       * List all projects
       * @param {Object} params - {}
       * @returns {Promise<Object>} List of projects
       */
      async executeListProjects(params) {
        // TODO: List projects via conversationManager
        // TODO: Return {projects: [...]}
        throw new Error('Not implemented: ToolExecutor.executeListProjects()');
      }
  
      /**
       * List tasks for a project
       * @param {Object} params - {project_name}
       * @returns {Promise<Object>} List of tasks
       */
      async executeListTasksForProject(params) {
        // TODO: List tasks via conversationManager
        // TODO: Return {tasks: [...]}
        throw new Error('Not implemented: ToolExecutor.executeListTasksForProject()');
      }
  
      /**
       * Read messages from a task
       * @param {Object} params - {project_name, task_name}
       * @returns {Promise<Object>} Task messages
       */
      async executeReadTaskMessages(params) {
        // TODO: Read task messages via conversationManager
        // TODO: Return {messages: [...]}
        throw new Error('Not implemented: ToolExecutor.executeReadTaskMessages()');
      }
  
      // Validation
  
      /**
       * Validate tool is available for current phase/item type
       * @param {string} toolName - Tool name
       * @param {Object} state - Current conversation state
       * @returns {Object} {valid: boolean, error: string|null}
       */
      validateToolAvailability(toolName, state) {
        // TODO: Check tool availability based on:
        //   - Current phase (planning/execution/review)
        //   - Current item type (if in execution)
        // TODO: Return validation result
        // TODO: Reference specs/PHASES.md tool availability matrix
        throw new Error('Not implemented: ToolExecutor.validateToolAvailability()');
      }
  
      // Utilities
  
      /**
       * Create a change entry from file operation
       * @param {string} type - Change type
       * @param {string} file - File path
       * @param {string} oldContent - Old content (for updates)
       * @param {string} newContent - New content
       * @returns {Object} ChangeEntry object
       * @private
       */
      createChangeEntry(type, file, oldContent, newContent) {
        // TODO: Create ChangeEntry with type, file, description
        // TODO: Generate short diff if <= 10 lines
        // TODO: Calculate lines changed
        // TODO: Return ChangeEntry
        throw new Error('Not implemented: ToolExecutor.createChangeEntry()');
      }
  
      /**
       * Generate a unified diff between two strings
       * @param {string} oldContent - Old content
       * @param {string} newContent - New content
       * @returns {string} Unified diff
       * @private
       */
      generateDiff(oldContent, newContent) {
        // TODO: Generate unified diff between old and new
        // TODO: Return diff string
        // NOTE: May need simple diff algorithm or library
        throw new Error('Not implemented: ToolExecutor.generateDiff()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ToolExecutor = ToolExecutor;
  
  })();

  // ============================================================================
  // src/conversation-manager.js
  // ============================================================================

  /**
   * conversation-manager.js
   *
   * MVP VERSION - Simplified conversation manager:
   * - In-memory message history only
   * - No persistence (no .agent/ directory)
   * - No mental models
   * - No ephemeral content tracking
   * - No phase management
   *
   * Just tracks messages for the conversation.
   */
  
  (function() {
    'use strict';
  
    /**
     * ConversationManager class (MVP version)
     * Simple in-memory message history
     */
    class ConversationManager {
      constructor() {
        this.state = {
          messages: [],
          status: 'idle' // idle, processing, waiting_for_user
        };
      }
  
      /**
       * Add a message to the conversation history
       * @param {Object} message - Message object with { role, content }
       * @returns {void}
       */
      addMessage(message) {
        this.state.messages.push(message);
      }
  
      /**
       * Add a user message
       * @param {string} content - User's message content
       * @returns {void}
       */
      addUserMessage(content) {
        this.addMessage({ type: 'user_msg', role: 'user', content });
      }
  
      /**
       * Add an assistant message
       * @param {string} content - Assistant's message content
       * @returns {void}
       */
      addAssistantMessage(content) {
        this.addMessage({ type: 'assistant_msg', role: 'assistant', content });
      }
  
      /**
       * Add a tool use indicator (for display only)
       * @param {string} toolName - Name of the tool being used
       * @param {Object} parameters - Tool parameters (optional, for display)
       * @returns {Object} The added tool message
       */
      addToolUse(toolName, parameters) {
        const toolMessage = {
          type: 'tool_use',
          role: 'tool_use',
          toolName: toolName,
          parameters: parameters || {},
          id: 'tool-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9)
        };
        this.addMessage(toolMessage);
        return toolMessage;
      }
  
      /**
       * Add a tool result (for display only)
       * @param {string} toolName - Name of the tool
       * @param {Object} result - Tool execution result
       * @param {string} toolUseId - ID of the corresponding tool_use message
       * @returns {Object} The added result message
       */
      addToolResult(toolName, result, toolUseId) {
        const resultMessage = {
          type: 'tool_result',
          role: 'tool_result',
          toolName: toolName,
          result: result,
          tool_use_id: toolUseId
        };
        this.addMessage(resultMessage);
        return resultMessage;
      }
  
      /**
       * Get all messages in conversation history
       * @returns {Array} Array of message objects
       */
      getMessages() {
        return this.state.messages;
      }
  
      /**
       * Get current conversation state
       * @returns {Object} Current state
       */
      getState() {
        return this.state;
      }
  
      /**
       * Get last message from history
       * @returns {Object|null} Last message or null
       */
      getLastMessage() {
        if (this.state.messages.length === 0) {
          return null;
        }
        return this.state.messages[this.state.messages.length - 1];
      }
  
      /**
       * Clear all messages
       * @returns {void}
       */
      clearMessages() {
        this.state.messages = [];
      }
  
      /**
       * Set processing status
       * @param {string} status - Status value (idle, processing, waiting_for_user)
       * @returns {void}
       */
      setStatus(status) {
        this.state.status = status;
      }
  
      /**
       * Get current status
       * @returns {string} Current status
       */
      getStatus() {
        return this.state.status;
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ConversationManager = ConversationManager;
  
  })();

  // ============================================================================
  // src/project-manager.js
  // ============================================================================

  /**
   * Project management utilities
   * Create, list, select, and manage projects
   */
  
  (function() {
    'use strict';
  
    const { FSManager } = window.module;
    const { Logger } = window.module;
    const logger = window.module.createLogger('ProjectManager');
  
    /**
     * Project status enum
     */
    const ProjectStatus = {
      IN_PROGRESS: 'in_progress',
      COMPLETE: 'complete',
      ABANDONED: 'abandoned'
    };
  
    /**
     * Task status enum
     */
    const TaskStatus = {
      NOT_STARTED: 'not_started',
      IN_PROGRESS: 'in_progress',
      COMPLETE: 'complete',
      ABANDONED: 'abandoned'
    };
  
    /**
     * Project manager
     */
    class ProjectManager {
      constructor(fsManager) {
        this.fsManager = fsManager;
      }
  
      /**
       * Create new project
       * @param {string} name - Project name
       * @returns {Promise<Object>} Project metadata
       */
      async createProject(name) {
        // 1. Generate project directory name (slugify)
        const projectDir = window.module.Utils.slugify(name);
  
        // 2. Create .agent/projects/{project-dir}/ directory
        const projectPath = `.agent/projects/${projectDir}`;
        await this.fsManager.createDirectory(projectPath);
  
        // 3. Create metadata.json with initial structure
        const metadata = {
          name: name,
          status: ProjectStatus.IN_PROGRESS,
          created: new Date().toISOString(),
          lastModified: new Date().toISOString(),
          projectMentalModel: {},
          tasks: []
        };
  
        await this.fsManager.writeJSON(`${projectPath}/metadata.json`, metadata);
  
        // 4. Return metadata object
        return { ...metadata, projectDir };
      }
  
      /**
       * List all projects
       * @returns {Promise<Array>} List of project metadata
       */
      async listProjects() {
        // 1. List directories in .agent/projects/
        const projectsPath = '.agent/projects';
  
        // Check if projects directory exists
        const exists = await this.fsManager.directoryExists(projectsPath);
        if (!exists) {
          return [];
        }
  
        // Use FSManager.listProjects() which returns directory names directly
        const projectDirs = await this.fsManager.listProjects();
  
        // 2. Read metadata.json from each project directory
        const projects = [];
        for (const projectDir of projectDirs) {
          try {
            const metadata = await this.fsManager.readJSON(`${projectsPath}/${projectDir}/metadata.json`);
            projects.push({ ...metadata, projectDir });
          } catch (error) {
            logger.warn(`Failed to read metadata for project ${projectDir}:`, error);
          }
        }
  
        // 3 & 4. Sort by lastModified (most recent first) and return
        return projects.sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified));
      }
  
      /**
       * Get project metadata
       * @param {string} projectDir - Project directory name
       * @returns {Promise<Object>} Project metadata
       */
      async getProject(projectDir) {
        // 1 & 2. Read and parse .agent/projects/{projectDir}/metadata.json
        const metadata = await this.fsManager.readJSON(`.agent/projects/${projectDir}/metadata.json`);
  
        // 3. Return metadata object with projectDir included
        return { ...metadata, projectDir };
      }
  
      /**
       * Update project metadata
       * @param {string} projectDir - Project directory name
       * @param {Object} updates - Partial metadata to merge
       * @returns {Promise<Object>} Updated metadata
       */
      async updateProject(projectDir, updates) {
        // 1. Read current metadata
        const metadata = await this.getProject(projectDir);
  
        // 2. Merge updates
        const updated = { ...metadata, ...updates };
  
        // 3. Set lastModified to current timestamp
        updated.lastModified = new Date().toISOString();
  
        // 4. Write metadata.json
        await this.fsManager.writeJSON(`.agent/projects/${projectDir}/metadata.json`, updated);
  
        // 5. Return updated metadata
        return updated;
      }
  
      /**
       * Add task to project
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name
       * @param {string} taskDescription - Task description
       * @returns {Promise<Object>} Task object
       */
      async addTask(projectDir, taskName, taskDescription) {
        // 1. Read project metadata
        const metadata = await this.getProject(projectDir);
  
        // 2. Create task object
        const task = {
          name: taskName,
          description: taskDescription,
          status: TaskStatus.IN_PROGRESS,
          created: new Date().toISOString(),
          currentPhase: 'execution'  // Used by sidebar to determine which phases to show
        };
  
        // 3. Add to tasks array
        metadata.tasks.push(task);
  
        // 4. Update project metadata
        await this.updateProject(projectDir, { tasks: metadata.tasks });
  
        // 5. Create empty task.jsonl file
        const taskFilePath = this.getTaskFilePath(projectDir, taskName);
        await this.fsManager.writeFile(taskFilePath, '');
  
        // 6. Return task object
        return task;
      }
  
      /**
       * Update task status
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name (matches task file)
       * @param {string} status - New status
       * @param {string} [summary] - Optional task summary for completed tasks
       * @returns {Promise<Object>} Updated task object
       */
      async updateTaskStatus(projectDir, taskName, status, summary = null) {
        // 1. Read project metadata
        const metadata = await this.getProject(projectDir);
  
        // 2. Find task by name
        const task = metadata.tasks.find(t => t.name === taskName);
        if (!task) {
          throw new Error(`Task not found: ${taskName}`);
        }
  
        // 3. Update status
        task.status = status;
  
        // 4. If status is "complete", set completed timestamp and summary
        if (status === TaskStatus.COMPLETE) {
          task.completed = new Date().toISOString();
          if (summary) {
            task.summary = summary;
          }
        }
  
        // 5. Update project metadata
        await this.updateProject(projectDir, { tasks: metadata.tasks });
  
        // 6. Return updated task object
        return task;
      }
  
      /**
       * Update task checklist (saves to task metadata)
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name
       * @param {Array} checklist - Checklist items with status
       * @returns {Promise<void>}
       */
      async updateTaskChecklist(projectDir, taskName, checklist) {
        // 1. Read project metadata
        const metadata = await this.getProject(projectDir);
  
        // 2. Find task by name
        const task = metadata.tasks.find(t => t.name === taskName);
        if (!task) {
          throw new Error(`Task not found: ${taskName}`);
        }
  
        // 3. Update checklist
        task.checklist = checklist;
  
        // 4. Update project metadata
        await this.updateProject(projectDir, { tasks: metadata.tasks });
      }
  
      /**
       * List tasks for project
       * @param {string} projectDir - Project directory name
       * @returns {Promise<Array>} List of tasks
       */
      async listTasks(projectDir) {
        // 1. Read project metadata
        const metadata = await this.getProject(projectDir);
  
        // 2 & 3. Return tasks array sorted by created (oldest first)
        return (metadata.tasks || []).sort((a, b) => new Date(a.created) - new Date(b.created));
      }
  
      /**
       * Get task file path
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name
       * @returns {string} Task file path
       */
      getTaskFilePath(projectDir, taskName) {
        // 1. Slugify task name to get filename
        const taskSlug = window.module.Utils.slugify(taskName);
  
        // 2. Return .agent/projects/{projectDir}/{task-slug}.jsonl
        return `.agent/projects/${projectDir}/${taskSlug}.jsonl`;
      }
  
      /**
       * Read task messages
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name
       * @returns {Promise<Array>} Array of message objects
       */
      async readTaskMessages(projectDir, taskName) {
        // 1. Get task file path
        const taskFilePath = this.getTaskFilePath(projectDir, taskName);
  
        // 2. Read JSONL file
        const content = await this.fsManager.readFile(taskFilePath);
  
        // Handle empty file
        if (!content.trim()) {
          return [];
        }
  
        // 3. Parse each line as JSON
        const lines = content.trim().split('\n');
        const messages = [];
  
        for (const line of lines) {
          if (line.trim()) {
            try {
              const message = JSON.parse(line);
              messages.push(message);
            } catch (error) {
              logger.warn(`Failed to parse JSONL line:`, error);
            }
          }
        }
  
        // 4 & 5. Return array of message objects, filtering out loading messages
        return messages.filter(m => m.type !== 'loading');
      }
  
      /**
       * Update project mental model
       * @param {string} projectDir - Project directory name
       * @param {Object} updates - Mental model updates (merge or replace)
       * @param {boolean} replace - If true, replace entire model; if false, merge
       * @returns {Promise<Object>} Updated project mental model
       */
      async updateProjectMentalModel(projectDir, updates, replace = false) {
        // 1. Read project metadata
        const metadata = await this.getProject(projectDir);
  
        // 2. If replace: set projectMentalModel = updates
        // 3. If merge: merge updates into projectMentalModel
        const updatedModel = replace
          ? updates
          : { ...metadata.projectMentalModel, ...updates };
  
        // 4. Update project metadata
        await this.updateProject(projectDir, { projectMentalModel: updatedModel });
  
        // 5. Return updated mental model
        return updatedModel;
      }
  
      /**
       * Delete project
       * @param {string} projectDir - Project directory name
       * @returns {Promise<void>}
       */
      async deleteProject(projectDir) {
        // 1. Confirm with user (via event system)
        // Note: Caller should confirm before calling this method
  
        // 2. Delete .agent/projects/{projectDir}/ directory recursively
        const projectPath = `.agent/projects/${projectDir}`;
        await this.fsManager.deleteDirectory(projectPath, true);
  
        // 3. Emit project_deleted event (if event bus available)
        if (window.module.EventBus) {
          window.module.EventBus.emit('project:deleted', { projectDir });
        }
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ProjectManager = ProjectManager;
    window.module.ProjectStatus = ProjectStatus;
    window.module.TaskStatus = TaskStatus;
  
  })();

  // ============================================================================
  // src/task-manager.js
  // ============================================================================

  /**
   * Task management utilities
   * Create tasks, manage task lifecycle, persist messages
   */
  
  (function() {
    'use strict';
  
    const { FSManager } = window.module;
    const { Logger } = window.module;
    const { MessageType } = window.module;
    const logger = window.module.createLogger('TaskManager');
  
    /**
     * Task manager
     */
    class TaskManager {
      constructor(fsManager, projectManager) {
        this.fsManager = fsManager;
        this.projectManager = projectManager;
      }
  
      /**
       * Create new task
       * @param {string} projectDir - Project directory name
       * @param {string} taskDescription - Task description
       * @param {Array} checklistItems - Initial checklist items
       * @returns {Promise<Object>} Task object
       */
      async createTask(projectDir, taskDescription, checklistItems) {
        // 1. Generate task filename from description (slugify)
        const taskName = taskDescription;
  
        // 2. Call projectManager.addTask()
        const task = await this.projectManager.addTask(projectDir, taskName, taskDescription);
  
        // 3. Write initial messages to task.jsonl
        const { createChecklistApprovedMessage, createPhaseTransitionMessage } = window.module.ConversationState;
  
        const checklistMessage = createChecklistApprovedMessage(taskDescription, checklistItems);
        await this.appendMessage(projectDir, taskName, checklistMessage);
  
        const transitionMessage = createPhaseTransitionMessage('planning', 'execution', 'checklist_approved');
        await this.appendMessage(projectDir, taskName, transitionMessage);
  
        // 4. Return task object
        return task;
      }
  
      /**
       * Append message to task file
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name
       * @param {Object} message - Message object
       * @returns {Promise<void>}
       */
      async appendMessage(projectDir, taskName, message) {
        // 1. Skip if message type is "loading" (not persisted)
        const { isPersistedMessageType } = window.module.ConversationState;
        if (!isPersistedMessageType(message.type)) {
          return;
        }
  
        // 2. Get task file path
        const taskFilePath = this.projectManager.getTaskFilePath(projectDir, taskName);
  
        // 3. Serialize message to JSON (single line)
        const line = JSON.stringify(message) + '\n';
  
        // 4 & 5. Append line to task.jsonl file (create if doesn't exist)
        await this.fsManager.appendFile(taskFilePath, line);
      }
  
      /**
       * Read all messages for task
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name
       * @returns {Promise<Array>} Array of message objects
       */
      async readMessages(projectDir, taskName) {
        // 1. Delegate to projectManager.readTaskMessages()
        return await this.projectManager.readTaskMessages(projectDir, taskName);
      }
  
      /**
       * Complete task
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name
       * @param {string} summary - Task completion summary
       * @returns {Promise<void>}
       */
      async completeTask(projectDir, taskName, summary) {
        // 1. Update task status to "complete" via projectManager
        await this.projectManager.updateTaskStatus(projectDir, taskName, 'complete', summary);
  
        // 2. Write phase_transition message (review  planning)
        const { createPhaseTransitionMessage } = window.module.ConversationState;
        const transitionMessage = createPhaseTransitionMessage('review', 'planning', 'review_passed');
        await this.appendMessage(projectDir, taskName, transitionMessage);
  
        // 3. Emit task_completed event
        if (window.module.EventBus) {
          window.module.EventBus.emit('task:completed', { projectDir, taskName, summary });
        }
      }
  
      /**
       * Rebuild task mental model from messages
       * @param {Array} messages - Task messages
       * @returns {Object} Task mental model (Map<string, string>)
       */
      rebuildTaskMentalModel(messages) {
        // 1. Filter messages for type: "mental_model_update"
        const { MessageType } = window.module.ConversationState;
        const updateMessages = messages.filter(m => m.type === MessageType.MENTAL_MODEL_UPDATE);
  
        // 2 & 3. Merge all updates into single mental model (later updates overwrite earlier)
        const mentalModel = {};
        for (const msg of updateMessages) {
          // 5. Handle both old format (scope field) and new format (no scope)
          const updates = msg.updates || {};
          Object.assign(mentalModel, updates);
        }
  
        // 4. Return merged mental model object
        return mentalModel;
      }
  
      /**
       * Get current checklist from messages
       * @param {Array} messages - Task messages
       * @returns {Array|null} Checklist items or null if not found
       */
      getCurrentChecklist(messages) {
        // 1. Find latest checklist_approved message
        const { MessageType } = window.module.ConversationState;
        const checklistMessages = messages.filter(m => m.type === MessageType.CHECKLIST_APPROVED);
  
        if (checklistMessages.length === 0) {
          // 5. Return null if no checklist found
          return null;
        }
  
        const latestChecklist = checklistMessages[checklistMessages.length - 1];
  
        // 2. Extract items array
        const items = latestChecklist.items || [];
  
        // 3. Rebuild current status by replaying item transitions
        // Note: For now, we assume checklist items have their status already set
        // In a full implementation, we'd replay tool_result messages for mark_complete/mark_failed
  
        // 4. Return items with current status
        return items;
      }
  
      /**
       * Get current phase from messages
       * @param {Array} messages - Task messages
       * @returns {string} Current phase (planning/execution/review)
       */
      getCurrentPhase(messages) {
        // 1. Find latest phase_transition message
        const { MessageType, Phase } = window.module.ConversationState;
        const transitions = messages.filter(m => m.type === MessageType.PHASE_TRANSITION);
  
        if (transitions.length === 0) {
          // 3. Default to "planning" if no transitions found
          return Phase.PLANNING;
        }
  
        const latestTransition = transitions[transitions.length - 1];
  
        // 2. Return "to" field
        return latestTransition.to;
      }
  
      /**
       * Get current item index from messages
       * @param {Array} messages - Task messages
       * @returns {number} Current item index (-1 if not in execution)
       */
      getCurrentItemIndex(messages) {
        // 1. Check current phase
        const { Phase, ItemStatus } = window.module.ConversationState;
        const currentPhase = this.getCurrentPhase(messages);
  
        // 2. If not execution, return -1
        if (currentPhase !== Phase.EXECUTION) {
          return -1;
        }
  
        // 3. Get checklist items
        const checklist = this.getCurrentChecklist(messages);
        if (!checklist || checklist.length === 0) {
          return -1;
        }
  
        // 4. Find first item with status "in_progress"
        const inProgressIndex = checklist.findIndex(item => item.status === ItemStatus.IN_PROGRESS);
        if (inProgressIndex !== -1) {
          // 5. Return its index
          return inProgressIndex;
        }
  
        // 6. If all complete, return checklist.length - 1
        return checklist.length - 1;
      }
  
      /**
       * Export task to summary
       * @param {string} projectDir - Project directory name
       * @param {string} taskName - Task name
       * @returns {Promise<string>} Task summary (for AI promotion)
       */
      async exportTaskSummary(projectDir, taskName) {
        // 1. Read all task messages
        const messages = await this.readMessages(projectDir, taskName);
  
        // 2. Get task mental model
        const mentalModel = this.rebuildTaskMentalModel(messages);
  
        // 3. Get checklist
        const checklist = this.getCurrentChecklist(messages);
  
        // Get task description from checklist_approved message
        const { MessageType } = window.module.ConversationState;
        const checklistMsg = messages.find(m => m.type === MessageType.CHECKLIST_APPROVED);
        const taskDescription = checklistMsg ? checklistMsg.task_description : taskName;
  
        // 4. Format summary
        let summary = `## Task: ${taskDescription}\n\n`;
  
        // Checklist items
        if (checklist && checklist.length > 0) {
          summary += `### Checklist:\n`;
          for (const item of checklist) {
            const status = item.status === 'complete' ? '' : '';
            summary += `${status} ${item.short_desc || item.content}\n`;
          }
          summary += '\n';
        }
  
        // Mental model notes
        if (Object.keys(mentalModel).length > 0) {
          summary += `### Mental Model Notes:\n`;
          for (const [key, note] of Object.entries(mentalModel)) {
            summary += `- ${key}: ${note}\n`;
          }
          summary += '\n';
        }
  
        // 5. Return formatted string for AI to review
        return summary;
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.TaskManager = TaskManager;
  
  })();

  // ============================================================================
  // src/checklist-manager.js
  // ============================================================================

  /**
   * checklist-manager.js
   *
   * Manages task checklists:
   * - Checklist creation and validation
   * - Item status tracking (pending/in_progress/complete/failed)
   * - Item types (coding/git/testing/research)
   * - Current item tracking
   * - Item advancement logic
   *
   * Based on: src_old/com/codeboss/javalayer/aiprocessor/ChecklistManager.java
   */
  
  (function() {
    'use strict';
  
    const { ItemType, ItemStatus, createChecklistItem } = window.module.ConversationState;
  
    /**
     * ChecklistManager class
     * Handles checklist creation and item progression
     */
    class ChecklistManager {
      constructor() {
        this.checklist = [];
        this.currentItemIndex = -1;
      }
  
      /**
       * Create a new checklist from items
       * @param {Array} items - Array of item objects with short_desc, detailed_desc, item_type
       * @returns {Array} Array of ChecklistItem objects
       */
      createChecklist(items) {
        // Validate items array
        if (!Array.isArray(items)) {
          throw new Error('Items must be an array');
        }
  
        // Create ChecklistItem objects for each item
        const checklist = [];
        for (const item of items) {
          // Validate item type
          if (!this.validateItemType(item.item_type)) {
            throw new Error(`Invalid item type: ${item.item_type}`);
          }
  
          // Create checklist item (all start as pending)
          const checklistItem = createChecklistItem(
            item.short_desc || item.content,
            item.detailed_desc || item.content,
            item.item_type
          );
  
          checklist.push(checklistItem);
        }
  
        // Return checklist
        return checklist;
      }
  
      /**
       * Set the checklist and mark first item as in_progress
       * @param {Array} items - Array of ChecklistItem objects
       * @returns {void}
       */
      setChecklist(items) {
        // Set this.checklist
        this.checklist = items;
  
        // Set first item to in_progress
        if (items.length > 0) {
          items[0].status = ItemStatus.IN_PROGRESS;
          // Set currentItemIndex to 0
          this.currentItemIndex = 0;
        } else {
          this.currentItemIndex = -1;
        }
      }
  
      /**
       * Get the current checklist
       * @returns {Array} Checklist items
       */
      getChecklist() {
        return this.checklist;
      }
  
      /**
       * Get current item index
       * @returns {number} Current item index (-1 if no checklist)
       */
      getCurrentItemIndex() {
        return this.currentItemIndex;
      }
  
      /**
       * Get current item
       * @returns {Object|null} Current ChecklistItem or null
       */
      getCurrentItem() {
        // Return checklist[currentItemIndex] or null
        if (this.currentItemIndex >= 0 && this.currentItemIndex < this.checklist.length) {
          return this.checklist[this.currentItemIndex];
        }
        return null;
      }
  
      /**
       * Mark current item as complete and advance to next
       * @returns {boolean} True if more items remain, false if all done
       */
      markCurrentComplete() {
        // Mark current item as complete
        if (this.currentItemIndex >= 0 && this.currentItemIndex < this.checklist.length) {
          this.checklist[this.currentItemIndex].status = ItemStatus.COMPLETE;
        }
  
        // Increment currentItemIndex
        this.currentItemIndex++;
  
        // If more items exist, mark next as in_progress
        if (this.currentItemIndex < this.checklist.length) {
          this.checklist[this.currentItemIndex].status = ItemStatus.IN_PROGRESS;
          // Return true if more items
          return true;
        }
  
        // Return false if done
        return false;
      }
  
      /**
       * Mark current item as failed
       * @param {string} reason - Failure reason
       * @returns {void}
       */
      markCurrentFailed(reason) {
        // Mark current item as failed and store failure reason
        if (this.currentItemIndex >= 0 && this.currentItemIndex < this.checklist.length) {
          this.checklist[this.currentItemIndex].status = ItemStatus.FAILED;
          this.checklist[this.currentItemIndex].failureReason = reason;
        }
      }
  
      /**
       * Check if all items are complete
       * @returns {boolean} True if all complete
       */
      isAllComplete() {
        // Check if all items have status === 'complete'
        return this.checklist.length > 0 && this.checklist.every(item => item.status === ItemStatus.COMPLETE);
      }
  
      /**
       * Check if current item is the last item
       * @returns {boolean} True if last item
       */
      isLastItem() {
        // Check if currentItemIndex === checklist.length - 1
        return this.currentItemIndex === this.checklist.length - 1;
      }
  
      /**
       * Get items by status
       * @param {string} status - Item status to filter by
       * @returns {Array} Items with matching status
       */
      getItemsByStatus(status) {
        // Filter checklist by status
        return this.checklist.filter(item => item.status === status);
      }
  
      /**
       * Validate item type
       * @param {string} itemType - Item type to validate
       * @returns {boolean} True if valid
       */
      validateItemType(itemType) {
        const validTypes = [ItemType.CODING, ItemType.GIT, ItemType.TESTING, ItemType.RESEARCH];
        return validTypes.includes(itemType);
      }
  
      /**
       * Get checklist summary
       * @returns {Object} Summary with counts by status
       */
      getSummary() {
        // Count items by status
        const summary = {
          pending: 0,
          in_progress: 0,
          complete: 0,
          failed: 0,
          total: this.checklist.length
        };
  
        for (const item of this.checklist) {
          if (item.status === ItemStatus.PENDING) summary.pending++;
          else if (item.status === ItemStatus.IN_PROGRESS) summary.in_progress++;
          else if (item.status === ItemStatus.COMPLETE) summary.complete++;
          else if (item.status === ItemStatus.FAILED) summary.failed++;
        }
  
        return summary;
      }
  
      /**
       * Clear checklist
       * @returns {void}
       */
      clear() {
        this.checklist = [];
        this.currentItemIndex = -1;
      }
  
      /**
       * Serialize checklist to JSON
       * @returns {Array} JSON-serializable checklist
       */
      toJSON() {
        return this.checklist;
      }
  
      /**
       * Load checklist from JSON
       * @param {Array} items - Checklist items
       * @returns {void}
       */
      fromJSON(items) {
        // Load checklist from JSON
        this.checklist = items || [];
  
        // Find current item (first in_progress item)
        const inProgressIndex = this.checklist.findIndex(item => item.status === ItemStatus.IN_PROGRESS);
  
        // Set currentItemIndex
        this.currentItemIndex = inProgressIndex !== -1 ? inProgressIndex : -1;
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ChecklistManager = ChecklistManager;
  
  })();

  // ============================================================================
  // src/checklist-parser.js
  // ============================================================================

  /**
   * checklist-parser.js
   *
   * Parses begin_execution tool parameters:
   * - Extract task description
   * - Extract checklist items
   * - Validate item types
   * - Create checklist structure
   *
   * Based on: src_old/com/codeboss/javalayer/aiprocessor/ChecklistParser.java
   */
  
  (function() {
    'use strict';
  
    const { ItemType, createChecklistItem } = window.module.ConversationState;
  
    /**
     * ChecklistParser class
     * Parses begin_execution tool parameters into checklist structure
     */
    class ChecklistParser {
      constructor() {
        this.validItemTypes = [ItemType.CODING, ItemType.GIT, ItemType.TESTING, ItemType.RESEARCH];
      }
  
      /**
       * Parse begin_execution tool parameters
       * @param {Object} parameters - Tool parameters
       * @returns {Object} {taskDescription, items, errors}
       */
      parse(parameters) {
        // TODO: Extract task_description
        // TODO: Extract items array
        // TODO: Validate task_description is non-empty
        // TODO: Validate items is array and non-empty
        // TODO: Parse each item
        // TODO: Return {taskDescription, items, errors}
        throw new Error('Not implemented: ChecklistParser.parse()');
      }
  
      /**
       * Parse a single checklist item
       * @param {Object} itemData - Raw item data
       * @param {number} index - Item index for error messages
       * @returns {Object} {item, errors}
       * @private
       */
      parseItem(itemData, index) {
        // TODO: Extract short_desc (or content for backward compatibility)
        // TODO: Extract detailed_desc (default to short_desc if missing)
        // TODO: Extract item_type
        // TODO: Validate all fields present
        // TODO: Validate item_type is valid
        // TODO: Create ChecklistItem
        // TODO: Return {item, errors}
        throw new Error('Not implemented: ChecklistParser.parseItem()');
      }
  
      /**
       * Validate task description
       * @param {string} taskDescription - Task description
       * @returns {Array<string>} Array of error messages
       * @private
       */
      validateTaskDescription(taskDescription) {
        const errors = [];
  
        // TODO: Check task_description is string
        // TODO: Check non-empty
        // TODO: Check reasonable length (e.g., 5-200 chars)
        // TODO: Return errors array
        throw new Error('Not implemented: ChecklistParser.validateTaskDescription()');
      }
  
      /**
       * Validate checklist items array
       * @param {Array} items - Items array
       * @returns {Array<string>} Array of error messages
       * @private
       */
      validateItems(items) {
        const errors = [];
  
        // TODO: Check items is array
        // TODO: Check non-empty
        // TODO: Check reasonable count (e.g., 1-50 items)
        // TODO: Return errors array
        throw new Error('Not implemented: ChecklistParser.validateItems()');
      }
  
      /**
       * Validate item type
       * @param {string} itemType - Item type
       * @returns {boolean} True if valid
       */
      isValidItemType(itemType) {
        return this.validItemTypes.includes(itemType);
      }
  
      /**
       * Get item type from string (case-insensitive)
       * @param {string} typeStr - Type string
       * @returns {string|null} ItemType constant or null
       */
      normalizeItemType(typeStr) {
        // TODO: Convert to lowercase
        // TODO: Match against valid item types
        // TODO: Return normalized type or null
        throw new Error('Not implemented: ChecklistParser.normalizeItemType()');
      }
  
      /**
       * Extract short description from item data
       * Handles both 'short_desc' and legacy 'content' field
       * @param {Object} itemData - Item data
       * @returns {string|null} Short description or null
       * @private
       */
      extractShortDesc(itemData) {
        // TODO: Try short_desc first
        // TODO: Fall back to content (legacy)
        // TODO: Return description or null
        throw new Error('Not implemented: ChecklistParser.extractShortDesc()');
      }
  
      /**
       * Extract detailed description from item data
       * @param {Object} itemData - Item data
       * @param {string} fallback - Fallback to short_desc if missing
       * @returns {string} Detailed description
       * @private
       */
      extractDetailedDesc(itemData, fallback) {
        // TODO: Try detailed_desc first
        // TODO: Fall back to provided fallback (short_desc)
        // TODO: Return description
        throw new Error('Not implemented: ChecklistParser.extractDetailedDesc()');
      }
  
      /**
       * Validate parsed result
       * @param {Object} result - Parse result
       * @returns {boolean} True if valid (no errors)
       */
      isValid(result) {
        return result.errors.length === 0;
      }
  
      /**
       * Format errors for display
       * @param {Array<string>} errors - Error messages
       * @returns {string} Formatted error message
       */
      formatErrors(errors) {
        // TODO: Format errors as bulleted list
        // TODO: Return formatted string
        throw new Error('Not implemented: ChecklistParser.formatErrors()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ChecklistParser = ChecklistParser;
  
  })();

  // ============================================================================
  // src/mode-manager.js
  // ============================================================================

  /**
   * mode-manager.js
   *
   * Manages phases and tool availability:
   * - Phase management (PLANNING/EXECUTION/REVIEW)
   * - Phase transitions
   * - Tool availability by phase and item type
   * - Validation rules per phase
   *
   * Based on: src_old/com/codeboss/javalayer/aiprocessor/ModeManager.java
   *           specs/PHASES.md
   */
  
  (function() {
    'use strict';
  
    const { Phase, ItemType } = window.module.ConversationState;
  
    /**
     * Tool availability by phase and item type
     * Based on specs/PHASES.md Tool Availability Matrix
     */
    const TOOL_AVAILABILITY = {
      // Read tools (all ephemeral)
      read_file: {
        planning: true,
        execution: { coding: true, git: true, testing: true, research: true },
        review: true
      },
      list_files: {
        planning: true,
        execution: { coding: true, research: true },
        review: true
      },
      search_files_by_name: {
        planning: true,
        execution: { coding: true, research: true },
        review: true
      },
      search_files_by_content: {
        planning: true,
        execution: { coding: true, research: true },
        review: true
      },
      git_read: {
        planning: true,
        execution: { coding: true, git: true, testing: true, research: true },
        review: true
      },
      list_projects: {
        planning: true,
        execution: { research: true },
        review: true
      },
      list_tasks_for_project: {
        planning: true,
        execution: { research: true },
        review: true
      },
      read_task_messages: {
        planning: true,
        execution: { research: true },
        review: true
      },
      read_change: {
        planning: true,
        execution: { coding: true, git: true, testing: true, research: true },
        review: true
      },
  
      // Mental model tools
      update_mental_model: {
        planning: true,  // MANDATORY after reads
        execution: { coding: true, git: true, testing: true, research: true },  // MANDATORY after reads
        review: true  // MANDATORY after reads
      },
  
      // Planning control
      begin_execution: {
        planning: true,
        execution: false,
        review: false
      },
  
      // Execution control
      mark_complete: {
        planning: false,
        execution: { coding: true, git: true, testing: true, research: true },
        review: false
      },
      mark_failed: {
        planning: false,
        execution: { coding: true, git: true, testing: true, research: true },
        review: false
      },
  
      // File write operations (coding only)
      create_file: {
        planning: false,
        execution: { coding: true },
        review: false
      },
      update_file: {
        planning: false,
        execution: { coding: true },
        review: false
      },
      delete_file: {
        planning: false,
        execution: { coding: true },
        review: false
      },
      move_file: {
        planning: false,
        execution: { coding: true },
        review: false
      },
      create_directory: {
        planning: false,
        execution: { coding: true },
        review: false
      },
      delete_directory_recursive: {
        planning: false,
        execution: { coding: true },
        review: false
      },
  
      // Git write operations (git only)
      git_write: {
        planning: false,
        execution: { git: true },
        review: false
      },
  
      // Command execution (testing only in execution, allowed in review)
      run_command: {
        planning: false,
        execution: { testing: true },
        review: true
      },
      list_processes: {
        planning: false,
        execution: { testing: true },
        review: true
      },
      stop_command: {
        planning: false,
        execution: { testing: true },
        review: true
      }
    };
  
    /**
     * ModeManager class
     * Manages phase state and tool availability
     */
    class ModeManager {
      constructor() {
        this.currentPhase = Phase.PLANNING;
        this.currentItemType = null;
      }
  
      /**
       * Set current phase
       * @param {string} phase - Phase name
       * @returns {void}
       */
      setPhase(phase) {
        // Validate phase is valid
        const validPhases = [Phase.PLANNING, Phase.EXECUTION, Phase.REVIEW];
        if (!validPhases.includes(phase)) {
          throw new Error(`Invalid phase: ${phase}. Must be one of: ${validPhases.join(', ')}`);
        }
  
        // Set currentPhase
        this.currentPhase = phase;
  
        // Clear currentItemType if leaving execution
        if (phase !== Phase.EXECUTION) {
          this.currentItemType = null;
        }
      }
  
      /**
       * Get current phase
       * @returns {string} Current phase
       */
      getPhase() {
        return this.currentPhase;
      }
  
      /**
       * Set current item type (for execution phase)
       * @param {string} itemType - Item type
       * @returns {void}
       */
      setItemType(itemType) {
        // Validate item type is valid
        const validItemTypes = [ItemType.CODING, ItemType.GIT, ItemType.TESTING, ItemType.RESEARCH];
        if (itemType !== null && !validItemTypes.includes(itemType)) {
          throw new Error(`Invalid item type: ${itemType}. Must be one of: ${validItemTypes.join(', ')}`);
        }
  
        // Set currentItemType
        this.currentItemType = itemType;
      }
  
      /**
       * Get current item type
       * @returns {string|null} Current item type or null
       */
      getItemType() {
        return this.currentItemType;
      }
  
      /**
       * Check if a tool is available in current phase/item type
       * @param {string} toolName - Tool name
       * @returns {boolean} True if tool is available
       */
      isToolAvailable(toolName) {
        // Look up tool in TOOL_AVAILABILITY
        const toolConfig = TOOL_AVAILABILITY[toolName];
        if (!toolConfig) {
          return false; // Unknown tool
        }
  
        // Check phase availability
        const phaseConfig = toolConfig[this.currentPhase];
        if (phaseConfig === undefined) {
          return false; // Tool not defined for this phase
        }
  
        // If execution phase, check item type availability
        if (this.currentPhase === Phase.EXECUTION) {
          if (typeof phaseConfig === 'boolean') {
            return phaseConfig;
          } else if (typeof phaseConfig === 'object') {
            // Item type specific - check current item type
            if (!this.currentItemType) {
              return false; // No item type set
            }
            return phaseConfig[this.currentItemType] === true;
          }
        }
  
        // For planning and review, phaseConfig is a boolean
        return phaseConfig === true;
      }
  
      /**
       * Validate tool call for current phase/item type
       * @param {string} toolName - Tool name
       * @returns {Object} {valid: boolean, error: string|null}
       */
      validateToolCall(toolName) {
        // Check if tool is available
        if (this.isToolAvailable(toolName)) {
          return { valid: true, error: null };
        }
  
        // Generate error message explaining why
        const toolConfig = TOOL_AVAILABILITY[toolName];
        if (!toolConfig) {
          return {
            valid: false,
            error: `Unknown tool: ${toolName}`
          };
        }
  
        // Check if tool exists in any phase
        if (this.currentPhase === Phase.PLANNING) {
          return {
            valid: false,
            error: `Tool '${toolName}' is not available in Planning phase. This tool is only available during Execution or Review.`
          };
        } else if (this.currentPhase === Phase.EXECUTION) {
          // Check if it's an item type issue
          const phaseConfig = toolConfig[this.currentPhase];
          if (typeof phaseConfig === 'object') {
            const availableItemTypes = Object.keys(phaseConfig).filter(k => phaseConfig[k]);
            return {
              valid: false,
              error: `Tool '${toolName}' is not available for item type '${this.currentItemType}'. Available for: ${availableItemTypes.join(', ')}`
            };
          } else {
            return {
              valid: false,
              error: `Tool '${toolName}' is not available in Execution phase.`
            };
          }
        } else if (this.currentPhase === Phase.REVIEW) {
          return {
            valid: false,
            error: `Tool '${toolName}' is not available in Review phase. Review is read-only - you cannot modify files.`
          };
        }
  
        return {
          valid: false,
          error: `Tool '${toolName}' is not available in current context.`
        };
      }
  
      /**
       * Get all available tools for current phase/item type
       * @returns {Array<string>} Array of available tool names
       */
      getAvailableTools() {
        // Iterate through TOOL_AVAILABILITY and filter to tools available for current phase/item type
        const availableTools = [];
  
        for (const toolName in TOOL_AVAILABILITY) {
          if (this.isToolAvailable(toolName)) {
            availableTools.push(toolName);
          }
        }
  
        return availableTools;
      }
  
      /**
       * Get tools by category for current phase/item type
       * @returns {Object} Tools grouped by category
       */
      getToolsByCategory() {
        const availableTools = this.getAvailableTools();
  
        const categories = {
          read_tools: [],
          write_tools: [],
          git_tools: [],
          command_tools: [],
          mental_model_tools: [],
          control_tools: []
        };
  
        // Define tool categories
        const readTools = ['read_file', 'list_files', 'search_files_by_name', 'search_files_by_content',
                           'list_projects', 'list_tasks_for_project', 'read_task_messages', 'read_change'];
        const writeTools = ['create_file', 'update_file', 'delete_file', 'move_file',
                            'create_directory', 'delete_directory_recursive'];
        const gitTools = ['git_read', 'git_write'];
        const commandTools = ['run_command', 'list_processes', 'stop_command'];
        const mentalModelTools = ['update_mental_model'];
        const controlTools = ['begin_execution', 'mark_complete', 'mark_failed'];
  
        // Categorize available tools
        for (const tool of availableTools) {
          if (readTools.includes(tool)) {
            categories.read_tools.push(tool);
          } else if (writeTools.includes(tool)) {
            categories.write_tools.push(tool);
          } else if (gitTools.includes(tool)) {
            categories.git_tools.push(tool);
          } else if (commandTools.includes(tool)) {
            categories.command_tools.push(tool);
          } else if (mentalModelTools.includes(tool)) {
            categories.mental_model_tools.push(tool);
          } else if (controlTools.includes(tool)) {
            categories.control_tools.push(tool);
          }
        }
  
        return categories;
      }
  
      /**
       * Validate phase transition
       * @param {string} fromPhase - Current phase
       * @param {string} toPhase - Target phase
       * @param {string} trigger - What triggered the transition
       * @returns {Object} {valid: boolean, error: string|null}
       */
      validatePhaseTransition(fromPhase, toPhase, trigger) {
        // Define valid transitions
        const validTransitions = {
          planning: {
            execution: ['checklist_approved']
          },
          execution: {
            review: ['all_items_complete'],
            planning: ['item_failed']
          },
          review: {
            planning: ['review_passed', 'review_found_issues']
          }
        };
  
        // Validate transition is allowed
        const allowedTransitions = validTransitions[fromPhase];
        if (!allowedTransitions) {
          return {
            valid: false,
            error: `Invalid source phase: ${fromPhase}`
          };
        }
  
        const allowedTriggers = allowedTransitions[toPhase];
        if (!allowedTriggers) {
          return {
            valid: false,
            error: `Cannot transition from ${fromPhase} to ${toPhase}`
          };
        }
  
        if (!allowedTriggers.includes(trigger)) {
          return {
            valid: false,
            error: `Invalid trigger '${trigger}' for transition ${fromPhase} -> ${toPhase}. Expected one of: ${allowedTriggers.join(', ')}`
          };
        }
  
        return { valid: true, error: null };
      }
  
      /**
       * Check if tool is a read operation (ephemeral)
       * @param {string} toolName - Tool name
       * @returns {boolean} True if read operation
       */
      isReadOperation(toolName) {
        const readTools = [
          'read_file',
          'git_read',
          'list_files',
          'search_files_by_name',
          'search_files_by_content',
          'list_projects',
          'list_tasks_for_project',
          'read_task_messages',
          'read_change'
        ];
        return readTools.includes(toolName);
      }
  
      /**
       * Check if tool is a write operation
       * @param {string} toolName - Tool name
       * @returns {boolean} True if write operation
       */
      isWriteOperation(toolName) {
        const writeTools = [
          'create_file',
          'update_file',
          'delete_file',
          'move_file',
          'create_directory',
          'delete_directory_recursive',
          'git_write'
        ];
        return writeTools.includes(toolName);
      }
  
      /**
       * Get phase description for user display
       * @param {string} phase - Phase name
       * @returns {string} Phase description
       */
      getPhaseDescription(phase) {
        const descriptions = {
          [Phase.PLANNING]: `Planning Phase - Explore the project and create implementation plan.
  Available actions:
  - Read files and search code
  - View git history and diffs
  - List projects and tasks
  - Update mental model with learnings
  - Create execution plan with begin_execution`,
  
          [Phase.EXECUTION]: `Execution Phase - Implement the plan systematically.
  Available actions depend on current checklist item type:
  - coding: File operations (create, update, delete, move)
  - git: Git operations (add, commit, push, branch)
  - testing: Run commands and tests
  - research: Read-only exploration
  All items: Mark complete or failed, update mental model`,
  
          [Phase.REVIEW]: `Review Phase - Validate completed work before finishing.
  Available actions:
  - Read files and search code
  - View git history and diffs
  - Run commands for validation
  - Update mental model with findings
  Note: Cannot modify files - review is read-only`
        };
  
        return descriptions[phase] || 'Unknown phase';
      }
  
      /**
       * Get item type description for user display
       * @param {string} itemType - Item type
       * @returns {string} Item type description
       */
      getItemTypeDescription(itemType) {
        const descriptions = {
          [ItemType.CODING]: `Coding Item - File operations only.
  Available tools:
  - File operations: create_file, update_file, delete_file, move_file
  - Directory operations: create_directory, delete_directory_recursive
  - Read operations: read_file, list_files, search files
  - Control: mark_complete, mark_failed`,
  
          [ItemType.GIT]: `Git Item - Git write operations.
  Available tools:
  - Git write: git_write (add, commit, push, branch)
  - Read operations: read_file, git_read
  - Control: mark_complete, mark_failed`,
  
          [ItemType.TESTING]: `Testing Item - Command execution.
  Available tools:
  - Commands: run_command, list_processes, stop_command
  - Read operations: read_file, git_read
  - Control: mark_complete, mark_failed`,
  
          [ItemType.RESEARCH]: `Research Item - Read-only investigation.
  Available tools:
  - Read operations: read_file, list_files, search files
  - Project/task viewing: list_projects, list_tasks_for_project, read_task_messages
  - Control: mark_complete, mark_failed`
        };
  
        return descriptions[itemType] || 'Unknown item type';
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ModeManager = ModeManager;
    window.module.TOOL_AVAILABILITY = TOOL_AVAILABILITY;
  
  })();

  // ============================================================================
  // src/response-parser.js
  // ============================================================================

  /**
   * response-parser.js
   *
   * Parses XML text responses with proper XML parameter support:
   * - Parses <execute> blocks with tools
   * - Parses <message> blocks with text
   * - Supports proper XML parameters (no JSON-in-XML)
   * - Uses xml-parser.js for XML parsing
   */
  
  (function() {
    'use strict';
  
    // Version logging to verify correct code is loaded
    console.log('[ResponseParser] Loading version 2.0 - Proper XML parameters (no JSON-in-XML)');
  
    /**
     * Parsed response structure
     * @typedef {Object} ParsedResponse
     * @property {boolean} hasMessage - True if response contains assistant text
     * @property {string|null} message - Assistant message text
     * @property {boolean} hasToolCalls - True if response contains tool calls
     * @property {Array} toolCalls - Array of tool call objects
     */
  
    /**
     * Tool call structure
     * @typedef {Object} ToolCall
     * @property {string} name - Tool name
     * @property {Object} parameters - Tool parameters
     */
  
    /**
     * ResponseParser class
     * Parses XML text responses from AI (either <execute> or <message>)
     */
    class ResponseParser {
      constructor() {
        // XML parser loaded from xml-parser.js
        this.xmlParser = window.module.XMLParser;
      }
  
      /**
       * Parse an AI API response (XML text)
       * @param {Object} apiResponse - API response with {content: string (XML text)}
       * @returns {ParsedResponse} Parsed response object
       */
      parse(apiResponse) {
        console.log('[ResponseParser] Parsing API response');
        console.log('[ResponseParser] Content type:', typeof apiResponse.content);
        console.log('[ResponseParser] Content preview:', apiResponse.content?.substring(0, 200));
  
        // Extract XML text from response
        const xmlText = apiResponse.content;
  
        if (!xmlText || typeof xmlText !== 'string') {
          console.error('[ResponseParser] Invalid response - content is not a string');
          return {
            hasMessage: false,
            message: null,
            hasToolCalls: false,
            toolCalls: []
          };
        }
  
        // Strip any clipboard markers (for compatibility with production code)
        let cleanedText = xmlText
          .replace(/\|{5}CLIP:TO_JAVA\|{5}/g, '')
          .replace(/\|{5}AI:END\|{5}/g, '')
          .trim();
  
        // Strip markdown code blocks (```xml, ```, etc.)
        // AI sometimes wraps XML in markdown code fences
        cleanedText = cleanedText.replace(/```(?:xml|html|text)?\n?/g, '');
        cleanedText = cleanedText.trim();
  
        console.log('[ResponseParser] Cleaned XML:', cleanedText.substring(0, 300));
  
        // Parse XML structure
        try {
          return this.parseXML(cleanedText);
        } catch (error) {
          console.error('[ResponseParser] Error parsing XML:', error);
          // Fallback: treat as plain message
          return {
            hasMessage: true,
            message: cleanedText,
            hasToolCalls: false,
            toolCalls: []
          };
        }
      }
  
      /**
       * Parse XML text into ParsedResponse
       * @param {string} xmlText - XML text (either <execute> or <message>)
       * @returns {ParsedResponse} Parsed response
       * @private
       */
      parseXML(xmlText) {
        let trimmed = xmlText.trim();
  
        // Check for both execute and message tags
        const hasExecute = trimmed.includes('<execute>') || trimmed.includes('</execute>');
        const hasMessage = trimmed.includes('<message>') || trimmed.includes('</message>');
  
        // Check if there are any XML tags at all
        if (!hasExecute && !hasMessage && !trimmed.includes('<tool ')) {
          // No XML tags - treat as plain message
          console.log('[ResponseParser] No XML tags found, treating as plain message');
          return {
            hasMessage: true,
            message: trimmed,
            hasToolCalls: false,
            toolCalls: []
          };
        }
  
        // Track all violations
        const violations = [];
  
        // Handle violation: both execute AND message present
        if (hasExecute && hasMessage) {
          console.warn('[ResponseParser] FORMAT VIOLATION: Response contains BOTH <execute> and <message> tags');
  
          // Extract message content to include in warning
          const messageContent = this.extractMessageContent(trimmed);
  
          // Strip message blocks
          trimmed = this.stripMessageBlocks(trimmed);
  
          // Add violation
          if (messageContent) {
            violations.push(`Response contained BOTH <execute> and <message> tags. Only ONE is allowed. The <execute> block was processed, but the <message> content was NOT shown to the user. Message content was: "${messageContent}"`);
          } else {
            violations.push(`Response contained BOTH <execute> and <message> tags. Only ONE is allowed. The <execute> block was processed.`);
          }
        }
  
        // Strip text BEFORE first tag
        const firstTagPos = this.findFirstTagPosition(trimmed);
        if (firstTagPos > 0) {
          const preamble = trimmed.substring(0, firstTagPos).trim();
          if (preamble) {
            violations.push(`Text before XML tags was NOT displayed to the user: "${preamble.length > 200 ? preamble.substring(0, 200) + '...' : preamble}"`);
            trimmed = trimmed.substring(firstTagPos);
          }
        }
  
        // Strip text AFTER last closing tag
        const lastCloseExecute = trimmed.lastIndexOf('</execute>');
        const lastCloseMessage = trimmed.lastIndexOf('</message>');
        const lastTagPos = Math.max(lastCloseExecute, lastCloseMessage);
  
        if (lastTagPos >= 0) {
          const endPos = lastTagPos + (lastCloseExecute > lastCloseMessage ? '</execute>'.length : '</message>'.length);
          if (endPos < trimmed.length) {
            const postamble = trimmed.substring(endPos).trim();
            if (postamble) {
              violations.push(`Text after XML tags was NOT displayed to the user: "${postamble.length > 200 ? postamble.substring(0, 200) + '...' : postamble}"`);
              trimmed = trimmed.substring(0, endPos);
            }
          }
        }
  
        // Combine all violations into one warning
        if (violations.length > 0) {
          this.violationWarning = 'FORMAT VIOLATION:\n' + violations.map((v, i) => `${i + 1}. ${v}`).join('\n');
          console.warn('[ResponseParser]', this.violationWarning);
        }
  
        // Check for <execute> tag
        if (trimmed.includes('<execute>')) {
          console.log('[ResponseParser] Found <execute> tag');
          return this.parseExecuteBlock(trimmed);
        }
  
        // Check for <message> tag
        if (trimmed.includes('<message>')) {
          console.log('[ResponseParser] Found <message> tag');
          return this.parseMessageBlock(trimmed);
        }
  
        // Check for <tool> tag directly (without <execute> wrapper)
        if (trimmed.includes('<tool ')) {
          console.log('[ResponseParser] Found <tool> tag (auto-wrapping in <execute>)');
          return this.parseExecuteBlock('<execute>' + trimmed + '</execute>');
        }
  
        // Fallback: treat as plain message
        console.log('[ResponseParser] Unknown XML format, treating as plain message');
        return {
          hasMessage: true,
          message: trimmed,
          hasToolCalls: false,
          toolCalls: []
        };
      }
  
      /**
       * Find position of first opening tag (<execute> or <message>)
       * @param {string} text - Text to search
       * @returns {number} Position of first tag, or -1 if not found
       * @private
       */
      findFirstTagPosition(text) {
        const executeStart = text.indexOf('<execute>');
        const messageStart = text.indexOf('<message>');
  
        if (executeStart >= 0 && messageStart >= 0) {
          return Math.min(executeStart, messageStart);
        } else if (executeStart >= 0) {
          return executeStart;
        } else if (messageStart >= 0) {
          return messageStart;
        }
        return -1;
      }
  
      /**
       * Extract message content from XML (for warning messages)
       * @param {string} xmlText - XML text containing <message> tags
       * @returns {string} Extracted message content
       * @private
       */
      extractMessageContent(xmlText) {
        const messageRegex = /<message>(.*?)<\/message>/gs;
        const matches = xmlText.match(messageRegex);
        if (!matches) return '';
  
        const content = matches.map(match => {
          const text = match.replace(/<\/?message>/g, '').trim();
          return text.length > 200 ? text.substring(0, 200) + '...' : text;
        }).join(' ');
  
        return content;
      }
  
      /**
       * Strip all <message> blocks from XML
       * @param {string} xmlText - XML text
       * @returns {string} XML with message blocks removed
       * @private
       */
      stripMessageBlocks(xmlText) {
        return xmlText.replace(/<message>.*?<\/message>/gs, '');
      }
  
      /**
       * Parse <execute> block to extract tools
       * @param {string} xmlText - XML text with <execute> tag
       * @returns {ParsedResponse} Parsed response with tools
       * @private
       */
      parseExecuteBlock(xmlText) {
        const toolCalls = [];
  
        // Use XMLParser to parse the XML
        const parsed = this.xmlParser.parse(xmlText);
  
        if (parsed.name !== 'execute') {
          console.error('[ResponseParser] Expected <execute> root, got:', parsed.name);
          return {
            hasMessage: false,
            message: null,
            hasToolCalls: false,
            toolCalls: []
          };
        }
  
        // Extract all <tool> children (or <invoke> for backward compatibility)
        let toolElements = parsed.children.filter(child => child.name === 'tool');
  
        // Check if AI used <invoke> instead of <tool> (common mistake)
        const invokeElements = parsed.children.filter(child => child.name === 'invoke');
        if (invokeElements.length > 0) {
          console.warn('[ResponseParser] AI used <invoke> instead of <tool> - treating as tools');
          toolElements = invokeElements;
        }
  
        for (const toolElement of toolElements) {
          const toolName = toolElement.attributes.name;
          if (!toolName) {
            console.warn('[ResponseParser] Tool missing name attribute');
            continue;
          }
  
          // Extract parameters - Support both old and new formats
          const parameters = this.extractToolParameters(toolElement, toolName);
  
          toolCalls.push({
            name: toolName,
            parameters: parameters
          });
        }
  
        console.log('[ResponseParser] Extracted', toolCalls.length, 'tool calls');
  
        return {
          hasMessage: false,
          message: null,
          hasToolCalls: toolCalls.length > 0,
          toolCalls: toolCalls
        };
      }
  
      /**
       * Extract parameters from tool element
       * Supports both old format (<parameter name="...">) and new format (direct child elements)
       * @param {Object} toolElement - Parsed tool XML element
       * @param {string} toolName - Tool name for schema lookup
       * @returns {Object} Parameters object
       * @private
       */
      extractToolParameters(toolElement, toolName) {
        const parameters = {};
  
        // Check for old format: <parameter name="...">value</parameter>
        const oldFormatParams = toolElement.children.filter(child => child.name === 'parameter');
  
        if (oldFormatParams.length > 0) {
          // OLD FORMAT: <parameter name="key">value</parameter>
          console.log(`[ResponseParser] Using OLD format for ${toolName}`);
  
          // Get tool schema for type information
          const toolDef = window.module.ToolDefinitions.getToolDefinition(toolName);
          const schema = toolDef ? toolDef.input_schema : null;
  
          for (const paramElement of oldFormatParams) {
            const paramName = paramElement.attributes.name;
            if (!paramName) {
              console.warn('[ResponseParser] Parameter missing name attribute');
              continue;
            }
  
            // Check if parameter has child elements (HYBRID format: old wrapper, new content)
            if (paramElement.children && paramElement.children.length > 0) {
              console.log(`[ResponseParser] HYBRID format detected for "${paramName}" - has child elements`);
  
              // Get expected type from schema
              const paramSchema = schema && schema.properties ? schema.properties[paramName] : null;
              const expectedType = paramSchema ? paramSchema.type : 'string';
  
              // Parse using NEW format logic
              const paramValue = this.parseParameterValue(paramElement, expectedType, paramSchema);
              parameters[paramName] = paramValue;
              continue;
            }
  
            // Normal OLD format: text content
            let paramValue = paramElement.textContent || '';
  
            // Try to parse JSON if it looks like JSON
            const trimmedValue = paramValue.trim();
            if (trimmedValue.startsWith('{') || trimmedValue.startsWith('[')) {
              try {
                paramValue = JSON.parse(trimmedValue);
                console.log(`[ResponseParser] Parsed JSON for parameter "${paramName}"`);
              } catch (e) {
                console.warn(`[ResponseParser] Failed to parse JSON for parameter "${paramName}":`, e.message);
              }
            }
  
            parameters[paramName] = paramValue;
          }
        } else {
          // NEW FORMAT: Parameters as direct child elements
          console.log(`[ResponseParser] Using NEW format for ${toolName}`);
  
          // Get tool schema to understand parameter types
          const toolDef = window.module.ToolDefinitions.getToolDefinition(toolName);
          const schema = toolDef ? toolDef.input_schema : null;
  
          for (const child of toolElement.children) {
            const paramName = child.name;
  
            // Get expected type from schema
            const paramSchema = schema && schema.properties ? schema.properties[paramName] : null;
            const expectedType = paramSchema ? paramSchema.type : 'string';
  
            // Parse based on structure and expected type
            const paramValue = this.parseParameterValue(child, expectedType, paramSchema);
            parameters[paramName] = paramValue;
          }
        }
  
        return parameters;
      }
  
      /**
       * Parse parameter value based on XML structure and expected type
       * @param {Object} element - XML element
       * @param {string} expectedType - Expected type from schema (string, object, array, integer, boolean)
       * @param {Object} paramSchema - Full parameter schema with items property for arrays
       * @returns {*} Parsed value
       * @private
       */
      parseParameterValue(element, expectedType, paramSchema) {
        // Handle object type: <updates><entry key="...">value</entry></updates>
        if (expectedType === 'object') {
          const obj = {};
          const entries = element.children.filter(child => child.name === 'entry');
          for (const entry of entries) {
            const key = entry.attributes.key;
            const value = entry.textContent || '';
            if (key) {
              obj[key] = value;
            }
          }
          console.log(`[ResponseParser] Parsed object with ${Object.keys(obj).length} entries`);
          return obj;
        }
  
        // Handle array type: <items><item>...</item></items>
        if (expectedType === 'array') {
          const arr = [];
          // Get the item schema to know what structure to expect
          const itemSchema = paramSchema && paramSchema.items ? paramSchema.items : null;
  
          // Look for <item> elements
          const itemElements = element.children.filter(child => child.name === 'item');
  
          for (const item of itemElements) {
            if (itemSchema && itemSchema.type === 'object') {
              // Parse array item as object with its child elements
              const itemObj = {};
              for (const prop of item.children) {
                // Get expected type for this property
                const propSchema = itemSchema.properties ? itemSchema.properties[prop.name] : null;
                const propType = propSchema ? propSchema.type : 'string';
                itemObj[prop.name] = this.parseParameterValue(prop, propType, propSchema);
              }
              arr.push(itemObj);
            } else {
              // Simple array of primitives
              arr.push(item.textContent || '');
            }
          }
          console.log(`[ResponseParser] Parsed array with ${arr.length} items`);
          return arr;
        }
  
        // Handle primitive types
        const textContent = element.textContent || '';
  
        if (expectedType === 'integer') {
          return parseInt(textContent, 10) || 0;
        }
  
        if (expectedType === 'boolean') {
          return textContent.toLowerCase() === 'true';
        }
  
        // Default: return as string
        return textContent;
      }
  
      /**
       * Parse <message> block to extract text
       * @param {string} xmlText - XML text with <message> tag
       * @returns {ParsedResponse} Parsed response with message
       * @private
       */
      parseMessageBlock(xmlText) {
        // Use XMLParser to parse the XML
        const parsed = this.xmlParser.parse(xmlText);
  
        if (parsed.name !== 'message') {
          console.error('[ResponseParser] Expected <message> root, got:', parsed.name);
          return {
            hasMessage: false,
            message: null,
            hasToolCalls: false,
            toolCalls: []
          };
        }
  
        const messageText = parsed.textContent || '';
  
        console.log('[ResponseParser] Extracted message:', messageText.substring(0, 100));
  
        return {
          hasMessage: messageText.trim().length > 0,
          message: messageText.trim(),
          hasToolCalls: false,
          toolCalls: []
        };
      }
  
      /**
       * Validate a parsed response
       * @param {ParsedResponse} parsed - Parsed response
       * @returns {boolean} True if valid
       */
      validate(parsed) {
        // Must have either a message or tool calls
        if (!parsed.hasMessage && !parsed.hasToolCalls) {
          return false;
        }
  
        // Validate tool calls have required fields
        if (parsed.hasToolCalls) {
          for (const call of parsed.toolCalls) {
            if (!call.name || typeof call.name !== 'string') {
              return false;
            }
            if (!call.parameters || typeof call.parameters !== 'object') {
              return false;
            }
          }
        }
  
        return true;
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ResponseParser = ResponseParser;
  
  })();

  // ============================================================================
  // src/message-formatter.js
  // ============================================================================

  /**
   * message-formatter.js
   *
   * Formats messages for AI API:
   * - Format conversation messages for Claude API
   * - Handle system prompts
   * - Message structure conversion
   * - Role mapping (user/assistant)
   *
   * Based on: src_old/com/codeboss/javalayer/aiprocessor/MessageFormatter.java
   */
  
  (function() {
    'use strict';
  
    const { MessageType } = window.module.ConversationState;
  
    /**
     * MessageFormatter class
     * Formats messages for Claude API format
     */
    class MessageFormatter {
      constructor() {
        // Claude API expects messages in specific format
        this.apiVersion = '2023-06-01';
      }
  
      /**
       * Format conversation history for AI API
       * @param {Array} messages - Conversation messages
       * @param {string} systemPrompt - System prompt
       * @returns {Object} {system, messages}
       */
      formatForAPI(messages, systemPrompt) {
        // TODO: Convert message objects to API format
        // TODO: Group by role (user/assistant)
        // TODO: Handle tool use and tool results
        // TODO: Return {system: systemPrompt, messages: [...]}
        throw new Error('Not implemented: MessageFormatter.formatForAPI()');
      }
  
      /**
       * Format a single message for API
       * @param {Object} message - Message object
       * @returns {Object|null} API message object or null if skip
       * @private
       */
      formatMessage(message) {
        // TODO: Switch on message type
        // TODO: Convert to appropriate API format
        // TODO: user_msg -> {role: 'user', content: ...}
        // TODO: assistant_msg -> {role: 'assistant', content: ...}
        // TODO: tool_use -> tool use content block
        // TODO: tool_result -> tool result content block
        // TODO: Skip internal messages (phase_transition, mental_model_update, etc.)
        throw new Error('Not implemented: MessageFormatter.formatMessage()');
      }
  
      /**
       * Format user message
       * @param {Object} message - User message object
       * @returns {Object} API message
       * @private
       */
      formatUserMessage(message) {
        // TODO: Return {role: 'user', content: message.content}
        throw new Error('Not implemented: MessageFormatter.formatUserMessage()');
      }
  
      /**
       * Format assistant message
       * @param {Object} message - Assistant message object
       * @returns {Object} API message
       * @private
       */
      formatAssistantMessage(message) {
        // TODO: Return {role: 'assistant', content: message.content}
        throw new Error('Not implemented: MessageFormatter.formatAssistantMessage()');
      }
  
      /**
       * Format tool use message
       * @param {Object} message - Tool use message object
       * @returns {Object} Tool use content block
       * @private
       */
      formatToolUse(message) {
        // TODO: Return tool use content block:
        // {
        //   type: 'tool_use',
        //   id: message.id,
        //   name: message.toolName,
        //   input: message.parameters
        // }
        throw new Error('Not implemented: MessageFormatter.formatToolUse()');
      }
  
      /**
       * Format tool result message
       * @param {Object} message - Tool result message object
       * @returns {Object} Tool result content block
       * @private
       */
      formatToolResult(message) {
        // TODO: Return tool result content block:
        // {
        //   type: 'tool_result',
        //   tool_use_id: correspondingToolUseId,
        //   content: JSON.stringify(message.result)
        // }
        throw new Error('Not implemented: MessageFormatter.formatToolResult()');
      }
  
      /**
       * Group messages by conversation turns
       * Claude API requires alternating user/assistant messages
       * @param {Array} messages - Formatted messages
       * @returns {Array} Grouped messages
       * @private
       */
      groupMessagesByTurn(messages) {
        // TODO: Group consecutive messages by same role
        // TODO: Combine tool_use and tool_result into single assistant turn
        // TODO: Ensure alternating user/assistant pattern
        throw new Error('Not implemented: MessageFormatter.groupMessagesByTurn()');
      }
  
      /**
       * Validate message format for API
       * @param {Object} apiMessage - Formatted API message
       * @returns {boolean} True if valid
       */
      validateAPIMessage(apiMessage) {
        // TODO: Check required fields (role, content)
        // TODO: Validate role is 'user' or 'assistant'
        // TODO: Validate content structure
        throw new Error('Not implemented: MessageFormatter.validateAPIMessage()');
      }
  
      /**
       * Format system prompt
       * @param {string} prompt - System prompt text
       * @returns {string} Formatted system prompt
       */
      formatSystemPrompt(prompt) {
        // TODO: Clean up and format system prompt
        // TODO: Ensure proper structure
        // TODO: Return formatted prompt
        throw new Error('Not implemented: MessageFormatter.formatSystemPrompt()');
      }
  
      /**
       * Count tokens in messages (estimate)
       * @param {Array} messages - API messages
       * @param {string} systemPrompt - System prompt
       * @returns {number} Estimated token count
       */
      estimateTokenCount(messages, systemPrompt) {
        // TODO: Estimate tokens for system prompt
        // TODO: Estimate tokens for each message
        // TODO: Use simple heuristic (chars / 4)
        // TODO: Return total estimate
        throw new Error('Not implemented: MessageFormatter.estimateTokenCount()');
      }
  
      /**
       * Truncate message history to fit token limit
       * @param {Array} messages - Messages to truncate
       * @param {number} maxTokens - Maximum tokens
       * @returns {Array} Truncated messages
       */
      truncateMessages(messages, maxTokens) {
        // TODO: Estimate current token count
        // TODO: If over limit, remove oldest messages
        // TODO: Keep at least last few turns
        // TODO: Return truncated messages
        throw new Error('Not implemented: MessageFormatter.truncateMessages()');
      }
  
      /**
       * Check if message should be included in API request
       * @param {Object} message - Message object
       * @returns {boolean} True if should include
       * @private
       */
      shouldIncludeMessage(message) {
        // Skip internal messages
        const skipTypes = [
          MessageType.PHASE_TRANSITION,
          MessageType.MENTAL_MODEL_UPDATE,
          MessageType.CHECKLIST_APPROVED,
          MessageType.LOADING
        ];
        return !skipTypes.includes(message.type);
      }
  
      /**
       * Extract content from message
       * @param {Object} message - Message object
       * @returns {string|Array|Object} Message content
       * @private
       */
      extractContent(message) {
        // TODO: Extract content based on message type
        // TODO: Handle different content structures
        // TODO: Return content
        throw new Error('Not implemented: MessageFormatter.extractContent()');
      }
  
      /**
       * Format error message for API
       * @param {Error} error - Error object
       * @returns {Object} Formatted error message
       */
      formatErrorMessage(error) {
        // TODO: Create user message with error details
        // TODO: Format for display to AI
        // TODO: Return formatted message
        throw new Error('Not implemented: MessageFormatter.formatErrorMessage()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.MessageFormatter = MessageFormatter;
  
  })();

  // ============================================================================
  // src/continuation-handler.js
  // ============================================================================

  /**
   * continuation-handler.js
   *
   * Handles token limit exceeded errors:
   * - Detect continuation needed in AI responses
   * - Automatic continuation requests
   * - Response assembly from multiple chunks
   *
   * Based on: src_old/com/codeboss/javalayer/aiprocessor/ContinuationHandler.java
   */
  
  (function() {
    'use strict';
  
    /**
     * ContinuationHandler class
     * Handles multi-turn responses when AI output is truncated
     */
    class ContinuationHandler {
      constructor(aiAPI) {
        this.aiAPI = aiAPI;
        this.assembledResponse = '';
        this.continuationInProgress = false;
      }
  
      /**
       * Check if response indicates continuation needed
       * @param {string} response - AI response to check
       * @returns {boolean} True if continuation needed
       */
      needsContinuation(response) {
        // TODO: Check for truncation indicators:
        //   - Response ends mid-sentence
        //   - Unclosed XML tags
        //   - API returns stop_reason === 'max_tokens'
        // TODO: Return true if continuation needed
        throw new Error('Not implemented: ContinuationHandler.needsContinuation()');
      }
  
      /**
       * Request continuation from AI
       * @param {Array} conversationHistory - Current conversation history
       * @param {string} partialResponse - Partial response received so far
       * @returns {Promise<string>} Continuation response
       */
      async requestContinuation(conversationHistory, partialResponse) {
        // TODO: Build continuation prompt
        // TODO: Add partial response to history as assistant message
        // TODO: Add continuation request as user message ("Please continue")
        // TODO: Submit to AI API
        // TODO: Return continuation response
        throw new Error('Not implemented: ContinuationHandler.requestContinuation()');
      }
  
      /**
       * Handle a response that may need continuation
       * Automatically requests continuations until response is complete
       * @param {string} initialResponse - Initial AI response
       * @param {Array} conversationHistory - Current conversation history
       * @returns {Promise<string>} Complete assembled response
       */
      async handleResponse(initialResponse, conversationHistory) {
        // TODO: Start with initial response
        // TODO: While needsContinuation:
        //   - Request continuation
        //   - Append to assembled response
        //   - Check if new response needs continuation
        // TODO: Return complete assembled response
        throw new Error('Not implemented: ContinuationHandler.handleResponse()');
      }
  
      /**
       * Assemble response chunks into complete response
       * @param {Array<string>} chunks - Response chunks
       * @returns {string} Assembled response
       * @private
       */
      assembleChunks(chunks) {
        // TODO: Concatenate chunks
        // TODO: Handle overlapping content if any
        // TODO: Clean up any continuation markers
        // TODO: Return assembled response
        throw new Error('Not implemented: ContinuationHandler.assembleChunks()');
      }
  
      /**
       * Detect truncation type
       * @param {string} response - Response to check
       * @returns {string|null} Truncation type or null if not truncated
       * @private
       */
      detectTruncationType(response) {
        // TODO: Check for different truncation types:
        //   - 'max_tokens' - Hit token limit
        //   - 'unclosed_xml' - Unclosed XML tags
        //   - 'mid_sentence' - Ends mid-sentence
        // TODO: Return truncation type or null
        throw new Error('Not implemented: ContinuationHandler.detectTruncationType()');
      }
  
      /**
       * Check for unclosed XML tags
       * @param {string} response - Response to check
       * @returns {boolean} True if has unclosed tags
       * @private
       */
      hasUnclosedXMLTags(response) {
        // TODO: Count opening and closing tags
        // TODO: Check if they match
        // TODO: Return true if unclosed tags exist
        throw new Error('Not implemented: ContinuationHandler.hasUnclosedXMLTags()');
      }
  
      /**
       * Check if response ends mid-sentence
       * @param {string} response - Response to check
       * @returns {boolean} True if ends mid-sentence
       * @private
       */
      endsMidSentence(response) {
        // TODO: Check if last character is not sentence-ending punctuation
        // TODO: Look for incomplete tool use tags
        // TODO: Return true if likely truncated mid-sentence
        throw new Error('Not implemented: ContinuationHandler.endsMidSentence()');
      }
  
      /**
       * Build continuation prompt
       * @param {string} partialResponse - Partial response so far
       * @returns {string} Continuation prompt
       * @private
       */
      buildContinuationPrompt(partialResponse) {
        // TODO: Create prompt asking AI to continue
        // TODO: Include context about what was already received
        // TODO: Ask to continue from where it left off
        throw new Error('Not implemented: ContinuationHandler.buildContinuationPrompt()');
      }
  
      /**
       * Reset handler state
       * @returns {void}
       */
      reset() {
        this.assembledResponse = '';
        this.continuationInProgress = false;
      }
  
      /**
       * Get maximum number of continuation attempts
       * @returns {number} Max continuations
       */
      getMaxContinuations() {
        return 5; // Prevent infinite loops
      }
  
      /**
       * Check if continuation is in progress
       * @returns {boolean} True if in progress
       */
      isContinuationInProgress() {
        return this.continuationInProgress;
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.ContinuationHandler = ContinuationHandler;
  
  })();

  // ============================================================================
  // src/prompt-generator.js
  // ============================================================================

  /**
   * prompt-generator.js
   *
   * FULL VERSION - Phase-aware prompt generation:
   * - System prompt with base instructions
   * - Phase context (planning/execution/review)
   * - Mental models (project + task)
   * - Recent changes (last 10 operations)
   * - Ephemeral content (cleared after each message)
   * - Current checklist with status
   * - Available tools filtered by phase/item type
   */
  
  (function() {
    'use strict';
  
    /**
     * PromptGenerator class (Full version - Phase-aware)
     * Builds messages array with full context for phase system
     */
    class PromptGenerator {
      constructor(modeManager, mentalModelManager, recentChangesTracker, ephemeralContentManager) {
        this.modeManager = modeManager;
        this.mentalModelManager = mentalModelManager;
        this.recentChangesTracker = recentChangesTracker;
        this.ephemeralContentManager = ephemeralContentManager;
        this.baseSystemPrompt = this.generateBaseSystemPrompt();
      }
  
      /**
       * Generate messages array for API
       * System prompt is prepended to first user message
       * @param {Array} conversationHistory - Array of {role, content} messages
       * @param {Object} context - Current context {project, task, checklist, phase, itemIndex}
       * @returns {Array} Messages array for API
       */
      generateMessages(conversationHistory, context = {}) {
        const messages = [];
        let systemPrepended = false;
  
        // Generate full system prompt with context
        const fullSystemPrompt = this.generateFullSystemPrompt(context);
  
        for (const msg of conversationHistory) {
          // Skip greeting and task_complete messages (display-only, not sent to API)
          if (msg.type === 'greeting' || msg.type === 'task_complete') {
            continue;
          }
  
          // Prepend system prompt to first user message
          if (msg.role === 'user' && !systemPrepended) {
            messages.push({
              role: 'user',
              content: fullSystemPrompt + '\n\n' + msg.content
            });
            systemPrepended = true;
          } else if (msg.role === 'user' || msg.role === 'assistant') {
            messages.push({
              role: msg.role,
              content: msg.content
            });
          }
        }
  
        return messages;
      }
  
      /**
       * Generate full system prompt with all context
       * @param {Object} context - Current context
       * @returns {string} Full system prompt
       * @private
       */
      generateFullSystemPrompt(context) {
        let prompt = this.baseSystemPrompt;
  
        // Add current phase context
        prompt += '\n\n' + this.generatePhaseContext(context);
  
        // Add project mental model
        if (this.mentalModelManager) {
          const projectModel = this.mentalModelManager.formatForPrompt('project');
          if (projectModel) {
            prompt += '\n\n' + projectModel;
          }
        }
  
        // Add task mental model
        if (this.mentalModelManager) {
          const taskModel = this.mentalModelManager.formatForPrompt('task');
          if (taskModel) {
            prompt += '\n\n' + taskModel;
          }
        }
  
        // Add recent changes
        if (this.recentChangesTracker) {
          const recentChanges = this.recentChangesTracker.formatForPrompt();
          if (recentChanges) {
            prompt += '\n\n' + recentChanges;
          }
        }
  
        // Add ephemeral content
        if (this.ephemeralContentManager) {
          const ephemeralContent = this.ephemeralContentManager.formatForPrompt();
          if (ephemeralContent) {
            prompt += '\n\n' + ephemeralContent;
          }
        }
  
        // Add current checklist
        if (context.checklist && context.checklist.length > 0) {
          prompt += '\n\n' + this.generateChecklistSection(context.checklist, context.itemIndex);
        }
  
        // Add available tools for current phase/item type
        prompt += '\n\n' + this.generateAvailableToolsSection();
  
        return prompt;
      }
  
      /**
       * Generate phase context section
       * @param {Object} context - Current context
       * @returns {string} Phase context
       * @private
       */
      generatePhaseContext(context) {
        const { Phase } = window.module.ConversationState;
        const phase = context.phase || Phase.PLANNING;
        const project = context.project || 'No project selected';
        const task = context.task || 'No task';
  
        let content = `## Current Context\n\n`;
        content += `**Project:** ${project}\n`;
        content += `**Task:** ${task}\n`;
        content += `**Phase:** ${phase}\n\n`;
  
        // Add phase-specific instructions
        if (this.modeManager) {
          const phaseDesc = this.modeManager.getPhaseDescription(phase);
          content += phaseDesc + '\n';
        }
  
        // Add item type context if in execution
        if (phase === Phase.EXECUTION && context.itemIndex >= 0) {
          const currentItem = context.checklist[context.itemIndex];
          if (currentItem && this.modeManager) {
            const itemTypeDesc = this.modeManager.getItemTypeDescription(currentItem.item_type);
            content += '\n' + itemTypeDesc + '\n';
          }
        }
  
        return content;
      }
  
      /**
       * Generate checklist section
       * @param {Array} checklist - Checklist items
       * @param {number} itemIndex - Current item index
       * @returns {string} Checklist section
       * @private
       */
      generateChecklistSection(checklist, itemIndex) {
        let content = '## Current Checklist\n\n';
  
        for (let i = 0; i < checklist.length; i++) {
          const item = checklist[i];
          const isCurrent = i === itemIndex;
          const status = item.status === 'complete' ? '' :
                        item.status === 'failed' ? '' :
                        item.status === 'in_progress' ? '' : '';
  
          content += `${status} ${item.short_desc || item.content}`;
          if (isCurrent) {
            content += ` ** CURRENT**`;
          }
          content += '\n';
        }
  
        return content;
      }
  
      /**
       * Generate available tools section
       * @returns {string} Available tools section
       * @private
       */
      generateAvailableToolsSection() {
        if (!this.modeManager) {
          return this.generateAllToolsSection();
        }
  
        const availableTools = this.modeManager.getAvailableTools();
        const toolsByCategory = this.modeManager.getToolsByCategory();
  
        let content = '## Available Tools\n\n';
        content += 'Tools you can use in current phase/item type:\n\n';
  
        // Read tools
        if (toolsByCategory.read_tools.length > 0) {
          content += '**Read Tools:**\n';
          for (const tool of toolsByCategory.read_tools) {
            content += `- ${tool}\n`;
          }
          content += '\n';
        }
  
        // Write tools
        if (toolsByCategory.write_tools.length > 0) {
          content += '**Write Tools:**\n';
          for (const tool of toolsByCategory.write_tools) {
            content += `- ${tool}\n`;
          }
          content += '\n';
        }
  
        // Git tools
        if (toolsByCategory.git_tools.length > 0) {
          content += '**Git Tools:**\n';
          for (const tool of toolsByCategory.git_tools) {
            content += `- ${tool}\n`;
          }
          content += '\n';
        }
  
        // Command tools
        if (toolsByCategory.command_tools.length > 0) {
          content += '**Command Tools:**\n';
          for (const tool of toolsByCategory.command_tools) {
            content += `- ${tool}\n`;
          }
          content += '\n';
        }
  
        // Mental model tools
        if (toolsByCategory.mental_model_tools.length > 0) {
          content += '**Mental Model Tools:**\n';
          for (const tool of toolsByCategory.mental_model_tools) {
            content += `- ${tool}\n`;
          }
          content += '\n';
        }
  
        // Control tools
        if (toolsByCategory.control_tools.length > 0) {
          content += '**Control Tools:**\n';
          for (const tool of toolsByCategory.control_tools) {
            content += `- ${tool}\n`;
          }
          content += '\n';
        }
  
        return content;
      }
  
      /**
       * Generate all tools section (fallback when no ModeManager)
       * @returns {string} All tools section
       * @private
       */
      generateAllToolsSection() {
        return `## Available Tools
  
  All tools are available (no phase restrictions):
  - read_file, list_files, search_files_by_name, search_files_by_content
  - create_file, update_file, delete_file, move_file
  - create_directory, delete_directory_recursive
  - run_command, git_read, git_write
  - update_mental_model, begin_execution, mark_complete, mark_failed
  `;
      }
  
      /**
       * Generate base system prompt with XML tool examples
       * @returns {string} Base system prompt
       * @private
       */
      generateBaseSystemPrompt() {
        return `You are Code Boss, an AI coding assistant with access to the user's file system.
  
  CRITICAL RESPONSE FORMAT RULES:
  1. To use tools: Return ONLY <execute>...</execute> with <tool> tags inside
  2. To send a message: Return ONLY <message>...</message> with your message inside
  3. NEVER return both <execute> AND <message> in the same response
  4. NEVER explain what tools you're about to use - just use them
  5. Use tools silently, then send a final message with results
  6. Always use <tool> tags, NEVER use <invoke> or other tag names
  
  WORKFLOW:
  - If you need information: Return <execute> with <tool> tags (no explanation text)
  - If you're done: Return <message> with your final response
  - The user will NOT see your tool calls, only your final message
  
  PHASE SYSTEM - CRITICAL:
  You operate in three phases: PLANNING, EXECUTION, and REVIEW.
  
  **PLANNING PHASE (current default):**
  - You CAN: read files, list files, search, update mental model
  - You CANNOT: create/edit/delete files, run commands, git operations
  - If user asks to create/modify files: Use begin_execution to create a plan first
  
  **EXECUTION PHASE (after begin_execution approved):**
  - You CAN: create/edit/delete files, run commands, all read operations
  - Work through checklist items one at a time
  - Call mark_complete when item is done, mark_failed if blocked
  
  **REVIEW PHASE:**
  - Review completed work
  - Update project mental model with learnings
  
  **To start making changes:**
  1. User asks to create/modify files
  2. Call begin_execution with task_description and items array
  3. System transitions to EXECUTION phase
  4. Now you can use write tools (create_file, update_file, etc.)
  
  **Example workflow:**
  User: "Create a test file"
  You: <execute><tool name="begin_execution">
    <task_description>Create test file</task_description>
    <items>
      <item>
        <short_desc>Create test.js</short_desc>
        <detailed_desc>Create test.js with sample code</detailed_desc>
        <item_type>coding</item_type>
      </item>
    </items>
  </tool></execute>
  [System transitions to EXECUTION phase]
  You: <execute><tool name="create_file">...</tool></execute>
  
  AVAILABLE TOOLS (you MUST use these EXACT tool names - they are CASE-SENSITIVE):
  
  IMPORTANT: Tool names are all lowercase with underscores. DO NOT use tools from other systems like:
  - "Read" - WRONG! Use "read_file" instead
  - "Glob" - WRONG! Use "list_files" instead
  - "Write" - WRONG! Use "create_file" or "update_file" instead
  - "Edit" - WRONG! Use "update_file" instead
  - "Bash" - WRONG! Use "run_command" instead
  
  CORRECT TOOL NAMES:
  - list_files: List files in a directory
  - read_file: Read a file's contents
  - create_file: Create a new file
  - update_file: Update an existing file
  - delete_file: Delete a file
  - move_file: Move/rename a file
  - create_directory: Create a directory
  - delete_directory_recursive: Delete a directory recursively
  - run_command: Run a shell command
  - git_read: Run a read-only git command
  - git_write: Run a git command that modifies the repository
  
  TOOL USAGE EXAMPLES (using proper XML - parameter names as tags):
  
  READ FILE (simple parameters):
    <execute>
      <tool name="read_file">
        <file_path>path/to/file.js</file_path>
        <looking_for>function definitions</looking_for>
        <why>need to understand the API</why>
      </tool>
    </execute>
  
  CREATE FILE:
    <execute>
      <tool name="create_file">
        <file_path>path/to/newfile.js</file_path>
        <content>file content here</content>
      </tool>
    </execute>
  
  UPDATE FILE:
    <execute>
      <tool name="update_file">
        <file_path>path/to/file.js</file_path>
        <old_content>exact text to replace</old_content>
        <new_content>new text</new_content>
      </tool>
    </execute>
  
  LIST FILES:
    <execute>
      <tool name="list_files">
        <directory_path">.</directory_path>
        <looking_for>JavaScript files</looking_for>
        <why>need to see project structure</why>
      </tool>
    </execute>
  
  UPDATE MENTAL MODEL (object parameter with entries):
    <execute>
      <tool name="update_mental_model">
        <updates>
          <entry key="src/app.js">main entry point handles initialization</entry>
          <entry key="src/tool-executor.js">executes tools from AI responses</entry>
          <entry key="test/sample.txt">contains test data for validation</entry>
        </updates>
      </tool>
    </execute>
  
  BEGIN EXECUTION (array parameter with items):
    <execute>
      <tool name="begin_execution">
        <task_description">Test file operations</task_description>
        <items>
          <item>
            <short_desc>Create test file</short_desc>
            <detailed_desc>Create a new JavaScript test file in test directory</detailed_desc>
            <item_type>coding</item_type>
          </item>
          <item>
            <short_desc>Read file</short_desc>
            <detailed_desc>Read created file to verify content</detailed_desc>
            <item_type>coding</item_type>
          </item>
        </items>
      </tool>
    </execute>
  
  MULTIPLE TOOLS (execute in sequence):
    <execute>
      <tool name="read_file">
        <file_path>package.json</file_path>
        <looking_for>dependencies</looking_for>
        <why>check required packages</why>
      </tool>
      <tool name="update_mental_model">
        <updates>
          <entry key="package.json">contains project dependencies and scripts</entry>
        </updates>
      </tool>
    </execute>
  
  SEND MESSAGE (when done with task):
    <message>I've completed the task. Here's what I found...</message>
  
  IMPORTANT XML FORMAT RULES:
  1. Parameters are XML elements (not <parameter name="...">)
  2. Simple values: <param_name>value</param_name>
  3. Objects: <param_name><entry key="...">value</entry></param_name>
  4. Arrays: <param_name><item><field>value</field></item></param_name>
  5. NO JSON inside XML - use proper XML nesting
  6. Parameter names use underscores (file_path not filePath)
  
  CORRECT EXAMPLE:
  User: "List files and read app.js"
  WRONG Response (mixing execute and message):
    <message>I'll list files first...</message>
    <execute><tool name="list_files">...</tool></execute>
  
  CORRECT Response (only execute):
    <execute>
      <tool name="list_files">
        <directory_path">.</directory_path>
        <looking_for>all files in root</looking_for>
        <why>understand project structure</why>
      </tool>
      <tool name="read_file">
        <file_path>app.js</file_path>
        <looking_for">main logic</looking_for>
        <why>understand application entry point</why>
      </tool>
      <tool name="update_mental_model">
        <updates>
          <entry key="app.js">application entry point</entry>
        </updates>
      </tool>
    </execute>
  (After tools execute, then send <message> with findings)`;
      }
  
      /**
       * Get the base system prompt
       * @returns {string} Base system prompt
       */
      getBaseSystemPrompt() {
        return this.baseSystemPrompt;
      }
  
      /**
       * Get the system prompt (deprecated - use generateFullSystemPrompt with context)
       * @returns {string} Base system prompt
       */
      getSystemPrompt() {
        return this.baseSystemPrompt;
      }
  
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.PromptGenerator = PromptGenerator;
  
  })();

  // ============================================================================
  // src/ai-processor.js
  // ============================================================================

  /**
   * ai-processor.js
   *
   * INTEGRATED VERSION - Full phase-aware agentic loop:
   * - Generates prompts with context (project/task/phase)
   * - Submits to AI API
   * - Parses responses
   * - Validates tool calls against phase system
   * - Executes tools with tracking (ephemeral content, recent changes, mental models)
   * - Handles control tools (begin_execution, mark_complete, mark_failed, update_mental_model)
   * - Loops until AI returns only text (no tools)
   *
   * Integrated with:
   * - ModeManager (phase/tool validation)
   * - ProjectManager (project metadata)
   * - TaskManager (task persistence)
   * - ChecklistManager (checklist tracking)
   * - EphemeralContentManager (ephemeral content tracking)
   * - MentalModelManager (mental model updates)
   * - RecentChangesTracker (change tracking)
   */
  
  (function() {
    'use strict';
  
    const { createPhaseTransitionMessage, createMentalModelUpdateMessage, createTaskCompleteMessage } = window.module.ConversationState;
  
    /**
     * AIProcessor class (Integrated version)
     * Handles the main agentic loop with full phase system integration
     */
    class AIProcessor {
      constructor(
        conversationManager,
        promptGenerator,
        responseParser,
        toolExecutor,
        toolDefinitions,
        aiApi,
        // New phase system managers
        modeManager,
        projectManager,
        taskManager,
        checklistManager,
        ephemeralContentManager,
        mentalModelManager,
        recentChangesTracker
      ) {
        // Existing components
        this.conversationManager = conversationManager;
        this.promptGenerator = promptGenerator;
        this.responseParser = responseParser;
        this.toolExecutor = toolExecutor;
        this.toolDefinitions = toolDefinitions;
        this.aiApi = aiApi;
        this.processing = false;
        this.onUpdate = null; // Callback for UI updates
  
        // Phase system managers
        this.modeManager = modeManager;
        this.projectManager = projectManager;
        this.taskManager = taskManager;
        this.checklistManager = checklistManager;
        this.ephemeralContentManager = ephemeralContentManager;
        this.mentalModelManager = mentalModelManager;
        this.recentChangesTracker = recentChangesTracker;
  
        // Current project/task state
        this.currentProject = null;  // Current project directory
        this.currentTask = null;     // Current task name
        this.taskJustCompleted = false; // Flag to indicate task completion pending
      }
  
      /**
       * Process a user message through the agentic loop
       * @param {string} userMessage - User's message
       * @returns {Promise<void>}
       */
      async processUserMessage(userMessage) {
        if (this.processing) {
          throw new Error('Already processing a message');
        }
  
        try {
          this.processing = true;
          this.conversationManager.setStatus('processing');
  
          // Add user message to conversation
          this.conversationManager.addUserMessage(userMessage);
          this.notifyUpdate();
  
          // Run agentic loop
          await this.agenticLoop();
  
          this.conversationManager.setStatus('idle');
          this.processing = false;
          this.notifyUpdate();
  
        } catch (error) {
          console.error('[AIProcessor] Error processing message:', error);
          this.conversationManager.setStatus('idle');
          this.processing = false;
          this.notifyUpdate();
          throw error;
        }
      }
  
      /**
       * Main agentic loop
       * Continues until AI responds with only a message (no tools)
       * @returns {Promise<void>}
       * @private
       */
      async agenticLoop() {
        let continueLoop = true;
        let iterations = 0;
        const maxIterations = 20; // Prevent infinite loops
  
        while (continueLoop && iterations < maxIterations) {
          iterations++;
  
          // 1. Generate messages and call AI
          const apiResponse = await this.callAI();
  
          // 2. Parse response
          const parsed = this.responseParser.parse(apiResponse);
  
          // 3. Handle assistant response
          if (parsed.hasMessage) {
            // AI sent a message - add it to conversation and display
            this.conversationManager.addAssistantMessage(parsed.message);
            this.notifyUpdate();
  
            // Clear ephemeral content after AI message (as per spec)
            if (this.ephemeralContentManager) {
              this.ephemeralContentManager.clearAll();
            }
  
            // Handle task completion if flagged
            if (this.taskJustCompleted) {
              // Add task completion message with continuation prompt
              const taskName = this.currentTask;
              const completionMsg = createTaskCompleteMessage(
                parsed.message, // The AI's final summary becomes the completion message
                `${taskName} is complete! Would you like to make any improvements or start something else?`
              );
              this.conversationManager.addMessage(completionMsg);
  
              // Return to planning mode
              this.modeManager.setPhase('planning');
              this.currentTask = null;
              this.checklistManager.clear();
              this.taskJustCompleted = false;
  
              this.notifyUpdate();
            }
  
            continueLoop = false; // Done - AI sent final message
          } else if (parsed.hasToolCalls) {
            // AI called tools - add CLEANED XML to conversation for API
            const cleanedXML = this.reconstructToolXML(parsed.toolCalls);
  
            this.conversationManager.addMessage({
              role: 'assistant',
              content: cleanedXML,
              display: false  // Don't display this in the UI
            });
  
            // Execute tools
            await this.executeToolCalls(parsed.toolCalls);
            // Continue loop to let AI see tool results
            continueLoop = true;
          } else {
            // No message and no tools - shouldn't happen but handle it
            continueLoop = false;
          }
        }
  
        if (iterations >= maxIterations) {
          console.warn('[AIProcessor] Max iterations reached');
        }
      }
  
      /**
       * Call AI API with current conversation
       * Passes context object to PromptGenerator
       * @returns {Promise<Object>} API response {content: string (XML text)}
       * @private
       */
      async callAI() {
        // Get conversation history
        const conversationHistory = this.conversationManager.getMessages();
  
        // Build context object for prompt generator
        const context = {
          project: this.currentProject,
          task: this.currentTask,
          phase: this.modeManager.getPhase(),
          itemIndex: this.checklistManager.getCurrentItemIndex(),
          checklist: this.checklistManager.getChecklist()
        };
  
        // Generate messages array for API (with context)
        const messages = this.promptGenerator.generateMessages(conversationHistory, context);
  
        // Call AI API
        const response = await this.aiApi.sendMessage(messages);
  
        return response;
      }
  
      /**
       * Execute tool calls with phase system integration
       * @param {Array} toolCalls - Array of tool calls {name, parameters}
       * @returns {Promise<void>}
       * @private
       */
      async executeToolCalls(toolCalls) {
        // Check if there was a format violation warning from the parser
        const violationWarning = this.responseParser.violationWarning;
  
        for (const toolCall of toolCalls) {
          let toolUseMsg;
          let toolUseDisplayed = false; // Declare at top of loop scope
          try {
            // PHASE VALIDATION: Check if tool is allowed in current phase/item type
            const validation = this.modeManager.validateToolCall(toolCall.name);
            if (!validation.valid) {
              const error = new Error(validation.error);
              error.recoverable = true; // Mark as recoverable so UI can hide it
              throw error;
            }
  
            // Add tool use indicator for display (skip control tools - they're internal)
            const isControlTool = ['begin_execution', 'mark_complete', 'mark_failed', 'update_mental_model'].includes(toolCall.name);
            if (!isControlTool) {
              toolUseMsg = this.conversationManager.addToolUse(toolCall.name, toolCall.parameters);
              toolUseDisplayed = true;
              this.notifyUpdate();
            }
  
            // Execute the tool
            const result = await this.toolExecutor.execute(toolCall.name, toolCall.parameters);
  
            // EPHEMERAL TRACKING: Track ephemeral content
            if (this.ephemeralContentManager.isEphemeralTool(toolCall.name)) {
              this.ephemeralContentManager.trackToolExecution(toolCall.name, toolCall.parameters, result);
            }
  
            // CHANGE TRACKING: Record changes for write operations
            if (this.modeManager.isWriteOperation(toolCall.name)) {
              this.recordChange(toolCall.name, toolCall.parameters, result);
            }
  
            // CONTROL TOOLS: Handle special control tools
            await this.handleControlTool(toolCall.name, toolCall.parameters, result);
  
            // Add tool result for display (skip control tools)
            if (!isControlTool) {
              this.conversationManager.addToolResult(toolCall.name, result, toolUseMsg.id);
              this.notifyUpdate();
            }
  
            // Add tool result to conversation as user message (plain text for AI)
            let toolResultText = `Tool result for ${toolCall.name}: ${JSON.stringify(result, null, 2)}`;
  
            // Add violation warning to first tool result if present
            if (violationWarning && toolCall === toolCalls[0]) {
              toolResultText = violationWarning + '\n\n' + toolResultText;
              // Clear the warning so it's only sent once
              this.responseParser.violationWarning = null;
            }
  
            this.conversationManager.addMessage({
              role: 'user',
              content: toolResultText,
              display: false  // Don't display - this is for AI to read
            });
  
          } catch (error) {
            console.error(`[AIProcessor] Tool execution error (${toolCall.name}):`, error);
  
            // Handle recoverable errors - hide the tool_use message we just added
            if (error.recoverable && toolUseDisplayed && toolUseMsg) {
              // Remove the tool_use message from conversation display
              const messages = this.conversationManager.getMessages();
              const msgIndex = messages.findIndex(m => m.id === toolUseMsg.id);
              if (msgIndex !== -1) {
                messages.splice(msgIndex, 1);
              }
            }
  
            // Add error result for display (skip control tools and recoverable errors)
            const errorResult = {
              error: error.message || 'Tool execution failed',
              recoverable: error.recoverable || false
            };
            const isControlToolError = ['begin_execution', 'mark_complete', 'mark_failed', 'update_mental_model'].includes(toolCall.name);
            const shouldDisplay = !isControlToolError && !error.recoverable;
  
            if (shouldDisplay) {
              this.conversationManager.addToolResult(toolCall.name, errorResult, toolUseMsg ? toolUseMsg.id : null);
              this.notifyUpdate();
            } else if (error.recoverable) {
              // Just update UI to reflect the removed tool_use
              this.notifyUpdate();
            }
  
            // Add error as tool result for AI
            let errorText = `Tool result for ${toolCall.name} (ERROR): ${error.message || 'Tool execution failed'}`;
  
            // Add violation warning to first error if present
            if (violationWarning && toolCall === toolCalls[0]) {
              errorText = violationWarning + '\n\n' + errorText;
              // Clear the warning so it's only sent once
              this.responseParser.violationWarning = null;
            }
  
            this.conversationManager.addMessage({
              role: 'user',
              content: errorText,
              display: false  // Don't display - this is for AI to read
            });
          }
        }
  
        // MENTAL MODEL VALIDATION: Check if mental model update is required
        const hasReads = toolCalls.some(tc => this.ephemeralContentManager.isEphemeralTool(tc.name));
        const hasUpdate = toolCalls.some(tc => tc.name === 'update_mental_model');
  
        if (hasReads && !hasUpdate) {
          // Add error about missing mental model update
          const errorMsg = this.mentalModelManager.generateMissingUpdateError();
          this.conversationManager.addMessage({
            role: 'user',
            content: errorMsg,
            display: false
          });
        }
      }
  
      /**
       * Record change for recent changes tracker
       * @param {string} toolName - Tool name
       * @param {Object} parameters - Tool parameters
       * @param {*} result - Tool result
       * @returns {void}
       * @private
       */
      recordChange(toolName, parameters, result) {
        if (toolName === 'create_file') {
          this.recentChangesTracker.recordCreate(parameters.path, parameters.content);
        }
        else if (toolName === 'update_file') {
          // Need old content - for MVP, record with empty old content
          // In full implementation, we'd read the file first
          this.recentChangesTracker.recordUpdate(parameters.path, '', parameters.new_content);
        }
        else if (toolName === 'delete_file') {
          this.recentChangesTracker.recordDelete(parameters.path);
        }
        else if (toolName === 'move_file') {
          this.recentChangesTracker.recordMove(parameters.source_path, parameters.dest_path);
        }
        else if (toolName === 'git_write' && result.success) {
          // Extract commit message from git args
          const isCommit = parameters.command && parameters.command.includes('commit');
          if (isCommit) {
            this.recentChangesTracker.recordGitCommit('Git commit', []);
          }
        }
      }
  
      /**
       * Handle control tools (begin_execution, mark_complete, mark_failed, update_mental_model)
       * @param {string} toolName - Tool name
       * @param {Object} parameters - Tool parameters
       * @param {*} result - Tool result
       * @returns {Promise<void>}
       * @private
       */
      async handleControlTool(toolName, parameters, result) {
        // Handle begin_execution
        if (toolName === 'begin_execution') {
          console.log('[AIProcessor] begin_execution called with parameters:', JSON.stringify(parameters, null, 2));
  
          const { task_description, items } = parameters;
          console.log('[AIProcessor] task_description:', task_description);
          console.log('[AIProcessor] items type:', typeof items, 'isArray:', Array.isArray(items));
          console.log('[AIProcessor] items:', JSON.stringify(items, null, 2));
  
          // Check if checklist contains any coding items
          const hasCodingItems = items.some(item => item.item_type === 'coding');
  
          // If there are coding items, automatically add a review step at the end
          let finalItems = [...items];
          if (hasCodingItems) {
            finalItems.push({
              short_desc: 'Review changes',
              detailed_desc: 'Review all code changes, ensure quality, and verify tests pass',
              item_type: 'testing'
            });
          }
  
          // Create checklist
          const checklist = this.checklistManager.createChecklist(finalItems);
  
          // Show to user for approval
          // TODO: Add approval UI in future
          const approved = true; // For now, auto-approve
  
          if (approved) {
            // Create task (with review item if coding was involved)
            await this.taskManager.createTask(this.currentProject, task_description, finalItems);
            this.currentTask = task_description;
  
            // Set checklist
            this.checklistManager.setChecklist(checklist);
  
            // Transition to execution
            this.modeManager.setPhase('execution');
  
            // Set item type for first item
            const firstItem = this.checklistManager.getCurrentItem();
            if (firstItem) {
              this.modeManager.setItemType(firstItem.item_type);
            }
  
            // Add phase transition message
            const msg = createPhaseTransitionMessage('planning', 'execution', 'checklist_approved');
            await this.taskManager.appendMessage(this.currentProject, this.currentTask, msg);
  
            // Notify UI to reload sidebar (show new task)
            this.notifyUpdate();
          }
        }
  
        // Handle mark_complete
        else if (toolName === 'mark_complete') {
          const hasMore = this.checklistManager.markCurrentComplete();
  
          // Save checklist after EVERY mark_complete (including the last one)
          const updatedChecklist = this.checklistManager.getChecklist();
          await this.projectManager.updateTaskChecklist(this.currentProject, this.currentTask, updatedChecklist);
  
          // Notify UI to update checklist display
          this.notifyUpdate();
  
          if (hasMore) {
            // More items - set item type for next item
            const nextItem = this.checklistManager.getCurrentItem();
            if (nextItem) {
              this.modeManager.setItemType(nextItem.item_type);
            }
          } else {
            // All complete - set flag to handle after AI's final message
            this.taskJustCompleted = true;
            // Don't transition yet - let AI send final summary message first
          }
        }
  
        // Handle mark_failed
        else if (toolName === 'mark_failed') {
          const { reason } = parameters;
          this.checklistManager.markCurrentFailed(reason);
  
          // Return to planning
          this.modeManager.setPhase('planning');
  
          const msg = createPhaseTransitionMessage('execution', 'planning', 'item_failed');
          await this.taskManager.appendMessage(this.currentProject, this.currentTask, msg);
        }
  
        // Handle update_mental_model
        else if (toolName === 'update_mental_model') {
          console.log('[AIProcessor] update_mental_model called with parameters:', JSON.stringify(parameters, null, 2));
  
          const { updates } = parameters;
          console.log('[AIProcessor] Extracted updates:', typeof updates, updates);
  
          // Validate
          const validation = this.mentalModelManager.validateUpdate(updates);
          if (!validation.valid) {
            console.error('[AIProcessor] Mental model validation failed:', validation.error);
            throw new Error(validation.error);
          }
  
          // Update task mental model
          this.mentalModelManager.updateTaskMentalModel(updates);
  
          // Add mental model update message ONLY if we have an active task
          if (this.currentTask) {
            const msg = createMentalModelUpdateMessage(updates);
            await this.taskManager.appendMessage(this.currentProject, this.currentTask, msg);
          } else {
            console.log('[AIProcessor] Mental model updated (no active task, not persisted to task log)');
          }
        }
      }
  
      /**
       * Set current project
       * @param {string} projectDir - Project directory name
       * @returns {Promise<void>}
       */
      async setProject(projectDir) {
        this.currentProject = projectDir;
  
        // Load project mental model
        const project = await this.projectManager.getProject(projectDir);
        this.mentalModelManager.setProjectMentalModel(project.projectMentalModel || {});
  
        // Set phase to planning
        this.modeManager.setPhase('planning');
        this.currentTask = null;
      }
  
      /**
       * Complete current task
       * @param {string} summary - Task completion summary
       * @returns {Promise<void>}
       */
      async completeTask(summary) {
        if (!this.currentTask) {
          throw new Error('No task to complete');
        }
  
        // Stage 2: Promote mental model to project level
        // TODO: In full implementation, call AI to review and promote
        // For now, just copy all task notes to project
        const taskModel = this.mentalModelManager.getTaskMentalModel();
        this.mentalModelManager.promoteToProjectMentalModel(taskModel);
  
        // Update project metadata with new mental model
        const projectModel = this.mentalModelManager.getProjectMentalModel();
        await this.projectManager.updateProjectMentalModel(this.currentProject, projectModel, true);
  
        // Complete task
        await this.taskManager.completeTask(this.currentProject, this.currentTask, summary);
  
        // Clear task mental model
        this.mentalModelManager.clearTaskMentalModel();
  
        // Return to planning
        this.modeManager.setPhase('planning');
        this.currentTask = null;
        this.checklistManager.clear();
      }
  
      /**
       * Reconstruct clean XML from parsed tool calls using NEW format
       * This removes any text the AI added outside <execute> tags
       * Uses proper XML structure (parameters as elements, not <parameter name="...">)
       * @param {Array} toolCalls - Array of parsed tool calls
       * @returns {string} Clean XML string
       * @private
       */
      reconstructToolXML(toolCalls) {
        let xml = '<execute>\n';
        for (const tool of toolCalls) {
          xml += `  <tool name="${tool.name}">\n`;
          for (const [paramName, paramValue] of Object.entries(tool.parameters)) {
            // Use NEW format: parameter names as direct child elements
            xml += `    <${paramName}>${this.escapeXML(paramValue)}</${paramName}>\n`;
          }
          xml += '  </tool>\n';
        }
        xml += '</execute>';
        return xml;
      }
  
      /**
       * Escape XML special characters
       * @param {*} value - Value to escape
       * @returns {string} Escaped string
       * @private
       */
      escapeXML(value) {
        if (typeof value === 'object') {
          return JSON.stringify(value); // Fallback for complex objects
        }
        const str = String(value);
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&apos;');
      }
  
      /**
       * Notify UI of updates
       * @private
       */
      notifyUpdate() {
        if (this.onUpdate) {
          this.onUpdate();
        }
      }
  
      /**
       * Set update callback for UI
       * @param {Function} callback - Callback function
       */
      setUpdateCallback(callback) {
        this.onUpdate = callback;
      }
  
      /**
       * Check if AI is currently processing
       * @returns {boolean} True if processing
       */
      isProcessing() {
        return this.processing;
      }
  
      /**
       * Get current project
       * @returns {string|null} Current project directory or null
       */
      getCurrentProject() {
        return this.currentProject;
      }
  
      /**
       * Get current task
       * @returns {string|null} Current task name or null
       */
      getCurrentTask() {
        return this.currentTask;
      }
  
      /**
       * Get current phase
       * @returns {string} Current phase
       */
      getCurrentPhase() {
        return this.modeManager.getPhase();
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.AIProcessor = AIProcessor;
  
  })();

  // ============================================================================
  // src/search-engine.js
  // ============================================================================

  /**
   * File search engine
   * Search files by name patterns and content
   */
  
  (function() {
    'use strict';
  
    const { FSManager } = window.module;
    const { Logger } = window.module;
    const logger = window.module.createLogger('SearchEngine');
  
    /**
     * Search result object
     */
    class SearchResult {
      constructor(filePath, matches = []) {
        this.filePath = filePath;
        this.matches = matches; // Array of {line, lineNumber, context}
      }
    }
  
    /**
     * Search engine
     */
    class SearchEngine {
      constructor(fsManager) {
        this.fsManager = fsManager;
      }
  
      /**
       * Search files by name pattern
       * @param {string} pattern - Glob pattern (e.g., "*.js", "**\/test*.java")
       * @param {string} directory - Directory to search (default: root)
       * @returns {Promise<Array<string>>} Array of matching file paths
       */
      async searchByName(pattern, directory = '.') {
        throw new Error('Not implemented: searchByName()');
  
        // TODO: Implementation
        // 1. Convert glob pattern to regex
        // 2. List all files recursively from directory
        // 3. Filter by pattern match
        // 4. Return array of matching file paths
        // 5. Limit results to 1000 files (configurable)
  
        // Pattern examples:
        // - "*.js"  /^.*\.js$/
        // - "test-*.java"  /^test-.*\.java$/
        // - "**\/foo.txt"  /^.*\/foo\.txt$/
      }
  
      /**
       * Search files by content
       * @param {string} searchTerm - Text to search for (supports regex)
       * @param {Object} options - Search options
       * @param {string} [options.directory] - Directory to search
       * @param {string} [options.filePattern] - File pattern filter (glob)
       * @param {boolean} [options.caseSensitive] - Case sensitive search
       * @param {boolean} [options.regex] - Treat searchTerm as regex
       * @param {number} [options.contextLines] - Lines of context around match
       * @returns {Promise<Array<SearchResult>>} Array of search results
       */
      async searchByContent(searchTerm, options = {}) {
        throw new Error('Not implemented: searchByContent()');
  
        // TODO: Implementation
        // 1. List all files (optionally filtered by filePattern)
        // 2. For each file:
        //    a. Read file content
        //    b. Search for searchTerm (as string or regex)
        //    c. Extract matching lines with context
        //    d. Create SearchResult object
        // 3. Return array of SearchResult objects
        // 4. Limit to 500 results (configurable)
        // 5. Skip binary files (check for null bytes)
        // 6. Skip large files >10MB (configurable)
  
        // Options:
        const {
          directory = '.',
          filePattern = null,
          caseSensitive = false,
          regex = false,
          contextLines = 2
        } = options;
      }
  
      /**
       * Get context lines around match
       * @param {Array<string>} lines - All file lines
       * @param {number} matchIndex - Index of matching line
       * @param {number} contextLines - Number of context lines before/after
       * @returns {Object} Context object {before, match, after}
       */
      getContext(lines, matchIndex, contextLines) {
        throw new Error('Not implemented: getContext()');
  
        // TODO: Implementation
        // 1. Extract contextLines before match
        // 2. Extract matching line
        // 3. Extract contextLines after match
        // 4. Return object: {before: [], match: '', after: []}
      }
  
      /**
       * Convert glob pattern to regex
       * @param {string} pattern - Glob pattern
       * @returns {RegExp} Regular expression
       */
      globToRegex(pattern) {
        throw new Error('Not implemented: globToRegex()');
  
        // TODO: Implementation
        // Conversions:
        // - *  [^/]*
        // - **  .*
        // - ?  .
        // - .  \.
        // - Escape other special regex chars
      }
  
      /**
       * Check if file is binary
       * @param {string} content - File content
       * @returns {boolean} True if binary
       */
      isBinary(content) {
        throw new Error('Not implemented: isBinary()');
  
        // TODO: Implementation
        // 1. Check first 8000 bytes for null bytes
        // 2. If found, likely binary
        // 3. Return boolean
      }
  
      /**
       * Search with ranking (relevance scoring)
       * @param {string} searchTerm - Search term
       * @param {Object} options - Search options
       * @returns {Promise<Array<SearchResult>>} Ranked results
       */
      async searchRanked(searchTerm, options = {}) {
        throw new Error('Not implemented: searchRanked()');
  
        // TODO: Implementation
        // 1. Perform searchByContent()
        // 2. Rank results by:
        //    - Number of matches
        //    - Match position (earlier is better)
        //    - File name match (boost if filename contains term)
        //    - File recency (optional)
        // 3. Sort by score (descending)
        // 4. Return sorted results
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.SearchEngine = SearchEngine;
    window.module.SearchResult = SearchResult;
  
  })();

  // ============================================================================
  // src/command-manager.js
  // ============================================================================

  /**
   * command-manager.js
   *
   * Manages command queue for executing shell commands via Node.js daemon:
   * - Writes commands to .agent/command-queue.json
   * - Polls for results in .agent/command-results/{id}.json
   * - Handles timeouts and errors
   * - Supports git and test commands
   *
   * Based on: COMMAND_EXECUTION_OPTIONS.md, GIT_COMMAND_QUEUE_DESIGN.md
   */
  
  (function() {
    'use strict';
  
    /**
     * CommandExecutor class
     * Executes shell commands via file-based queue
     */
    class CommandExecutor {
      /**
       * @param {Object} fsManager - File system manager instance
       */
      constructor(fsManager) {
        this.fsManager = fsManager;
        this.pollInterval = 50;    // 50ms polling
        this.timeout = 300000;      // 5 minutes default
        this.maxOutputSize = 10 * 1024 * 1024; // 10MB
      }
  
      /**
       * Execute a shell command
       * @param {string} command - Command to execute
       * @param {string} workingDir - Working directory for command
       * @param {number} timeout - Optional timeout override (ms)
       * @returns {Promise<Object>} {stdout, stderr, exitCode, error?}
       */
      async executeCommand(command, workingDir, timeout = null) {
        // Validate command
        this.validateCommand(command, workingDir);
  
        const commandId = this.generateCommandId();
        const effectiveTimeout = timeout || this.timeout;
  
        try {
          // Write command to queue
          await this.writeToQueue(commandId, command, workingDir);
  
          // Poll for result
          const result = await this.pollForResult(commandId, effectiveTimeout);
  
          return result;
  
        } catch (error) {
          // Clean up on error
          await this.cleanupCommand(commandId);
          throw error;
        }
      }
  
      /**
       * Write command to queue file
       * @param {string} commandId - Unique command ID
       * @param {string} command - Command to execute
       * @param {string} workingDir - Working directory
       * @private
       */
      async writeToQueue(commandId, command, workingDir) {
        const queueData = {
          id: commandId,
          command: command,
          cwd: workingDir,
          timestamp: Date.now(),
          status: 'pending'
        };
  
        await this.fsManager.writeJSON('.agent/command-queue.json', queueData);
      }
  
      /**
       * Poll for command result
       * @param {string} commandId - Command ID to wait for
       * @param {number} timeout - Timeout in ms
       * @returns {Promise<Object>} Command result
       * @private
       */
      async pollForResult(commandId, timeout) {
        const startTime = Date.now();
        const resultPath = `.agent/command-results/${commandId}.json`;
  
        while (Date.now() - startTime < timeout) {
          try {
            const result = await this.fsManager.readJSON(resultPath);
  
            if (result.status === 'complete' || result.status === 'error') {
              // Clean up result file
              await this.fsManager.deleteFile(resultPath);
  
              // Check for error status
              if (result.status === 'error') {
                return {
                  stdout: result.stdout || '',
                  stderr: result.stderr || '',
                  exitCode: result.exitCode || 1,
                  error: result.error
                };
              }
  
              return {
                stdout: result.stdout,
                stderr: result.stderr,
                exitCode: result.exitCode
              };
            }
          } catch (e) {
            // File doesn't exist yet, keep polling
          }
  
          await this.sleep(this.pollInterval);
        }
  
        throw new Error(`Command execution timed out after ${timeout}ms`);
      }
  
      /**
       * Clean up command files
       * @param {string} commandId - Command ID to clean up
       * @private
       */
      async cleanupCommand(commandId) {
        try {
          await this.fsManager.deleteFile(`.agent/command-results/${commandId}.json`);
        } catch (e) {
          // File might not exist, ignore
        }
  
        try {
          // Clear queue by writing idle status
          await this.fsManager.writeJSON('.agent/command-queue.json', {
            status: 'idle',
            timestamp: Date.now()
          });
        } catch (e) {
          // Ignore errors
        }
      }
  
      /**
       * Validate command for security
       * @param {string} command - Command to validate
       * @param {string} workingDir - Working directory
       * @throws {Error} If command is invalid or dangerous
       * @private
       */
      validateCommand(command, workingDir) {
        if (!command || typeof command !== 'string') {
          throw new Error('Command must be a non-empty string');
        }
  
        if (!workingDir || typeof workingDir !== 'string') {
          throw new Error('Working directory must be a non-empty string');
        }
  
        // Check for dangerous patterns
        const dangerousPatterns = [
          'rm -rf /',
          'sudo ',
          'su ',
          'chmod +s',
          ':(){ :|:& };:' // Fork bomb
        ];
  
        for (const pattern of dangerousPatterns) {
          if (command.includes(pattern)) {
            throw new Error(`Dangerous command pattern detected: ${pattern}`);
          }
        }
  
        // Check for directory traversal in working directory
        if (workingDir.includes('..')) {
          throw new Error('Directory traversal not allowed in working directory');
        }
  
        // Validate working directory is not absolute root
        if (workingDir === '/' || workingDir === 'C:\\') {
          throw new Error('Cannot execute commands in root directory');
        }
      }
  
      /**
       * Generate unique command ID
       * @returns {string} Command ID
       * @private
       */
      generateCommandId() {
        return 'cmd_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }
  
      /**
       * Sleep for specified milliseconds
       * @param {number} ms - Milliseconds to sleep
       * @returns {Promise<void>}
       * @private
       */
      sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }
  
      /**
       * Check if command daemon is running
       * @returns {Promise<boolean>} True if daemon is responsive
       */
      async isDaemonRunning() {
        try {
          // Try to execute a simple echo command with short timeout
          const result = await this.executeCommand(
            'echo "ping"',
            '.',
            5000  // 5 second timeout
          );
          return result.exitCode === 0;
        } catch (e) {
          return false;
        }
      }
  
      /**
       * Get command execution status
       * @param {string} commandId - Command ID to check
       * @returns {Promise<Object|null>} Status or null if not found
       */
      async getCommandStatus(commandId) {
        try {
          const result = await this.fsManager.readJSON(
            `.agent/command-results/${commandId}.json`
          );
          return result;
        } catch (e) {
          return null;
        }
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.CommandExecutor = CommandExecutor;
    window.module.CommandManager = CommandExecutor; // Alias for compatibility
  
  })();

  // ============================================================================
  // src/file-hash-tracker.js
  // ============================================================================

  /**
   * file-hash-tracker.js
   *
   * Tracks file hashes before modifications:
   * - Track file content hashes before changes
   * - Detect external file changes
   * - Integration with undo stack
   *
   * Based on: src_old/com/codeboss/javalayer/aiprocessor/FileHashTracker.java
   */
  
  (function() {
    'use strict';
  
    /**
     * FileHashTracker class
     * Tracks file content hashes to detect external changes
     */
    class FileHashTracker {
      constructor(fsManager) {
        this.fsManager = fsManager;
        this.hashes = new Map(); // filePath -> hash
      }
  
      /**
       * Compute hash of string content
       * @param {string} content - Content to hash
       * @returns {Promise<string>} Hash string
       * @private
       */
      async computeHash(content) {
        // TODO: Use Web Crypto API to compute SHA-256 hash
        // TODO: Convert to hex string
        // TODO: Return hash
        throw new Error('Not implemented: FileHashTracker.computeHash()');
      }
  
      /**
       * Track a file's current hash
       * @param {string} filePath - File path
       * @returns {Promise<string>} Computed hash
       */
      async trackFile(filePath) {
        // TODO: Read file content
        // TODO: Compute hash
        // TODO: Store in hashes map
        // TODO: Return hash
        throw new Error('Not implemented: FileHashTracker.trackFile()');
      }
  
      /**
       * Update tracked hash for a file
       * @param {string} filePath - File path
       * @param {string} content - New content
       * @returns {Promise<string>} New hash
       */
      async updateHash(filePath, content) {
        // TODO: Compute hash of new content
        // TODO: Update hashes map
        // TODO: Return new hash
        throw new Error('Not implemented: FileHashTracker.updateHash()');
      }
  
      /**
       * Check if file has been modified externally
       * @param {string} filePath - File path
       * @returns {Promise<boolean>} True if modified externally
       */
      async hasExternalChanges(filePath) {
        // TODO: Get stored hash
        // TODO: Read current file content
        // TODO: Compute current hash
        // TODO: Compare with stored hash
        // TODO: Return true if different
        throw new Error('Not implemented: FileHashTracker.hasExternalChanges()');
      }
  
      /**
       * Get stored hash for a file
       * @param {string} filePath - File path
       * @returns {string|null} Stored hash or null
       */
      getHash(filePath) {
        return this.hashes.get(filePath) || null;
      }
  
      /**
       * Remove hash for a file (e.g., after deletion)
       * @param {string} filePath - File path
       * @returns {void}
       */
      removeHash(filePath) {
        this.hashes.delete(filePath);
      }
  
      /**
       * Check if file is tracked
       * @param {string} filePath - File path
       * @returns {boolean} True if tracked
       */
      isTracked(filePath) {
        return this.hashes.has(filePath);
      }
  
      /**
       * Get all tracked files
       * @returns {Array<string>} Array of file paths
       */
      getTrackedFiles() {
        return Array.from(this.hashes.keys());
      }
  
      /**
       * Clear all tracked hashes
       * @returns {void}
       */
      clear() {
        this.hashes.clear();
      }
  
      /**
       * Get count of tracked files
       * @returns {number} Number of tracked files
       */
      getTrackedCount() {
        return this.hashes.size;
      }
  
      /**
       * Verify file integrity
       * @param {string} filePath - File path
       * @returns {Promise<Object>} {valid: boolean, currentHash: string, storedHash: string}
       */
      async verifyFile(filePath) {
        // TODO: Get stored hash
        // TODO: Read current file
        // TODO: Compute current hash
        // TODO: Compare hashes
        // TODO: Return verification result
        throw new Error('Not implemented: FileHashTracker.verifyFile()');
      }
  
      /**
       * Verify all tracked files
       * @returns {Promise<Object>} {valid: Array, modified: Array, deleted: Array}
       */
      async verifyAll() {
        // TODO: For each tracked file:
        //   - Verify file exists
        //   - Verify hash matches
        //   - Categorize as valid/modified/deleted
        // TODO: Return categorized results
        throw new Error('Not implemented: FileHashTracker.verifyAll()');
      }
  
      /**
       * Sync hashes for all files in a directory
       * @param {string} directoryPath - Directory path
       * @param {boolean} recursive - Recurse into subdirectories
       * @returns {Promise<number>} Number of files tracked
       */
      async syncDirectory(directoryPath, recursive = false) {
        // TODO: List all files in directory
        // TODO: Track each file
        // TODO: Return count of tracked files
        throw new Error('Not implemented: FileHashTracker.syncDirectory()');
      }
  
      /**
       * Export hashes to JSON
       * @returns {Object} Hashes map as plain object
       */
      toJSON() {
        // TODO: Convert Map to plain object
        // TODO: Return serializable object
        throw new Error('Not implemented: FileHashTracker.toJSON()');
      }
  
      /**
       * Import hashes from JSON
       * @param {Object} data - Hashes data
       * @returns {void}
       */
      fromJSON(data) {
        // TODO: Clear current hashes
        // TODO: Load hashes from data
        throw new Error('Not implemented: FileHashTracker.fromJSON()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.FileHashTracker = FileHashTracker;
  
  })();

  // ============================================================================
  // src/undo-stack.js
  // ============================================================================

  /**
   * undo-stack.js
   *
   * Tracks file changes for undo functionality:
   * - Track file states before modifications
   * - Support undo operations
   * - Integration with file hash tracker
   *
   * Based on: src_old/com/codeboss/javalayer/aiprocessor/UndoStack.java
   */
  
  (function() {
    'use strict';
  
    /**
     * UndoEntry class
     * Represents a single undoable operation
     */
    class UndoEntry {
      constructor(operation, filePath, beforeContent, afterContent, timestamp) {
        this.operation = operation; // 'create', 'update', 'delete', 'move'
        this.filePath = filePath;
        this.beforeContent = beforeContent; // Content before change (null for create)
        this.afterContent = afterContent;   // Content after change (null for delete)
        this.timestamp = timestamp || Date.now();
        this.fromPath = null; // For move operations
        this.toPath = null;   // For move operations
      }
    }
  
    /**
     * UndoStack class
     * Manages undo history and operations
     */
    class UndoStack {
      constructor(fsManager, fileHashTracker) {
        this.fsManager = fsManager;
        this.fileHashTracker = fileHashTracker;
        this.stack = [];
        this.maxStackSize = 50; // Keep last 50 operations
      }
  
      /**
       * Track a file creation
       * @param {string} filePath - File path
       * @param {string} content - File content
       * @returns {void}
       */
      trackCreate(filePath, content) {
        // TODO: Create UndoEntry for create operation
        // TODO: beforeContent = null, afterContent = content
        // TODO: Add to stack
        // TODO: Trim stack if over maxStackSize
        throw new Error('Not implemented: UndoStack.trackCreate()');
      }
  
      /**
       * Track a file update
       * @param {string} filePath - File path
       * @param {string} beforeContent - Content before update
       * @param {string} afterContent - Content after update
       * @returns {void}
       */
      trackUpdate(filePath, beforeContent, afterContent) {
        // TODO: Create UndoEntry for update operation
        // TODO: Store both before and after content
        // TODO: Add to stack
        // TODO: Trim stack if over maxStackSize
        throw new Error('Not implemented: UndoStack.trackUpdate()');
      }
  
      /**
       * Track a file deletion
       * @param {string} filePath - File path
       * @param {string} beforeContent - Content before deletion
       * @returns {void}
       */
      trackDelete(filePath, beforeContent) {
        // TODO: Create UndoEntry for delete operation
        // TODO: beforeContent = content, afterContent = null
        // TODO: Add to stack
        // TODO: Trim stack if over maxStackSize
        throw new Error('Not implemented: UndoStack.trackDelete()');
      }
  
      /**
       * Track a file move
       * @param {string} fromPath - Source path
       * @param {string} toPath - Destination path
       * @param {string} content - File content
       * @returns {void}
       */
      trackMove(fromPath, toPath, content) {
        // TODO: Create UndoEntry for move operation
        // TODO: Store fromPath and toPath
        // TODO: Add to stack
        // TODO: Trim stack if over maxStackSize
        throw new Error('Not implemented: UndoStack.trackMove()');
      }
  
      /**
       * Undo the last N operations
       * @param {number} count - Number of operations to undo (default 1)
       * @returns {Promise<Object>} Result with undone operations and errors
       */
      async undo(count = 1) {
        // TODO: Validate count
        // TODO: Get last N entries from stack
        // TODO: For each entry (in reverse order):
        //   - Undo the operation
        //   - Track any errors
        // TODO: Remove undone entries from stack
        // TODO: Return {undone: [...], errors: [...]}
        throw new Error('Not implemented: UndoStack.undo()');
      }
  
      /**
       * Undo a single operation
       * @param {UndoEntry} entry - Entry to undo
       * @returns {Promise<void>}
       * @private
       */
      async undoEntry(entry) {
        // TODO: Switch on operation type:
        //   - create: Delete the created file
        //   - update: Restore beforeContent
        //   - delete: Recreate file with beforeContent
        //   - move: Move file back from toPath to fromPath
        // TODO: Update file hash tracker
        throw new Error('Not implemented: UndoStack.undoEntry()');
      }
  
      /**
       * Get undo history
       * @param {number} count - Number of recent entries to return
       * @returns {Array} Array of UndoEntry objects
       */
      getHistory(count = 10) {
        // TODO: Return last N entries from stack
        // TODO: Most recent first
        throw new Error('Not implemented: UndoStack.getHistory()');
      }
  
      /**
       * Check if undo is available
       * @returns {boolean} True if undo operations are available
       */
      canUndo() {
        return this.stack.length > 0;
      }
  
      /**
       * Get count of undoable operations
       * @returns {number} Number of operations that can be undone
       */
      getUndoCount() {
        return this.stack.length;
      }
  
      /**
       * Clear undo stack
       * @returns {void}
       */
      clear() {
        this.stack = [];
      }
  
      /**
       * Get stack size limit
       * @returns {number} Max stack size
       */
      getMaxStackSize() {
        return this.maxStackSize;
      }
  
      /**
       * Set stack size limit
       * @param {number} size - New max size
       * @returns {void}
       */
      setMaxStackSize(size) {
        // TODO: Set maxStackSize
        // TODO: Trim stack if current size exceeds new limit
        throw new Error('Not implemented: UndoStack.setMaxStackSize()');
      }
  
      /**
       * Trim stack to max size
       * Removes oldest entries
       * @private
       */
      trimStack() {
        // TODO: If stack.length > maxStackSize
        // TODO: Remove oldest entries (from beginning)
        throw new Error('Not implemented: UndoStack.trimStack()');
      }
  
      /**
       * Format undo history for display
       * @param {number} count - Number of entries to format
       * @returns {string} Formatted history
       */
      formatHistory(count = 10) {
        // TODO: Get last N entries
        // TODO: Format each entry with:
        //   - Timestamp
        //   - Operation type
        //   - File path
        //   - Brief description
        // TODO: Return formatted string
        throw new Error('Not implemented: UndoStack.formatHistory()');
      }
  
      /**
       * Serialize stack to JSON for persistence
       * @returns {Array} JSON-serializable stack
       */
      toJSON() {
        // TODO: Serialize stack entries
        // TODO: May need to limit content size for large files
        throw new Error('Not implemented: UndoStack.toJSON()');
      }
  
      /**
       * Load stack from JSON
       * @param {Array} data - Serialized stack data
       * @returns {void}
       */
      fromJSON(data) {
        // TODO: Deserialize stack entries
        // TODO: Recreate UndoEntry objects
        throw new Error('Not implemented: UndoStack.fromJSON()');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.UndoStack = UndoStack;
    window.module.UndoEntry = UndoEntry;
  
  })();

  // ============================================================================
  // src/file-cache.js
  // ============================================================================

  /**
   * File structure cache (optional optimization)
   * Cache file metadata and method signatures to reduce token usage
   * Based on src_old/com/codeboss/javalayer/filecache/
   */
  
  (function() {
    'use strict';
  
    const { FileNode } = window.module;
    const { TokenEstimator } = window.module;
    const { Logger } = window.module;
    const logger = window.module.createLogger('FileCache');
  
    /**
     * File structure cache
     * Maintains in-memory cache of file structure with method signatures
     */
    class FileStructureCache {
      constructor(tokenEstimator, budgetManager) {
        this.tokenEstimator = tokenEstimator;
        this.budgetManager = budgetManager;
        this.root = null; // Root FileNode
        this.cache = new Map(); // path  FileNode
        this.enabled = false; // Start disabled, enable when needed
      }
  
      /**
       * Build cache from directory
       * @param {string} rootPath - Root directory path
       * @param {FSManager} fsManager - File system manager
       * @returns {Promise<void>}
       */
      async buildCache(rootPath, fsManager) {
        throw new Error('Not implemented: buildCache()');
  
        // TODO: Implementation
        // 1. Create root FileNode
        // 2. Recursively traverse directory
        // 3. For each file:
        //    a. Create FileNode with metadata
        //    b. Extract method signatures (optional)
        //    c. Estimate token cost
        //    d. Add to cache
        // 4. Build parent-child relationships
        // 5. Calculate total token budget
      }
  
      /**
       * Get file node from cache
       * @param {string} filePath - File path
       * @returns {FileNode|null} File node or null
       */
      getFile(filePath) {
        throw new Error('Not implemented: getFile()');
  
        // TODO: Implementation
        // 1. Normalize path
        // 2. Look up in cache Map
        // 3. Return FileNode or null
      }
  
      /**
       * Update file in cache
       * @param {string} filePath - File path
       * @param {string} content - New file content
       * @returns {void}
       */
      updateFile(filePath, content) {
        throw new Error('Not implemented: updateFile()');
  
        // TODO: Implementation
        // 1. Get FileNode from cache
        // 2. Update metadata (size, lines, hash)
        // 3. Re-extract method signatures (if applicable)
        // 4. Re-estimate token cost
        // 5. Update in cache
      }
  
      /**
       * Add file to cache
       * @param {string} filePath - File path
       * @param {string} content - File content
       * @returns {FileNode} Created file node
       */
      addFile(filePath, content) {
        throw new Error('Not implemented: addFile()');
  
        // TODO: Implementation
        // 1. Create FileNode
        // 2. Extract metadata and signatures
        // 3. Add to cache Map
        // 4. Update parent directory node
        // 5. Return FileNode
      }
  
      /**
       * Remove file from cache
       * @param {string} filePath - File path
       * @returns {void}
       */
      removeFile(filePath) {
        throw new Error('Not implemented: removeFile()');
  
        // TODO: Implementation
        // 1. Get FileNode
        // 2. Remove from cache Map
        // 3. Update parent directory node
        // 4. Recalculate token budgets
      }
  
      /**
       * Get files within token budget
       * @param {number} maxTokens - Maximum tokens to include
       * @param {Array<string>} priorityPaths - Priority file paths (always include)
       * @returns {Array<FileNode>} Files within budget
       */
      getFilesWithinBudget(maxTokens, priorityPaths = []) {
        throw new Error('Not implemented: getFilesWithinBudget()');
  
        // TODO: Implementation
        // 1. Start with priority files (always included)
        // 2. Add other files sorted by:
        //    - Recency (recently modified first)
        //    - Relevance (based on current task)
        //    - Size (smaller files first)
        // 3. Keep adding while under maxTokens
        // 4. Return array of FileNodes
      }
  
      /**
       * Generate prompt section with file structure
       * @param {number} maxTokens - Maximum tokens for this section
       * @returns {string} Formatted file structure prompt
       */
      generatePromptSection(maxTokens) {
        throw new Error('Not implemented: generatePromptSection()');
  
        // TODO: Implementation
        // 1. Get files within budget
        // 2. Format as tree structure with method signatures
        // 3. Return formatted string
        // Example format:
        // ```
        // src/
        //   Calculator.java (150 tokens)
        //     - add(a, b)
        //     - subtract(a, b)
        //     - multiply(a, b)
        //   User.java (200 tokens)
        //     - constructor(name, email)
        //     - validate()
        // ```
      }
  
      /**
       * Clear cache
       */
      clear() {
        throw new Error('Not implemented: clear()');
  
        // TODO: Implementation
        // 1. Clear cache Map
        // 2. Reset root FileNode
        // 3. Reset budgets
      }
  
      /**
       * Enable/disable cache
       * @param {boolean} enabled - Whether cache is enabled
       */
      setEnabled(enabled) {
        this.enabled = enabled;
        if (!enabled) {
          this.clear();
        }
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.FileStructureCache = FileStructureCache;
  
  })();

  // ============================================================================
  // src/method-signature-extractor.js
  // ============================================================================

  /**
   * Method signature extractor (optional optimization)
   * Extract method/function signatures from source files
   * Language-specific parsing for Java, JavaScript, Python, etc.
   */
  
  (function() {
    'use strict';
  
    const { Logger } = window.module;
    const logger = window.module.createLogger('MethodSignatureExtractor');
  
    /**
     * Method signature class
     */
    class MethodSignature {
      constructor(name, parameters, returnType, visibility, lineNumber) {
        this.name = name;
        this.parameters = parameters; // Array of {name, type}
        this.returnType = returnType;
        this.visibility = visibility; // public, private, protected
        this.lineNumber = lineNumber;
      }
  
      /**
       * Format as string
       * @returns {string} Formatted signature
       */
      toString() {
        throw new Error('Not implemented: toString()');
  
        // TODO: Implementation
        // Example formats:
        // Java: public int add(int a, int b)
        // JavaScript: add(a, b)
        // Python: def add(a: int, b: int) -> int
      }
    }
  
    /**
     * Method signature extractor
     */
    class MethodSignatureExtractor {
      /**
       * Extract method signatures from source code
       * @param {string} content - Source code content
       * @param {string} language - Language (java, javascript, python, etc.)
       * @returns {Array<MethodSignature>} Extracted signatures
       */
      static extract(content, language) {
        throw new Error('Not implemented: extract()');
  
        // TODO: Implementation
        // 1. Route to language-specific extractor
        // 2. Parse source code for method/function definitions
        // 3. Extract signature components
        // 4. Return array of MethodSignature objects
  
        // Dispatching:
        /*
        switch (language.toLowerCase()) {
          case 'java':
            return this.extractJava(content);
          case 'javascript':
          case 'typescript':
            return this.extractJavaScript(content);
          case 'python':
            return this.extractPython(content);
          default:
            return [];
        }
        */
      }
  
      /**
       * Extract Java method signatures
       * @param {string} content - Java source code
       * @returns {Array<MethodSignature>} Extracted signatures
       */
      static extractJava(content) {
        throw new Error('Not implemented: extractJava()');
  
        // TODO: Implementation
        // 1. Use regex to match method declarations
        // 2. Pattern: (public|private|protected)?\s*(static)?\s*(\w+)\s+(\w+)\s*\((.*?)\)
        // 3. Parse parameter list
        // 4. Extract line number
        // 5. Create MethodSignature objects
        // 6. Return array
  
        // Example regex:
        // /(?:public|private|protected)?\s*(?:static)?\s*(\w+)\s+(\w+)\s*\((.*?)\)/g
      }
  
      /**
       * Extract JavaScript/TypeScript function signatures
       * @param {string} content - JavaScript source code
       * @returns {Array<MethodSignature>} Extracted signatures
       */
      static extractJavaScript(content) {
        throw new Error('Not implemented: extractJavaScript()');
  
        // TODO: Implementation
        // 1. Match function declarations: function name(params) { }
        // 2. Match arrow functions: const name = (params) => { }
        // 3. Match class methods: methodName(params) { }
        // 4. Match async functions: async function name(params) { }
        // 5. Extract parameters (may have types in TypeScript)
        // 6. Create MethodSignature objects
      }
  
      /**
       * Extract Python function/method signatures
       * @param {string} content - Python source code
       * @returns {Array<MethodSignature>} Extracted signatures
       */
      static extractPython(content) {
        throw new Error('Not implemented: extractPython()');
  
        // TODO: Implementation
        // 1. Match function definitions: def name(params):
        // 2. Match async functions: async def name(params):
        // 3. Parse type hints: def add(a: int, b: int) -> int:
        // 4. Extract parameters with types
        // 5. Create MethodSignature objects
      }
  
      /**
       * Parse parameter list string
       * @param {string} paramString - Parameter list string
       * @param {string} language - Language
       * @returns {Array<Object>} Array of {name, type}
       */
      static parseParameters(paramString, language) {
        throw new Error('Not implemented: parseParameters()');
  
        // TODO: Implementation
        // 1. Split by comma (handle nested generics)
        // 2. For each parameter:
        //    a. Parse name and type
        //    b. Handle default values
        //    c. Handle spread/rest operators
        // 3. Return array of {name, type}
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.MethodSignatureExtractor = MethodSignatureExtractor;
    window.module.MethodSignature = MethodSignature;
  
  })();

  // ============================================================================
  // src/budget-manager.js
  // ============================================================================

  /**
   * Budget manager for token allocation (optional optimization)
   * Manages token budgets across different prompt sections
   */
  
  (function() {
    'use strict';
  
    const { TokenEstimator } = window.module;
    const { Logger } = window.module;
    const logger = window.module.createLogger('BudgetManager');
  
    /**
     * Budget manager
     */
    class BudgetManager {
      constructor(maxInputTokens = 200000, maxOutputTokens = 8000) {
        this.maxInputTokens = maxInputTokens;
        this.maxOutputTokens = maxOutputTokens;
  
        // Budget allocation percentages
        this.budgets = {
          baseInstructions: 0.10,  // 10% - System prompt, base instructions
          phaseInstructions: 0.05, // 5% - Phase-specific instructions
          mentalModels: 0.15,      // 15% - Project + task mental models
          ephemeralContent: 0.40,  // 40% - Files, git output, searches
          recentChanges: 0.05,     // 5% - Recent changes
          checklist: 0.05,         // 5% - Current checklist
          tools: 0.05,             // 5% - Tool definitions
          history: 0.15            // 15% - Conversation history
        };
  
        // Current usage tracking
        this.usage = {};
        this.resetUsage();
      }
  
      /**
       * Reset usage tracking
       */
      resetUsage() {
        throw new Error('Not implemented: resetUsage()');
  
        // TODO: Implementation
        // 1. Initialize usage object with 0 for each section
        // 2. Calculate max tokens per section based on budgets
      }
  
      /**
       * Get max tokens for section
       * @param {string} section - Section name
       * @returns {number} Max tokens for section
       */
      getMaxTokens(section) {
        throw new Error('Not implemented: getMaxTokens()');
  
        // TODO: Implementation
        // 1. Get budget percentage for section
        // 2. Calculate: maxInputTokens * percentage
        // 3. Return token count
      }
  
      /**
       * Track token usage for section
       * @param {string} section - Section name
       * @param {number} tokens - Token count
       */
      trackUsage(section, tokens) {
        throw new Error('Not implemented: trackUsage()');
  
        // TODO: Implementation
        // 1. Add tokens to usage[section]
        // 2. Log if over budget
        // 3. Update total usage
      }
  
      /**
       * Get remaining budget for section
       * @param {string} section - Section name
       * @returns {number} Remaining tokens
       */
      getRemainingBudget(section) {
        throw new Error('Not implemented: getRemainingBudget()');
  
        // TODO: Implementation
        // 1. Get max tokens for section
        // 2. Subtract current usage
        // 3. Return remaining (or 0 if over budget)
      }
  
      /**
       * Check if section is over budget
       * @param {string} section - Section name
       * @returns {boolean} True if over budget
       */
      isOverBudget(section) {
        throw new Error('Not implemented: isOverBudget()');
  
        // TODO: Implementation
        // 1. Compare usage[section] to max
        // 2. Return boolean
      }
  
      /**
       * Get total usage
       * @returns {number} Total tokens used
       */
      getTotalUsage() {
        throw new Error('Not implemented: getTotalUsage()');
  
        // TODO: Implementation
        // 1. Sum all usage values
        // 2. Return total
      }
  
      /**
       * Check if total usage is near limit
       * @param {number} threshold - Threshold percentage (default 0.8)
       * @returns {boolean} True if near limit
       */
      isNearLimit(threshold = 0.8) {
        throw new Error('Not implemented: isNearLimit()');
  
        // TODO: Implementation
        // 1. Get total usage
        // 2. Compare to maxInputTokens * threshold
        // 3. Return boolean
      }
  
      /**
       * Generate budget report
       * @returns {string} Formatted budget report
       */
      generateReport() {
        throw new Error('Not implemented: generateReport()');
  
        // TODO: Implementation
        // 1. Format each section with:
        //    - Section name
        //    - Usage / Max
        //    - Percentage used
        // 2. Show total usage
        // 3. Return formatted string
  
        // Example format:
        // Budget Report:
        // - Base Instructions: 15,000 / 20,000 (75%)
        // - Ephemeral Content: 65,000 / 80,000 (81%)
        // - History: 25,000 / 30,000 (83%)
        // Total: 180,000 / 200,000 (90%)
      }
  
      /**
       * Suggest budget adjustments
       * @returns {Object} Suggested adjustments
       */
      suggestAdjustments() {
        throw new Error('Not implemented: suggestAdjustments()');
  
        // TODO: Implementation
        // 1. Find sections that are over budget
        // 2. Find sections that are under budget
        // 3. Suggest reallocations
        // 4. Return object with suggestions
      }
  
      /**
       * Update budget allocation
       * @param {string} section - Section name
       * @param {number} percentage - New percentage (0-1)
       */
      updateBudget(section, percentage) {
        throw new Error('Not implemented: updateBudget()');
  
        // TODO: Implementation
        // 1. Validate percentage
        // 2. Update budgets[section]
        // 3. Ensure total percentages = 1.0
        // 4. Warn if total != 1.0
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.BudgetManager = BudgetManager;
  
  })();

  // ============================================================================
  // src/compaction-engine.js
  // ============================================================================

  /**
   * Compaction engine (optional optimization)
   * Compact conversation history and context when approaching token limits
   *
   * NOTE: May not be needed with ephemeral content system
   * Kept for potential future use if token limits become an issue
   */
  
  (function() {
    'use strict';
  
    const { TokenEstimator } = window.module;
    const { Logger } = window.module;
    const logger = window.module.createLogger('CompactionEngine');
  
    /**
     * Compaction strategy enum
     */
    const CompactionStrategy = {
      REMOVE_OLD_MESSAGES: 'remove_old_messages',
      SUMMARIZE_MESSAGES: 'summarize_messages',
      TRUNCATE_TOOL_RESULTS: 'truncate_tool_results',
      REMOVE_DUPLICATE_CONTENT: 'remove_duplicate_content'
    };
  
    /**
     * Compaction engine
     */
    class CompactionEngine {
      constructor(tokenEstimator) {
        this.tokenEstimator = tokenEstimator;
        this.enabled = false; // Start disabled
      }
  
      /**
       * Compact conversation history
       * @param {Array} messages - Message history
       * @param {number} targetTokens - Target token count
       * @param {Array<string>} strategies - Compaction strategies to use
       * @returns {Array} Compacted messages
       */
      compact(messages, targetTokens, strategies = []) {
        throw new Error('Not implemented: compact()');
  
        // TODO: Implementation
        // 1. Estimate current token count
        // 2. If under target, return messages unchanged
        // 3. Apply strategies in order until under target:
        //    - REMOVE_OLD_MESSAGES: Remove oldest messages first
        //    - SUMMARIZE_MESSAGES: Summarize groups of messages
        //    - TRUNCATE_TOOL_RESULTS: Truncate long tool results
        //    - REMOVE_DUPLICATE_CONTENT: Remove repeated content
        // 4. Return compacted messages
      }
  
      /**
       * Remove old messages
       * @param {Array} messages - Message history
       * @param {number} targetTokens - Target token count
       * @returns {Array} Compacted messages
       */
      removeOldMessages(messages, targetTokens) {
        throw new Error('Not implemented: removeOldMessages()');
  
        // TODO: Implementation
        // 1. Keep most recent messages
        // 2. Remove oldest messages until under target
        // 3. Always keep first message (usually task description)
        // 4. Return remaining messages
      }
  
      /**
       * Summarize messages
       * @param {Array} messages - Message history
       * @param {number} targetTokens - Target token count
       * @returns {Array} Compacted messages with summaries
       */
      summarizeMessages(messages, targetTokens) {
        throw new Error('Not implemented: summarizeMessages()');
  
        // TODO: Implementation
        // 1. Group old messages into chunks
        // 2. For each chunk, create summary message:
        //    "Summary of 5 messages: User requested X, AI did Y, Z"
        // 3. Replace chunk with summary
        // 4. Keep recent messages intact
        // 5. Return compacted messages
      }
  
      /**
       * Truncate tool results
       * @param {Array} messages - Message history
       * @param {number} targetTokens - Target token count
       * @returns {Array} Compacted messages with truncated results
       */
      truncateToolResults(messages, targetTokens) {
        throw new Error('Not implemented: truncateToolResults()');
  
        // TODO: Implementation
        // 1. Find tool_result messages
        // 2. Truncate large results:
        //    - File content: Keep first/last N lines
        //    - Search results: Keep top N results
        //    - Git log: Keep recent N commits
        // 3. Add truncation indicator: "[truncated]"
        // 4. Return compacted messages
      }
  
      /**
       * Remove duplicate content
       * @param {Array} messages - Message history
       * @returns {Array} Compacted messages
       */
      removeDuplicateContent(messages) {
        throw new Error('Not implemented: removeDuplicateContent()');
  
        // TODO: Implementation
        // 1. Track seen content (by hash)
        // 2. When duplicate found:
        //    - Replace with reference: "See message #123"
        // 3. Keep first occurrence
        // 4. Return compacted messages
      }
  
      /**
       * Calculate compaction statistics
       * @param {Array} original - Original messages
       * @param {Array} compacted - Compacted messages
       * @returns {Object} Statistics
       */
      calculateStats(original, compacted) {
        throw new Error('Not implemented: calculateStats()');
  
        // TODO: Implementation
        // 1. Count original messages and tokens
        // 2. Count compacted messages and tokens
        // 3. Calculate reduction percentage
        // 4. Return stats object:
        //    {
        //      originalMessages: 50,
        //      compactedMessages: 30,
        //      originalTokens: 100000,
        //      compactedTokens: 60000,
        //      reductionPercent: 40
        //    }
      }
  
      /**
       * Enable/disable compaction
       * @param {boolean} enabled - Whether compaction is enabled
       */
      setEnabled(enabled) {
        this.enabled = enabled;
        logger.info('Compaction engine', enabled ? 'enabled' : 'disabled');
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.CompactionEngine = CompactionEngine;
    window.module.CompactionStrategy = CompactionStrategy;
  
  })();

  // ============================================================================
  // src/ui/vdom.js
  // ============================================================================

  (function() {
      function h(tag, props, ...children) {
          return {
              tag,
              props: props || {},
              children: children.flat().filter(child => child != null)
          };
      }
  
      function convertUnicodeToHtmlEntities(str) {
          return str.replace(/[\u0080-\uFFFF]/g, function(char) {
              return '&#' + char.charCodeAt(0) + ';';
          });
      }
  
      function text(content) {
          const strContent = String(content);
          // Convert unicode characters to HTML entities for proper browser display
          const converted = convertUnicodeToHtmlEntities(strContent);
          return {
              type: 'text',
              content: converted
          };
      }
  
      function createDOMNode(vnode) {
          if (!vnode) return null;
  
          if (vnode.type === 'text') {
              // If content contains HTML entities, parse them manually (Trusted Types compliant)
              if (vnode.content.includes('&#')) {
                  // Parse HTML entities like &#8595; without using innerHTML
                  const parsed = vnode.content.replace(/&#(\d+);/g, (match, dec) => {
                      return String.fromCharCode(parseInt(dec, 10));
                  });
                  return document.createTextNode(parsed);
              }
              return document.createTextNode(vnode.content);
          }
  
          const el = document.createElement(vnode.tag);
  
          if (vnode.props) {
              Object.keys(vnode.props).forEach(key => {
                  if (key === 'className') {
                      el.className = vnode.props[key];
                  } else if (key.startsWith('on')) {
                      const eventName = key.substring(2).toLowerCase();
                      el.addEventListener(eventName, vnode.props[key]);
                  } else {
                      el.setAttribute(key, vnode.props[key]);
                  }
              });
          }
  
          if (vnode.children) {
              vnode.children.forEach(child => {
                  const childNode = createDOMNode(child);
                  if (childNode) {
                      el.appendChild(childNode);
                  }
              });
          }
  
          return el;
      }
  
      window.module["vdom.js"] = {
          h,
          text,
          createDOMNode
      };
  })();

  // ============================================================================
  // src/ui/diff.js
  // ============================================================================

  (function() {
      const { createDOMNode } = window.module["vdom.js"];
  
      function diff(oldVNode, newVNode) {
          const patches = [];
  
          if (!oldVNode && !newVNode) {
              return patches;
          }
  
          if (!oldVNode && newVNode) {
              patches.push({ type: 'CREATE', vnode: newVNode });
              return patches;
          }
  
          if (oldVNode && !newVNode) {
              patches.push({ type: 'REMOVE' });
              return patches;
          }
  
          if (oldVNode.type === 'text' && newVNode.type === 'text') {
              if (oldVNode.content !== newVNode.content) {
                  patches.push({ type: 'TEXT', content: newVNode.content });
              }
              return patches;
          }
  
          if (oldVNode.type === 'text' || newVNode.type === 'text' || oldVNode.tag !== newVNode.tag) {
              patches.push({ type: 'REPLACE', vnode: newVNode });
              return patches;
          }
  
          const propPatches = diffProps(oldVNode.props, newVNode.props);
          if (propPatches.length > 0) {
              patches.push({ type: 'PROPS', patches: propPatches });
          }
  
          const childPatches = diffChildren(oldVNode.children, newVNode.children);
          if (childPatches.length > 0) {
              patches.push({ type: 'CHILDREN', patches: childPatches });
          }
  
          return patches;
      }
  
      function diffProps(oldProps = {}, newProps = {}) {
          const patches = [];
  
          const allKeys = new Set([...Object.keys(oldProps), ...Object.keys(newProps)]);
  
          allKeys.forEach(key => {
              if (key.startsWith('on')) {
                  return;
              }
  
              if (!(key in newProps)) {
                  patches.push({ type: 'REMOVE_PROP', key });
              } else if (!(key in oldProps) || oldProps[key] !== newProps[key]) {
                  patches.push({ type: 'SET_PROP', key, value: newProps[key] });
              }
          });
  
          return patches;
      }
  
      function diffChildren(oldChildren = [], newChildren = []) {
          const patches = [];
  
          // Build a map of keyed old children for efficient lookup
          const oldKeyedChildren = new Map();
          const oldUnkeyedChildren = [];
  
          oldChildren.forEach((child, index) => {
              if (child && child.props && child.props.key != null) {
                  oldKeyedChildren.set(child.props.key, { child, index });
              } else {
                  oldUnkeyedChildren.push({ child, index });
              }
          });
  
          // Track which old indices have been used
          const usedOldIndices = new Set();
          let unkeyedIndex = 0;
  
          // First pass: match new children with old children by key or position
          for (let newIndex = 0; newIndex < newChildren.length; newIndex++) {
              const newChild = newChildren[newIndex];
              const newKey = newChild && newChild.props && newChild.props.key;
  
              let oldIndex = -1;
              let oldChild = null;
  
              if (newKey != null && oldKeyedChildren.has(newKey)) {
                  // Match by key
                  const match = oldKeyedChildren.get(newKey);
                  oldChild = match.child;
                  oldIndex = match.index;
                  usedOldIndices.add(oldIndex);
              } else if (unkeyedIndex < oldUnkeyedChildren.length) {
                  // Match unkeyed children by position
                  const match = oldUnkeyedChildren[unkeyedIndex];
                  oldChild = match.child;
                  oldIndex = match.index;
                  usedOldIndices.add(oldIndex);
                  unkeyedIndex++;
              }
  
              // Generate diff for this child
              patches[newIndex] = diff(oldChild, newChild);
          }
  
          // Second pass: mark unused old children for removal
          for (let i = oldChildren.length; i < Math.max(oldChildren.length, newChildren.length); i++) {
              // Old children beyond new children length should be removed
              if (i >= newChildren.length) {
                  patches[i] = diff(oldChildren[i], null);
              }
          }
  
          return patches;
      }
  
      function patch(parent, patches, index = 0) {
          if (!patches || patches.length === 0) {
              return;
          }
  
          // Safety check: ensure parent exists
          if (!parent) {
              console.warn('[VDOM] patch called with undefined parent, index:', index);
              return;
          }
  
          const el = parent.childNodes[index];
  
          patches.forEach(p => {
              switch (p.type) {
                  case 'CREATE':
                      parent.appendChild(createDOMNode(p.vnode));
                      break;
  
                  case 'REMOVE':
                      if (el && el.parentNode) {
                          el.parentNode.removeChild(el);
                      }
                      break;
  
                  case 'REPLACE':
                      if (el && el.parentNode) {
                          el.parentNode.replaceChild(createDOMNode(p.vnode), el);
                      }
                      break;
  
                  case 'TEXT':
                      if (el) {
                          el.textContent = p.content;
                      }
                      break;
  
                  case 'PROPS':
                      if (el) {
                          patchProps(el, p.patches);
                      }
                      break;
  
                  case 'CHILDREN':
                      if (el) {
                          patchChildren(el, p.patches);
                      }
                      break;
              }
          });
      }
  
      function patchProps(el, propPatches) {
          propPatches.forEach(p => {
              if (p.type === 'REMOVE_PROP') {
                  if (p.key === 'className') {
                      el.className = '';
                  } else {
                      el.removeAttribute(p.key);
                  }
              } else if (p.type === 'SET_PROP') {
                  if (p.key === 'className') {
                      el.className = p.value;
                  } else {
                      el.setAttribute(p.key, p.value);
                  }
              }
          });
      }
  
      function patchChildren(parent, childPatches) {
          childPatches.forEach((patches, i) => {
              patch(parent, patches, i);
          });
      }
  
      window.module["diff.js"] = {
          diff,
          patch
      };
  })();

  // ============================================================================
  // src/ui/render.js
  // ============================================================================

  (function() {
      const { h, text } = window.module["vdom.js"];
  
      /**
       * Main render function - renders entire app based on current screen
       */
      function render(state) {
          if (!state) {
              return h('div', { id: 'app-root' }, []);
          }
  
          if (state.currentScreen === 'welcome') {
              return renderWelcomeScreen(state);
          } else {
              return renderChatScreen(state);
          }
      }
  
      /**
       * Render welcome screen
       */
      function renderWelcomeScreen(state) {
          return h('div', { id: 'welcome-screen', className: 'screen' }, [
              h('div', { className: 'welcome-content' }, [
                  h('div', { className: 'welcome-header' }, text('Code Boss MVP')),
                  h('div', { className: 'welcome-message' }, text('AI-powered coding assistant')),
                  h('button', {
                      id: 'select-directory-btn',
                      className: 'primary-button'
                  }, text('Select Working Directory'))
              ])
          ]);
      }
  
      /**
       * Render chat screen with split-panel layout (sidebar + chat)
       */
      function renderChatScreen(state) {
          const messages = state.messages || [];
          const messageNodes = messages
              .map((msg, index) => renderMessage(msg, messages, index, state))
              .filter(node => node !== null);
  
          // Add loading indicator if backend is processing
          if (state.isProcessing) {
              console.log('[render] isProcessing=true, adding loading animation');
              messageNodes.push(renderLoading());
          } else {
              console.log('[render] isProcessing=false, no loading animation');
          }
  
          const chatHistory = h('div', { className: 'chat-history' }, messageNodes);
  
          // Render sidebar if sidebar module is available
          const { renderSidebar } = window.module["sidebar.js"] || {};
          const sidebarNode = renderSidebar ? renderSidebar(state.sidebar || {
              projects: [],
              currentProject: state.currentProject,
              currentTask: state.currentTask,
              isMinimized: false
          }) : null;
  
          // Render modals if modal module is available
          const { renderCreateProjectModal, renderFileContentModal } = window.module["modal.js"] || {};
          const createProjectModalNode = renderCreateProjectModal ? renderCreateProjectModal(state.modal) : null;
          const fileContentModalNode = renderFileContentModal ? renderFileContentModal(state.modal) : null;
  
          return h('div', { id: 'chat-screen', className: 'screen' }, [
              // Sidebar (left panel)
              sidebarNode,
  
              // Chat panel (right panel)
              h('div', { id: 'chat-panel' }, [
                  h('div', { id: 'chat-container' }, [chatHistory]),
                  h('div', { id: 'input-container' }, [
                      // Check if last message is task_complete - show button instead of input
                      (messages.length > 0 && messages[messages.length - 1].type === 'task_complete') ?
                          h('button', {
                              id: 'start-new-task-btn',
                              className: 'primary-button',
                              disabled: state.isProcessing
                          }, text('Start New Task'))
                      :
                          h('textarea', {
                              id: 'message-input',
                              placeholder: state.sidebar.currentProject ? 'Type your message...' : 'Select a project to start...',
                              autocomplete: 'off',
                              rows: '1',
                              disabled: !state.sidebar.currentProject || state.isProcessing
                          }, text(''))
                  ])
              ]),
  
              // Modals (overlay on top)
              createProjectModalNode,
              fileContentModalNode
          ].filter(Boolean));
      }
  
      function renderMessage(msg, allMessages, index, state) {
          switch (msg.type) {
              case 'user_msg':
                  return renderUserMessage(msg);
              case 'assistant_msg':
                  return renderAssistantMessage(msg);
              case 'greeting':
                  return renderAssistantMessage(msg); // Render greetings as assistant messages
              case 'task_complete':
                  return renderTaskComplete(msg); // Render task completion as assistant message
              case 'tool_use':
                  return renderToolUse(msg, allMessages, index, state);
              case 'tool_result':
                  return renderToolResult(msg, allMessages, index, state);
              case 'error':
                  return renderError(msg);
              case 'mode_transition':
                  return renderModeTransition(msg);
              case 'command_result':
                  return renderCommandResult(msg);
              case 'approval_request':
                  return renderApprovalRequest(msg);
              default:
                  return null;
          }
      }
  
      function renderUserMessage(msg) {
          const content = msg.content.replace(/\\n/g, '\n');
          return h('div', { className: 'message user-message' }, [
              h('div', { className: 'message-prefix' }, text('> ')),
              h('div', { className: 'message-content' }, text(content))
          ]);
      }
  
      function renderAssistantMessage(msg) {
          const content = parseAssistantContent(msg.content);
          return h('div', { className: 'message assistant-message' }, content);
      }
  
      function parseAssistantContent(content) {
          if (!content) return [text('')];
  
          const lines = content.split('\n');
          const elements = [];
          let inChecklist = false;
          let checklistTitle = '';
          let checklistItems = [];
  
          for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
  
              if (line.match(/^\*\*Plan:/)) {
                  inChecklist = true;
                  checklistTitle = line.replace(/^\*\*/, '').replace(/\*\*$/, '');
                  checklistItems = [];
                  continue;
              }
  
              if (inChecklist) {
                  const checkboxMatch = line.match(/^(\[[ x]\])\s+(.+)$/);
                  if (checkboxMatch) {
                      const status = checkboxMatch[1];
                      const itemContent = checkboxMatch[2];
                      checklistItems.push({ status, content: itemContent });
                      continue;
                  } else if (line.trim() === '' || !line.match(/^\[/)) {
                      if (checklistItems.length > 0) {
                          elements.push(renderChecklist(checklistTitle, checklistItems));
                          checklistTitle = '';
                          checklistItems = [];
                      }
                      inChecklist = false;
                  }
              }
  
              if (!inChecklist) {
                  if (line.startsWith('| ')) {
                      elements.push(h('div', { className: 'system-line' }, [
                          h('span', { className: 'pipe-prefix' }, text('| ')),
                          text(line.substring(2))
                      ]));
                  } else if (line.match(/^\[\d+\/\d+\]\s*/)) {
                      elements.push(h('div', { className: 'progress-line' }, text(line)));
                  } else if (line.match(/^\[\]/)) {
                      elements.push(h('div', { className: 'completion-line' }, text(line)));
                  } else {
                      elements.push(h('div', { className: 'text-line' }, text(line)));
                  }
              }
          }
  
          if (inChecklist && checklistItems.length > 0) {
              elements.push(renderChecklist(checklistTitle, checklistItems));
          }
  
          return elements;
      }
  
      function renderChecklist(title, items) {
          return h('div', { className: 'checklist' }, [
              h('div', { className: 'checklist-title' }, text(title)),
              ...items.map(item => {
                  const statusClass = item.status === '[]' ? 'completed' :
                                     item.status === '[]' ? 'skipped' : 'pending';
                  return h('div', { className: `checklist-item ${statusClass}` }, [
                      h('span', { className: 'checkbox' }, text(item.status + ' ')),
                      text(item.content)
                  ]);
              })
          ]);
      }
  
      function renderToolUse(msg, allMessages, index, state) {
          // Hide manage_checklist tool use when action is 'add' during planning
          if (msg.toolName === 'manage_checklist' && msg.parameters && msg.parameters.action === 'add' && state.mode === 'planning') {
              return null;
          }
  
          // Hide begin_execution, mark_complete, review_pass, and review_fail tool use
          if (msg.toolName === 'begin_execution' ||
              msg.toolName === 'mark_complete' ||
              msg.toolName === 'review_pass' ||
              msg.toolName === 'review_fail') {
              return null;
          }
  
          const params = formatParams(msg.parameters);
  
          // Look ahead to find the next tool_result or error to determine bullet status
          let bulletClass = 'tool-bullet-pending'; // default: flashing gray
          for (let i = index + 1; i < allMessages.length; i++) {
              const nextMsg = allMessages[i];
              if (nextMsg.type === 'tool_result' || nextMsg.type === 'error') {
                  // Check if it's an error: either type='error' or result contains 'error' field
                  const hasError = nextMsg.type === 'error' ||
                                  (nextMsg.result && nextMsg.result.error);
                  if (hasError) {
                      bulletClass = 'tool-bullet-error'; // red
                  } else {
                      bulletClass = 'tool-bullet-success'; // green
                  }
                  break;
              }
              // Stop looking if we hit another tool_use or assistant message
              if (nextMsg.type === 'tool_use' || nextMsg.type === 'assistant_msg') {
                  break;
              }
          }
  
          // Special rendering for create_file, update_file, and update_file_batch with chevron instead of bullet
          if (msg.toolName === 'create_file' || msg.toolName === 'update_file' || msg.toolName === 'update_file_batch') {
              // Check if result has error or if there are enough lines to show chevron
              let hasError = false;
              let shouldShowChevron = false;
  
              // Look ahead to check for errors and line count
              for (let i = index + 1; i < allMessages.length; i++) {
                  const nextMsg = allMessages[i];
                  if (nextMsg.type === 'tool_result' && nextMsg.tool_use_id === msg.id) {
                      hasError = nextMsg.result && nextMsg.result.error;
  
                      // Calculate line count for this tool
                      if (!hasError && msg.parameters) {
                          let lineCount = 0;
                          if (msg.toolName === 'create_file' && msg.parameters.content) {
                              lineCount = msg.parameters.content.split('\n').length;
                          } else if (msg.toolName === 'update_file') {
                              const oldContent = msg.parameters.old_content || '';
                              const newContent = msg.parameters.new_content || '';
                              const diffLines = computeLineDiff(oldContent, newContent);
                              lineCount = diffLines.filter(line => line.type !== 'unchanged').length;
                          } else if (msg.toolName === 'update_file_batch' && msg.parameters.updates) {
                              try {
                                  const updates = JSON.parse(msg.parameters.updates || '[]');
                                  updates.forEach(update => {
                                      const oldContent = update.old_content || '';
                                      const newContent = update.new_content || '';
                                      const diffLines = computeLineDiff(oldContent, newContent);
                                      lineCount += diffLines.filter(line => line.type !== 'unchanged').length;
                                  });
                              } catch (e) {
                                  // JSON parse error, don't show chevron
                              }
                          }
                          shouldShowChevron = lineCount > 10;
                      }
                      break;
                  }
                  // Stop looking if we hit another tool_use
                  if (nextMsg.type === 'tool_use') {
                      break;
                  }
              }
  
              // Display name overrides
              let displayName;
              if (msg.toolName === 'update_file_batch') {
                  displayName = 'Multi Edit File';
              } else if (msg.toolName === 'update_file') {
                  displayName = 'Edit File';
              } else {
                  displayName = formatToolName(msg.toolName);
              }
  
              // Only show chevron if no error and > 10 lines
              if (shouldShowChevron) {
                  const uiController = window.module.uiControllerInstance;
                  const expandedFiles = uiController ? uiController.expandedFiles : {};
                  const showFullContent = expandedFiles[msg.id] === true;
                  const chevronClass = showFullContent ? 'file-chevron' : 'file-chevron collapsed';
  
                  console.log('[CHEVRON] tool_use msg.id:', msg.id, 'expanded:', expandedFiles[msg.id]);
  
                  return h('div', { className: 'message tool-message' }, [
                      h('div', {
                          className: 'message-prefix ' + chevronClass + ' ' + bulletClass,
                          onclick: () => {
                              if (uiController) {
                                  uiController.expandedFiles[msg.id] = !uiController.expandedFiles[msg.id];
                                  console.log('[CHEVRON CLICK] toggled msg.id:', msg.id, 'new value:', uiController.expandedFiles[msg.id]);
                                  uiController.refreshRender();
                              }
                          }
                      }, text(' ')),
                      h('div', {
                          className: 'tool-header clickable-header',
                          onclick: () => {
                              if (uiController) {
                                  uiController.expandedFiles[msg.id] = !uiController.expandedFiles[msg.id];
                                  uiController.refreshRender();
                              }
                          }
                      }, [
                          h('span', { className: 'tool-name tool-name-bold' }, text(displayName)),
                          params ? text(' ' + params) : null
                      ])
                  ]);
              } else {
                  // Show regular bullet without chevron
                  return h('div', { className: 'message tool-message' }, [
                      h('div', { className: 'message-prefix ' + bulletClass }, text(' ')),
                      h('div', { className: 'tool-header' }, [
                          h('span', { className: 'tool-name tool-name-bold' }, text(displayName)),
                          params ? text(' ' + params) : null
                      ])
                  ]);
              }
          }
  
          return h('div', { className: 'message tool-message' }, [
              h('div', { className: 'message-prefix ' + bulletClass }, text(' ')),
              h('div', { className: 'tool-header' }, [
                  h('span', { className: 'tool-name tool-name-bold' }, text(formatToolName(msg.toolName))),
                  params ? text(' ' + params) : null
              ])
          ]);
      }
  
      function renderToolResult(msg, allMessages, index, state) {
          // Hide manage_checklist result when action is 'add' during planning
          if (msg.toolName === 'manage_checklist' && msg.result && msg.result.action === 'add' && state.mode === 'planning') {
              return null;
          }
  
          // Custom rendering for begin_execution with pending approval
          if (msg.toolName === 'begin_execution' && msg.result && msg.result.status === 'pending_approval') {
              return renderPlanApproval(msg.result);
          }
  
          // Hide begin_execution result when auto-approved
          if (msg.toolName === 'begin_execution' && msg.result && msg.result.status === 'auto_approved') {
              return null;
          }
  
          // Hide review_pass and review_fail tool results (we show custom bars instead)
          if (msg.toolName === 'review_pass' || msg.toolName === 'review_fail') {
              return null;
          }
  
          // Custom rendering for begin_execution
          if (msg.toolName === 'begin_execution' && msg.result && msg.result.checklist) {
              return renderBeginExecutionChecklist(msg.result.checklist);
          }
  
          // Custom rendering for task_start
          if (msg.toolName === 'task_start' && msg.result) {
              return renderTaskStart(msg.result);
          }
  
          // Custom rendering for review_start
          if (msg.toolName === 'review_start' && msg.result) {
              return renderReviewStart(msg.result);
          }
  
          // Custom rendering for review_end
          if (msg.toolName === 'review_end' && msg.result) {
              return renderReviewEnd(msg.result);
          }
  
          // Custom rendering for mark_complete
          if (msg.toolName === 'mark_complete' && msg.result) {
              return renderMarkComplete(msg.result);
          }
  
          // Custom rendering for create_file and update_file - show actual content
          if ((msg.toolName === 'create_file' || msg.toolName === 'update_file') && msg.result && !msg.result.error) {
              const toolUseMsg = findToolUseMessage(allMessages, msg.tool_use_id);
              if (toolUseMsg && toolUseMsg.parameters) {
                  // Always show content (either preview or full)
                  const uiController = window.module.uiControllerInstance;
                  const expandedFiles = uiController ? uiController.expandedFiles : {};
                  const showFullContent = expandedFiles[msg.tool_use_id] === true;
                  console.log('[TOOL_RESULT] msg.tool_use_id:', msg.tool_use_id, 'expanded:', expandedFiles[msg.tool_use_id], 'showFullContent:', showFullContent);
                  return renderFileContent(msg.toolName, toolUseMsg.parameters, msg.result, msg.tool_use_id, showFullContent);
              }
          }
  
          // Custom rendering for update_file_batch - show all diffs with separators
          if (msg.toolName === 'update_file_batch' && msg.result && !msg.result.error) {
              const toolUseMsg = findToolUseMessage(allMessages, msg.tool_use_id);
              if (toolUseMsg && toolUseMsg.parameters) {
                  const uiController = window.module.uiControllerInstance;
                  const expandedFiles = uiController ? uiController.expandedFiles : {};
                  const showFullContent = expandedFiles[msg.tool_use_id] === true;
                  return renderBatchFileContent(toolUseMsg.parameters, msg.result, msg.tool_use_id, showFullContent);
              }
          }
  
          const resultLines = formatToolResult(msg.toolName, msg.result);
          return h('div', { className: 'message tool-result' },
              resultLines.map(line => {
                  const className = line.startsWith('  +') ? 'diff-add' :
                                  line.startsWith('  -') ? 'diff-remove' :
                                  line.startsWith('  ') ? 'success' :
                                  line.startsWith('  Oops,') ? 'tool-error' : 'result-line';
                  return h('div', { className }, text(line));
              })
          );
      }
  
      function renderError(msg) {
          // Special rendering for recoverable AI errors (formatting_error and multiple_update_file_error)
          if (msg.toolName === 'formatting_error' || msg.toolName === 'multiple_update_file_error') {
              const lines = [];
              if (msg.result && msg.result.error) {
                  // Build main message with friendly tone
                  const mainMessage = 'Oops, invalid message. Try again, AI!';
                  lines.push(h('div', { className: 'recoverable-error-content' }, text(mainMessage)));
  
                  // Add error details in muted style
                  if (msg.result.hint) {
                      lines.push(h('div', { className: 'recoverable-error-hint' }, text('  ' + msg.result.hint)));
                  }
                  if (msg.result.attempt && msg.result.max_attempts) {
                      lines.push(h('div', { className: 'recoverable-error-hint' },
                          text('  Attempt ' + msg.result.attempt + ' of ' + msg.result.max_attempts)));
                  }
              }
              return h('div', { className: 'message recoverable-error-message' }, [
                  h('div', { className: 'message-prefix recoverable-error-prefix' }, text('! ')),
                  h('div', { className: 'recoverable-error-body' }, lines)
              ]);
          }
  
          // Default error rendering for other error types
          const lines = [];
          if (msg.result && msg.result.error) {
              lines.push(h('div', { className: 'error' }, text('   ' + msg.result.error)));
              if (msg.result.hint) {
                  lines.push(h('div', { className: 'error-hint' }, text('     ' + msg.result.hint)));
              }
              if (msg.result.attempt && msg.result.max_attempts) {
                  lines.push(h('div', { className: 'error-hint' },
                      text('     Attempt ' + msg.result.attempt + ' of ' + msg.result.max_attempts)));
              }
          }
          return h('div', { className: 'message error-message' }, lines);
      }
  
      function formatToolName(toolName) {
          // Convert snake_case to Title Case
          // e.g., "search_files_by_name" -> "Search Files By Name"
          return toolName
              .split('_')
              .map(word => word.charAt(0).toUpperCase() + word.slice(1))
              .join(' ');
      }
  
      function formatParams(params) {
          if (!params) return '';
  
          // Special formatting for search tools - show what we're searching for
          if (params.pattern) {
              const pattern = '"' + params.pattern + '"';
              const dir = params.directory_path || '.';
              return pattern + ' in ' + dir;
          }
  
          // Test/process management tools - show name
          if (params.name) {
              return params.name;
          }
  
          // Stop test - show pid or name
          if (params.pid) {
              return 'PID ' + params.pid;
          }
  
          // Git tools - show the command
          if (params.git_args) {
              return 'git ' + params.git_args;
          }
  
          // Fall back to file_path or directory_path
          if (params.file_path) return params.file_path;
          if (params.directory_path) return params.directory_path;
          return '';
      }
  
      function formatToolResult(toolName, result) {
          if (!result) return ['  No result'];
  
          if (result.error) {
              // Friendly error messages for common cases
              if (result.error.includes('could not be found') || result.error.includes('NotFoundError')) {
                  return ['  Oops, that file doesn\'t exist, AI!'];
              }
              return ['  Oops, ' + result.error];
          }
  
          const lines = [];
  
          switch (toolName) {
              case 'formatting_error':
                  if (result.error) {
                      lines.push('   ' + result.error);
                      if (result.hint) {
                          lines.push('     ' + result.hint);
                      }
                      if (result.attempt && result.max_attempts) {
                          lines.push('     Attempt ' + result.attempt + ' of ' + result.max_attempts);
                      }
                  }
                  break;
  
              case 'read_file':
                  if (result.lines !== undefined) {
                      lines.push('  Read ' + result.lines + ' lines');
                  }
                  break;
  
              case 'list_files':
                  if (result.count !== undefined) {
                      lines.push('  Listed ' + result.count + ' items');
                  }
                  break;
  
              case 'create_file':
                  if (result.created) {
                      lines.push('   Created ' + result.file_path);
                  }
                  break;
  
              case 'update_file':
                  if (result.updated) {
                      lines.push('   Updated ' + result.file_path);
                  }
                  if (result.diff) {
                      lines.push(...formatDiff(result.diff));
                  }
                  break;
  
              case 'delete_file':
                  if (result.deleted) {
                      lines.push('   Deleted ' + result.file_path);
                  }
                  break;
  
              case 'manage_checklist':
                  if (result.action === 'add') {
                      lines.push('   Added item: ' + result.id);
                  } else if (result.action === 'list') {
                      lines.push('  ' + result.count + ' items');
                  }
                  break;
  
              case 'search_files_by_name':
                  if (result.count !== undefined) {
                      const fileWord = result.count === 1 ? 'file' : 'files';
                      const hasTimeout = result.warning && result.warning.toLowerCase().includes('timeout');
                      const timeoutText = hasTimeout ? ' (timed out)' : '';
                      lines.push('  Found ' + result.count + ' ' + fileWord + timeoutText);
                  }
                  break;
  
              case 'search_files_by_content':
                  if (result.count !== undefined) {
                      const matchWord = result.count === 1 ? 'match' : 'matches';
                      const hasTimeout = result.warning && result.warning.toLowerCase().includes('timeout');
                      const timeoutText = hasTimeout ? ' (timed out)' : '';
                      lines.push('  Found ' + result.count + ' ' + matchWord + timeoutText);
                  }
                  break;
  
              default:
                  if (result.success !== undefined) {
                      lines.push(result.success ? '   Success' : '   Failed');
                  } else {
                      lines.push('  Completed');
                  }
          }
  
          return lines.length > 0 ? lines : ['  Completed'];
      }
  
      function formatDiff(diff) {
          if (typeof diff === 'string') {
              return diff.split('\n').map(line => '  ' + line);
          }
          return ['  (diff)'];
      }
  
      function renderLoading() {
          return h('div', { className: 'message loading-message' }, [
              h('div', { className: 'loading-bubble' }, [
                  h('span', { className: 'loading-dot' }),
                  h('span', { className: 'loading-dot' }),
                  h('span', { className: 'loading-dot' })
              ])
          ]);
      }
  
      function renderModeTransition(msg) {
          // Hide mode transitions in the UI
          return null;
      }
  
      function renderPlanApproval(result) {
          const elements = [];
  
          // Plan box with lined paper style
          const planBoxElements = [];
  
          // Plan header
          planBoxElements.push(
              h('div', { className: 'plan-header' }, text('Plan'))
          );
  
          // Plan description
          if (result.description) {
              planBoxElements.push(
                  h('div', { className: 'plan-description' },
                      text(result.description)
                  )
              );
          }
  
          // Checklist preview
          if (result.checklist_preview && result.checklist_preview.length > 0) {
              const checklistItems = result.checklist_preview.map(item =>
                  h('div', { className: 'plan-checklist-item' }, [
                      h('span', { className: 'plan-checkbox' }, text(' ')),
                      h('span', { className: 'plan-item-content' }, text(item.content || item.short_desc || '(no description)'))
                  ])
              );
  
              planBoxElements.push(
                  h('div', { className: 'plan-checklist' }, checklistItems)
              );
          }
  
          elements.push(
              h('div', { className: 'plan-box' }, planBoxElements)
          );
  
          // Approval message (question from AI) below the box in terminal style
          if (result.approval_message) {
              elements.push(
                  h('div', { className: 'approval-question' },
                      text(result.approval_message)
                  )
              );
          }
  
          return h('div', { className: 'message plan-approval-message' }, elements);
      }
  
      function renderBeginExecutionChecklist(checklist) {
          if (!checklist || checklist.length === 0) {
              return null;
          }
  
          return h('div', { className: 'message begin-execution-checklist' },
              checklist.map(item => {
                  const checkbox = item.completed ? '[\u2713]' : '[ ]';
                  return h('div', { className: 'execution-checklist-item' }, [
                      h('span', { className: 'execution-checkbox' }, text(checkbox + ' ')),
                      text(item.content || item.short_desc || item.shortDesc || '(no description)')
                  ]);
              })
          );
      }
  
      function renderMarkComplete(result) {
          const elements = [];
  
          // Task completion notification with strikethrough
          if (result.content) {
              elements.push(
                  h('div', { className: 'task-complete-notification' }, [
                      h('span', { className: 'task-complete-icon' }, text('')),
                      h('span', { className: 'task-complete-content' }, text(result.content))
                  ])
              );
          }
  
          // Next task start notification
          if (result.next_task && result.total_items && result.completed_count) {
              const nextTaskNum = result.completed_count + 1;
              const progressText = nextTaskNum + '/' + result.total_items + ': ' + result.next_task.content;
              elements.push(
                  h('div', { className: 'task-start-notification' }, [
                      h('span', { className: 'task-start-icon' }, text('')),
                      h('span', { className: 'task-start-content' }, text(progressText))
                  ])
              );
          }
  
          return h('div', { className: 'message mark-complete-message' }, elements);
      }
  
      // Helper function to find tool_use message by tool_use_id
      function findToolUseMessage(allMessages, toolUseId) {
          return allMessages.find(m => m.type === 'tool_use' && m.id === toolUseId);
      }
  
      // Simple line-by-line diff algorithm
      function computeLineDiff(oldText, newText) {
          const oldLines = oldText.split('\n');
          const newLines = newText.split('\n');
          const result = [];
  
          // Simple LCS-based diff
          const lcs = computeLCS(oldLines, newLines);
          let oldIndex = 0;
          let newIndex = 0;
          let lcsIndex = 0;
  
          while (oldIndex < oldLines.length || newIndex < newLines.length) {
              if (lcsIndex < lcs.length &&
                  oldIndex < oldLines.length &&
                  newIndex < newLines.length &&
                  oldLines[oldIndex] === lcs[lcsIndex] &&
                  newLines[newIndex] === lcs[lcsIndex]) {
                  // Line unchanged
                  result.push({
                      type: 'unchanged',
                      content: oldLines[oldIndex],
                      oldLineNum: oldIndex + 1,
                      newLineNum: newIndex + 1
                  });
                  oldIndex++;
                  newIndex++;
                  lcsIndex++;
              } else if (oldIndex < oldLines.length &&
                         (lcsIndex >= lcs.length || oldLines[oldIndex] !== lcs[lcsIndex])) {
                  // Line removed
                  result.push({
                      type: 'removed',
                      content: oldLines[oldIndex],
                      oldLineNum: oldIndex + 1
                  });
                  oldIndex++;
              } else if (newIndex < newLines.length) {
                  // Line added
                  result.push({
                      type: 'added',
                      content: newLines[newIndex],
                      newLineNum: newIndex + 1
                  });
                  newIndex++;
              }
          }
  
          return result;
      }
  
      // Compute longest common subsequence for diff
      function computeLCS(arr1, arr2) {
          const m = arr1.length;
          const n = arr2.length;
          const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  
          for (let i = 1; i <= m; i++) {
              for (let j = 1; j <= n; j++) {
                  if (arr1[i - 1] === arr2[j - 1]) {
                      dp[i][j] = dp[i - 1][j - 1] + 1;
                  } else {
                      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                  }
              }
          }
  
          // Backtrack to find LCS
          const lcs = [];
          let i = m;
          let j = n;
          while (i > 0 && j > 0) {
              if (arr1[i - 1] === arr2[j - 1]) {
                  lcs.unshift(arr1[i - 1]);
                  i--;
                  j--;
              } else if (dp[i - 1][j] > dp[i][j - 1]) {
                  i--;
              } else {
                  j--;
              }
          }
  
          return lcs;
      }
  
      // Render file content for create_file and update_file
      function renderFileContent(toolName, parameters, result, toolUseId, showFullContent) {
          const maxLines = 10;
  
          if (toolName === 'create_file') {
              // Show each line with green "+" prefix like a diff
              const content = parameters.content || '';
              const lines = content.split('\n');
  
              const uiController = window.module.uiControllerInstance;
              const expandedFiles = uiController ? uiController.expandedFiles : {};
              console.log('[RENDER] create_file:', {
                  toolUseId,
                  totalLines: lines.length,
                  showFullContent,
                  expandedFilesValue: expandedFiles[toolUseId]
              });
  
              // If file has <= 10 lines, always show full content (no preview mode)
              // Otherwise, show preview (10 lines) or full content based on showFullContent state
              const linesToShow = lines.length <= maxLines ? lines :
                                 (showFullContent ? lines : lines.slice(0, maxLines));
  
              const lineElements = linesToShow.map((line, index) => {
                  const lineNum = (index + 1).toString().padStart(3, ' ');
                  const isLastLine = index === linesToShow.length - 1;
                  const shouldShowMore = lines.length > maxLines && !showFullContent && isLastLine;
  
                  return h('div', {
                      className: 'diff-line diff-add',
                      key: `${toolUseId}-line-${index + 1}`  // Unique key for proper VDOM diffing
                  }, [
                      h('span', { className: 'diff-line-number' }, text(lineNum)),
                      h('span', { className: 'diff-line-content' }, text(' + ' + line)),
                      shouldShowMore ? h('span', {
                          className: 'show-more-link',
                          onclick: () => {
                              if (uiController) {
                                  uiController.expandedFiles[toolUseId] = true;
                                  uiController.refreshRender();
                              }
                          }
                      }, text('show more')) : null
                  ]);
              });
  
              console.log('[CREATE_FILE] toolUseId:', toolUseId, 'linesToShow.length:', linesToShow.length, 'lineElements.length:', lineElements.length, 'showFullContent:', showFullContent);
  
              console.log('[CREATE_FILE] Returning lineElements.length:', lineElements.length, 'keys:', lineElements.map(el => el.props?.key).join(', '));
  
              return h('div', {
                  className: 'message tool-result file-content-result',
                  key: `${toolUseId}-content`  // Add key to container to help VDOM
              }, lineElements);
          } else if (toolName === 'update_file') {
              // Show line-by-line diff with + for additions and - for removals
              const oldContent = parameters.old_content || '';
              const newContent = parameters.new_content || '';
  
              // Get start_line from result (similar to update_file_batch)
              const startLine = result && result.start_line ? result.start_line : 1;
  
              const diffLines = computeLineDiff(oldContent, newContent);
              const visibleLines = diffLines.filter(line => line.type !== 'unchanged');
  
              // If diff has <= 10 lines, always show full content (no preview mode)
              // Otherwise, show preview (10 lines) or full content based on showFullContent state
              const linesToShow = visibleLines.length <= maxLines ? visibleLines :
                                 (showFullContent ? visibleLines : visibleLines.slice(0, maxLines));
  
              const lineElements = linesToShow.map((line, index) => {
                  // Calculate actual file line number using start_line
                  let lineNum;
                  if (line.type === 'added' && line.newLineNum !== undefined) {
                      // For added lines, calculate from start line + offset in new content
                      lineNum = startLine + line.newLineNum - 1;
                  } else if (line.type === 'removed' && line.oldLineNum !== undefined) {
                      // For removed lines, use start line + offset in old content
                      lineNum = startLine + line.oldLineNum - 1;
                  } else {
                      // Fallback
                      lineNum = startLine;
                  }
  
                  const className = line.type === 'added' ? 'diff-line diff-add' : 'diff-line diff-remove';
                  const prefix = line.type === 'added' ? ' + ' : ' - ';
  
                  const isLastLine = index === linesToShow.length - 1;
                  const shouldShowMore = visibleLines.length > maxLines && !showFullContent && isLastLine;
  
                  return h('div', {
                      className,
                      key: `${toolUseId}-${line.type}-${lineNum}`  // Use actual line number in key
                  }, [
                      h('span', { className: 'diff-line-number' }, text(lineNum.toString().padStart(3, ' '))),
                      h('span', { className: 'diff-line-content' }, text(prefix + line.content)),
                      shouldShowMore ? h('span', {
                          className: 'show-more-link',
                          onclick: () => {
                              const uiController = window.module.uiControllerInstance;
                              if (uiController) {
                                  uiController.expandedFiles[toolUseId] = true;
                                  uiController.refreshRender();
                              }
                          }
                      }, text('show more')) : null
                  ]);
              });
  
              return h('div', {
                  className: 'message tool-result file-content-result',
                  key: `${toolUseId}-content`  // Add key to container to help VDOM
              }, lineElements);
          }
  
          return null;
      }
  
      // Render batch file updates with blank line separators between diffs
      function renderBatchFileContent(parameters, result, toolUseId, showFullContent) {
          const maxLines = 10;
          const updates = JSON.parse(parameters.updates || '[]');
  
          // Get updates_detail from result if available (includes line numbers)
          const updatesDetail = result && result.updates_detail ? result.updates_detail : [];
  
          if (!updates || updates.length === 0) {
              return h('div', { className: 'message tool-result' }, [text('  No updates')]);
          }
  
          // Calculate total visible lines across all updates to determine if we should preview
          let totalVisibleLines = 0;
          const allVisibleLines = [];
  
          updates.forEach((update) => {
              const oldContent = update.old_content || '';
              const newContent = update.new_content || '';
              const diffLines = computeLineDiff(oldContent, newContent);
              const visibleLines = diffLines.filter(line => line.type !== 'unchanged');
              allVisibleLines.push(visibleLines);
              totalVisibleLines += visibleLines.length;
          });
  
          const allElements = [];
          let linesSoFar = 0;
          const shouldShowMore = totalVisibleLines > maxLines && !showFullContent;
  
          updates.forEach((update, updateIndex) => {
              const oldContent = update.old_content || '';
              const newContent = update.new_content || '';
  
              // Get the start line from updates_detail if available
              const startLine = updatesDetail[updateIndex] ? updatesDetail[updateIndex].start_line : 1;
              console.log('[MULTI_EDIT] updateIndex:', updateIndex, 'startLine:', startLine, 'updatesDetail:', updatesDetail[updateIndex]);
  
              const visibleLines = allVisibleLines[updateIndex];
  
              // Determine lines to show for this update
              // If total lines <= 10, show all lines
              // If collapsed mode and we've shown 10 lines already, skip this update
              // If collapsed mode and we haven't hit the limit, show what we can
              let linesToShow;
              if (totalVisibleLines <= maxLines) {
                  linesToShow = visibleLines;
              } else if (showFullContent) {
                  linesToShow = visibleLines;
              } else {
                  const remainingLines = maxLines - linesSoFar;
                  if (remainingLines <= 0) {
                      // Already shown 10 lines, skip this update
                      return;
                  }
                  linesToShow = visibleLines.slice(0, remainingLines);
              }
  
              linesSoFar += linesToShow.length;
              if (updateIndex === 0) {
                  console.log('[MULTI_EDIT_LINES] updateIndex:', updateIndex, 'visibleLines.length:', visibleLines.length, 'linesToShow.length:', linesToShow.length, 'showFullContent:', showFullContent, 'linesSoFar:', linesSoFar);
              }
  
              const lineElements = linesToShow.map((line, lineIndex) => {
                  // Calculate actual file line number using the start line from Java
                  let lineNum;
                  if (line.type === 'added' && line.newLineNum !== undefined) {
                      // For added lines, calculate from start line + offset in new content
                      lineNum = startLine + line.newLineNum - 1;
                      if (updateIndex === 0 && lineIndex < 3) {
                          console.log('[LINE_CALC] ADDED updateIndex:', updateIndex, 'lineIndex:', lineIndex, 'startLine:', startLine, 'newLineNum:', line.newLineNum, ' lineNum:', lineNum);
                      }
                  } else if (line.type === 'removed' && line.oldLineNum !== undefined) {
                      // For removed lines, use start line + offset in old content
                      lineNum = startLine + line.oldLineNum - 1;
                      if (updateIndex === 0 && lineIndex < 3) {
                          console.log('[LINE_CALC] REMOVED updateIndex:', updateIndex, 'lineIndex:', lineIndex, 'startLine:', startLine, 'oldLineNum:', line.oldLineNum, ' lineNum:', lineNum);
                      }
                  } else {
                      // Fallback if line numbers are missing
                      lineNum = startLine;
                  }
  
                  const className = line.type === 'added' ? 'diff-line diff-add' : 'diff-line diff-remove';
                  const prefix = line.type === 'added' ? ' + ' : ' - ';
  
                  // Create unique key for proper VDOM diffing
                  const uniqueKey = `${toolUseId}-update${updateIndex}-${line.type}-${lineNum}`;
  
                  // Check if this is the very last line that will be shown (for "show more" link)
                  const isVeryLastLine = shouldShowMore && linesSoFar === maxLines && lineIndex === linesToShow.length - 1;
  
                  return h('div', {
                      className,
                      key: uniqueKey  // Unique key for proper VDOM diffing
                  }, [
                      h('span', { className: 'diff-line-number' }, text(lineNum.toString().padStart(3, ' '))),
                      h('span', { className: 'diff-line-content' }, text(prefix + line.content)),
                      isVeryLastLine ? h('span', {
                          className: 'show-more-link',
                          onclick: () => {
                              const uiController = window.module.uiControllerInstance;
                              if (uiController) {
                                  uiController.expandedFiles[toolUseId] = true;
                                  uiController.refreshRender();
                              }
                          }
                      }, text('show more')) : null
                  ]);
              });
  
              // Add all line elements for this update
              allElements.push(...lineElements);
  
              // Add 1 blank line between updates (but not after the last one)
              // Only add separator if we're not at the end and haven't hit the preview limit
              if (updateIndex < updates.length - 1 && (showFullContent || totalVisibleLines <= maxLines || linesSoFar < maxLines)) {
                  allElements.push(h('div', { className: 'batch-separator' }));
              }
          });
  
          return h('div', {
              className: 'message tool-result file-content-result',
              key: `${toolUseId}-content`  // Add key to container to help VDOM
          }, allElements);
      }
  
      function renderTaskStart(result) {
          if (!result.content || !result.task_number || !result.total_items) {
              return null;
          }
  
          const progressText = result.task_number + '/' + result.total_items + ': ' + result.content;
          return h('div', { className: 'message task-start-message' }, [
              h('div', { className: 'task-start-notification' }, [
                  h('span', { className: 'task-start-icon' }, text('')),
                  h('span', { className: 'task-start-content' }, text(progressText))
              ])
          ]);
      }
  
      function renderReviewStart(result) {
          const message = result.message || 'Code review checkpoint';
          return h('div', { className: 'message review-start-message' }, [
              h('div', { className: 'review-start-notification' }, [
                  h('span', { className: 'review-start-icon' }, text('')),
                  h('span', { className: 'review-start-content' }, text(message))
              ])
          ]);
      }
  
      function renderReviewEnd(result) {
          const verdict = result.verdict || 'PASS';
          const message = verdict === 'PASS' ? 'Review passed' : 'Review failed';
          return h('div', { className: 'message review-end-message' }, [
              h('div', { className: 'review-end-notification' }, [
                  h('span', { className: 'review-end-icon' }, text('')),
                  h('span', { className: 'review-end-content' }, text(message))
              ])
          ]);
      }
  
      function getModeDisplayText(mode) {
          const modeMap = {
              'planning': 'Planning...',
              'execution': 'Coding...',
              'testing': 'Testing...',
              'review': 'Reviewing...'
          };
          return modeMap[mode] || mode;
      }
  
      function renderCommandResult(msg) {
          // This message type is never displayed - it only exists to trigger clipboard copy
          // The clipboard data is in msg.result.clipboard_data
          // Copy to clipboard when this message is encountered
          if (msg.result && msg.result.clipboard_data) {
              navigator.clipboard.writeText(msg.result.clipboard_data).then(() => {
                  console.log('[UI] Command result: Copied ' + msg.result.clipboard_data.length + ' characters to clipboard');
              }).catch(err => {
                  console.error('[UI] Command result: Failed to copy to clipboard:', err);
              });
          }
          // Return null so this message is not displayed in the UI
          return null;
      }
  
      function renderApprovalRequest(msg) {
          // Render approval request as an assistant message with special styling
          const content = msg.content || '';
          const lines = content.split('\n');
  
          return h('div', { className: 'message approval-request-message' },
              lines.map(line => h('div', { className: 'approval-line' }, text(line)))
          );
      }
  
      function renderTaskComplete(msg) {
          // Render task completion message - just display the completion message
          // The continuation prompt is stored but shown via button click
          const content = parseAssistantContent(msg.completionMessage);
          return h('div', { className: 'message assistant-message task-complete-message' }, content);
      }
  
  
      window.module["render.js"] = {
          render
      };
  })();

  // ============================================================================
  // src/ui/ui-injector.js
  // ============================================================================

  /**
   * UI injector for browser-only mode
   * Replaces internal AI tool UI with Code Boss terminal interface
   */
  
  (function() {
    'use strict';
  
    /**
     * HTML template for terminal UI
     * Based on index.html from original UI
     */
    const TERMINAL_HTML = `
      <div id="code-boss-terminal">
        <div id="chat-container"></div>
        <div id="input-container">
          <textarea
            id="message-input"
            placeholder="Type your message... (Shift+Enter for new line)"
            rows="1"
          ></textarea>
        </div>
      </div>
    `;
  
    /**
     * CSS styles for terminal UI
     * Based on styles.css from original UI
     */
    const TERMINAL_CSS = `
      /* TODO: Copy full styles from src/ui/styles.css */
  
      #code-boss-terminal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        background-color: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Courier New', monospace;
        z-index: 10000;
      }
  
      #chat-container {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        scroll-behavior: smooth;
      }
  
      #input-container {
        border-top: 1px solid #3e3e3e;
        padding: 1rem;
        background-color: #252526;
      }
  
      #message-input {
        width: 100%;
        background-color: #3c3c3c;
        color: #d4d4d4;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 0.5rem;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        resize: none;
        max-height: 200px;
        overflow-y: auto;
      }
  
      #message-input:focus {
        outline: none;
        border-color: #007acc;
      }
  
      #scroll-to-bottom {
        position: fixed;
        bottom: 100px;
        right: 20px;
        width: 40px;
        height: 40px;
        background-color: #007acc;
        color: white;
        border: none;
        border-radius: 50%;
        font-size: 20px;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10001;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
  
      #scroll-to-bottom:hover {
        background-color: #005a9e;
      }
  
      /* ... rest of styles ... */
    `;
  
    /**
     * Inject terminal UI into page
     */
    function injectUI() {
      throw new Error('Not implemented: injectUI()');
  
      // TODO: Implementation
      // 1. Hide existing page content (internal AI tool UI)
      // 2. Create style element with TERMINAL_CSS
      // 3. Append styles to <head>
      // 4. Create terminal container from TERMINAL_HTML
      // 5. Append terminal to <body>
      // 6. Load morphdom library (if not already loaded)
      // 7. Return terminal element
  
      // Example:
      /*
      // Hide existing content
      const existingContent = document.body.querySelectorAll('*:not(#code-boss-terminal)');
      existingContent.forEach(el => {
        if (el.id !== 'code-boss-terminal') {
          el.style.display = 'none';
        }
      });
  
      // Add styles
      const styleEl = document.createElement('style');
      styleEl.textContent = TERMINAL_CSS;
      document.head.appendChild(styleEl);
  
      // Add terminal HTML
      const terminalEl = document.createElement('div');
      terminalEl.innerHTML = TERMINAL_HTML;
      document.body.appendChild(terminalEl.firstElementChild);
  
      // Load morphdom if needed
      if (!window.morphdom) {
        loadMorphdom();
      }
  
      return document.getElementById('code-boss-terminal');
      */
    }
  
    /**
     * Load morphdom library
     */
    function loadMorphdom() {
      throw new Error('Not implemented: loadMorphdom()');
  
      // TODO: Implementation
      // 1. Check if morphdom already loaded
      // 2. If not, inject script tag or inline morphdom code
      // 3. Wait for load
      // 4. Set window.morphdom
  
      // Option 1: Load from CDN
      /*
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/morphdom@2.7.0/dist/morphdom-umd.min.js';
      script.onload = () => {
        console.log('morphdom loaded');
      };
      document.head.appendChild(script);
      */
  
      // Option 2: Inline morphdom code (bundle it)
      // ... inline morphdom source code here ...
    }
  
    /**
     * Show directory selection UI
     * @returns {Promise<FileSystemDirectoryHandle>} Selected directory handle
     */
    function showDirectoryPicker() {
      throw new Error('Not implemented: showDirectoryPicker()');
  
      // TODO: Implementation
      // 1. Show button/modal prompting user to select directory
      // 2. On click, call window.showDirectoryPicker()
      // 3. Return directory handle
      // 4. Handle errors (user cancellation, browser not supported)
  
      // Example:
      /*
      return new Promise((resolve, reject) => {
        const modal = document.createElement('div');
        modal.innerHTML = `
          <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                      background: #252526; padding: 2rem; border-radius: 8px; z-index: 10002;">
            <h2>Select Working Directory</h2>
            <p>Choose the directory containing your project code.</p>
            <button id="select-dir-btn">Select Directory</button>
            <button id="cancel-btn">Cancel</button>
          </div>
        `;
        document.body.appendChild(modal);
  
        document.getElementById('select-dir-btn').addEventListener('click', async () => {
          try {
            const dirHandle = await window.showDirectoryPicker();
            document.body.removeChild(modal);
            resolve(dirHandle);
          } catch (error) {
            reject(error);
          }
        });
  
        document.getElementById('cancel-btn').addEventListener('click', () => {
          document.body.removeChild(modal);
          reject(new Error('User cancelled directory selection'));
        });
      });
      */
    }
  
    /**
     * Restore UI (remove terminal, show original content)
     */
    function restoreUI() {
      throw new Error('Not implemented: restoreUI()');
  
      // TODO: Implementation
      // 1. Remove terminal element
      // 2. Remove injected styles
      // 3. Show original page content
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.UIInjector = {
      injectUI,
      showDirectoryPicker,
      restoreUI
    };
  
  })();

  // ============================================================================
  // src/ui/api-local.js
  // ============================================================================

  /**
   * Local API implementation for browser-only mode
   * Replaces HTTP/SSE calls with direct function calls to AIProcessor
   */
  
  (function() {
    'use strict';
  
    /**
     * Get current conversation state
     * @returns {Promise<Object>} Current state
     */
    async function getState() {
      throw new Error('Not implemented: getState()');
  
      // TODO: Implementation
      // 1. Get ConversationManager instance
      // 2. Call conversationManager.getState()
      // 3. Return state object
      // 4. Format matches SSE format from Java version:
      //    {
      //      status: 'processing' | 'complete' | 'error',
      //      currentPhase: 'planning' | 'execution' | 'review',
      //      currentProject: 'Project Name',
      //      currentTask: 'Task Name' | null,
      //      messages: [...],
      //      checklist: [...],
      //      busy: false
      //    }
    }
  
    /**
     * Send user message and process through agentic loop
     * @param {string} message - User message
     * @param {Function} onStateUpdate - Callback for state updates
     * @returns {Promise<Object>} Final state
     */
    async function sendMessage(message, onStateUpdate) {
      throw new Error('Not implemented: sendMessage()');
  
      // TODO: Implementation
      // 1. Get AIProcessor instance
      // 2. Subscribe to state updates via EventBus
      // 3. Call aiProcessor.processUserMessage(message)
      // 4. On each state update event:
      //    a. Call onStateUpdate(state)
      //    b. Check if status is 'complete' or 'error'
      //    c. If so, unsubscribe and return final state
      // 5. Return final state
  
      // Example flow:
      /*
      const aiProcessor = window.module.aiProcessorInstance;
      const eventBus = window.module.EventBus;
  
      return new Promise((resolve, reject) => {
        // Subscribe to state changes
        const unsubscribe = eventBus.on('state:changed', (state) => {
          try {
            onStateUpdate(state);
  
            if (state.status === 'complete' || state.status === 'error') {
              unsubscribe();
              resolve(state);
            }
          } catch (error) {
            console.error('[API] Error in state update callback:', error);
          }
        });
  
        // Start processing
        aiProcessor.processUserMessage(message).catch(error => {
          console.error('[API] Error processing message:', error);
          unsubscribe();
          reject(error);
        });
      });
      */
    }
  
    /**
     * Send command (e.g., /help, /undo)
     * @param {string} command - Command name
     * @param {Array} args - Command arguments
     * @param {Function} onStateUpdate - Callback for state updates
     * @returns {Promise<Object>} Final state
     */
    async function sendCommand(command, args, onStateUpdate) {
      throw new Error('Not implemented: sendCommand()');
  
      // TODO: Implementation
      // 1. Get CommandHandler or AIProcessor instance
      // 2. Route to appropriate command handler
      // 3. Process and return state updates
      // 4. Similar pattern to sendMessage()
    }
  
    /**
     * Approve checklist (user approves begin_execution)
     * @param {boolean} approved - Whether user approved
     * @param {Function} onStateUpdate - Callback for state updates
     * @returns {Promise<Object>} Final state
     */
    async function approveChecklist(approved, onStateUpdate) {
      throw new Error('Not implemented: approveChecklist()');
  
      // TODO: Implementation
      // 1. Get AIProcessor instance
      // 2. Call aiProcessor.handleChecklistApproval(approved)
      // 3. Return state updates via callback
      // 4. If approved: transition to execution phase
      // 5. If rejected: return to planning
    }
  
    /**
     * Interrupt current AI processing
     * @returns {Promise<void>}
     */
    async function interrupt() {
      throw new Error('Not implemented: interrupt()');
  
      // TODO: Implementation
      // 1. Get AIProcessor instance
      // 2. Set interrupt flag
      // 3. Stop current agentic loop
      // 4. Return control to user
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module['api-local.js'] = {
      getState,
      sendMessage,
      sendCommand,
      approveChecklist,
      interrupt
    };
  
  })();

  // ============================================================================
  // src/ui/main-local.js
  // ============================================================================

  /**
   * Local main UI controller for browser-only mode
   * Modified version of main.js that uses local API instead of HTTP
   */
  
  (function() {
    'use strict';
  
    const { render } = window.module['render.js'];
    const { getState, sendMessage, approveChecklist } = window.module['api-local.js'];
    const { createDOMNode } = window.module['vdom.js'];
    const morphdom = window.morphdom;
  
    let currentState = null;
    let isProcessing = false;
  
    // Local UI state (not from conversation state)
    const localState = {
      expandedFiles: {}
    };
  
    const chatContainer = document.getElementById('chat-container');
    const messageInput = document.getElementById('message-input');
    let scrollButton = null;
  
    // Track scroll state for button visibility
    let lastMessageCountAtBottom = 0;
    let mouseNearBottom = false;
    let shouldMaintainScrollLock = false;
  
    /**
     * Update UI with new state
     * @param {Object} newState - New conversation state
     */
    function updateUI(newState) {
      throw new Error('Not implemented: updateUI() - copy implementation from main.js');
  
      // TODO: Copy full implementation from main.js (lines 24-68)
      // This is identical to HTTP version
    }
  
    /**
     * Check if scrolled near bottom
     * @returns {boolean}
     */
    function isNearBottom() {
      throw new Error('Not implemented: isNearBottom() - copy implementation from main.js');
  
      // TODO: Copy from main.js (lines 70-75)
    }
  
    /**
     * Handle scroll events
     */
    function handleScroll() {
      throw new Error('Not implemented: handleScroll() - copy implementation from main.js');
  
      // TODO: Copy from main.js (lines 77-92)
    }
  
    /**
     * Check if new messages since last bottom scroll
     * @returns {boolean}
     */
    function hasNewMessagesSinceBottom() {
      throw new Error('Not implemented: hasNewMessagesSinceBottom() - copy from main.js');
  
      // TODO: Copy from main.js (lines 94-97)
    }
  
    /**
     * Update scroll button visibility
     */
    function updateScrollButtonVisibility() {
      throw new Error('Not implemented: updateScrollButtonVisibility() - copy from main.js');
  
      // TODO: Copy from main.js (lines 99-110)
    }
  
    /**
     * Scroll chat to bottom
     */
    function scrollToBottom() {
      throw new Error('Not implemented: scrollToBottom() - copy from main.js');
  
      // TODO: Copy from main.js (lines 112-127)
    }
  
    /**
     * Create scroll-to-bottom button
     */
    function createScrollButton() {
      throw new Error('Not implemented: createScrollButton() - copy from main.js');
  
      // TODO: Copy from main.js (lines 129-136)
    }
  
    /**
     * Show scroll button
     */
    function showScrollButton() {
      throw new Error('Not implemented: showScrollButton() - copy from main.js');
  
      // TODO: Copy from main.js (lines 138-142)
    }
  
    /**
     * Hide scroll button
     */
    function hideScrollButton() {
      throw new Error('Not implemented: hideScrollButton() - copy from main.js');
  
      // TODO: Copy from main.js (lines 144-148)
    }
  
    /**
     * Auto-resize message input
     */
    function autoResize() {
      throw new Error('Not implemented: autoResize() - copy from main.js');
  
      // TODO: Copy from main.js (lines 150-160)
    }
  
    /**
     * Handle message submit
     * @param {KeyboardEvent} event
     */
    function handleSubmit(event) {
      throw new Error('Not implemented: handleSubmit()');
  
      // TODO: Similar to main.js (lines 162-184) but:
      // 1. Check for special commands (/, /help, /undo, etc.)
      // 2. If command, route to command handler
      // 3. Otherwise, call sendMessage() from api-local.js
      // 4. Handle state updates via callback
  
      // Example:
      /*
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        if (isProcessing) return;
  
        const message = messageInput.value.trim();
        if (!message) return;
  
        // Check for commands
        if (message.startsWith('/')) {
          handleCommand(message);
          return;
        }
  
        messageInput.value = '';
        messageInput.style.height = 'auto';
        messageInput.disabled = true;
        isProcessing = true;
  
        sendMessage(message, updateUI).catch(error => {
          console.error('[UI] Error sending message:', error);
          isProcessing = false;
          messageInput.disabled = false;
          messageInput.focus();
        });
      }
      */
    }
  
    /**
     * Handle special commands
     * @param {string} message - Command message
     */
    function handleCommand(message) {
      throw new Error('Not implemented: handleCommand()');
  
      // TODO: Implementation
      // 1. Parse command and arguments
      // 2. Route to appropriate handler:
      //    - /help  show help message
      //    - /undo [n]  undo last n operations
      //    - /interrupt  interrupt AI processing
      //    - /copyjs  copy bundled JS to clipboard
      //    - /mousecapture  enable mouse text capture
      // 3. Update UI with result
    }
  
    /**
     * Handle checklist approval
     * @param {boolean} approved - Whether user approved
     */
    function handleChecklistApproval(approved) {
      throw new Error('Not implemented: handleChecklistApproval()');
  
      // TODO: Implementation
      // 1. Disable approval buttons
      // 2. Call approveChecklist() from api-local.js
      // 3. Update UI via callback
      // 4. Re-enable message input
    }
  
    /**
     * Start UI
     */
    async function start() {
      throw new Error('Not implemented: start()');
  
      // TODO: Implementation
      // 1. Create scroll button
      // 2. Setup event listeners (mostly same as main.js)
      // 3. Load initial state via getState()
      // 4. Update UI with initial state
      // 5. Focus message input
      // 6. Subscribe to global events via EventBus:
      //    - checklist_needs_approval  show approval UI
      //    - phase_changed  update UI
      //    - error  show error message
  
      // Example:
      /*
      console.log('Code Boss Local UI starting...');
  
      createScrollButton();
  
      const inputContainer = document.getElementById('input-container');
      inputContainer.addEventListener('click', (e) => {
        if (e.target === inputContainer) {
          messageInput.focus();
        }
      });
  
      // Mouse tracking (same as main.js)
      document.addEventListener('mousemove', (e) => {
        const buttonY = window.innerHeight - 100;
        const inputContainerTop = inputContainer.getBoundingClientRect().top;
        mouseNearBottom = e.clientY >= buttonY || e.clientY >= inputContainerTop;
        if (!isNearBottom()) {
          updateScrollButtonVisibility();
        }
      });
  
      messageInput.addEventListener('keydown', handleSubmit);
      messageInput.addEventListener('input', autoResize);
      chatContainer.addEventListener('scroll', handleScroll);
  
      // Subscribe to events
      const eventBus = window.module.EventBus;
      eventBus.on('checklist:needs_approval', (data) => {
        // Show approval UI
        currentState.status = 'awaiting_approval';
        currentState.pendingChecklist = data;
        updateUI(currentState);
      });
  
      try {
        const initialState = await getState();
        updateUI(initialState);
        if (initialState.messages && initialState.messages.length > 0) {
          scrollToBottom();
          lastMessageCountAtBottom = initialState.messages.length;
        }
      } catch (error) {
        console.error('Failed to load initial state:', error);
        updateUI({
          status: 'error',
          messages: [],
          error: 'Failed to initialize Code Boss'
        });
      }
  
      messageInput.focus();
      */
    }
  
    /**
     * Refresh render (for local state changes)
     */
    function refreshRender() {
      throw new Error('Not implemented: refreshRender() - copy from main.js');
  
      // TODO: Copy from main.js (lines 238-244)
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module['main-local.js'] = {
      start,
      refreshRender,
      localState
    };
  
  })();

  // ============================================================================
  // src/ui-controller.js
  // ============================================================================

  /**
   * ui-controller.js
   *
   * Terminal UI using Virtual DOM pattern:
   * - Declarative rendering with morphdom
   * - React-style state updates
   * - No duplicate messages
   * - Loading animations
   */
  
  (function() {
    'use strict';
  
    class UIController {
      constructor() {
        this.onUserInput = null;
        this.onDirectorySelect = null;
        this.state = {
          messages: [],
          isProcessing: false,
          inputEnabled: true,
          currentScreen: 'welcome',
          sidebar: {
            projects: [],
            currentProject: null,
            currentTask: null,
            isMinimized: false,
            activeTab: 'projects' // 'projects' or 'memory'
          },
          modal: {
            showCreateProject: false,
            showFileContent: false,
            projectName: '',
            projectDescription: '',
            fileName: '',
            content: '',
            error: null
          },
          currentProject: null,
          currentTask: null
        };
  
        // Scroll state management
        this.lastMessageCountAtBottom = 0;
        this.mouseNearBottom = false;
        this.shouldMaintainScrollLock = false;
        this.scrollButton = null;
  
        // File expansion state for diff display
        this.expandedFiles = {};
  
        // Expose this instance globally for render.js to access
        window.module.uiControllerInstance = this;
      }
  
      /**
       * Initialize the UI
       * @param {string} containerId - ID of container element
       */
      initialize(containerId) {
        this.containerId = containerId;
        const container = document.getElementById(containerId);
        if (!container) {
          throw new Error(`Container #${containerId} not found`);
        }
  
        // Initial render of the app using VDOM
        this.renderApp();
  
        this.injectStyles();
        this.setupEventListeners();
        this.createScrollButton();
  
        console.log('[UIController] UI initialized');
      }
  
      /**
       * Set up event listeners (called once during init)
       * @private
       */
      setupEventListeners() {
        // Global mouse tracking for scroll button
        document.addEventListener('mousemove', (e) => {
          const inputContainer = document.getElementById('input-container');
          if (!inputContainer) return;
  
          const buttonY = window.innerHeight - 100;
          const inputContainerTop = inputContainer.getBoundingClientRect().top;
          this.mouseNearBottom = e.clientY >= buttonY || e.clientY >= inputContainerTop;
  
          if (!this.isNearBottom()) {
            this.updateScrollButtonVisibility();
          }
        });
  
        // Attach initial screen listeners based on state
        if (this.state.currentScreen === 'welcome') {
          this.attachWelcomeEventListeners();
        } else {
          this.attachChatEventListeners();
        }
      }
  
      /**
       * Attach event listeners for welcome screen
       * @private
       */
      attachWelcomeEventListeners() {
        const dirButton = document.getElementById('select-directory-btn');
        if (dirButton && !dirButton._hasListener) {
          dirButton._hasListener = true;
          dirButton.addEventListener('click', () => {
            if (this.onDirectorySelect) {
              this.onDirectorySelect();
            }
          });
        }
      }
  
      /**
       * Attach event listeners for chat screen
       * @private
       */
      attachChatEventListeners() {
        const input = document.getElementById('message-input');
        const chatContainer = document.getElementById('chat-container');
        const inputContainer = document.getElementById('input-container');
  
        if (!input || !chatContainer || !inputContainer) return;
  
        // Auto-grow textarea
        if (!input._hasInputListener) {
          input._hasInputListener = true;
          input.addEventListener('input', () => {
            input.style.height = 'auto';
            input.style.height = input.scrollHeight + 'px';
          });
        }
  
        // Enter to send
        if (!input._hasKeydownListener) {
          input._hasKeydownListener = true;
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              this.handleSend();
            }
          });
        }
  
        // Scroll tracking for smart auto-scroll
        if (!chatContainer._hasScrollListener) {
          chatContainer._hasScrollListener = true;
          chatContainer.addEventListener('scroll', () => this.handleScroll());
        }
  
        // Focus input when clicking in input container OR handle start new task button
        if (!inputContainer._hasClickListener) {
          inputContainer._hasClickListener = true;
          inputContainer.addEventListener('click', (e) => {
            // Handle "Start New Task" button
            if (e.target.id === 'start-new-task-btn') {
              this.handleStartNewTask();
            } else if (e.target === inputContainer && input) {
              input.focus();
            }
          });
        }
      }
  
      /**
       * Main update function - React-style
       * Call this whenever state changes
       */
      updateUI(newState) {
        this.state = { ...this.state, ...newState };
        this.renderApp();
      }
  
      /**
       * Render the entire app using VDOM
       * @private
       */
      renderApp() {
        const container = document.getElementById(this.containerId);
        if (!container) return;
  
        // Check scroll state before render (for chat screen)
        const chatContainer = document.getElementById('chat-container');
        const wasNearBottom = chatContainer ? this.isNearBottom() : false;
        if (wasNearBottom) {
          this.shouldMaintainScrollLock = true;
        }
  
        // Generate virtual DOM for entire app
        const { render } = window.module["render.js"];
        const { createDOMNode } = window.module["vdom.js"];
        if (!render) {
          console.error('[UIController] render function not found in window.module["render.js"]');
          return;
        }
        const vnode = render(this.state);
        const newDOM = createDOMNode(vnode);
  
        // Efficiently patch DOM with morphdom
        if (container.children.length === 0) {
          container.appendChild(newDOM);
        } else {
          window.morphdom(container.firstChild, newDOM);
        }
  
        // After DOM update, handle scroll and event listeners
        if (this.state.currentScreen === 'chat') {
          // Re-attach event listeners that may have been lost during morph
          this.attachChatEventListeners();
  
          // Scroll if needed
          if (this.shouldMaintainScrollLock || wasNearBottom) {
            this.scrollToBottom();
          }
  
          // Update button visibility
          this.updateScrollButtonVisibility();
        } else if (this.state.currentScreen === 'welcome') {
          // Re-attach welcome screen event listeners
          this.attachWelcomeEventListeners();
        }
      }
  
      /**
       * Show welcome screen
       */
      showWelcomeScreen() {
        this.updateUI({ currentScreen: 'welcome' });
      }
  
      /**
       * Show chat screen
       */
      async showChatScreen() {
        this.updateUI({ currentScreen: 'chat' });
        // Load projects to populate the sidebar
        await this.loadProjects();
      }
  
      /**
       * Update messages
       * @param {Array} messages - All messages from conversation
       */
      setMessages(messages) {
        this.updateUI({ messages });
      }
  
      /**
       * Set processing state
       * @param {boolean} isProcessing - Is AI currently processing?
       */
      setProcessing(isProcessing) {
        const input = document.getElementById('message-input');
        if (input) {
          input.disabled = isProcessing;
        }
        this.updateUI({ isProcessing, inputEnabled: !isProcessing });
      }
  
      /**
       * Set user input callback
       * @param {Function} callback - Callback (message) => void
       */
      setUserInputCallback(callback) {
        this.onUserInput = callback;
      }
  
      /**
       * Set directory selection callback
       * @param {Function} callback - Callback when directory button is clicked
       */
      setDirectorySelectionCallback(callback) {
        this.onDirectorySelect = callback;
      }
  
      /**
       * Refresh render - force re-render without changing state
       * Used by diff expand/collapse functionality
       */
      refreshRender() {
        this.renderApp();
      }
  
      /**
       * Handle send
       * @private
       */
      handleSend() {
        const input = document.getElementById('message-input');
        const message = input.value.trim();
  
        if (message && this.onUserInput) {
          this.onUserInput(message);
          input.value = '';
          input.style.height = 'auto';
        }
      }
  
      /**
       * Handle start new task button click
       * @private
       */
      async handleStartNewTask() {
        // Get the task completion message (last message)
        const messages = this.state.messages;
        if (messages.length === 0 || messages[messages.length - 1].type !== 'task_complete') {
          console.warn('[UIController] No task completion message found');
          return;
        }
  
        const taskCompleteMsg = messages[messages.length - 1];
        const continuationPrompt = taskCompleteMsg.continuationPrompt;
  
        // Clear conversation
        const app = window.CodeBossApp;
        if (app && app.components.conversationManager) {
          app.components.conversationManager.state.messages = [];
        }
  
        // Add continuation prompt as greeting
        if (app && app.components.conversationManager && continuationPrompt) {
          const { createGreetingMessage } = window.module.ConversationState;
          const greetingMsg = createGreetingMessage(continuationPrompt);
          app.components.conversationManager.state.messages.push(greetingMsg);
        }
  
        // Update UI
        if (app && app.components.conversationManager) {
          const newMessages = app.components.conversationManager.getMessages();
          this.setMessages(newMessages);
        }
  
        this.renderApp();
      }
  
      /**
       * Check if scroll is near bottom (within threshold)
       * @private
       */
      isNearBottom() {
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) return false;
  
        // If within 150px of bottom, consider "at bottom"
        const threshold = 150;
        return chatContainer.scrollHeight - chatContainer.scrollTop - chatContainer.clientHeight < threshold;
      }
  
      /**
       * Handle scroll events
       * @private
       */
      handleScroll() {
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) return;
  
        // If user manually scrolls significantly away from bottom, release the lock
        // Need to scroll more than 300px away to break the lock
        const significantlyAwayFromBottom =
          chatContainer.scrollHeight - chatContainer.scrollTop - chatContainer.clientHeight > 300;
  
        if (significantlyAwayFromBottom) {
          this.shouldMaintainScrollLock = false;
        }
  
        // Update button visibility
        this.updateScrollButtonVisibility();
  
        // Update last message count when at bottom
        if (this.isNearBottom() && this.state.messages) {
          this.lastMessageCountAtBottom = this.state.messages.length;
        }
      }
  
      /**
       * Check if there are new messages since last scroll to bottom
       * @private
       */
      hasNewMessagesSinceBottom() {
        if (!this.state.messages) return false;
        return this.state.messages.length > this.lastMessageCountAtBottom;
      }
  
      /**
       * Update scroll button visibility
       * @private
       */
      updateScrollButtonVisibility() {
        if (this.isNearBottom()) {
          this.hideScrollButton();
        } else {
          // Show button if there are new messages, or if mouse is near bottom
          if (this.hasNewMessagesSinceBottom() || this.mouseNearBottom) {
            this.showScrollButton();
          } else {
            this.hideScrollButton();
          }
        }
      }
  
      /**
       * Scroll to bottom with smart behavior
       * @private
       */
      scrollToBottom() {
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) return;
  
        // Wait for layout to complete, especially important for large messages
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            chatContainer.scrollTo({
              top: chatContainer.scrollHeight,
              // Use instant scroll during processing to maintain lock without lag
              behavior: this.shouldMaintainScrollLock ? 'instant' : 'smooth'
            });
  
            // Update last message count after scrolling
            if (this.state.messages) {
              this.lastMessageCountAtBottom = this.state.messages.length;
            }
          });
        });
      }
  
      /**
       * Create scroll-to-bottom button
       * @private
       */
      createScrollButton() {
        this.scrollButton = document.createElement('div');
        this.scrollButton.id = 'scroll-to-bottom';
        this.scrollButton.textContent = '';  // Use textContent instead of innerHTML for Trusted Types
        this.scrollButton.style.display = 'none';
        this.scrollButton.addEventListener('click', () => this.scrollToBottom());
        document.body.appendChild(this.scrollButton);
      }
  
      /**
       * Show scroll button
       * @private
       */
      showScrollButton() {
        if (this.scrollButton) {
          this.scrollButton.style.display = 'flex';
        }
      }
  
      /**
       * Hide scroll button
       * @private
       */
      hideScrollButton() {
        if (this.scrollButton) {
          this.scrollButton.style.display = 'none';
        }
      }
  
      /**
       * Enable/disable input (legacy compatibility)
       * @param {boolean} enabled - Whether input should be enabled
       */
      setInputEnabled(enabled) {
        const input = document.getElementById('message-input');
        if (input) input.disabled = !enabled;
      }
  
      /**
       * Show/hide input container (legacy compatibility)
       * @param {boolean} visible - Whether input should be visible
       */
      setInputVisible(visible) {
        const inputContainer = document.getElementById('input-container');
        if (inputContainer) {
          inputContainer.style.display = visible ? 'block' : 'none';
        }
      }
  
      /**
       * Toggle sidebar visibility
       */
      toggleSidebar() {
        this.state.sidebar.isMinimized = !this.state.sidebar.isMinimized;
        this.renderApp();
      }
  
      /**
       * Switch sidebar tab
       * @param {string} tab - Tab name ('projects' or 'memory')
       */
      switchSidebarTab(tab) {
        this.state.sidebar.activeTab = tab;
        this.renderApp();
      }
  
      /**
       * Toggle project expand/collapse and select project
       * @param {string} projectDir - Project directory
       */
      async toggleProject(projectDir) {
        const projects = this.state.sidebar.projects;
        const project = projects.find(p => p.projectDir === projectDir);
        if (!project) return;
  
        // Toggle expansion
        project.expanded = !project.expanded;
  
        // If clicking a different project (or no project selected), select it and enter planning mode
        if (this.state.sidebar.currentProject !== projectDir) {
          await this.selectProject(projectDir);
        } else {
          this.renderApp();
        }
      }
  
      /**
       * Select a project and enter planning mode
       * @param {string} projectDir - Project directory
       */
      async selectProject(projectDir) {
        console.log(`[UIController] selectProject: ${projectDir}`);
  
        try {
          const app = window.CodeBossApp;
          if (!app) {
            console.error('[UIController] App not available');
            return;
          }
  
          // Clear current conversation
          if (app.components.conversationManager) {
            app.components.conversationManager.state.messages = [];
          }
  
          // Set project in AI processor (this enters planning mode)
          if (app.components.aiProcessor) {
            await app.components.aiProcessor.setProject(projectDir);
          }
  
          // Show planning mode welcome message
          const project = this.state.sidebar.projects.find(p => p.projectDir === projectDir);
          const projectName = project ? project.name : projectDir;
  
          const planningMessage = ` Planning Mode: ${projectName}
  
  Let's discuss what you'd like to build. Tell me about your ideas, and we'll create a plan together.
  
  Once we have a solid plan, I'll create a checklist and begin execution.`;
  
          if (app.components.conversationManager) {
            const { createGreetingMessage } = window.module.ConversationState;
            const greetingMsg = createGreetingMessage(planningMessage);
            app.components.conversationManager.state.messages.push(greetingMsg);
          }
  
          // Update UI with all changes at once
          const messages = app.components.conversationManager.getMessages();
          this.updateUI({
            messages,
            sidebar: {
              ...this.state.sidebar,
              currentProject: projectDir,
              currentTask: null
            },
            currentProject: projectDir,
            currentTask: null
          });
  
        } catch (error) {
          console.error('[UIController] Failed to select project:', error);
        }
      }
  
      /**
       * Toggle task expand/collapse
       * @param {string} projectDir - Project directory
       * @param {string} taskName - Task name
       */
      toggleTask(projectDir, taskName) {
        const projects = this.state.sidebar.projects;
        const project = projects.find(p => p.projectDir === projectDir);
        if (!project) return;
  
        const task = project.tasks?.find(t => t.name === taskName);
        if (!task) return;
  
        // Toggle expansion
        task.expanded = !task.expanded;
        this.renderApp();
      }
  
      /**
       * Select a task and load its conversation
       * @param {string} projectDir - Project directory
       * @param {string} taskName - Task name
       */
      async selectTask(projectDir, taskName) {
        console.log(`[UIController] selectTask: ${projectDir}/${taskName}`);
  
        try {
          const app = window.CodeBossApp;
          if (!app || !app.components.taskManager) {
            console.error('[UIController] TaskManager not available');
            return;
          }
  
          // Load task messages
          const taskManager = app.components.taskManager;
          const messages = await taskManager.readMessages(projectDir, taskName);
  
          console.log(`[UIController] Loaded ${messages.length} messages for task ${taskName}`);
  
          // Update conversation manager with task messages
          if (app.components.conversationManager) {
            app.components.conversationManager.state.messages = messages;
            this.setMessages(messages);
          }
  
          // Update sidebar to show this task as current
          this.state.sidebar.currentProject = projectDir;
          this.state.sidebar.currentTask = taskName;
  
          // Update global current task
          this.state.currentProject = projectDir;
          this.state.currentTask = taskName;
  
          this.renderApp();
  
        } catch (error) {
          console.error('[UIController] Failed to select task:', error);
        }
      }
  
      /**
       * Show create project modal
       */
      showCreateProjectModal() {
        this.state.modal = {
          showCreateProject: true,
          showFileContent: false,
          projectName: '',
          projectDescription: '',
          fileName: '',
          content: '',
          error: null
        };
        this.renderApp();
      }
  
      /**
       * Close modal
       */
      closeModal() {
        this.state.modal = {
          showCreateProject: false,
          showFileContent: false,
          projectName: '',
          projectDescription: '',
          fileName: '',
          content: '',
          error: null
        };
        this.renderApp();
      }
  
      /**
       * Create project (from modal)
       */
      async createProject() {
        const nameInput = document.getElementById('project-name-input');
        const descInput = document.getElementById('project-desc-input');
  
        if (!nameInput) {
          console.error('[UIController] Project name input not found');
          return;
        }
  
        const name = nameInput.value.trim();
        const description = descInput ? descInput.value.trim() : '';
  
        if (!name) {
          this.state.modal.error = 'Project name is required';
          this.renderApp();
          return;
        }
  
        console.log(`[UIController] Creating project: ${name}`);
  
        try {
          // Get the app instance and create project
          const app = window.CodeBossApp;
          if (!app || !app.components.projectManager) {
            console.error('[UIController] ProjectManager not available');
            this.state.modal.error = 'Project manager not available';
            this.renderApp();
            return;
          }
  
          const projectManager = app.components.projectManager;
          const project = await projectManager.createProject(name);
  
          console.log(`[UIController] Project created: ${project.projectDir}`);
  
          // Close modal
          this.closeModal();
  
          // Reload project list and update sidebar
          await this.loadProjects();
  
          // Automatically select the newly created project and enter planning mode
          await this.selectProject(project.projectDir);
  
        } catch (error) {
          console.error('[UIController] Failed to create project:', error);
          this.state.modal.error = `Failed to create project: ${error.message}`;
          this.renderApp();
        }
      }
  
      /**
       * Copy to clipboard
       * @param {string} text - Text to copy
       */
      async copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          console.log('[UIController] Copied to clipboard');
        } catch (err) {
          console.error('[UIController] Failed to copy to clipboard:', err);
        }
      }
  
      /**
       * Update sidebar with project/task data
       * @param {Object} sidebarData - Sidebar data
       */
      updateSidebar(sidebarData) {
        this.state.sidebar = { ...this.state.sidebar, ...sidebarData };
        this.renderApp();
      }
  
      /**
       * Load projects from ProjectManager and update sidebar
       */
      async loadProjects() {
        try {
          const app = window.CodeBossApp;
          if (!app || !app.components.projectManager) {
            console.warn('[UIController] ProjectManager not available for loadProjects');
            return;
          }
  
          const projectManager = app.components.projectManager;
          const projects = await projectManager.listProjects();
  
          console.log(`[UIController] Loaded ${projects.length} projects:`, projects);
          console.log('[UIController] Current sidebar state before update:', JSON.parse(JSON.stringify(this.state.sidebar)));
  
          // Update sidebar with projects
          this.updateSidebar({ projects });
  
          console.log('[UIController] Current sidebar state after update:', JSON.parse(JSON.stringify(this.state.sidebar)));
  
        } catch (error) {
          console.error('[UIController] Failed to load projects:', error);
        }
      }
  
      /**
       * Update task checklist in sidebar
       * @param {string} projectDir - Project directory
       * @param {string} taskName - Task name
       * @param {Array} checklist - Checklist items with completion status
       */
      updateTaskChecklist(projectDir, taskName, checklist) {
        try {
          // Find the project in sidebar
          const project = this.state.sidebar.projects.find(p => p.projectDir === projectDir);
          if (!project) return;
  
          // Find the task in project
          const task = project.tasks?.find(t => t.name === taskName);
          if (!task) return;
  
          // Update task with checklist
          task.checklist = checklist;
          task.currentItemIndex = checklist.findIndex(item => item.status === 'in_progress');
  
          // Re-render to show updated checklist
          this.renderApp();
  
        } catch (error) {
          console.error('[UIController] Failed to update task checklist:', error);
        }
      }
  
      /**
       * Inject CSS styles
       * @private
       */
      injectStyles() {
        const styleId = 'code-boss-styles';
        if (document.getElementById(styleId)) return;
  
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
          /* Base styles */
          body {
            font-family: 'Consolas', 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
            margin: 0;
          }
  
          #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
          }
  
          /* Welcome Screen */
          #welcome-screen {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #1a1a1a;
          }
  
          .welcome-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
          }
  
          .welcome-header {
            font-size: 48px;
            font-weight: bold;
            color: #d4a017;
            margin-bottom: 16px;
            letter-spacing: 2px;
          }
  
          .welcome-message {
            font-size: 18px;
            color: #909090;
            margin-bottom: 48px;
          }
  
          .primary-button {
            background: #d4a017;
            color: #1a1a1a;
            border: none;
            padding: 16px 32px;
            font-size: 16px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
          }
  
          .primary-button:hover {
            background: #e5b028;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 160, 23, 0.3);
          }
  
          .primary-button:active {
            transform: translateY(0);
          }
  
          /* Chat Screen */
          #chat-screen {
            display: flex;
            flex-direction: row;
            flex: 1;
            overflow: hidden;
          }
  
          #chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 80px;
          }
  
          #chat-container::-webkit-scrollbar {
            width: 8px;
          }
  
          #chat-container::-webkit-scrollbar-track {
            background: #2d2d2d;
          }
  
          #chat-container::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
          }
  
          #chat-container::-webkit-scrollbar-thumb:hover {
            background: #777;
          }
  
          .chat-history {
            max-width: 1200px;
            margin: 0 auto;
          }
  
          /* Messages */
          .message {
            margin-bottom: 16px;
          }
  
          .user-message {
            display: flex;
            gap: 0;
            color: #707070;
          }
  
          .message-prefix {
            flex-shrink: 0;
          }
  
          .message-content {
            flex: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
          }
  
          .assistant-message {
            color: #d4a017;
            padding-left: 2ch;
            background-image: linear-gradient(
              to right,
              transparent 0px,
              transparent calc(1ch - 5px),
              #d4a017 calc(1ch - 5px),
              #d4a017 calc(1ch - 4px),
              transparent calc(1ch - 4px)
            );
            background-repeat: no-repeat;
            background-size: 100% 100%;
          }
  
          .text-line {
            min-height: 1.6em;
          }
  
          .tool-message {
            display: flex;
            gap: 8px;
            color: #909090;
          }
  
          .tool-content {
            flex: 1;
          }
  
          .tool-header {
            font-weight: bold;
            color: #b0b0b0;
            margin-bottom: 4px;
          }
  
          .tool-result {
            margin-top: 4px;
            padding-left: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
          }
  
          .tool-error {
            color: #d44;
          }
  
          /* Loading Animation */
          .loading-message {
            display: flex;
            align-items: center;
            padding: 12px 0;
          }
  
          .loading-bubble {
            display: flex;
            gap: 6px;
            padding: 8px 12px;
            background: rgba(212, 160, 23, 0.1);
            border-radius: 4px;
          }
  
          .loading-dot {
            width: 6px;
            height: 6px;
            background: #d4a017;
            border-radius: 50%;
            animation: loading-bounce 1.4s infinite ease-in-out both;
          }
  
          .loading-dot:nth-child(1) {
            animation-delay: -0.32s;
          }
  
          .loading-dot:nth-child(2) {
            animation-delay: -0.16s;
          }
  
          @keyframes loading-bounce {
            0%, 80%, 100% {
              transform: scale(0);
              opacity: 0.5;
            }
            40% {
              transform: scale(1);
              opacity: 1;
            }
          }
  
          /* Input */
          #input-container {
            position: relative;
            background: #2d2d2d;
            border-top: 1px solid #404040;
            padding: 12px 16px;
          }
  
          #input-container::before {
            content: '> ';
            position: absolute;
            left: calc(16px + 0.5ch);
            top: 16px;
            color: white;
          }
  
          #message-input {
            width: 100%;
            background: transparent;
            border: none;
            color: #e0e0e0;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
            padding-left: 2ch;
            max-height: 200px;
            overflow-y: auto;
          }
  
          #message-input::placeholder {
            color: #707070;
          }
  
          #message-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
          }
        `;
        document.head.appendChild(style);
      }
    }
  
    window.module = window.module || {};
    window.module.UIController = UIController;
  
  })();

  // ============================================================================
  // src/ai-api.js
  // ============================================================================

  /**
   * ai-api.js
   *
   * Dual-mode AI API integration:
   * - Production: Internal API at /api/ai/messages (auth token, no key)
   * - Development: Direct Anthropic API (API key required)
   * - Non-streaming responses (MVP)
   */
  
  (function() {
      'use strict';
  
      // Version logging to verify correct code is loaded
      console.log('[AIApi] Loading version 2.0 - Streaming fix (no streamDone flag, continue on DONE)');
  
      const ANTHROPIC_API_URL = 'https://api.anthropic.com/v1/messages';
      const DEFAULT_INTERNAL_API_URL = '/api/chat/completions';
      const ANTHROPIC_VERSION = '2023-06-01';
      const MODEL = 'claude-3-5-sonnet-20241022';
      const INTERNAL_MODEL = 'Anthropic Claude 4 Sonnet';
      const MAX_TOKENS = 8000;
  
      // Configurable via localStorage
      const CONFIG_AI_URL = 'AI_URL';  // Custom API URL
      const CONFIG_API_KEY_HEADER = 'API_KEY_HEADER';  // Custom auth header name
  
      /**
       * AIApi class
       * Handles communication with AI API (internal or Anthropic)
       */
      class AIApi {
          constructor(apiKey = null, useInternalAPI = false) {
              this.apiKey = apiKey;
              this.useInternalAPI = useInternalAPI;
  
              // Auto-detect mode if not specified
              if (apiKey === null && !useInternalAPI) {
                  this.useInternalAPI = this.detectInternalAPI();
              }
          }
  
          /**
           * Detect if internal API is available
           * @returns {boolean} True if internal API should be used
           */
          detectInternalAPI() {
              // Check if we have an auth token in localStorage
              const authToken = getAuthToken();
              return authToken !== null;
          }
  
          /**
           * Send message to AI API
           * NOTE: XML-based tool approach - tools are in system prompt, not as parameter
           * @param {Array} messages - Array of message objects {role, content}
           * @returns {Promise<Object>} API response with text content (XML format)
           */
          async sendMessage(messages) {
              if (this.useInternalAPI) {
                  return this.sendToInternalAPI(messages);
              } else {
                  return this.sendToAnthropicAPI(messages);
              }
          }
  
          /**
           * Send to internal API (production)
           * Supports custom AI_URL and API_KEY_HEADER from localStorage
           * @param {Array} messages - Message array (system prompt in first user message)
           * @returns {Promise<Object>} API response {content: string, role: 'assistant'}
           */
          async sendToInternalAPI(messages) {
              const authToken = getAuthToken();
  
              // Priority: window.CONSTANTS (dev) > localStorage (custom) > defaults (production)
              const customUrl = (window.CONSTANTS && window.CONSTANTS.AI_URL) ||
                              localStorage.getItem(CONFIG_AI_URL) ||
                              DEFAULT_INTERNAL_API_URL;
  
              const customHeaderName = (window.CONSTANTS && window.CONSTANTS.API_KEY_HEADER) ||
                                      localStorage.getItem(CONFIG_API_KEY_HEADER);
  
              const apiUrl = customUrl;
  
              console.log('[AIApi] Using internal API:', apiUrl);
              if (authToken) {
                  console.log('[AIApi] Using auth header:', customHeaderName || 'Authorization');
              } else {
                  console.log('[AIApi] No auth token - calling API without authentication');
              }
              if (window.CONSTANTS) {
                  console.log('[AIApi] Using dev constants from window.CONSTANTS');
              }
  
              const timestamp = Date.now();
              const sessionId = 'session-' + Math.random().toString(36).substr(2, 9);
              const assistantMessageId = 'msg-' + timestamp + '-assistant';
  
              const requestBody = {
                  stream: true,
                  model: INTERNAL_MODEL,
                  messages: messages,
                  params: {},
                  features: {
                      web_search: false
                  },
                  session_id: sessionId,
                  id: assistantMessageId,
                  background_tasks: {
                      title_generation: false,
                      tags_generation: false
                  }
              };
  
              // NOTE: No tools parameter - XML-based tool approach
  
              // Log the request for debugging
              console.log('[AIApi] Request body:', JSON.stringify({
                  ...requestBody,
                  messages: messages.map(m => ({
                      role: m.role,
                      content: typeof m.content === 'string' ? m.content.substring(0, 200) + (m.content.length > 200 ? '...' : '') : m.content
                  }))
              }, null, 2));
  
              try {
                  const headers = {
                      'Content-Type': 'application/json'
                  };
  
                  // Only add auth header if we have a token
                  if (authToken) {
                      const headerName = customHeaderName || 'Authorization';
                      const headerValue = customHeaderName ? authToken : `Bearer ${authToken}`;
                      headers[headerName] = headerValue;
                  }
  
                  const response = await fetch(apiUrl, {
                      method: 'POST',
                      headers: headers,
                      body: JSON.stringify(requestBody)
                  });
  
                  if (!response.ok) {
                      const errorText = await response.text();
                      throw new Error(`Internal API request failed (${response.status}): ${errorText}`);
                  }
  
                  // Read streaming response and collect text
                  // API streams text in OpenAI format: data: {"choices":[{"delta":{"content":"..."}}]}
                  const reader = response.body.getReader();
                  const decoder = new TextDecoder();
                  let finalContent = '';
  
                  console.log('[AIApi] Starting to read streaming response...');
  
                  while (true) {
                      const { done, value } = await reader.read();
                      if (done) break;
  
                      const chunk = decoder.decode(value);
                      const lines = chunk.split('\n');
  
                      for (const line of lines) {
                          if (line.startsWith('data: ')) {
                              const data = line.slice(6).trim();
                              if (data === '[DONE]') {
                                  console.log('[AIApi] Received [DONE] marker');
                                  // Don't exit - just skip processing this line
                                  // The stream will naturally end when done=true
                                  continue;
                              }
  
                              if (!data) continue;
  
                              try {
                                  const parsed = JSON.parse(data);
                                  // Extract text content from OpenAI-style streaming
                                  if (parsed.choices && parsed.choices[0] &&
                                      parsed.choices[0].delta && parsed.choices[0].delta.content) {
                                      finalContent += parsed.choices[0].delta.content;
                                  }
                              } catch (e) {
                                  // Ignore parsing errors
                                  console.warn('[AIApi] Error parsing SSE data:', e);
                              }
                          }
                      }
                  }
  
                  console.log('[AIApi] Collected', finalContent.length, 'characters of text');
                  console.log('[AIApi] Response preview:', finalContent.substring(0, 200));
  
                  // Return response with text content (will contain XML like <execute> or <message>)
                  return {
                      content: finalContent,
                      role: 'assistant',
                      stop_reason: 'end_turn'
                  };
              } catch (error) {
                  console.error('[AIApi] Internal API request failed:', error);
                  throw error;
              }
          }
  
          /**
           * Send to Anthropic API (development)
           * NOTE: Direct Anthropic API doesn't support XML tools, this is for testing only
           * @param {Array} messages - Message array
           * @returns {Promise<Object>} API response {content: string}
           */
          async sendToAnthropicAPI(messages) {
              if (!this.apiKey) {
                  throw new Error('No API key provided for Anthropic API');
              }
  
              const requestBody = {
                  model: MODEL,
                  max_tokens: MAX_TOKENS,
                  messages: messages
              };
  
              // NOTE: No tools parameter - XML approach doesn't use native tool API
  
              try {
                  const response = await fetch(ANTHROPIC_API_URL, {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'x-api-key': this.apiKey,
                          'anthropic-version': ANTHROPIC_VERSION
                      },
                      body: JSON.stringify(requestBody)
                  });
  
                  if (!response.ok) {
                      const errorText = await response.text();
                      throw new Error(`Anthropic API request failed (${response.status}): ${errorText}`);
                  }
  
                  const data = await response.json();
  
                  // Extract text from content blocks
                  let textContent = '';
                  if (data.content && Array.isArray(data.content)) {
                      for (const block of data.content) {
                          if (block.type === 'text') {
                              textContent += block.text;
                          }
                      }
                  }
  
                  // Return simplified response format
                  return {
                      content: textContent,
                      role: 'assistant',
                      stop_reason: data.stop_reason || 'end_turn'
                  };
              } catch (error) {
                  console.error('[AIApi] Anthropic API request failed:', error);
                  throw error;
              }
          }
  
          /**
           * Extract text content from API response
           * @param {Object} response - API response object
           * @returns {string} Text content
           */
          extractTextContent(response) {
              if (!response.content || !Array.isArray(response.content)) {
                  return '';
              }
  
              return response.content
                  .filter(block => block.type === 'text')
                  .map(block => block.text)
                  .join('');
          }
  
          /**
           * Extract tool uses from API response
           * @param {Object} response - API response object
           * @returns {Array} Array of tool use objects
           */
          extractToolUses(response) {
              if (!response.content || !Array.isArray(response.content)) {
                  return [];
              }
  
              return response.content
                  .filter(block => block.type === 'tool_use')
                  .map(block => ({
                      id: block.id,
                      name: block.name,
                      input: block.input
                  }));
          }
  
          /**
           * Check if response has tool uses
           * @param {Object} response - API response object
           * @returns {boolean} True if response contains tool uses
           */
          hasToolUses(response) {
              return this.extractToolUses(response).length > 0;
          }
  
          /**
           * Get stop reason from response
           * @param {Object} response - API response object
           * @returns {string} Stop reason (end_turn, tool_use, max_tokens, etc.)
           */
          getStopReason(response) {
              return response.stop_reason || 'unknown';
          }
      }
  
      /**
       * Get auth token from localStorage (for internal API)
       * Uses the same key as the internal AI UI: 'token'
       * @returns {string|null} Auth token or null
       */
      function getAuthToken() {
          // Use 'token' key to match internal AI UI
          return localStorage.getItem('token');
      }
  
      /**
       * Set auth token in localStorage (for internal API)
       * Uses the same key as the internal AI UI: 'token'
       * @param {string} token - Auth token to store
       */
      function setAuthToken(token) {
          // Use 'token' key to match internal AI UI
          localStorage.setItem('token', token);
      }
  
      /**
       * Get API key from localStorage (for Anthropic API)
       * @returns {string|null} API key or null
       */
      function getApiKey() {
          const storage = window.module.StorageManager ? new window.module.StorageManager() : null;
          if (storage) {
              return storage.getString('anthropic_api_key', null);
          }
          // Fallback to direct localStorage
          return localStorage.getItem('code_boss:anthropic_api_key');
      }
  
      /**
       * Set API key in localStorage (for Anthropic API)
       * @param {string} apiKey - API key to store
       */
      function setApiKey(apiKey) {
          const storage = window.module.StorageManager ? new window.module.StorageManager() : null;
          if (storage) {
              storage.setString('anthropic_api_key', apiKey);
          } else {
              // Fallback to direct localStorage
              localStorage.setItem('code_boss:anthropic_api_key', apiKey);
          }
      }
  
      // Export to window.module
      window.module = window.module || {};
      window.module.AIApi = AIApi;
      window.module.getAuthToken = getAuthToken;
      window.module.setAuthToken = setAuthToken;
      window.module.getApiKey = getApiKey;
      window.module.setApiKey = setApiKey;
  
  })();

  // ============================================================================
  // src/app.js
  // ============================================================================

  /**
   * app.js
   *
   * MVP VERSION - Main application entry point:
   * - Initializes all components
   * - Wires up dependencies
   * - Sets up API key
   * - Handles directory selection
   * - Starts the application
   */
  
  (function() {
    'use strict';
  
    /**
     * CodeBossApp class (MVP version)
     * Main application controller
     */
    class CodeBossApp {
      constructor() {
        this.initialized = false;
        this.components = {};
      }
  
      /**
       * Initialize the application
       * @param {string} containerId - Container element ID
       * @returns {Promise<void>}
       */
      async initialize(containerId) {
        console.log('[CodeBossApp] Initializing...');
  
        try {
          // 1. Initialize storage manager
          this.components.storageManager = new window.module.StorageManager();
  
          // 2. Get auth credentials (default to production mode)
          // In production (internal AI tool), token is automatically available in localStorage
          // In development, user can set API key via prompt
          const authToken = window.module.getAuthToken();
          const apiKey = window.module.getApiKey();
  
          // Don't prompt - just proceed with whatever auth is available
          // If neither is available, we'll use production mode and let the internal API handle auth
  
          // 3. Initialize file system manager
          this.components.fsManager = new window.module.FileSystemManager();
  
          // 4. Initialize command executor (for run_command tool)
          this.components.commandExecutor = new window.module.CommandManager(this.components.fsManager);
  
          // 5. Initialize conversation manager
          this.components.conversationManager = new window.module.ConversationManager();
  
          // 6. Initialize tool definitions
          this.components.toolDefinitions = window.module.ToolDefinitions;
  
          // 7. Initialize tool executor
          this.components.toolExecutor = new window.module.ToolExecutor(
            this.components.fsManager,
            this.components.commandExecutor
          );
  
          // 8. Initialize AI API (auto-detects mode based on auth token vs API key)
          this.components.aiApi = new window.module.AIApi(apiKey, authToken !== null);
  
          // 9. Initialize phase system managers (before prompt generator)
          this.components.modeManager = new window.module.ModeManager();
  
          this.components.projectManager = new window.module.ProjectManager(this.components.fsManager);
  
          this.components.checklistManager = new window.module.ChecklistManager();
  
          this.components.ephemeralContentManager = new window.module.EphemeralContentManager();
  
          this.components.mentalModelManager = new window.module.MentalModelManager();
  
          this.components.recentChangesTracker = new window.module.RecentChangesTracker();
  
          this.components.taskManager = new window.module.TaskManager(
            this.components.fsManager,
            this.components.projectManager
          );
  
          // 10. Initialize prompt generator (with managers)
          this.components.promptGenerator = new window.module.PromptGenerator(
            this.components.modeManager,
            this.components.mentalModelManager,
            this.components.recentChangesTracker,
            this.components.ephemeralContentManager
          );
  
          // 11. Initialize response parser
          this.components.responseParser = new window.module.ResponseParser();
  
          // 12. Initialize AI processor (with phase system integration)
          this.components.aiProcessor = new window.module.AIProcessor(
            this.components.conversationManager,
            this.components.promptGenerator,
            this.components.responseParser,
            this.components.toolExecutor,
            this.components.toolDefinitions,
            this.components.aiApi,
            // Phase system managers
            this.components.modeManager,
            this.components.projectManager,
            this.components.taskManager,
            this.components.checklistManager,
            this.components.ephemeralContentManager,
            this.components.mentalModelManager,
            this.components.recentChangesTracker
          );
  
          // 13. Initialize UI controller
          this.components.uiController = new window.module.UIController();
          this.components.uiController.initialize(containerId);
  
          // 14. Wire up UI callbacks
          this.components.uiController.setUserInputCallback((message) => {
            this.handleUserMessage(message);
          });
  
          // 15. Wire up AI processor callbacks
          this.components.aiProcessor.setUpdateCallback(() => {
            this.handleAIUpdate();
          });
  
          this.initialized = true;
          console.log('[CodeBossApp] Initialization complete');
  
          // Check if directory is already selected
          const hasDirectoryAccess = this.components.fsManager.hasDirectoryAccess();
  
          if (!hasDirectoryAccess) {
            // Show welcome screen with directory selection button
            this.components.uiController.showWelcomeScreen();
            this.components.uiController.setDirectorySelectionCallback(async () => {
              await this.handleDirectorySelection();
            });
          } else {
            // Show chat screen directly (directory already selected)
            await this.components.uiController.showChatScreen();
            this.showProjectSelectionMessage();
          }
  
        } catch (error) {
          console.error('[CodeBossApp] Initialization failed:', error);
          alert(`Initialization failed: ${error.message}`);
        }
      }
  
      /**
       * Prompt user for authentication
       * Production: Auth token for internal API
       * Development: API key for Anthropic API
       * @private
       */
      promptForAuth() {
        const choice = confirm(
          'Code Boss requires authentication.\n\n' +
          'Click OK for Production mode (internal API with auth token)\n' +
          'Click Cancel for Development mode (Anthropic API with API key)'
        );
  
        if (choice) {
          // Production mode - auth token
          const authToken = prompt('Please enter your auth token for the internal API:');
          if (authToken) {
            window.module.setAuthToken(authToken);
            window.location.reload();
          } else {
            alert('Auth token is required for production mode');
          }
        } else {
          // Development mode - API key
          const apiKey = prompt('Please enter your Anthropic API key:');
          if (apiKey) {
            window.module.setApiKey(apiKey);
            window.location.reload();
          } else {
            alert('API key is required for development mode');
          }
        }
      }
  
      /**
       * Prompt user to select directory
       * @returns {Promise<void>}
       * @private
       */
      async promptForDirectory() {
        alert('Code Boss needs access to a directory to work with files.\n\nClick OK to select a directory.');
  
        try {
          await this.components.fsManager.requestDirectoryAccess();
          console.log('[CodeBossApp] Directory access granted');
        } catch (error) {
          console.error('[CodeBossApp] Directory access denied:', error);
          alert('Directory access is required. Please refresh and try again.');
          throw error;
        }
      }
  
      /**
       * Handle directory selection
       * @private
       */
      async handleDirectorySelection() {
        try {
          console.log('[CodeBossApp] Step 1: Requesting directory access...');
          await this.components.fsManager.requestDirectoryAccess();
          console.log('[CodeBossApp] Step 1 SUCCESS: Directory access granted');
  
          console.log('[CodeBossApp] Step 2: Initializing .agent directory...');
          await this.components.fsManager.initializeAgentDirectory();
          console.log('[CodeBossApp] Step 2 SUCCESS: .agent directory initialized');
  
          console.log('[CodeBossApp] Step 3: Switching to chat screen...');
          // Switch to chat screen (this will load projects in sidebar)
          await this.components.uiController.showChatScreen();
  
          // Show message prompting user to select/create a project
          this.showProjectSelectionMessage();
          console.log('[CodeBossApp] Step 3 SUCCESS: All done!');
  
        } catch (error) {
          console.error('[CodeBossApp] FAILED at some step. Error details:');
          console.error('[CodeBossApp] Error name:', error.name);
          console.error('[CodeBossApp] Error message:', error.message);
          console.error('[CodeBossApp] Error stack:', error.stack);
          alert(`Directory setup failed: ${error.message}\n\nCheck console for details.`);
        }
      }
  
      /**
       * Show welcome message in chat
       * @private
       */
      showWelcomeMessage() {
        const dirPath = this.components.fsManager.getDirectoryPath();
  
        const welcomeMessage = `Welcome to Code Boss MVP!
  
  Working directory: ${dirPath}
  
  You can ask me to:
  - Read and modify files
  - Create new files and directories
  - List directory contents
  - Run shell commands
  - Use git operations
  
  Type your message below to get started!`;
  
        this.components.conversationManager.addAssistantMessage(welcomeMessage);
        this.handleAIUpdate();
      }
  
      /**
       * Show project selection message
       * Prompts user to select or create a project
       * @private
       */
      showProjectSelectionMessage() {
        const dirPath = this.components.fsManager.getDirectoryPath();
        const { createGreetingMessage } = window.module.ConversationState;
  
        const message = `Welcome to Code Boss!
  
  Working directory: ${dirPath}
  
  To get started, please select an existing project from the sidebar or create a new project using the "+ New Project" button.
  
  Once you select a project, we'll enter Planning mode where we can discuss what you'd like to build.`;
  
        // Use greeting message type (not sent to API)
        const greetingMsg = createGreetingMessage(message);
        this.components.conversationManager.state.messages.push(greetingMsg);
        this.handleAIUpdate();
      }
  
      /**
       * Handle user message
       * @param {string} message - User's message
       * @returns {Promise<void>}
       * @private
       */
      async handleUserMessage(message) {
        if (!this.initialized) {
          console.error('[CodeBossApp] App not initialized');
          return;
        }
  
        // Check if directory access is required
        const hasDirectoryAccess = this.components.fsManager.hasDirectoryAccess();
        if (!hasDirectoryAccess) {
          this.components.conversationManager.addAssistantMessage(
            ' Please select a working directory first using the button above before chatting.'
          );
          this.handleAIUpdate();
          return;
        }
  
        try {
          // Show processing state (disables input and shows loading animation)
          this.components.uiController.setProcessing(true);
  
          // Process the message
          await this.components.aiProcessor.processUserMessage(message);
  
          // Hide processing state (re-enables input and hides loading animation)
          this.components.uiController.setProcessing(false);
  
        } catch (error) {
          console.error('[CodeBossApp] Error processing message:', error);
          this.components.uiController.setProcessing(false);
  
          // Show error to user
          this.components.conversationManager.addAssistantMessage(
            `Error: ${error.message}`
          );
          this.handleAIUpdate();
        }
      }
  
      /**
       * Handle AI update (new message added)
       * Also reloads sidebar to show any new tasks/checklist updates
       * @private
       */
      async handleAIUpdate() {
        // Get all messages
        const messages = this.components.conversationManager.getMessages();
  
        // Update UI with new messages (VDOM will handle efficient rendering)
        this.components.uiController.setMessages(messages);
  
        // Reload sidebar to show any new tasks or checklist updates
        await this.components.uiController.loadProjects();
  
        // Update sidebar with current project/task/phase state
        const currentProject = this.components.aiProcessor.getCurrentProject();
        const currentTask = this.components.aiProcessor.getCurrentTask();
        const currentPhase = this.components.aiProcessor.getCurrentPhase();
  
        if (currentProject) {
          this.components.uiController.updateSidebar({
            currentProject: currentProject,
            currentTask: currentTask
          });
        }
  
        // Update sidebar with checklist if in execution phase
        if (currentPhase === 'execution' && currentTask) {
          const checklist = this.components.checklistManager.getChecklist();
          this.components.uiController.updateTaskChecklist(currentProject, currentTask, checklist);
        }
      }
  
      /**
       * Get application components
       * @returns {Object} Components object
       */
      getComponents() {
        return this.components;
      }
    }
  
    // Export to window.module
    window.module = window.module || {};
    window.module.CodeBossApp = CodeBossApp;
  
  })();

  // Auto-start when DOM ready
  (async function() {
    try {
      console.log('Code Boss MVP - Browser Edition');
      console.log('Initializing...');

      // Create app instance
      const app = new window.module.CodeBossApp();

      // Create container div if it doesn't exist
      let container = document.getElementById('app');
      if (!container) {
        container = document.createElement('div');
        container.id = 'app';
        document.body.appendChild(container);
      }

      // Initialize with container
      await app.initialize('app');

      console.log('Code Boss initialized successfully');

      // Export to window for debugging
      window.CodeBossApp = app;

    } catch (error) {
      console.error('Failed to initialize Code Boss:', error);
      alert('Failed to initialize Code Boss: ' + error.message);
    }
  })();

  console.log('Code Boss bundle loaded successfully');

})();
