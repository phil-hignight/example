// AI Agent - Built 2025-11-28T20:24:59.091Z
(function() {
  window.module = {};

  // Module: api-client.js
  // API Client
  window.module['api-client.js'] = {
    chatId: null,
    sessionId: null,
  
    init: function() {
      const utils = window.module['utils.js'];
      this.sessionId = utils.generateSessionId();
    },
  
    createNewChat: async function(firstMessage) {
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      const messageId = utils.generateUUID();
      const timestamp = utils.getTimestamp();
  
      const payload = {
        chat: {
          id: '',
          title: 'Chat Pending',
          models: [config.MODEL],
          params: {},
          history: {
            messages: {
              [messageId]: {
                id: messageId,
                parentId: null,
                childrenIds: [],
                role: 'user',
                content: firstMessage,
                timestamp: timestamp,
                models: [config.MODEL]
              }
            },
            currentId: messageId
          },
          messages: [
            {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: 'user',
              content: firstMessage,
              timestamp: timestamp,
              models: [config.MODEL]
            }
          ],
          tags: [],
          timestamp: Date.now()
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/new`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to create chat: ${response.status} ${response.statusText}`);
      }
  
      const data = await response.json();
      this.chatId = data.id;
  
      return { chatId: data.id, messageId };
    },
  
    updateChat: async function(messages) {
      const config = window.module['config.js'];
  
      // Build history object
      const historyMessages = {};
      messages.forEach((msg) => {
        historyMessages[msg.id] = {
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp,
          ...(msg.role === 'user' ? { models: [config.MODEL] } : {
            model: config.MODEL,
            modelIdx: 0,
            modelName: config.MODEL,
            userContext: null
          })
        };
      });
  
      const currentId = messages[messages.length - 1].id;
  
      const payload = {
        chat: {
          models: [config.MODEL],
          files: [],
          params: {},
          history: {
            messages: historyMessages,
            currentId: currentId
          },
          messages: messages.map(msg => ({
            id: msg.id,
            parentId: msg.parentId,
            childrenIds: msg.childrenIds,
            content: msg.content,
            role: msg.role,
            timestamp: msg.timestamp,
            ...(msg.role === 'user' ? { models: [config.MODEL] } : {
              model: config.MODEL,
              modelIdx: 0,
              modelName: config.MODEL,
              userContext: null
            })
          }))
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/${this.chatId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to update chat: ${response.status} ${response.statusText}`);
      }
  
      return await response.json();
    },
  
    getCompletion: async function(messages, assistantMessageId) {
      const config = window.module['config.js'];
  
      const userMessages = messages
        .filter(m => m.role === 'user')
        .map(m => ({
          role: 'user',
          content: m.content
        }));
  
      const payload = {
        stream: true,
        model: config.MODEL,
        messages: userMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: true,
          tags_generation: true
        }
      };
  
      const response = await fetch(`${config.API_BASE}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to get completion: ${response.status} ${response.statusText}`);
      }
  
      return response;
    }
  };
  

  // Module: config.js
  // Configuration
  window.module['config.js'] = {
    API_BASE: 'https://chat.niprgpt.mil/api',
    MODEL: 'Anthropic Claude 4 Sonnet',
    MAX_RETRIES: 5,
    TIMEOUT_MS: 30000 // 30 seconds
  };
  

  // Module: file-system.js
  // File System Handler
  window.module['file-system.js'] = {
    directoryHandle: null,
    fileTree: [],
  
    requestDirectory: async function() {
      try {
        this.directoryHandle = await window.showDirectoryPicker();
        this.fileTree = await this.buildFileTree(this.directoryHandle);
        return true;
      } catch (err) {
        console.error('Directory access error:', err);
        return false;
      }
    },
  
    buildFileTree: async function(dirHandle, path = '') {
      const entries = [];
  
      for await (const entry of dirHandle.values()) {
        const fullPath = path ? `${path}/${entry.name}` : entry.name;
  
        if (entry.kind === 'directory') {
          const children = await this.buildFileTree(entry, fullPath);
          entries.push({
            name: entry.name,
            type: 'directory',
            path: fullPath,
            children: children,
            handle: entry
          });
        } else {
          // Read file to get character count
          let charCount = 0;
          try {
            const file = await entry.getFile();
            const text = await file.text();
            charCount = text.length;
          } catch (err) {
            console.warn('Could not read file for char count:', entry.name);
          }
  
          entries.push({
            name: entry.name,
            type: 'file',
            path: fullPath,
            handle: entry,
            charCount: charCount
          });
        }
      }
  
      return entries.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
    },
  
    readFile: async function(fileEntry) {
      try {
        const file = await fileEntry.handle.getFile();
        const text = await file.text();
        return text;
      } catch (err) {
        console.error('File read error:', err);
        return null;
      }
    }
  };
  

  // Module: main.js
  // Main entry point
  window.module['main.js'] = {
    version: '1.0.0',
  
    run: function() {
      console.log('Initializing API Test Interface...');
      console.log('Version:', this.version);
  
      const uiManager = window.module['ui-manager.js'];
      uiManager.init();
  
      console.log('API Test Interface ready!');
    }
  };
  

  // Module: ui-manager.js
  // UI Manager
  window.module['ui-manager.js'] = {
    messages: [],
    expandedDirs: new Set(),
  
    init: function() {
      const apiClient = window.module['api-client.js'];
      apiClient.init();
  
      this.initUI();
    },
  
    initUI: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Create main container
      const container = document.createElement('div');
      container.id = 'test-interface';
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      // Header
      const header = document.createElement('div');
      header.style.cssText = `
        background: #252526;
        padding: 12px 20px;
        border-bottom: 1px solid #3e3e42;
        display: flex;
        align-items: center;
        gap: 15px;
      `;
      header.innerHTML = `
        <h1 style="margin: 0; font-size: 18px; font-weight: 600;">API Test Interface</h1>
        <button id="selectFolder" style="
          background: #0e639c;
          color: white;
          border: none;
          padding: 6px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 13px;
        ">Select Folder</button>
        <span id="folderName" style="color: #858585; font-size: 13px;"></span>
      `;
  
      // Main content area
      const mainContent = document.createElement('div');
      mainContent.style.cssText = `
        display: flex;
        flex: 1;
        overflow: hidden;
      `;
  
      // Left panel - File tree
      const leftPanel = document.createElement('div');
      leftPanel.style.cssText = `
        width: 30%;
        background: #252526;
        border-right: 1px solid #3e3e42;
        overflow-y: auto;
        padding: 10px;
      `;
      leftPanel.innerHTML = '<div id="fileTree" style="font-size: 13px;"></div>';
  
      // Right panel - Chat
      const rightPanel = document.createElement('div');
      rightPanel.style.cssText = `
        width: 70%;
        display: flex;
        flex-direction: column;
      `;
  
      // Chat messages area
      const chatArea = document.createElement('div');
      chatArea.id = 'chatArea';
      chatArea.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 20px;
      `;
  
      // Input area
      const inputArea = document.createElement('div');
      inputArea.style.cssText = `
        background: #252526;
        border-top: 1px solid #3e3e42;
        padding: 15px;
      `;
      inputArea.innerHTML = `
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
          <textarea id="chatInput" placeholder="Enter your message..." style="
            flex: 1;
            background: #3c3c3c;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 10px;
            font-family: inherit;
            font-size: 13px;
            resize: vertical;
            min-height: 60px;
          "></textarea>
        </div>
        <div style="display: flex; gap: 10px; align-items: center;">
          <button id="addToConversation" style="
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 18px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
          ">Add to Conversation</button>
          <button id="submitToAI" style="
            background: #16825d;
            color: white;
            border: none;
            padding: 8px 18px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
          ">Submit to AI</button>
          <div id="charCounter" style="
            margin-left: auto;
            font-size: 13px;
            color: #858585;
          ">0 chars</div>
        </div>
        <div id="errorDisplay" style="
          margin-top: 10px;
          padding: 10px;
          background: #5a1d1d;
          border: 1px solid #f48771;
          border-radius: 4px;
          color: #f48771;
          display: none;
          font-size: 12px;
        "></div>
      `;
  
      rightPanel.appendChild(chatArea);
      rightPanel.appendChild(inputArea);
  
      mainContent.appendChild(leftPanel);
      mainContent.appendChild(rightPanel);
  
      container.appendChild(header);
      container.appendChild(mainContent);
  
      document.body.appendChild(container);
  
      // Attach event listeners
      this.attachEventListeners();
      this.updateCharCounter();
    },
  
    attachEventListeners: function() {
      const self = this;
      const fileSystem = window.module['file-system.js'];
  
      document.getElementById('selectFolder').addEventListener('click', async () => {
        const success = await fileSystem.requestDirectory();
        if (success) {
          document.getElementById('folderName').textContent = fileSystem.directoryHandle.name;
          self.renderFileTree();
        }
      });
  
      document.getElementById('addToConversation').addEventListener('click', () => {
        self.addMessageToConversation();
      });
  
      document.getElementById('submitToAI').addEventListener('click', () => {
        self.submitToAI();
      });
  
      document.getElementById('chatInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
          self.addMessageToConversation();
        }
      });
    },
  
    renderFileTree: function() {
      const fileSystem = window.module['file-system.js'];
      const utils = window.module['utils.js'];
      const self = this;
  
      const treeContainer = document.getElementById('fileTree');
      treeContainer.innerHTML = '';
  
      const renderEntry = (entry, level = 0) => {
        const item = document.createElement('div');
        item.style.cssText = `
          padding: 4px 8px;
          padding-left: ${level * 20 + 8}px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 6px;
        `;
  
        if (entry.type === 'directory') {
          const isExpanded = self.expandedDirs.has(entry.path);
          const icon = isExpanded ? 'üìÇ' : 'üìÅ';
          item.innerHTML = `<span>${icon}</span><span>${entry.name}</span>`;
  
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isExpanded) {
              self.expandedDirs.delete(entry.path);
            } else {
              self.expandedDirs.add(entry.path);
            }
            self.renderFileTree();
          });
  
          treeContainer.appendChild(item);
  
          if (isExpanded && entry.children) {
            entry.children.forEach(child => renderEntry(child, level + 1));
          }
        } else {
          const charCountStr = utils.formatCharCount(entry.charCount);
          item.innerHTML = `
            <span>üìÑ</span>
            <span style="flex: 1;">${entry.name}</span>
            <span style="color: #858585; font-size: 11px; margin-left: 8px;">${charCountStr}</span>
          `;
          item.style.display = 'flex';
          item.addEventListener('click', async (e) => {
            e.stopPropagation();
            await self.addFileToConversation(entry);
          });
          item.addEventListener('mouseenter', () => {
            item.style.background = '#2a2d2e';
          });
          item.addEventListener('mouseleave', () => {
            item.style.background = '';
          });
          treeContainer.appendChild(item);
        }
      };
  
      fileSystem.fileTree.forEach(entry => renderEntry(entry));
    },
  
    addFileToConversation: async function(fileEntry) {
      const fileSystem = window.module['file-system.js'];
      const content = await fileSystem.readFile(fileEntry);
      if (content !== null) {
        const messageContent = `File: ${fileEntry.path}\n\n\`\`\`\n${content}\n\`\`\``;
        this.addMessage('user', messageContent);
        this.showError(`Added file: ${fileEntry.path}`, 'info');
      } else {
        this.showError(`Failed to read file: ${fileEntry.path}`);
      }
    },
  
    addMessageToConversation: function() {
      const input = document.getElementById('chatInput');
      const content = input.value.trim();
  
      if (content) {
        this.addMessage('user', content);
        input.value = '';
        this.hideError();
      }
    },
  
    addMessage: function(role, content) {
      const utils = window.module['utils.js'];
      const timestamp = utils.getTimestamp();
      const messageId = utils.generateUUID();
  
      const message = {
        id: messageId,
        role: role,
        content: content,
        timestamp: timestamp,
        parentId: this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null,
        childrenIds: []
      };
  
      // Update parent's childrenIds
      if (message.parentId) {
        const parent = this.messages.find(m => m.id === message.parentId);
        if (parent) {
          parent.childrenIds.push(messageId);
        }
      }
  
      this.messages.push(message);
      this.renderChat();
      this.updateCharCounter();
    },
  
    renderChat: function() {
      const utils = window.module['utils.js'];
      const chatArea = document.getElementById('chatArea');
      chatArea.innerHTML = '';
  
      this.messages.forEach(msg => {
        const msgDiv = document.createElement('div');
        msgDiv.style.cssText = `
          margin-bottom: 20px;
          padding: 15px;
          background: ${msg.role === 'user' ? '#0e639c20' : '#16825d20'};
          border-left: 3px solid ${msg.role === 'user' ? '#0e639c' : '#16825d'};
          border-radius: 4px;
        `;
  
        const headerDiv = document.createElement('div');
        headerDiv.style.cssText = `
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        `;
  
        const roleLabel = document.createElement('div');
        roleLabel.style.cssText = `
          font-weight: 600;
          color: ${msg.role === 'user' ? '#4db8ff' : '#5fb583'};
          font-size: 12px;
          text-transform: uppercase;
        `;
        roleLabel.textContent = msg.role;
  
        const charLabel = document.createElement('div');
        charLabel.style.cssText = `
          color: #858585;
          font-size: 11px;
        `;
        const charCount = msg.content?.length || 0;
        charLabel.textContent = `${utils.formatCharCount(charCount)} chars`;
  
        headerDiv.appendChild(roleLabel);
        headerDiv.appendChild(charLabel);
  
        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `
          white-space: pre-wrap;
          word-break: break-word;
          font-size: 13px;
          line-height: 1.6;
        `;
        contentDiv.textContent = msg.content;
  
        msgDiv.appendChild(headerDiv);
        msgDiv.appendChild(contentDiv);
        chatArea.appendChild(msgDiv);
      });
  
      chatArea.scrollTop = chatArea.scrollHeight;
    },
  
    updateCharCounter: function() {
      const utils = window.module['utils.js'];
      const count = utils.countCharacters(this.messages);
      const formatted = utils.formatCharCount(count);
      document.getElementById('charCounter').textContent = `${formatted} chars`;
    },
  
    submitToAI: async function() {
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
      const apiClient = window.module['api-client.js'];
  
      if (this.messages.length === 0) {
        this.showError('No messages to submit. Add messages to the conversation first.');
        return;
      }
  
      // Filter to only user messages for the first message
      const userMessages = this.messages.filter(m => m.role === 'user');
      if (userMessages.length === 0) {
        this.showError('No user messages in conversation.');
        return;
      }
  
      this.showError('Submitting to AI...', 'info');
  
      try {
        // Step 1: Create new chat if needed
        if (!apiClient.chatId) {
          const { chatId } = await apiClient.createNewChat(userMessages[0].content);
          console.log('Created chat:', chatId);
        }
  
        // Step 2: Create assistant message placeholder
        const assistantMessageId = utils.generateUUID();
        const assistantMessage = {
          id: assistantMessageId,
          role: 'assistant',
          content: '',
          timestamp: utils.getTimestamp(),
          parentId: this.messages[this.messages.length - 1].id,
          childrenIds: []
        };
  
        // Update parent's childrenIds
        const parent = this.messages[this.messages.length - 1];
        parent.childrenIds.push(assistantMessageId);
  
        this.messages.push(assistantMessage);
        this.renderChat();
  
        // Step 3: Update chat with current conversation
        await apiClient.updateChat(this.messages);
        console.log('Updated chat');
  
        // Step 4: Get completion with retry logic
        let retryCount = 0;
        let success = false;
  
        while (retryCount < config.MAX_RETRIES && !success) {
          try {
            if (retryCount > 0) {
              this.showError(`Retry attempt ${retryCount}/${config.MAX_RETRIES}...`, 'info');
              console.log(`Retry attempt ${retryCount}/${config.MAX_RETRIES}`);
            }
  
            const response = await apiClient.getCompletion(this.messages, assistantMessageId);
            console.log('Getting completion...');
  
            // Step 5: Stream response with timeout
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let hasReceivedData = false;
  
            try {
              while (true) {
                // Race the read against a timeout
                const timeoutPromise = new Promise((_, reject) => {
                  setTimeout(() => {
                    reject(new Error(`Timeout: No data received for ${config.TIMEOUT_MS / 1000} seconds`));
                  }, config.TIMEOUT_MS);
                });
  
                const readPromise = reader.read();
  
                let result;
                try {
                  result = await Promise.race([readPromise, timeoutPromise]);
                } catch (timeoutError) {
                  console.warn(`Timeout occurred (hasReceivedData: ${hasReceivedData})`);
                  await reader.cancel();
                  throw timeoutError;
                }
  
                const { done, value } = result;
  
                if (done) {
                  console.log('Stream ended');
                  break;
                }
  
                hasReceivedData = true;
                console.log(`Received ${value.length} bytes`);
  
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop(); // Keep incomplete line in buffer
  
                for (const line of lines) {
                  if (line.startsWith('data: ')) {
                    const data = line.substring(6);
  
                    if (data === '[DONE]') {
                      console.log('Received [DONE] marker');
                      continue;
                    }
  
                    try {
                      const parsed = JSON.parse(data);
  
                      if (parsed.choices && parsed.choices[0]?.delta?.content) {
                        assistantMessage.content += parsed.choices[0].delta.content;
                        this.renderChat();
                      } else if (parsed.done && parsed.content) {
                        assistantMessage.content = parsed.content;
                        this.renderChat();
                      }
                    } catch (e) {
                      console.warn('Failed to parse streaming data:', data);
                    }
                  }
                }
              }
  
              // Check if we actually got content
              if (!assistantMessage.content || assistantMessage.content.trim().length === 0) {
                console.warn('Stream completed but no content received');
                throw new Error('Stream completed without content');
              }
  
              success = true; // Completed successfully
              console.log('Stream completed successfully with content');
            } catch (streamError) {
              console.error('Stream error:', streamError);
              throw streamError;
            }
  
          } catch (retryError) {
            retryCount++;
            console.error(`Attempt ${retryCount} failed:`, retryError.message);
  
            if (retryCount >= config.MAX_RETRIES) {
              throw new Error(`Failed after ${config.MAX_RETRIES} attempts. Last error: ${retryError.message}`);
            }
  
            // Wait a bit before retrying
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
  
        this.updateCharCounter();
        this.showError('AI response completed successfully!', 'success');
  
      } catch (error) {
        console.error('Submit error:', error);
        this.showError(`Error: ${error.message}`);
  
        // Remove the failed assistant message
        this.messages.pop();
        this.renderChat();
      }
    },
  
    showError: function(message, type = 'error') {
      const errorDiv = document.getElementById('errorDisplay');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
  
      if (type === 'info') {
        errorDiv.style.background = '#1a3a52';
        errorDiv.style.borderColor = '#4db8ff';
        errorDiv.style.color = '#4db8ff';
      } else if (type === 'success') {
        errorDiv.style.background = '#1a3d2e';
        errorDiv.style.borderColor = '#5fb583';
        errorDiv.style.color = '#5fb583';
      } else {
        errorDiv.style.background = '#5a1d1d';
        errorDiv.style.borderColor = '#f48771';
        errorDiv.style.color = '#f48771';
      }
  
      if (type === 'success' || type === 'info') {
        setTimeout(() => this.hideError(), 3000);
      }
    },
  
    hideError: function() {
      document.getElementById('errorDisplay').style.display = 'none';
    }
  };
  

  // Module: utils.js
  // Utility Functions
  window.module['utils.js'] = {
    generateUUID: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    },
  
    generateSessionId: function() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
      let result = '';
      for (let i = 0; i < 20; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    },
  
    getTimestamp: function() {
      return Math.floor(Date.now() / 1000);
    },
  
    countCharacters: function(messages) {
      return messages.reduce((total, msg) => total + (msg.content?.length || 0), 0);
    },
  
    formatCharCount: function(count) {
      return `${(count / 1000).toFixed(1)}K`;
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
