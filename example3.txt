// AI Agent - Built 2025-11-29T18:24:35.356Z
(function() {
  window.module = {};

  // Module: api-client.js
  // API Client
  window.module['api-client.js'] = {
    chatId: null,
    sessionId: null,
  
    init: function() {
      const utils = window.module['utils.js'];
      this.sessionId = utils.generateSessionId();
    },
  
    createNewChat: async function(firstMessage) {
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      const messageId = utils.generateUUID();
      const timestamp = utils.getTimestamp();
  
      const payload = {
        chat: {
          id: '',
          title: 'Chat Pending',
          models: [config.MODEL],
          params: {},
          history: {
            messages: {
              [messageId]: {
                id: messageId,
                parentId: null,
                childrenIds: [],
                role: 'user',
                content: firstMessage,
                timestamp: timestamp,
                models: [config.MODEL]
              }
            },
            currentId: messageId
          },
          messages: [
            {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: 'user',
              content: firstMessage,
              timestamp: timestamp,
              models: [config.MODEL]
            }
          ],
          tags: [],
          timestamp: Date.now()
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/new`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to create chat: ${response.status} ${response.statusText}`);
      }
  
      const data = await response.json();
      this.chatId = data.id;
  
      return { chatId: data.id, messageId };
    },
  
    updateChat: async function(messages) {
      const config = window.module['config.js'];
  
      // Build history object
      const historyMessages = {};
      messages.forEach((msg) => {
        historyMessages[msg.id] = {
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp,
          ...(msg.role === 'user' ? { models: [config.MODEL] } : {
            model: config.MODEL,
            modelIdx: 0,
            modelName: config.MODEL,
            userContext: null
          })
        };
      });
  
      const currentId = messages[messages.length - 1].id;
  
      const payload = {
        chat: {
          models: [config.MODEL],
          files: [],
          params: {},
          history: {
            messages: historyMessages,
            currentId: currentId
          },
          messages: messages.map(msg => ({
            id: msg.id,
            parentId: msg.parentId,
            childrenIds: msg.childrenIds,
            content: msg.content,
            role: msg.role,
            timestamp: msg.timestamp,
            ...(msg.role === 'user' ? { models: [config.MODEL] } : {
              model: config.MODEL,
              modelIdx: 0,
              modelName: config.MODEL,
              userContext: null
            })
          }))
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/${this.chatId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to update chat: ${response.status} ${response.statusText}`);
      }
  
      return await response.json();
    },
  
    getCompletion: async function(apiMessages, assistantMessageId) {
      const config = window.module['config.js'];
  
      // apiMessages is already in API format from api-renderer
      const payload = {
        stream: true,
        model: config.MODEL,
        messages: apiMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: true,
          tags_generation: true
        }
      };
  
      const response = await fetch(`${config.API_BASE}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to get completion: ${response.status} ${response.statusText}`);
      }
  
      return response;
    }
  };
  

  // Module: api-renderer.js
  // API Renderer
  // Transforms internal message format to API format
  window.module['api-renderer.js'] = {
    renderMessagesForAPI: function(messages) {
      const modeManager = window.module['mode-manager.js'];
      const apiMessages = [];
  
      // Find latest summary
      let latestSummaryIndex = -1;
      let summaryContent = null;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].type === 'summary') {
          latestSummaryIndex = i;
          summaryContent = messages[i].content;
          break;
        }
      }
  
      // Start converting messages after the summary (or from beginning if no summary)
      const startIndex = latestSummaryIndex >= 0 ? latestSummaryIndex + 1 : 0;
  
      let firstUserMessageIndex = -1;
      let pendingWarnings = []; // Can accumulate multiple warnings
      let pendingToolResults = []; // Can accumulate multiple tool results
  
      for (let i = startIndex; i < messages.length; i++) {
        const msg = messages[i];
  
        // Collect system_warning messages to merge with next user message
        if (msg.type === 'system_warning') {
          pendingWarnings.push(msg.warning);
          continue;
        }
  
        // Collect tool results to combine
        if (msg.type === 'tool_result') {
          pendingToolResults.push(msg);
          continue;
        }
  
        // Flush pending tool results before processing other message types
        if (pendingToolResults.length > 0) {
          const combinedResults = pendingToolResults.map(result => {
            if (result.success) {
              // Include the file path in the result for read_file
              const path = result.args?.path || '';
              const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
              return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
            } else {
              return `Tool: ${result.tool}\nError: ${result.error}`;
            }
          }).join('\n\n');
  
          apiMessages.push({
            role: 'user',
            content: combinedResults
          });
          pendingToolResults = [];
        }
  
        // Handle different message types
        if (msg.type === 'user') {
          let content = msg.content;
  
          // Is this the first user message we're adding to API?
          if (firstUserMessageIndex === -1) {
            firstUserMessageIndex = apiMessages.length;
  
            // Build prefix: system prompt + summary (if exists)
            let prefix = modeManager.getSystemPrompt();
  
            if (summaryContent) {
              prefix += '\n\n' + summaryContent;
            }
  
            content = prefix + '\n\n' + content;
          }
  
          // Prepend any pending warnings
          if (pendingWarnings.length > 0) {
            const warningsText = pendingWarnings.map(w => `[System: ${w}]`).join('\n');
            content = warningsText + '\n\n' + content;
            pendingWarnings = [];
          }
  
          apiMessages.push({
            role: 'user',
            content: content
          });
  
        } else if (msg.type === 'assistant') {
          // Assistant message responses use = prefix
          apiMessages.push({
            role: 'assistant',
            content: '=' + msg.content + '|||||END|||||'
          });
  
        } else if (msg.type === 'tool_use') {
          // Tool execution - stringify tools array without wrapper
          apiMessages.push({
            role: 'assistant',
            content: JSON.stringify({ tools: msg.tools }) + '|||||END|||||'
          });
  
        } else if (msg.type === 'system_error') {
          apiMessages.push({
            role: 'user',
            content: `Error: ${msg.error}`
          });
  
        } else if (msg.type === 'partial') {
          // TODO: Combine consecutive partials into single assistant message
          // Partials should be combined before being sent to API
          // For now, skip partials (combination not yet implemented)
          continue;
        }
      }
  
      // Flush any remaining tool results at the end
      if (pendingToolResults.length > 0) {
        const combinedResults = pendingToolResults.map(result => {
          if (result.success) {
            const path = result.args?.path || '';
            const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
            return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
          } else {
            return `Tool: ${result.tool}\nError: ${result.error}`;
          }
        }).join('\n\n');
  
        apiMessages.push({
          role: 'user',
          content: combinedResults
        });
      }
  
      return apiMessages;
    }
  };
  

  // Module: config.js
  // Configuration
  window.module['config.js'] = {
    API_BASE: 'https://chat.niprgpt.mil/api',
    MODEL: 'Anthropic Claude 4 Sonnet',
    MAX_RETRIES: 5,
    TIMEOUT_MS: 30000 // 30 seconds
  };
  

  // Module: conversation-manager.js
  // Conversation Manager
  // Manages message array, character counting, and (TODO) summarization
  window.module['conversation-manager.js'] = {
    messages: [],
  
    init: function() {
      this.messages = [];
    },
  
    addMessage: function(message) {
      const utils = window.module['utils.js'];
  
      // Ensure message has required fields
      if (!message.id) {
        message.id = utils.generateUUID();
      }
      if (!message.timestamp) {
        message.timestamp = utils.getTimestamp();
      }
      if (!message.parentId) {
        message.parentId = this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null;
      }
      if (!message.childrenIds) {
        message.childrenIds = [];
      }
  
      // Update parent's childrenIds
      if (message.parentId) {
        const parent = this.messages.find(m => m.id === message.parentId);
        if (parent) {
          parent.childrenIds.push(message.id);
        }
      }
  
      // TODO: Check 500K character limit and trigger summarization
      // For now, just add the message
      this.messages.push(message);
  
      return message;
    },
  
    getMessages: function() {
      return this.messages;
    },
  
    getTotalCharacterCount: function() {
      const utils = window.module['utils.js'];
      return utils.countCharacters(this.messages);
    },
  
    // TODO: Implement summarization
    summarize: function() {
      console.warn('Summarization not yet implemented');
      return null;
    }
  };
  

  // Module: file-system.js
  // File System Handler
  window.module['file-system.js'] = {
    directoryHandle: null,
    fileTree: [],
  
    requestDirectory: async function() {
      try {
        this.directoryHandle = await window.showDirectoryPicker();
        this.fileTree = await this.buildFileTree(this.directoryHandle);
        return true;
      } catch (err) {
        console.error('Directory access error:', err);
        return false;
      }
    },
  
    buildFileTree: async function(dirHandle, path = '') {
      const entries = [];
  
      for await (const entry of dirHandle.values()) {
        const fullPath = path ? `${path}/${entry.name}` : entry.name;
  
        if (entry.kind === 'directory') {
          const children = await this.buildFileTree(entry, fullPath);
          entries.push({
            name: entry.name,
            type: 'directory',
            path: fullPath,
            children: children,
            handle: entry
          });
        } else {
          // Read file to get character count
          let charCount = 0;
          try {
            const file = await entry.getFile();
            const text = await file.text();
            charCount = text.length;
          } catch (err) {
            console.warn('Could not read file for char count:', entry.name);
          }
  
          entries.push({
            name: entry.name,
            type: 'file',
            path: fullPath,
            handle: entry,
            charCount: charCount
          });
        }
      }
  
      return entries.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
    },
  
    readFile: async function(fileEntry) {
      try {
        const file = await fileEntry.handle.getFile();
        const text = await file.text();
        return text;
      } catch (err) {
        console.error('File read error:', err);
        return null;
      }
    }
  };
  

  // Module: main.js
  // Main entry point
  window.module['main.js'] = {
    version: '2.0.0-alpha',
  
    run: function() {
      console.log('Initializing API Test Interface v2.0...');
      console.log('Version:', this.version);
      console.log('Mode: Planning Mode (Execution Mode not yet implemented)');
  
      // Initialize all modules (they self-initialize when ui-manager.init() calls them)
      const uiManager = window.module['ui-manager.js'];
      uiManager.init();
  
      console.log('API Test Interface ready!');
      console.log('');
      console.log('v2.0 Features:');
      console.log('âœ“ New message system with types');
      console.log('âœ“ JSON response format with terminator');
      console.log('âœ“ Planning Mode with system prompt');
      console.log('âœ“ Tool system (list_folder, read_file)');
      console.log('âœ“ Message processor (parse & validate)');
      console.log('');
      console.log('TODO:');
      console.log('- Execution Mode');
      console.log('- Tool execution (create_file, edit_file)');
      console.log('- Summarization (500K limit)');
      console.log('- Partial message continuation');
      console.log('- Auto-call after tool execution');
    }
  };
  

  // Module: message-processor.js
  // Message Processor
  // Handles processing of streamed responses with = prefix (message) or { prefix (tools)
  window.module['message-processor.js'] = {
    TERMINATOR: '|||||END|||||',
  
    processStreamedResponse: function(rawText) {
      // Check for terminator
      if (!rawText.includes(this.TERMINATOR)) {
        return {
          complete: false,
          content: rawText,
          error: null
        };
      }
  
      // Extract content before terminator
      const terminatorIndex = rawText.indexOf(this.TERMINATOR);
      const content = rawText.substring(0, terminatorIndex);
  
      // Detect response type by first character
      const firstChar = content.charAt(0);
  
      if (firstChar === '=') {
        // Message response
        return this.processMessage(content);
      } else if (firstChar === '{') {
        // Tool execution response
        return this.processTools(content);
      } else {
        return {
          complete: true,
          content: null,
          error: `Invalid response format: must start with = or {, got "${firstChar}"`,
          originalContent: rawText
        };
      }
    },
  
    processMessage: function(text) {
      // Remove = prefix
      const message = text.substring(1);
  
      return {
        complete: true,
        content: {
          type: 'message',
          text: message
        },
        error: null
      };
    },
  
    processTools: function(jsonText) {
      // Parse JSON
      try {
        const data = JSON.parse(jsonText);
  
        // Validate structure
        if (!data || typeof data !== 'object') {
          return {
            complete: true,
            content: null,
            error: 'Invalid tools response: not an object',
            originalContent: jsonText
          };
        }
  
        if (!Array.isArray(data.tools)) {
          return {
            complete: true,
            content: null,
            error: 'Invalid tools response: tools must be an array',
            originalContent: jsonText
          };
        }
  
        // TODO: Add comprehensive tool validation
        // - Check each tool has name and args
        // - Validate tool names
        // - Validate args match tool requirements
  
        return {
          complete: true,
          content: {
            type: 'execute',
            tools: data.tools
          },
          error: null
        };
  
      } catch (e) {
        // TODO: Implement JSON repair logic
        return {
          complete: true,
          content: null,
          error: `JSON parse error: ${e.message}`,
          originalContent: jsonText
        };
      }
    }
  };
  

  // Module: mode-manager.js
  // Mode Manager
  // Manages mode state, transitions, and prompt selection
  window.module['mode-manager.js'] = {
    state: {
      mode: 'planning', // Always start in planning mode
      checklist: [],
      current_item_index: 0
    },
  
    init: function() {
      this.state = {
        mode: 'planning',
        checklist: [],
        current_item_index: 0
      };
    },
  
    getMode: function() {
      return this.state.mode;
    },
  
    getSystemPrompt: function() {
      if (this.state.mode === 'planning') {
        return this.getPlanningModePrompt();
      } else {
        return this.getExecutionModePrompt();
      }
    },
  
    getPlanningModePrompt: function() {
      return `<system-reminder>
  You are a helpful AI coding assistant in PLANNING MODE.
  
  Your goal is to understand what the user wants to accomplish through conversation.
  
  ## What you should do:
  
  1. Ask clarifying questions about the task
  2. Explore the codebase using list_folder and read_file (as many files as needed)
  3. Understand the current state and requirements
  4. When ready to make CHANGES, create a checklist and exit to execution mode
  
  IMPORTANT: You can read as many files as you want in planning mode. Only exit to execution mode when you need to CREATE or MODIFY files. Reading is part of planning.
  
  ## Response Format
  
  ALL responses must end with |||||END|||||
  
  Two response types in planning mode:
  
  ### 1. Message Response
  When you want to ask questions or discuss, start with = followed by your message:
  
  =Your message to the user here. Can be multiple lines.
  You can include newlines and formatting.|||||END|||||
  
  ### 2. Tool Execution
  When you need to use tools, start with { and provide valid JSON:
  
  {"tools":[{"name":"list_folder","args":{"path":"src/"}},{"name":"read_file","args":{"path":"src/main.js"}}]}|||||END|||||
  
  IMPORTANT: Don't send a message first saying you're going to use tools. Just use them.
  The user sees the tool execution, so announcing it is redundant.
  
  ## Available Tools in Planning Mode
  
  - list_folder: Explore directories (non-recursive)
  - read_file: Read file contents
  - exit_planning: Exit planning with checklist
  
  Example exit_planning:
  {"tools":[{"name":"exit_planning","args":{"checklist":[{"short_desc":"Brief description for UI","long_desc":"Detailed description for execution"}]}}]}|||||END|||||
  
  ## Rules
  
  1. Be conversational and ask questions
  2. Don't start implementing until you call exit_planning
  3. Break down complex tasks into discrete checklist items
  4. Each checklist item should be independently verifiable
  5. Keep short_desc concise (for UI display)
  6. Make long_desc detailed (for execution context)
  7. **ACTION OVER ANNOUNCEMENT**: When you need to use tools, just use them immediately. Don't send a message saying "Let me check..." or "I'll read..." - just execute the tools. The user will see the tool results.
  
  </system-reminder>`;
    },
  
    getExecutionModePrompt: function() {
      // TODO: Implement execution mode
      const currentItem = this.state.checklist[this.state.current_item_index];
      const taskDesc = currentItem ? currentItem.long_desc : 'No task assigned';
  
      return `<system-reminder>
  You are a helpful AI coding assistant in EXECUTION MODE.
  
  Your ONLY job is to complete the current checklist item.
  
  ## Current Task
  
  ${taskDesc}
  
  ## What you should do:
  
  1. Focus ONLY on this task
  2. Use file operations as needed
  3. When finished, call item_completed
  4. If you can't complete it, call item_failed with a reason
  
  ## Response Format
  
  ALL responses must end with |||||END|||||
  
  Two response types:
  
  ### 1. Message Response
  Start with = followed by your message:
  
  =Task completed successfully.|||||END|||||
  
  ### 2. Tool Execution
  Start with { and provide valid JSON:
  
  {"tools":[{"name":"create_file","args":{"path":"src/new.js","content":"console.log('hello');"}}]}|||||END|||||
  
  ## Available Tools in Execution Mode
  
  - list_folder: Explore directories
  - read_file: Read files
  - create_file: Create new files
  - edit_file: Edit existing files
  - item_completed: Mark task complete
  - item_failed: Mark task failed
  
  ## Rules
  
  1. Focus ONLY on the current task
  2. Don't try to complete other checklist items
  3. Be concise in execution mode
  4. Always call item_completed or item_failed when done
  5. If uncertain or blocked, call item_failed to return to planning
  
  </system-reminder>`;
    },
  
    // TODO: Implement mode transitions
    transitionToExecution: function(checklist) {
      console.warn('Execution mode not yet implemented - staying in planning mode');
      // this.state.mode = 'execution';
      // this.state.checklist = checklist;
      // this.state.current_item_index = 0;
    },
  
    transitionToPlanning: function(reason) {
      this.state.mode = 'planning';
      this.state.current_item_index = 0;
    }
  };
  

  // Module: tool-executor.js
  // Tool Executor
  // Executes tools and returns results
  window.module['tool-executor.js'] = {
    executeTools: async function(tools) {
      const results = [];
  
      // Execute tools sequentially
      for (let i = 0; i < tools.length; i++) {
        const tool = tools[i];
        const result = await this.executeTool(tool);
  
        results.push(result);
  
        // Stop on first error
        if (!result.success) {
          break;
        }
      }
  
      return results;
    },
  
    executeTool: async function(tool) {
      const fileSystem = window.module['file-system.js'];
  
      try {
        switch (tool.name) {
          case 'list_folder':
            return await this.listFolder(tool.args);
  
          case 'read_file':
            return await this.readFile(tool.args);
  
          case 'create_file':
            // TODO: Implement create_file
            return {
              tool: 'create_file',
              success: false,
              error: 'create_file not yet implemented',
              args: tool.args
            };
  
          case 'edit_file':
            // TODO: Implement edit_file
            return {
              tool: 'edit_file',
              success: false,
              error: 'edit_file not yet implemented',
              args: tool.args
            };
  
          case 'exit_planning':
            // TODO: Implement mode transition
            return {
              tool: 'exit_planning',
              success: false,
              error: 'exit_planning not yet implemented (execution mode disabled)',
              args: tool.args
            };
  
          case 'item_completed':
          case 'item_failed':
            // TODO: Implement execution mode tools
            return {
              tool: tool.name,
              success: false,
              error: `${tool.name} not yet implemented (execution mode disabled)`,
              args: tool.args
            };
  
          default:
            return {
              tool: tool.name,
              success: false,
              error: `Unknown tool: ${tool.name}`,
              args: tool.args
            };
        }
      } catch (error) {
        return {
          tool: tool.name,
          success: false,
          error: error.message,
          args: tool.args
        };
      }
    },
  
    listFolder: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'list_folder',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the folder in the file tree
      const folder = this.findFolderInTree(fileSystem.fileTree, args.path);
      if (!folder) {
        return {
          tool: 'list_folder',
          success: false,
          error: `Directory not found: ${args.path}`,
          args: args
        };
      }
  
      // Return children
      const entries = folder.children.map(child => ({
        name: child.name,
        type: child.type,
        size_bytes: child.type === 'file' ? child.charCount : 0
      }));
  
      return {
        tool: 'list_folder',
        success: true,
        result: entries,
        args: args
      };
    },
  
    readFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'read_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the file in the file tree
      const file = this.findFileInTree(fileSystem.fileTree, args.path);
      if (!file) {
        return {
          tool: 'read_file',
          success: false,
          error: `File not found: ${args.path}`,
          args: args
        };
      }
  
      // Read the file
      const content = await fileSystem.readFile(file);
      if (content === null) {
        return {
          tool: 'read_file',
          success: false,
          error: `Failed to read file: ${args.path}`,
          args: args
        };
      }
  
      // TODO: Handle start_line and end_line parameters
      return {
        tool: 'read_file',
        success: true,
        result: content,
        args: args
      };
    },
  
    findFolderInTree: function(tree, path) {
      if (!path || path === '' || path === '.') {
        return { children: tree };
      }
  
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'directory') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFolderInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    },
  
    findFileInTree: function(tree, path) {
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'file') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFileInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    }
  };
  

  // Module: ui-manager.js
  // UI Manager v2.0
  // Coordinates UI rendering and handles user interactions
  window.module['ui-manager.js'] = {
    init: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const modeManager = window.module['mode-manager.js'];
      const apiClient = window.module['api-client.js'];
  
      conversationManager.init();
      modeManager.init();
      apiClient.init();
  
      this.showIntroScreen();
    },
  
    showIntroScreen: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Create intro container
      const container = document.createElement('div');
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
  
      const content = document.createElement('div');
      content.style.cssText = `
        text-align: center;
        max-width: 500px;
        padding: 40px;
      `;
  
      content.innerHTML = `
        <h1 style="font-size: 32px; margin-bottom: 16px; font-weight: 600;">
          API Test Interface v2.0
        </h1>
        <p style="font-size: 16px; color: #858585; margin-bottom: 32px;">
          Planning Mode â€¢ AI-Driven Development
        </p>
        <p style="font-size: 14px; margin-bottom: 32px; line-height: 1.6;">
          Select a project folder to begin. The AI will use tools to explore
          and modify files as you work together.
        </p>
        <button id="selectFolderIntro" style="
          background: #0e639c;
          color: white;
          border: none;
          padding: 12px 32px;
          border-radius: 3px;
          cursor: pointer;
          font-size: 15px;
          font-weight: 500;
        ">Select Folder</button>
      `;
  
      container.appendChild(content);
      document.body.appendChild(container);
  
      document.getElementById('selectFolderIntro').addEventListener('click', () => this.selectFolderAndStart());
    },
  
    selectFolderAndStart: async function() {
      const fileSystem = window.module['file-system.js'];
      const success = await fileSystem.requestDirectory();
  
      if (success) {
        this.initChatUI();
      }
    },
  
    initChatUI: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Add spinner animation style
      const style = document.createElement('style');
      style.textContent = `
        @keyframes spin {
          0% { content: 'â ‹'; }
          12.5% { content: 'â ™'; }
          25% { content: 'â ¹'; }
          37.5% { content: 'â ¸'; }
          50% { content: 'â ¼'; }
          62.5% { content: 'â ´'; }
          75% { content: 'â ¦'; }
          87.5% { content: 'â §'; }
          100% { content: 'â ‡'; }
        }
        .spinner::before {
          content: 'â ‹';
          animation: spin 0.8s steps(8) infinite;
        }
      `;
      document.head.appendChild(style);
  
      // Create main container
      const container = document.createElement('div');
      container.id = 'test-interface';
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      // Chat area (full width, no header)
      const chatPanel = document.createElement('div');
      chatPanel.style.cssText = `
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      const chatArea = document.createElement('div');
      chatArea.id = 'chatArea';
      chatArea.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 20px;
      `;
      chatPanel.appendChild(chatArea);
  
      // Input area
      const inputArea = document.createElement('div');
      inputArea.style.cssText = `
        padding: 15px 20px;
        background: #252526;
        border-top: 1px solid #3e3e42;
      `;
      inputArea.innerHTML = `
        <textarea id="userInput" placeholder="Type your message (Enter to send, Shift+Enter for newline)..." style="
          width: 100%;
          min-height: 80px;
          background: #1e1e1e;
          color: #d4d4d4;
          border: 1px solid #3e3e42;
          border-radius: 3px;
          padding: 10px;
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          font-size: 13px;
          resize: vertical;
        "></textarea>
        <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span id="folderName" style="font-size: 12px; color: #858585;"></span>
            <span id="loadingIndicator" style="font-size: 12px; color: #858585; display: none;">
              <span class="spinner"></span> <span id="loadingText">Processing...</span>
            </span>
          </div>
          <span id="charCount" style="font-size: 12px; color: #858585;"></span>
        </div>
        <div id="errorMsg" style="margin-top: 4px; color: #f48771; font-size: 13px;"></div>
      `;
      chatPanel.appendChild(inputArea);
  
      container.appendChild(chatPanel);
      document.body.appendChild(container);
  
      // Event listeners
      document.getElementById('userInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSubmit();
        }
        // Shift+Enter allows newline (default textarea behavior)
      });
  
      // Set folder name
      const fileSystem = window.module['file-system.js'];
      const folderNameElement = document.getElementById('folderName');
      if (fileSystem.directoryHandle) {
        folderNameElement.textContent = `ðŸ“ ${fileSystem.directoryHandle.name}`;
      }
  
      this.updateCharCounter();
    },
  
    handleSubmit: async function() {
      const input = document.getElementById('userInput');
      const content = input.value.trim();
  
      if (!content) return;
  
      // Clear input
      input.value = '';
  
      // Hide any previous error
      this.hideError();
  
      try {
        // Add user message
        await this.addUserMessage(content);
  
        // Get AI response
        await this.getAIResponse();
  
      } catch (error) {
        console.error('Error:', error);
        this.showError(error.message);
      }
    },
  
    addUserMessage: async function(content) {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
  
      const userMessage = {
        type: 'user',
        content: content
      };
  
      conversationManager.addMessage(userMessage);
      this.renderChat();
      this.updateCharCounter();
    },
  
    getAIResponse: async function() {
      const conversationManager = window.module['conversation-manager.js'];
      const apiRenderer = window.module['api-renderer.js'];
      const apiClient = window.module['api-client.js'];
      const messageProcessor = window.module['message-processor.js'];
      const toolExecutor = window.module['tool-executor.js'];
      const utils = window.module['utils.js'];
      const config = window.module['config.js'];
  
      // Show loading indicator
      this.showLoading('Thinking...');
  
      // Render messages for API
      const messages = conversationManager.getMessages();
      const apiMessages = apiRenderer.renderMessagesForAPI(messages);
  
      // Create chat if needed
      if (!apiClient.chatId && messages.length > 0) {
        const firstUserMsg = messages.find(m => m.type === 'user');
        if (firstUserMsg) {
          await apiClient.createNewChat(firstUserMsg.content);
        }
      }
  
      // Get completion with streaming
      const assistantMessageId = utils.generateUUID();
  
      let retryCount = 0;
      let success = false;
      let accumulatedContent = '';
      let streamingMessageId = null;
      let responseType = null; // 'message' or 'tools'
  
      while (retryCount < config.MAX_RETRIES && !success) {
        try {
          const response = await apiClient.getCompletion(apiMessages, assistantMessageId);
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
  
          while (true) {
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Timeout')), config.TIMEOUT_MS);
            });
  
            const readPromise = reader.read();
            const result = await Promise.race([readPromise, timeoutPromise]);
  
            if (result.done) break;
  
            const chunk = decoder.decode(result.value, { stream: true });
            const lines = chunk.split('\n');
  
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const data = line.slice(6);
                if (data === '[DONE]') continue;
  
                try {
                  const parsed = JSON.parse(data);
                  if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                    const deltaContent = parsed.choices[0].delta.content;
                    accumulatedContent += deltaContent;
  
                    // Detect response type from first character
                    if (responseType === null && accumulatedContent.length > 0) {
                      const firstChar = accumulatedContent.charAt(0);
                      if (firstChar === '=') {
                        responseType = 'message';
                        // Create streaming message
                        streamingMessageId = utils.generateUUID();
                        conversationManager.addMessage({
                          id: streamingMessageId,
                          type: 'assistant',
                          content: '',
                          streaming: true
                        });
                      } else if (firstChar === '{') {
                        responseType = 'tools';
                        // Don't create message yet, wait for complete JSON
                      }
                    }
  
                    // Update streaming message in real-time
                    if (responseType === 'message' && streamingMessageId) {
                      // Extract message content (remove = prefix and terminator if present)
                      let messageContent = accumulatedContent.substring(1); // Remove =
                      const terminatorIndex = messageContent.indexOf(messageProcessor.TERMINATOR);
                      if (terminatorIndex !== -1) {
                        messageContent = messageContent.substring(0, terminatorIndex);
                      }
  
                      // Update the streaming message
                      const msgs = conversationManager.getMessages();
                      const streamingMsg = msgs.find(m => m.id === streamingMessageId);
                      if (streamingMsg) {
                        streamingMsg.content = messageContent;
                        this.renderChat();
                        this.updateCharCounter();
                      }
                    }
                  }
                } catch (e) {
                  // Ignore parse errors in streaming data
                }
              }
            }
          }
  
          // Process the accumulated response
          const processed = messageProcessor.processStreamedResponse(accumulatedContent);
  
          if (processed.error) {
            // Add system error message
            conversationManager.addMessage({
              type: 'system_error',
              error: processed.error,
              originalContent: processed.originalContent || accumulatedContent
            });
            this.renderChat();
            this.updateCharCounter();
            this.hideLoading();
            return;
          }
  
          if (!processed.complete) {
            // TODO: Handle partial responses with continuation
            conversationManager.addMessage({
              type: 'partial',
              content: accumulatedContent,
              completion: false
            });
            this.renderChat();
            this.updateCharCounter();
            this.hideLoading();
            return;
          }
  
          // Successfully got complete response
          const aiResponse = processed.content;
  
          if (aiResponse.type === 'message') {
            // Message was already streamed, just mark as complete
            if (streamingMessageId) {
              const msgs = conversationManager.getMessages();
              const streamingMsg = msgs.find(m => m.id === streamingMessageId);
              if (streamingMsg) {
                streamingMsg.streaming = false;
                streamingMsg.content = aiResponse.text;
              }
            } else {
              // Fallback: add message if streaming didn't work
              conversationManager.addMessage({
                type: 'assistant',
                content: aiResponse.text
              });
            }
            this.renderChat();
            this.updateCharCounter();
            this.hideLoading();
            success = true;
  
          } else if (aiResponse.type === 'execute') {
            // Tool execution
            conversationManager.addMessage({
              type: 'tool_use',
              tools: aiResponse.tools
            });
            this.renderChat();
            this.updateCharCounter();
  
            // Update loading indicator for tool execution
            this.showLoading('Executing tools...');
  
            // Execute tools
            const toolResults = await toolExecutor.executeTools(aiResponse.tools);
  
            // Add tool results to conversation
            for (const result of toolResults) {
              conversationManager.addMessage({
                type: 'tool_result',
                tool: result.tool,
                success: result.success,
                result: result.result,
                error: result.error,
                args: result.args
              });
            }
  
            this.renderChat();
            this.updateCharCounter();
  
            // Auto-call API again to let AI respond to tool results
            await this.getAIResponse();
            success = true;
          }
  
        } catch (error) {
          retryCount++;
          console.warn(`Attempt ${retryCount} failed:`, error.message);
  
          if (retryCount >= config.MAX_RETRIES) {
            this.hideLoading();
            throw error;
          }
  
          // Wait 1 second before retry
          await new Promise(resolve => setTimeout(resolve, 1000));
          accumulatedContent = ''; // Reset for retry
          streamingMessageId = null;
          responseType = null;
        }
      }
  
      this.hideLoading();
      this.updateCharCounter();
    },
  
    renderChat: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const uiRenderer = window.module['ui-renderer.js'];
      const chatArea = document.getElementById('chatArea');
  
      chatArea.innerHTML = '';
  
      const messages = conversationManager.getMessages();
      messages.forEach(msg => {
        const msgElement = uiRenderer.renderMessage(msg);
        chatArea.appendChild(msgElement);
      });
  
      // Scroll to bottom
      chatArea.scrollTop = chatArea.scrollHeight;
    },
  
    updateCharCounter: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
      const charCount = document.getElementById('charCount');
  
      const total = conversationManager.getTotalCharacterCount();
      charCount.textContent = `Total: ${utils.formatCharCount(total)}`;
    },
  
    showError: function(message) {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = message;
    },
  
    hideError: function() {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = '';
    },
  
    showLoading: function(text = 'Processing...') {
      const loadingIndicator = document.getElementById('loadingIndicator');
      const loadingText = document.getElementById('loadingText');
      if (loadingIndicator && loadingText) {
        loadingText.textContent = text;
        loadingIndicator.style.display = 'inline';
      }
    },
  
    hideLoading: function() {
      const loadingIndicator = document.getElementById('loadingIndicator');
      if (loadingIndicator) {
        loadingIndicator.style.display = 'none';
      }
    }
  };
  

  // Module: ui-renderer.js
  // UI Renderer
  // Renders messages in the UI
  window.module['ui-renderer.js'] = {
    renderMessage: function(message) {
      const utils = window.module['utils.js'];
      const msgDiv = document.createElement('div');
      msgDiv.style.cssText = 'margin-bottom: 20px; padding: 15px; border-radius: 8px; font-family: monospace;';
  
      // Different styles for different message types
      if (message.type === 'user') {
        msgDiv.style.backgroundColor = '#2d2d30';
        msgDiv.style.borderLeft = '4px solid #007acc';
        msgDiv.innerHTML = `
          <div style="color: #007acc; font-weight: bold; margin-bottom: 8px;">User</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(message.content)}</div>
          <div style="color: #858585; font-size: 11px; margin-top: 8px;">${utils.formatCharCount(message.content.length)}</div>
        `;
      } else if (message.type === 'assistant') {
        msgDiv.style.backgroundColor = '#1e3a1e';
        msgDiv.style.borderLeft = '4px solid #4ec9b0';
  
        // Try to parse and display JSON content nicely
        let displayContent = message.content;
        try {
          const parsed = JSON.parse(message.content.replace('|||||END|||||', ''));
          if (parsed.type === 'message') {
            displayContent = parsed.content;
          } else {
            displayContent = JSON.stringify(parsed, null, 2);
          }
        } catch (e) {
          // Not JSON, display as-is
        }
  
        msgDiv.innerHTML = `
          <div style="color: #4ec9b0; font-weight: bold; margin-bottom: 8px;">Assistant</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(displayContent)}</div>
          <div style="color: #858585; font-size: 11px; margin-top: 8px;">${utils.formatCharCount(message.content.length)}</div>
        `;
      } else if (message.type === 'system_error') {
        msgDiv.style.backgroundColor = '#3a1e1e';
        msgDiv.style.borderLeft = '4px solid #f48771';
        msgDiv.innerHTML = `
          <div style="color: #f48771; font-weight: bold; margin-bottom: 8px;">System Error</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(message.error)}</div>
        `;
      } else if (message.type === 'system_warning') {
        msgDiv.style.backgroundColor = '#3a341e';
        msgDiv.style.borderLeft = '4px solid #dcdcaa';
        msgDiv.innerHTML = `
          <div style="color: #dcdcaa; font-weight: bold; margin-bottom: 8px;">System Warning</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(message.warning)}</div>
        `;
      } else if (message.type === 'tool_use') {
        msgDiv.style.backgroundColor = '#2d2d30';
        msgDiv.style.borderLeft = '4px solid #ce9178';
        msgDiv.innerHTML = `
          <div style="color: #ce9178; font-weight: bold; margin-bottom: 8px;">Tool Use</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(JSON.stringify(message.tools, null, 2))}</div>
        `;
      } else if (message.type === 'tool_result') {
        msgDiv.style.backgroundColor = '#2d2d30';
        msgDiv.style.borderLeft = '4px solid #b5cea8';
        const resultText = message.success ? JSON.stringify(message.result, null, 2) : message.error;
        msgDiv.innerHTML = `
          <div style="color: #b5cea8; font-weight: bold; margin-bottom: 8px;">Tool Result: ${message.tool}</div>
          <div style="color: ${message.success ? '#d4d4d4' : '#f48771'}; white-space: pre-wrap;">${this.escapeHtml(resultText)}</div>
        `;
      } else {
        // Unknown type - display basic info
        msgDiv.style.backgroundColor = '#2d2d30';
        msgDiv.innerHTML = `
          <div style="color: #858585; font-weight: bold; margin-bottom: 8px;">Unknown Type: ${message.type}</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(JSON.stringify(message, null, 2))}</div>
        `;
      }
  
      return msgDiv;
    },
  
    escapeHtml: function(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };
  

  // Module: utils.js
  // Utility Functions
  window.module['utils.js'] = {
    generateUUID: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    },
  
    generateSessionId: function() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
      let result = '';
      for (let i = 0; i < 20; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    },
  
    getTimestamp: function() {
      return Math.floor(Date.now() / 1000);
    },
  
    countCharacters: function(messages) {
      // Count entire JSON structure, not just content
      // This matches the spec requirement for 500K limit
      return messages.reduce((total, msg) => total + JSON.stringify(msg).length, 0);
    },
  
    formatCharCount: function(count) {
      return `${(count / 1000).toFixed(1)}K`;
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
