// AI Agent - Built 2025-11-29T17:14:58.715Z
(function() {
  window.module = {};

  // Module: api-client.js
  // API Client
  window.module['api-client.js'] = {
    chatId: null,
    sessionId: null,
  
    init: function() {
      const utils = window.module['utils.js'];
      this.sessionId = utils.generateSessionId();
    },
  
    createNewChat: async function(firstMessage) {
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      const messageId = utils.generateUUID();
      const timestamp = utils.getTimestamp();
  
      const payload = {
        chat: {
          id: '',
          title: 'Chat Pending',
          models: [config.MODEL],
          params: {},
          history: {
            messages: {
              [messageId]: {
                id: messageId,
                parentId: null,
                childrenIds: [],
                role: 'user',
                content: firstMessage,
                timestamp: timestamp,
                models: [config.MODEL]
              }
            },
            currentId: messageId
          },
          messages: [
            {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: 'user',
              content: firstMessage,
              timestamp: timestamp,
              models: [config.MODEL]
            }
          ],
          tags: [],
          timestamp: Date.now()
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/new`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to create chat: ${response.status} ${response.statusText}`);
      }
  
      const data = await response.json();
      this.chatId = data.id;
  
      return { chatId: data.id, messageId };
    },
  
    updateChat: async function(messages) {
      const config = window.module['config.js'];
  
      // Build history object
      const historyMessages = {};
      messages.forEach((msg) => {
        historyMessages[msg.id] = {
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp,
          ...(msg.role === 'user' ? { models: [config.MODEL] } : {
            model: config.MODEL,
            modelIdx: 0,
            modelName: config.MODEL,
            userContext: null
          })
        };
      });
  
      const currentId = messages[messages.length - 1].id;
  
      const payload = {
        chat: {
          models: [config.MODEL],
          files: [],
          params: {},
          history: {
            messages: historyMessages,
            currentId: currentId
          },
          messages: messages.map(msg => ({
            id: msg.id,
            parentId: msg.parentId,
            childrenIds: msg.childrenIds,
            content: msg.content,
            role: msg.role,
            timestamp: msg.timestamp,
            ...(msg.role === 'user' ? { models: [config.MODEL] } : {
              model: config.MODEL,
              modelIdx: 0,
              modelName: config.MODEL,
              userContext: null
            })
          }))
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/${this.chatId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to update chat: ${response.status} ${response.statusText}`);
      }
  
      return await response.json();
    },
  
    getCompletion: async function(apiMessages, assistantMessageId) {
      const config = window.module['config.js'];
  
      // apiMessages is already in API format from api-renderer
      const payload = {
        stream: true,
        model: config.MODEL,
        messages: apiMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: true,
          tags_generation: true
        }
      };
  
      const response = await fetch(`${config.API_BASE}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to get completion: ${response.status} ${response.statusText}`);
      }
  
      return response;
    }
  };
  

  // Module: api-renderer.js
  // API Renderer
  // Transforms internal message format to API format
  window.module['api-renderer.js'] = {
    renderMessagesForAPI: function(messages) {
      const modeManager = window.module['mode-manager.js'];
      const apiMessages = [];
  
      // Find latest summary
      let latestSummaryIndex = -1;
      let summaryContent = null;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].type === 'summary') {
          latestSummaryIndex = i;
          summaryContent = messages[i].content;
          break;
        }
      }
  
      // Start converting messages after the summary (or from beginning if no summary)
      const startIndex = latestSummaryIndex >= 0 ? latestSummaryIndex + 1 : 0;
  
      let firstUserMessageIndex = -1;
      let pendingWarnings = []; // Can accumulate multiple warnings
  
      for (let i = startIndex; i < messages.length; i++) {
        const msg = messages[i];
  
        // Collect system_warning messages to merge with next user message
        if (msg.type === 'system_warning') {
          pendingWarnings.push(msg.warning);
          continue;
        }
  
        // Handle different message types
        if (msg.type === 'user') {
          let content = msg.content;
  
          // Is this the first user message we're adding to API?
          if (firstUserMessageIndex === -1) {
            firstUserMessageIndex = apiMessages.length;
  
            // Build prefix: system prompt + summary (if exists)
            let prefix = modeManager.getSystemPrompt();
  
            if (summaryContent) {
              prefix += '\n\n' + summaryContent;
            }
  
            content = prefix + '\n\n' + content;
          }
  
          // Prepend any pending warnings
          if (pendingWarnings.length > 0) {
            const warningsText = pendingWarnings.map(w => `[System: ${w}]`).join('\n');
            content = warningsText + '\n\n' + content;
            pendingWarnings = [];
          }
  
          apiMessages.push({
            role: 'user',
            content: content
          });
  
        } else if (msg.type === 'assistant') {
          // Assistant message responses are already in JSON format
          apiMessages.push({
            role: 'assistant',
            content: msg.content
          });
  
        } else if (msg.type === 'tool_use') {
          // Tool execution - stringify the tools array
          apiMessages.push({
            role: 'assistant',
            content: JSON.stringify({ type: 'execute', tools: msg.tools }) + '|||||END|||||'
          });
  
        } else if (msg.type === 'tool_result') {
          // Tool results are sent as user messages
          const resultText = msg.success
            ? `Tool: ${msg.tool}\nResult: ${JSON.stringify(msg.result)}`
            : `Tool: ${msg.tool}\nError: ${msg.error}`;
          apiMessages.push({
            role: 'user',
            content: resultText
          });
  
        } else if (msg.type === 'system_error') {
          apiMessages.push({
            role: 'user',
            content: `Error: ${msg.error}`
          });
  
        } else if (msg.type === 'partial') {
          // TODO: Combine consecutive partials into single assistant message
          // Partials should be combined before being sent to API
          // For now, skip partials (combination not yet implemented)
          continue;
        }
      }
  
      return apiMessages;
    }
  };
  

  // Module: config.js
  // Configuration
  window.module['config.js'] = {
    API_BASE: 'https://chat.niprgpt.mil/api',
    MODEL: 'Anthropic Claude 4 Sonnet',
    MAX_RETRIES: 5,
    TIMEOUT_MS: 30000 // 30 seconds
  };
  

  // Module: conversation-manager.js
  // Conversation Manager
  // Manages message array, character counting, and (TODO) summarization
  window.module['conversation-manager.js'] = {
    messages: [],
  
    init: function() {
      this.messages = [];
    },
  
    addMessage: function(message) {
      const utils = window.module['utils.js'];
  
      // Ensure message has required fields
      if (!message.id) {
        message.id = utils.generateUUID();
      }
      if (!message.timestamp) {
        message.timestamp = utils.getTimestamp();
      }
      if (!message.parentId) {
        message.parentId = this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null;
      }
      if (!message.childrenIds) {
        message.childrenIds = [];
      }
  
      // Update parent's childrenIds
      if (message.parentId) {
        const parent = this.messages.find(m => m.id === message.parentId);
        if (parent) {
          parent.childrenIds.push(message.id);
        }
      }
  
      // TODO: Check 500K character limit and trigger summarization
      // For now, just add the message
      this.messages.push(message);
  
      return message;
    },
  
    getMessages: function() {
      return this.messages;
    },
  
    getTotalCharacterCount: function() {
      const utils = window.module['utils.js'];
      return utils.countCharacters(this.messages);
    },
  
    // TODO: Implement summarization
    summarize: function() {
      console.warn('Summarization not yet implemented');
      return null;
    }
  };
  

  // Module: file-system.js
  // File System Handler
  window.module['file-system.js'] = {
    directoryHandle: null,
    fileTree: [],
  
    requestDirectory: async function() {
      try {
        this.directoryHandle = await window.showDirectoryPicker();
        this.fileTree = await this.buildFileTree(this.directoryHandle);
        return true;
      } catch (err) {
        console.error('Directory access error:', err);
        return false;
      }
    },
  
    buildFileTree: async function(dirHandle, path = '') {
      const entries = [];
  
      for await (const entry of dirHandle.values()) {
        const fullPath = path ? `${path}/${entry.name}` : entry.name;
  
        if (entry.kind === 'directory') {
          const children = await this.buildFileTree(entry, fullPath);
          entries.push({
            name: entry.name,
            type: 'directory',
            path: fullPath,
            children: children,
            handle: entry
          });
        } else {
          // Read file to get character count
          let charCount = 0;
          try {
            const file = await entry.getFile();
            const text = await file.text();
            charCount = text.length;
          } catch (err) {
            console.warn('Could not read file for char count:', entry.name);
          }
  
          entries.push({
            name: entry.name,
            type: 'file',
            path: fullPath,
            handle: entry,
            charCount: charCount
          });
        }
      }
  
      return entries.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
    },
  
    readFile: async function(fileEntry) {
      try {
        const file = await fileEntry.handle.getFile();
        const text = await file.text();
        return text;
      } catch (err) {
        console.error('File read error:', err);
        return null;
      }
    }
  };
  

  // Module: main.js
  // Main entry point
  window.module['main.js'] = {
    version: '2.0.0-alpha',
  
    run: function() {
      console.log('Initializing API Test Interface v2.0...');
      console.log('Version:', this.version);
      console.log('Mode: Planning Mode (Execution Mode not yet implemented)');
  
      // Initialize all modules (they self-initialize when ui-manager.init() calls them)
      const uiManager = window.module['ui-manager.js'];
      uiManager.init();
  
      console.log('API Test Interface ready!');
      console.log('');
      console.log('v2.0 Features:');
      console.log('✓ New message system with types');
      console.log('✓ JSON response format with terminator');
      console.log('✓ Planning Mode with system prompt');
      console.log('✓ Tool system (list_folder, read_file)');
      console.log('✓ Message processor (parse & validate)');
      console.log('');
      console.log('TODO:');
      console.log('- Execution Mode');
      console.log('- Tool execution (create_file, edit_file)');
      console.log('- Summarization (500K limit)');
      console.log('- Partial message continuation');
      console.log('- Auto-call after tool execution');
    }
  };
  

  // Module: message-processor.js
  // Message Processor
  // Handles 3-layer processing: trimming, parsing, validation
  window.module['message-processor.js'] = {
    TERMINATOR: '|||||END|||||',
  
    processStreamedResponse: function(rawText) {
      // Layer 1: Trim text (basic implementation)
      const trimmed = this.trimText(rawText);
  
      // Check for terminator
      if (!trimmed.includes(this.TERMINATOR)) {
        return {
          complete: false,
          content: trimmed,
          error: null
        };
      }
  
      // Layer 2: Parse JSON
      const parsed = this.parseJSON(trimmed);
      if (parsed.error) {
        return {
          complete: true,
          content: null,
          error: parsed.error,
          originalContent: trimmed
        };
      }
  
      // Layer 3: Validate (basic implementation)
      const validated = this.validate(parsed.data);
      if (validated.error) {
        return {
          complete: true,
          content: null,
          error: validated.error,
          originalContent: trimmed
        };
      }
  
      return {
        complete: true,
        content: validated.data,
        error: null
      };
    },
  
    trimText: function(text) {
      // TODO: Implement sophisticated trimming logic
      // For now, just trim whitespace
      return text.trim();
    },
  
    parseJSON: function(text) {
      // Extract JSON before terminator
      const terminatorIndex = text.indexOf(this.TERMINATOR);
      if (terminatorIndex === -1) {
        return { error: 'Terminator not found', data: null };
      }
  
      const jsonText = text.substring(0, terminatorIndex).trim();
  
      try {
        const data = JSON.parse(jsonText);
        return { error: null, data: data };
      } catch (e) {
        // TODO: Implement JSON repair logic
        return { error: `JSON parse error: ${e.message}`, data: null };
      }
    },
  
    validate: function(data) {
      // Basic validation
      if (!data || typeof data !== 'object') {
        return { error: 'Invalid data: not an object', data: null };
      }
  
      if (!data.type) {
        return { error: 'Invalid data: missing type field', data: null };
      }
  
      const validTypes = ['message', 'execute'];
      if (!validTypes.includes(data.type)) {
        return { error: `Invalid data: unknown type "${data.type}"`, data: null };
      }
  
      if (data.type === 'message' && !data.content) {
        return { error: 'Invalid message: missing content', data: null };
      }
  
      if (data.type === 'execute' && !Array.isArray(data.tools)) {
        return { error: 'Invalid execute: tools must be an array', data: null };
      }
  
      // TODO: Add more comprehensive validation
      return { error: null, data: data };
    }
  };
  

  // Module: mode-manager.js
  // Mode Manager
  // Manages mode state, transitions, and prompt selection
  window.module['mode-manager.js'] = {
    state: {
      mode: 'planning', // Always start in planning mode
      checklist: [],
      current_item_index: 0
    },
  
    init: function() {
      this.state = {
        mode: 'planning',
        checklist: [],
        current_item_index: 0
      };
    },
  
    getMode: function() {
      return this.state.mode;
    },
  
    getSystemPrompt: function() {
      if (this.state.mode === 'planning') {
        return this.getPlanningModePrompt();
      } else {
        return this.getExecutionModePrompt();
      }
    },
  
    getPlanningModePrompt: function() {
      return `<system-reminder>
  You are a helpful AI coding assistant in PLANNING MODE.
  
  Your goal is to understand what the user wants to accomplish through conversation.
  
  ## What you should do:
  
  1. Ask clarifying questions about the task
  2. Explore the codebase using list_folder and read_file
  3. Understand the current state and requirements
  4. When you have enough information, create a checklist of discrete tasks
  
  ## Response Format
  
  ALL responses must be valid JSON followed by |||||END|||||
  
  Three response types in planning mode:
  
  ### 1. Message Response
  When you want to ask questions or discuss:
  
  {
    "type": "message",
    "content": "Your message to the user here"
  }|||||END|||||
  
  ### 2. Execute Response
  When you need to explore the codebase:
  
  {
    "type": "execute",
    "tools": [
      {"name": "list_folder", "args": {"path": "src/"}},
      {"name": "read_file", "args": {"path": "src/main.js"}}
    ]
  }|||||END|||||
  
  ### 3. Exit Planning
  When you're ready to start execution:
  
  {
    "type": "execute",
    "tools": [
      {
        "name": "exit_planning",
        "args": {
          "checklist": [
            {
              "short_desc": "Brief description for UI",
              "long_desc": "Detailed description for execution"
            }
          ]
        }
      }
    ]
  }|||||END|||||
  
  ## Available Tools in Planning Mode
  
  - list_folder: Explore directories (non-recursive)
  - read_file: Read file contents
  - exit_planning: Exit planning with checklist
  
  ## Rules
  
  1. Be conversational and ask questions
  2. Don't start implementing until you call exit_planning
  3. Break down complex tasks into discrete checklist items
  4. Each checklist item should be independently verifiable
  5. Keep short_desc concise (for UI display)
  6. Make long_desc detailed (for execution context)
  
  </system-reminder>`;
    },
  
    getExecutionModePrompt: function() {
      // TODO: Implement execution mode
      const currentItem = this.state.checklist[this.state.current_item_index];
      const taskDesc = currentItem ? currentItem.long_desc : 'No task assigned';
  
      return `<system-reminder>
  You are a helpful AI coding assistant in EXECUTION MODE.
  
  Your ONLY job is to complete the current checklist item.
  
  ## Current Task
  
  ${taskDesc}
  
  ## What you should do:
  
  1. Focus ONLY on this task
  2. Use file operations as needed
  3. When finished, call item_completed
  4. If you can't complete it, call item_failed with a reason
  
  ## Response Format
  
  ALL responses must be valid JSON followed by |||||END|||||
  
  ## Available Tools in Execution Mode
  
  - list_folder: Explore directories
  - read_file: Read files
  - create_file: Create new files
  - edit_file: Edit existing files
  - item_completed: Mark task complete
  - item_failed: Mark task failed
  
  ## Rules
  
  1. Focus ONLY on the current task
  2. Don't try to complete other checklist items
  3. Be concise in execution mode
  4. Always call item_completed or item_failed when done
  5. If uncertain or blocked, call item_failed to return to planning
  
  </system-reminder>`;
    },
  
    // TODO: Implement mode transitions
    transitionToExecution: function(checklist) {
      console.warn('Execution mode not yet implemented - staying in planning mode');
      // this.state.mode = 'execution';
      // this.state.checklist = checklist;
      // this.state.current_item_index = 0;
    },
  
    transitionToPlanning: function(reason) {
      this.state.mode = 'planning';
      this.state.current_item_index = 0;
    }
  };
  

  // Module: tool-executor.js
  // Tool Executor
  // Executes tools and returns results
  window.module['tool-executor.js'] = {
    executeTools: async function(tools) {
      const results = [];
  
      // Execute tools sequentially
      for (let i = 0; i < tools.length; i++) {
        const tool = tools[i];
        const result = await this.executeTool(tool);
  
        results.push(result);
  
        // Stop on first error
        if (!result.success) {
          break;
        }
      }
  
      return results;
    },
  
    executeTool: async function(tool) {
      const fileSystem = window.module['file-system.js'];
  
      try {
        switch (tool.name) {
          case 'list_folder':
            return await this.listFolder(tool.args);
  
          case 'read_file':
            return await this.readFile(tool.args);
  
          case 'create_file':
            // TODO: Implement create_file
            return {
              tool: 'create_file',
              success: false,
              error: 'create_file not yet implemented',
              args: tool.args
            };
  
          case 'edit_file':
            // TODO: Implement edit_file
            return {
              tool: 'edit_file',
              success: false,
              error: 'edit_file not yet implemented',
              args: tool.args
            };
  
          case 'exit_planning':
            // TODO: Implement mode transition
            return {
              tool: 'exit_planning',
              success: false,
              error: 'exit_planning not yet implemented (execution mode disabled)',
              args: tool.args
            };
  
          case 'item_completed':
          case 'item_failed':
            // TODO: Implement execution mode tools
            return {
              tool: tool.name,
              success: false,
              error: `${tool.name} not yet implemented (execution mode disabled)`,
              args: tool.args
            };
  
          default:
            return {
              tool: tool.name,
              success: false,
              error: `Unknown tool: ${tool.name}`,
              args: tool.args
            };
        }
      } catch (error) {
        return {
          tool: tool.name,
          success: false,
          error: error.message,
          args: tool.args
        };
      }
    },
  
    listFolder: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'list_folder',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the folder in the file tree
      const folder = this.findFolderInTree(fileSystem.fileTree, args.path);
      if (!folder) {
        return {
          tool: 'list_folder',
          success: false,
          error: `Directory not found: ${args.path}`,
          args: args
        };
      }
  
      // Return children
      const entries = folder.children.map(child => ({
        name: child.name,
        type: child.type,
        size_bytes: child.type === 'file' ? child.charCount : 0
      }));
  
      return {
        tool: 'list_folder',
        success: true,
        result: entries,
        args: args
      };
    },
  
    readFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'read_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the file in the file tree
      const file = this.findFileInTree(fileSystem.fileTree, args.path);
      if (!file) {
        return {
          tool: 'read_file',
          success: false,
          error: `File not found: ${args.path}`,
          args: args
        };
      }
  
      // Read the file
      const content = await fileSystem.readFile(file);
      if (content === null) {
        return {
          tool: 'read_file',
          success: false,
          error: `Failed to read file: ${args.path}`,
          args: args
        };
      }
  
      // TODO: Handle start_line and end_line parameters
      return {
        tool: 'read_file',
        success: true,
        result: content,
        args: args
      };
    },
  
    findFolderInTree: function(tree, path) {
      if (!path || path === '' || path === '.') {
        return { children: tree };
      }
  
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'directory') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFolderInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    },
  
    findFileInTree: function(tree, path) {
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'file') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFileInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    }
  };
  

  // Module: ui-manager.js
  // UI Manager v2.0
  // Coordinates UI rendering and handles user interactions
  window.module['ui-manager.js'] = {
    init: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const modeManager = window.module['mode-manager.js'];
      const apiClient = window.module['api-client.js'];
  
      conversationManager.init();
      modeManager.init();
      apiClient.init();
  
      this.initUI();
    },
  
    initUI: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Create main container
      const container = document.createElement('div');
      container.id = 'test-interface';
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      // Header
      const header = document.createElement('div');
      header.style.cssText = `
        background: #252526;
        padding: 12px 20px;
        border-bottom: 1px solid #3e3e42;
        display: flex;
        align-items: center;
        gap: 15px;
      `;
      header.innerHTML = `
        <h1 style="margin: 0; font-size: 18px; font-weight: 600;">API Test Interface v2.0 (Planning Mode)</h1>
        <button id="selectFolder" style="
          background: #0e639c;
          color: white;
          border: none;
          padding: 6px 16px;
          border-radius: 3px;
          cursor: pointer;
          font-size: 13px;
        ">Select Folder</button>
        <span id="charCount" style="margin-left: auto; font-size: 13px; color: #858585;"></span>
      `;
      container.appendChild(header);
  
      // Chat area (full width, no sidebar)
      const chatPanel = document.createElement('div');
      chatPanel.style.cssText = `
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      const chatArea = document.createElement('div');
      chatArea.id = 'chatArea';
      chatArea.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 20px;
      `;
      chatPanel.appendChild(chatArea);
  
      // Input area
      const inputArea = document.createElement('div');
      inputArea.style.cssText = `
        padding: 15px 20px;
        background: #252526;
        border-top: 1px solid #3e3e42;
      `;
      inputArea.innerHTML = `
        <textarea id="userInput" placeholder="Type your message..." style="
          width: 100%;
          min-height: 80px;
          background: #1e1e1e;
          color: #d4d4d4;
          border: 1px solid #3e3e42;
          border-radius: 3px;
          padding: 10px;
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          font-size: 13px;
          resize: vertical;
        "></textarea>
        <div style="margin-top: 10px; display: flex; gap: 10px;">
          <button id="submitBtn" style="
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
          ">Send</button>
          <div id="errorMsg" style="color: #f48771; font-size: 13px; align-self: center;"></div>
        </div>
      `;
      chatPanel.appendChild(inputArea);
  
      container.appendChild(chatPanel);
      document.body.appendChild(container);
  
      // Event listeners
      document.getElementById('selectFolder').addEventListener('click', () => this.selectFolder());
      document.getElementById('submitBtn').addEventListener('click', () => this.handleSubmit());
      document.getElementById('userInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
          this.handleSubmit();
        }
      });
  
      this.updateCharCounter();
    },
  
    selectFolder: async function() {
      const fileSystem = window.module['file-system.js'];
      await fileSystem.requestDirectory();
      // No UI update needed - AI will use tools to access files
    },
  
    handleSubmit: async function() {
      const input = document.getElementById('userInput');
      const content = input.value.trim();
  
      if (!content) return;
  
      // Clear input
      input.value = '';
  
      // Hide any previous error
      this.hideError();
  
      try {
        // Add user message
        await this.addUserMessage(content);
  
        // Get AI response
        await this.getAIResponse();
  
      } catch (error) {
        console.error('Error:', error);
        this.showError(error.message);
      }
    },
  
    addUserMessage: async function(content) {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
  
      const userMessage = {
        type: 'user',
        content: content
      };
  
      conversationManager.addMessage(userMessage);
      this.renderChat();
      this.updateCharCounter();
    },
  
    getAIResponse: async function() {
      const conversationManager = window.module['conversation-manager.js'];
      const apiRenderer = window.module['api-renderer.js'];
      const apiClient = window.module['api-client.js'];
      const messageProcessor = window.module['message-processor.js'];
      const toolExecutor = window.module['tool-executor.js'];
      const utils = window.module['utils.js'];
      const config = window.module['config.js'];
  
      // Render messages for API
      const messages = conversationManager.getMessages();
      const apiMessages = apiRenderer.renderMessagesForAPI(messages);
  
      // Create chat if needed
      if (!apiClient.chatId && messages.length > 0) {
        const firstUserMsg = messages.find(m => m.type === 'user');
        if (firstUserMsg) {
          await apiClient.createNewChat(firstUserMsg.content);
        }
      }
  
      // Update chat
      // TODO: This still uses old format - need to refactor
      // For now, skip updateChat and go straight to getCompletion
  
      // Get completion with streaming
      const assistantMessageId = utils.generateUUID();
  
      let retryCount = 0;
      let success = false;
      let accumulatedContent = '';
  
      while (retryCount < config.MAX_RETRIES && !success) {
        try {
          const response = await apiClient.getCompletion(apiMessages, assistantMessageId);
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
  
          while (true) {
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Timeout')), config.TIMEOUT_MS);
            });
  
            const readPromise = reader.read();
            const result = await Promise.race([readPromise, timeoutPromise]);
  
            if (result.done) break;
  
            const chunk = decoder.decode(result.value, { stream: true });
            const lines = chunk.split('\n');
  
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const data = line.slice(6);
                if (data === '[DONE]') continue;
  
                try {
                  const parsed = JSON.parse(data);
                  if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                    accumulatedContent += parsed.choices[0].delta.content;
                  }
                } catch (e) {
                  // Ignore parse errors in streaming data
                }
              }
            }
          }
  
          // Process the accumulated response
          const processed = messageProcessor.processStreamedResponse(accumulatedContent);
  
          if (processed.error) {
            // Add system error message
            conversationManager.addMessage({
              type: 'system_error',
              error: processed.error,
              originalContent: processed.originalContent || accumulatedContent
            });
            this.renderChat();
            return;
          }
  
          if (!processed.complete) {
            // TODO: Handle partial responses with continuation
            conversationManager.addMessage({
              type: 'partial',
              content: accumulatedContent,
              completion: false
            });
            this.renderChat();
            return;
          }
  
          // Successfully got complete response
          const aiResponse = processed.content;
  
          if (aiResponse.type === 'message') {
            // Simple message response
            conversationManager.addMessage({
              type: 'assistant',
              content: accumulatedContent
            });
            this.renderChat();
            success = true;
  
          } else if (aiResponse.type === 'execute') {
            // Tool execution
            conversationManager.addMessage({
              type: 'tool_use',
              tools: aiResponse.tools
            });
            this.renderChat();
  
            // Execute tools
            const toolResults = await toolExecutor.executeTools(aiResponse.tools);
  
            // Add tool results to conversation
            for (const result of toolResults) {
              conversationManager.addMessage({
                type: 'tool_result',
                tool: result.tool,
                success: result.success,
                result: result.result,
                error: result.error,
                args: result.args
              });
            }
  
            this.renderChat();
  
            // TODO: Auto-call API again to let AI respond to tool results
            // For now, just stop
            success = true;
          }
  
        } catch (error) {
          retryCount++;
          console.warn(`Attempt ${retryCount} failed:`, error.message);
  
          if (retryCount >= config.MAX_RETRIES) {
            throw error;
          }
  
          // Wait 1 second before retry
          await new Promise(resolve => setTimeout(resolve, 1000));
          accumulatedContent = ''; // Reset for retry
        }
      }
  
      this.updateCharCounter();
    },
  
    renderChat: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const uiRenderer = window.module['ui-renderer.js'];
      const chatArea = document.getElementById('chatArea');
  
      chatArea.innerHTML = '';
  
      const messages = conversationManager.getMessages();
      messages.forEach(msg => {
        const msgElement = uiRenderer.renderMessage(msg);
        chatArea.appendChild(msgElement);
      });
  
      // Scroll to bottom
      chatArea.scrollTop = chatArea.scrollHeight;
    },
  
    updateCharCounter: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
      const charCount = document.getElementById('charCount');
  
      const total = conversationManager.getTotalCharacterCount();
      charCount.textContent = `Total: ${utils.formatCharCount(total)}`;
    },
  
    showError: function(message) {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = message;
    },
  
    hideError: function() {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = '';
    }
  };
  

  // Module: ui-renderer.js
  // UI Renderer
  // Renders messages in the UI
  window.module['ui-renderer.js'] = {
    renderMessage: function(message) {
      const utils = window.module['utils.js'];
      const msgDiv = document.createElement('div');
      msgDiv.style.cssText = 'margin-bottom: 20px; padding: 15px; border-radius: 8px; font-family: monospace;';
  
      // Different styles for different message types
      if (message.type === 'user') {
        msgDiv.style.backgroundColor = '#2d2d30';
        msgDiv.style.borderLeft = '4px solid #007acc';
        msgDiv.innerHTML = `
          <div style="color: #007acc; font-weight: bold; margin-bottom: 8px;">User</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(message.content)}</div>
          <div style="color: #858585; font-size: 11px; margin-top: 8px;">${utils.formatCharCount(message.content.length)}</div>
        `;
      } else if (message.type === 'assistant') {
        msgDiv.style.backgroundColor = '#1e3a1e';
        msgDiv.style.borderLeft = '4px solid #4ec9b0';
  
        // Try to parse and display JSON content nicely
        let displayContent = message.content;
        try {
          const parsed = JSON.parse(message.content.replace('|||||END|||||', ''));
          if (parsed.type === 'message') {
            displayContent = parsed.content;
          } else {
            displayContent = JSON.stringify(parsed, null, 2);
          }
        } catch (e) {
          // Not JSON, display as-is
        }
  
        msgDiv.innerHTML = `
          <div style="color: #4ec9b0; font-weight: bold; margin-bottom: 8px;">Assistant</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(displayContent)}</div>
          <div style="color: #858585; font-size: 11px; margin-top: 8px;">${utils.formatCharCount(message.content.length)}</div>
        `;
      } else if (message.type === 'system_error') {
        msgDiv.style.backgroundColor = '#3a1e1e';
        msgDiv.style.borderLeft = '4px solid #f48771';
        msgDiv.innerHTML = `
          <div style="color: #f48771; font-weight: bold; margin-bottom: 8px;">System Error</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(message.error)}</div>
        `;
      } else if (message.type === 'system_warning') {
        msgDiv.style.backgroundColor = '#3a341e';
        msgDiv.style.borderLeft = '4px solid #dcdcaa';
        msgDiv.innerHTML = `
          <div style="color: #dcdcaa; font-weight: bold; margin-bottom: 8px;">System Warning</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(message.warning)}</div>
        `;
      } else if (message.type === 'tool_use') {
        msgDiv.style.backgroundColor = '#2d2d30';
        msgDiv.style.borderLeft = '4px solid #ce9178';
        msgDiv.innerHTML = `
          <div style="color: #ce9178; font-weight: bold; margin-bottom: 8px;">Tool Use</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(JSON.stringify(message.tools, null, 2))}</div>
        `;
      } else if (message.type === 'tool_result') {
        msgDiv.style.backgroundColor = '#2d2d30';
        msgDiv.style.borderLeft = '4px solid #b5cea8';
        const resultText = message.success ? JSON.stringify(message.result, null, 2) : message.error;
        msgDiv.innerHTML = `
          <div style="color: #b5cea8; font-weight: bold; margin-bottom: 8px;">Tool Result: ${message.tool}</div>
          <div style="color: ${message.success ? '#d4d4d4' : '#f48771'}; white-space: pre-wrap;">${this.escapeHtml(resultText)}</div>
        `;
      } else {
        // Unknown type - display basic info
        msgDiv.style.backgroundColor = '#2d2d30';
        msgDiv.innerHTML = `
          <div style="color: #858585; font-weight: bold; margin-bottom: 8px;">Unknown Type: ${message.type}</div>
          <div style="color: #d4d4d4; white-space: pre-wrap;">${this.escapeHtml(JSON.stringify(message, null, 2))}</div>
        `;
      }
  
      return msgDiv;
    },
  
    escapeHtml: function(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };
  

  // Module: utils.js
  // Utility Functions
  window.module['utils.js'] = {
    generateUUID: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    },
  
    generateSessionId: function() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
      let result = '';
      for (let i = 0; i < 20; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    },
  
    getTimestamp: function() {
      return Math.floor(Date.now() / 1000);
    },
  
    countCharacters: function(messages) {
      // Count entire JSON structure, not just content
      // This matches the spec requirement for 500K limit
      return messages.reduce((total, msg) => total + JSON.stringify(msg).length, 0);
    },
  
    formatCharCount: function(count) {
      return `${(count / 1000).toFixed(1)}K`;
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
