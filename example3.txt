// AI Agent - Built 2025-11-30T17:42:31.912Z
(function() {
  window.module = {};

  // Module: api-client.js
  // API Client
  window.module['api-client.js'] = {
    chatId: null,
    sessionId: null,
  
    init: function() {
      const utils = window.module['utils.js'];
      this.sessionId = utils.generateSessionId();
    },
  
    createNewChat: async function(firstMessage) {
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      const messageId = utils.generateUUID();
      const timestamp = utils.getTimestamp();
  
      const payload = {
        chat: {
          id: '',
          title: 'Chat Pending',
          models: [config.MODEL],
          params: {},
          history: {
            messages: {
              [messageId]: {
                id: messageId,
                parentId: null,
                childrenIds: [],
                role: 'user',
                content: firstMessage,
                timestamp: timestamp,
                models: [config.MODEL]
              }
            },
            currentId: messageId
          },
          messages: [
            {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: 'user',
              content: firstMessage,
              timestamp: timestamp,
              models: [config.MODEL]
            }
          ],
          tags: [],
          timestamp: Date.now()
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/new`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to create chat: ${response.status} ${response.statusText}`);
      }
  
      const data = await response.json();
      this.chatId = data.id;
  
      return { chatId: data.id, messageId };
    },
  
    updateChat: async function(messages) {
      const config = window.module['config.js'];
  
      // Build history object
      const historyMessages = {};
      messages.forEach((msg) => {
        historyMessages[msg.id] = {
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp,
          ...(msg.role === 'user' ? { models: [config.MODEL] } : {
            model: config.MODEL,
            modelIdx: 0,
            modelName: config.MODEL,
            userContext: null
          })
        };
      });
  
      const currentId = messages[messages.length - 1].id;
  
      const payload = {
        chat: {
          models: [config.MODEL],
          files: [],
          params: {},
          history: {
            messages: historyMessages,
            currentId: currentId
          },
          messages: messages.map(msg => ({
            id: msg.id,
            parentId: msg.parentId,
            childrenIds: msg.childrenIds,
            content: msg.content,
            role: msg.role,
            timestamp: msg.timestamp,
            ...(msg.role === 'user' ? { models: [config.MODEL] } : {
              model: config.MODEL,
              modelIdx: 0,
              modelName: config.MODEL,
              userContext: null
            })
          }))
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/${this.chatId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to update chat: ${response.status} ${response.statusText}`);
      }
  
      return await response.json();
    },
  
    getCompletion: async function(apiMessages, assistantMessageId) {
      const config = window.module['config.js'];
  
      // apiMessages is already in API format from api-renderer
      const payload = {
        stream: true,
        model: config.MODEL,
        messages: apiMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: true,
          tags_generation: true
        }
      };
  
      console.log('=== GET COMPLETION REQUEST ===');
      console.log('Messages count:', apiMessages.length);
      console.log('Last message:', apiMessages[apiMessages.length - 1]);
      console.log('Full payload:', payload);
  
      const response = await fetch(`${config.API_BASE}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to get completion: ${response.status} ${response.statusText}`);
      }
  
      console.log('Response status:', response.status);
  
      return response;
    },
  
    getContinuation: async function(apiMessages, assistantMessageId, partialContent) {
      const config = window.module['config.js'];
  
      console.log('=== GET CONTINUATION REQUEST ===');
      console.log('Original messages count:', apiMessages.length);
      console.log('Partial content length:', partialContent.length);
      console.log('Partial content starts with:', partialContent.substring(0, 100));
      console.log('Partial content ends with:', partialContent.substring(partialContent.length - 100));
  
      // Determine if this is a message or tool call
      const isToolCall = partialContent.startsWith('{');
      const isMessage = partialContent.startsWith('=');
  
      let wrappedContent;
      let continuationPrompt;
  
      if (isToolCall) {
        // For tool calls, ask for a CONTINUATION (not complete JSON)
        // Use ~ prefix to indicate it's a continuation that should be appended
        wrappedContent = `Here's a partial response that got cut off:\n\`\`\`json\n${partialContent}\n\`\`\``;
  
        continuationPrompt = `Your previous response was cut off mid-JSON. Send ONLY the continuation text that should be appended.
  
  The response ended with: "${partialContent.substring(partialContent.length - 100)}"
  
  Start your response with ~ followed by the exact text that should come next. Do NOT send complete JSON, do NOT start with {, just send the raw continuation text that will be appended to what you already wrote.
  
  Example: if the partial ended with "...delay", you might send:
  ~ed memory access made them impractical for large-scale use."}}]}|||||END|||||
  
  The ~ tells the system this is a continuation to be appended, not a new complete response.`;
      } else if (isMessage) {
        // For messages: also use ~ for continuation
        const messageContent = partialContent.substring(1); // Remove = prefix
        wrappedContent = `Here's a partial message that got cut off:\n\`\`\`\n${messageContent}\n\`\`\``;
  
        continuationPrompt = `Your previous message was cut off. Send ONLY the continuation text.
  
  The message ended with: "${messageContent.substring(messageContent.length - 100)}"
  
  Start your response with ~ followed by the next words. This will be appended to what you already wrote.
  
  Example: if it ended with "...early memory solution", you might send:
  ~. These devices stored data as acoustic pulses...|||||END|||||`;
      } else {
        // Unknown format, send as-is
        wrappedContent = partialContent;
        continuationPrompt = '[System: Your previous response was cut off. Please continue from where you left off with ~ prefix.]';
      }
  
      // Build continuation messages with wrapped content
      const continueMessages = [
        ...apiMessages,
        {
          role: 'assistant',
          content: wrappedContent
        },
        {
          role: 'user',
          content: continuationPrompt
        }
      ];
  
      console.log('Continue messages count:', continueMessages.length);
      console.log('Continuation prompt:', continuationPrompt.substring(0, 200));
      console.log('Last 3 messages:');
      for (let i = Math.max(0, continueMessages.length - 3); i < continueMessages.length; i++) {
        console.log(`  [${i}] ${continueMessages[i].role}:`, continueMessages[i].content.substring(0, 150));
      }
  
      const payload = {
        stream: true,
        model: config.MODEL,
        messages: continueMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: false,
          tags_generation: false
        }
      };
  
      console.log('Full continuation payload:', payload);
  
      const response = await fetch(`${config.API_BASE}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to get continuation: ${response.status} ${response.statusText}`);
      }
  
      console.log('Continuation response status:', response.status);
  
      return response;
    }
  };
  

  // Module: api-renderer.js
  // API Renderer
  // Transforms internal message format to API format
  window.module['api-renderer.js'] = {
    renderMessagesForAPI: function(messages) {
      const modeManager = window.module['mode-manager.js'];
      const apiMessages = [];
  
      // Find latest summary
      let latestSummaryIndex = -1;
      let summaryContent = null;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].type === 'summary') {
          latestSummaryIndex = i;
          summaryContent = messages[i].content;
          break;
        }
      }
  
      // Start converting messages after the summary (or from beginning if no summary)
      const startIndex = latestSummaryIndex >= 0 ? latestSummaryIndex + 1 : 0;
  
      let firstUserMessageIndex = -1;
      let pendingWarnings = []; // Can accumulate multiple warnings
      let pendingToolUses = []; // Can accumulate multiple tool uses to combine into one assistant message
      let pendingToolResults = []; // Can accumulate multiple tool results
  
      for (let i = startIndex; i < messages.length; i++) {
        const msg = messages[i];
  
        // Collect system_warning messages to merge with next user message
        if (msg.type === 'system_warning') {
          pendingWarnings.push(msg.warning);
          continue;
        }
  
        // Collect tool uses to combine into single assistant message
        if (msg.type === 'tool_use') {
          pendingToolUses.push(msg.tool);
          continue;
        }
  
        // Collect tool results to combine
        if (msg.type === 'tool_result') {
          pendingToolResults.push(msg);
          continue;
        }
  
        // Flush pending tool uses before processing other message types
        if (pendingToolUses.length > 0) {
          apiMessages.push({
            role: 'assistant',
            content: JSON.stringify({ tools: pendingToolUses }) + '|||||END|||||'
          });
          pendingToolUses = [];
        }
  
        // Flush pending tool results before processing other message types
        if (pendingToolResults.length > 0) {
          const combinedResults = pendingToolResults.map(result => {
            if (result.success) {
              // Include the file path in the result for read_file
              const path = result.args?.path || '';
              const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
              return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
            } else {
              return `Tool: ${result.tool}\nError: ${result.error}`;
            }
          }).join('\n\n');
  
          apiMessages.push({
            role: 'user',
            content: combinedResults
          });
          pendingToolResults = [];
        }
  
        // Handle different message types
        if (msg.type === 'user') {
          let content = msg.content;
  
          // Is this the first user message we're adding to API?
          if (firstUserMessageIndex === -1) {
            firstUserMessageIndex = apiMessages.length;
  
            // Build prefix: system prompt + summary (if exists)
            let prefix = modeManager.getSystemPrompt();
  
            if (summaryContent) {
              prefix += '\n\n' + summaryContent;
            }
  
            content = prefix + '\n\n' + content;
          }
  
          // Prepend any pending warnings
          if (pendingWarnings.length > 0) {
            const warningsText = pendingWarnings.map(w => `[System: ${w}]`).join('\n');
            content = warningsText + '\n\n' + content;
            pendingWarnings = [];
          }
  
          apiMessages.push({
            role: 'user',
            content: content
          });
  
        } else if (msg.type === 'assistant') {
          // Assistant message responses use = prefix
          apiMessages.push({
            role: 'assistant',
            content: '=' + msg.content + '|||||END|||||'
          });
  
        } else if (msg.type === 'system_error') {
          apiMessages.push({
            role: 'user',
            content: `Error: ${msg.error}`
          });
  
        } else if (msg.type === 'partial') {
          // TODO: Combine consecutive partials into single assistant message
          // Partials should be combined before being sent to API
          // For now, skip partials (combination not yet implemented)
          continue;
        }
      }
  
      // Flush any remaining tool uses at the end
      if (pendingToolUses.length > 0) {
        apiMessages.push({
          role: 'assistant',
          content: JSON.stringify({ tools: pendingToolUses }) + '|||||END|||||'
        });
      }
  
      // Flush any remaining tool results at the end
      if (pendingToolResults.length > 0) {
        const combinedResults = pendingToolResults.map(result => {
          if (result.success) {
            const path = result.args?.path || '';
            const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
            return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
          } else {
            return `Tool: ${result.tool}\nError: ${result.error}`;
          }
        }).join('\n\n');
  
        apiMessages.push({
          role: 'user',
          content: combinedResults
        });
      }
  
      return apiMessages;
    }
  };
  

  // Module: config.js
  // Configuration
  window.module['config.js'] = {
    API_BASE: 'https://chat.niprgpt.mil/api',
    MODEL: 'Anthropic Claude 4 Sonnet',
    MAX_RETRIES: 5,
    TIMEOUT_MS: 30000 // 30 seconds
  };
  

  // Module: conversation-manager.js
  // Conversation Manager
  // Manages message array, character counting, and (TODO) summarization
  window.module['conversation-manager.js'] = {
    messages: [],
  
    init: function() {
      this.messages = [];
    },
  
    addMessage: function(message) {
      const utils = window.module['utils.js'];
  
      // Ensure message has required fields
      if (!message.id) {
        message.id = utils.generateUUID();
      }
      if (!message.timestamp) {
        message.timestamp = utils.getTimestamp();
      }
      if (!message.parentId) {
        message.parentId = this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null;
      }
      if (!message.childrenIds) {
        message.childrenIds = [];
      }
  
      // Update parent's childrenIds
      if (message.parentId) {
        const parent = this.messages.find(m => m.id === message.parentId);
        if (parent) {
          parent.childrenIds.push(message.id);
        }
      }
  
      // TODO: Check 500K character limit and trigger summarization
      // For now, just add the message
      this.messages.push(message);
  
      return message;
    },
  
    getMessages: function() {
      return this.messages;
    },
  
    getTotalCharacterCount: function() {
      const utils = window.module['utils.js'];
      return utils.countCharacters(this.messages);
    },
  
    // TODO: Implement summarization
    summarize: function() {
      console.warn('Summarization not yet implemented');
      return null;
    }
  };
  

  // Module: file-system.js
  // File System Handler
  window.module['file-system.js'] = {
    directoryHandle: null,
    fileTree: [],
  
    requestDirectory: async function() {
      try {
        this.directoryHandle = await window.showDirectoryPicker();
        this.fileTree = await this.buildFileTree(this.directoryHandle);
        return true;
      } catch (err) {
        console.error('Directory access error:', err);
        return false;
      }
    },
  
    buildFileTree: async function(dirHandle, path = '') {
      const entries = [];
  
      for await (const entry of dirHandle.values()) {
        const fullPath = path ? `${path}/${entry.name}` : entry.name;
  
        if (entry.kind === 'directory') {
          const children = await this.buildFileTree(entry, fullPath);
          entries.push({
            name: entry.name,
            type: 'directory',
            path: fullPath,
            children: children,
            handle: entry
          });
        } else {
          // Read file to get character count
          let charCount = 0;
          try {
            const file = await entry.getFile();
            const text = await file.text();
            charCount = text.length;
          } catch (err) {
            console.warn('Could not read file for char count:', entry.name);
          }
  
          entries.push({
            name: entry.name,
            type: 'file',
            path: fullPath,
            handle: entry,
            charCount: charCount
          });
        }
      }
  
      return entries.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
    },
  
    readFile: async function(fileEntry) {
      try {
        const file = await fileEntry.handle.getFile();
        const text = await file.text();
        return text;
      } catch (err) {
        console.error('File read error:', err);
        return null;
      }
    },
  
    createFile: async function(path, content) {
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      try {
        // Split path into parts
        const parts = path.split('/');
        const fileName = parts.pop();
  
        // Navigate to the target directory, creating folders as needed
        let currentHandle = this.directoryHandle;
        for (const part of parts) {
          if (part) {
            currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
          }
        }
  
        // Create the file
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        // Rebuild file tree to include new file
        this.fileTree = await this.buildFileTree(this.directoryHandle);
  
        return true;
      } catch (err) {
        console.error('File create error:', err);
        throw err;
      }
    },
  
    editFile: async function(path, oldText, newText) {
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      try {
        // Find the file in the tree
        const fileEntry = this.findFileInTree(this.fileTree, path);
        if (!fileEntry) {
          throw new Error(`File not found: ${path}`);
        }
  
        // Read current content
        const currentContent = await this.readFile(fileEntry);
        if (currentContent === null) {
          throw new Error(`Failed to read file: ${path}`);
        }
  
        // Replace old text with new text
        const newContent = currentContent.replace(oldText, newText);
  
        // Check if replacement happened
        if (newContent === currentContent) {
          throw new Error('Old text not found in file');
        }
  
        // Write new content
        const writable = await fileEntry.handle.createWritable();
        await writable.write(newContent);
        await writable.close();
  
        // Update char count in tree
        fileEntry.charCount = newContent.length;
  
        return true;
      } catch (err) {
        console.error('File edit error:', err);
        throw err;
      }
    },
  
    findFileInTree: function(tree, path) {
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'file') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFileInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    }
  };
  

  // Module: main.js
  // Main entry point
  window.module['main.js'] = {
    version: '2.0.0-alpha',
  
    run: function() {
      console.log('Initializing API Test Interface v2.0...');
      console.log('Version:', this.version);
      console.log('Mode: Planning Mode (Execution Mode not yet implemented)');
  
      // Initialize all modules (they self-initialize when ui-manager.init() calls them)
      const uiManager = window.module['ui-manager.js'];
      uiManager.init();
  
      console.log('API Test Interface ready!');
      console.log('');
      console.log('v2.0 Features:');
      console.log('✓ New message system with types');
      console.log('✓ JSON response format with terminator');
      console.log('✓ Planning Mode with system prompt');
      console.log('✓ Tool system (list_folder, read_file)');
      console.log('✓ Message processor (parse & validate)');
      console.log('');
      console.log('TODO:');
      console.log('- Execution Mode');
      console.log('- Tool execution (create_file, edit_file)');
      console.log('- Summarization (500K limit)');
      console.log('- Partial message continuation');
      console.log('- Auto-call after tool execution');
    }
  };
  

  // Module: message-processor.js
  // Message Processor
  // Handles processing of streamed responses with = prefix (message) or { prefix (tools)
  window.module['message-processor.js'] = {
    TERMINATOR: '|||||END|||||',
  
    processStreamedResponse: function(rawText) {
      // Check for terminator
      if (!rawText.includes(this.TERMINATOR)) {
        return {
          complete: false,
          content: rawText,
          error: null
        };
      }
  
      // Extract content before terminator
      const terminatorIndex = rawText.indexOf(this.TERMINATOR);
      const content = rawText.substring(0, terminatorIndex);
  
      // Detect response type by first character
      const firstChar = content.charAt(0);
  
      if (firstChar === '=') {
        // Message response
        return this.processMessage(content);
      } else if (firstChar === '{') {
        // Tool execution response
        return this.processTools(content);
      } else {
        return {
          complete: true,
          content: null,
          error: `Invalid response format: must start with = or {, got "${firstChar}"`,
          originalContent: rawText
        };
      }
    },
  
    processMessage: function(text) {
      // Remove = prefix
      const message = text.substring(1);
  
      return {
        complete: true,
        content: {
          type: 'message',
          text: message
        },
        error: null
      };
    },
  
    processTools: function(jsonText) {
      // Parse JSON
      try {
        const data = JSON.parse(jsonText);
  
        // Validate structure
        if (!data || typeof data !== 'object') {
          return {
            complete: true,
            content: null,
            error: 'Invalid tools response: not an object',
            originalContent: jsonText
          };
        }
  
        if (!Array.isArray(data.tools)) {
          return {
            complete: true,
            content: null,
            error: 'Invalid tools response: tools must be an array',
            originalContent: jsonText
          };
        }
  
        // TODO: Add comprehensive tool validation
        // - Check each tool has name and args
        // - Validate tool names
        // - Validate args match tool requirements
  
        return {
          complete: true,
          content: {
            type: 'execute',
            tools: data.tools
          },
          error: null
        };
  
      } catch (e) {
        // TODO: Implement JSON repair logic
        return {
          complete: true,
          content: null,
          error: `JSON parse error: ${e.message}`,
          originalContent: jsonText
        };
      }
    }
  };
  

  // Module: mode-manager.js
  // Mode Manager
  // Manages mode state, transitions, and prompt selection
  window.module['mode-manager.js'] = {
    state: {
      mode: 'planning', // Always start in planning mode
      checklist: [],
      current_item_index: 0
    },
  
    init: function() {
      this.state = {
        mode: 'planning',
        checklist: [],
        current_item_index: 0
      };
    },
  
    getMode: function() {
      return this.state.mode;
    },
  
    getSystemPrompt: function() {
      if (this.state.mode === 'planning') {
        return this.getPlanningModePrompt();
      } else {
        return this.getExecutionModePrompt();
      }
    },
  
    getPlanningModePrompt: function() {
      return `<system-reminder>
  You are a helpful AI coding assistant in PLANNING MODE.
  
  Your goal is to understand what the user wants to accomplish through conversation.
  
  ## What you should do:
  
  1. Ask clarifying questions about the task
  2. Explore the codebase using list_folder and read_file (as many files as needed)
  3. Understand the current state and requirements
  4. When ready to make CHANGES, create a checklist and exit to execution mode
  
  IMPORTANT: You can read as many files as you want in planning mode. Only exit to execution mode when you need to CREATE or MODIFY files. Reading is part of planning.
  
  ## Response Format
  
  ALL responses must end with |||||END|||||
  
  Two response types in planning mode:
  
  ### 1. Message Response
  When you want to ask questions or discuss, start with = followed by your message:
  
  =Your message to the user here. Can be multiple lines.
  You can include newlines and formatting.|||||END|||||
  
  ### 2. Tool Execution
  When you need to use tools, start with { and provide valid JSON:
  
  {"tools":[{"name":"list_folder","args":{"path":"src/"}},{"name":"read_file","args":{"path":"src/main.js"}}]}|||||END|||||
  
  IMPORTANT: Don't send a message first saying you're going to use tools. Just use them.
  The user sees the tool execution, so announcing it is redundant.
  
  ## Available Tools in Planning Mode
  
  - list_folder: Explore directories (non-recursive)
  - read_file: Read file contents
  - exit_planning: Exit planning with checklist
  
  Example exit_planning:
  {"tools":[{"name":"exit_planning","args":{"checklist":[{"short_desc":"Brief description for UI","long_desc":"Detailed description for execution"}]}}]}|||||END|||||
  
  ## Rules
  
  1. Be conversational and ask questions
  2. Don't start implementing until you call exit_planning
  3. Break down complex tasks into discrete checklist items
  4. Each checklist item should be independently verifiable
  5. Keep short_desc concise (for UI display)
  6. Make long_desc detailed (for execution context)
  7. **ACTION OVER ANNOUNCEMENT**: When you need to use tools, just use them immediately. Don't send a message saying "Let me check..." or "I'll read..." - just execute the tools. The user will see the tool results.
  
  </system-reminder>`;
    },
  
    getExecutionModePrompt: function() {
      // TODO: Implement execution mode
      const currentItem = this.state.checklist[this.state.current_item_index];
      const taskDesc = currentItem ? currentItem.long_desc : 'No task assigned';
  
      return `<system-reminder>
  You are a helpful AI coding assistant in EXECUTION MODE.
  
  Your ONLY job is to complete the current checklist item.
  
  ## Current Task
  
  ${taskDesc}
  
  ## What you should do:
  
  1. Focus ONLY on this task
  2. Use file operations as needed
  3. When finished, call item_completed
  4. If you can't complete it, call item_failed with a reason
  
  ## Response Format
  
  ALL responses must end with |||||END|||||
  
  Two response types:
  
  ### 1. Message Response
  Start with = followed by your message:
  
  =Task completed successfully.|||||END|||||
  
  ### 2. Tool Execution
  Start with { and provide valid JSON:
  
  {"tools":[{"name":"create_file","args":{"path":"src/new.js","content":"console.log('hello');"}}]}|||||END|||||
  
  ## Available Tools in Execution Mode
  
  - list_folder: Explore directories
  - read_file: Read files
  - create_file: Create new files
  - edit_file: Edit existing files
  - item_completed: Mark task complete
  - item_failed: Mark task failed
  
  ## Rules
  
  1. Focus ONLY on the current task
  2. Don't try to complete other checklist items
  3. Be concise in execution mode
  4. Always call item_completed or item_failed when done
  5. If uncertain or blocked, call item_failed to return to planning
  
  </system-reminder>`;
    },
  
    transitionToExecution: function(checklist) {
      this.state.mode = 'execution';
      this.state.checklist = checklist;
      this.state.current_item_index = 0;
      console.log('Transitioned to execution mode with', checklist.length, 'items');
    },
  
    transitionToPlanning: function(reason) {
      this.state.mode = 'planning';
      this.state.current_item_index = 0;
      console.log('Transitioned to planning mode:', reason);
    }
  };
  

  // Module: tool-executor.js
  // Tool Executor
  // Executes tools and returns results
  window.module['tool-executor.js'] = {
    // Define tool availability by mode
    PLANNING_TOOLS: ['list_folder', 'read_file', 'exit_planning'],
    EXECUTION_TOOLS: ['list_folder', 'read_file', 'create_file', 'edit_file', 'item_completed', 'item_failed'],
  
    executeTools: async function(tools) {
      const results = [];
  
      // Execute tools sequentially
      for (let i = 0; i < tools.length; i++) {
        const tool = tools[i];
        const result = await this.executeTool(tool);
  
        results.push(result);
  
        // Stop on first error
        if (!result.success) {
          break;
        }
      }
  
      return results;
    },
  
    validateToolAvailability: function(toolName) {
      const modeManager = window.module['mode-manager.js'];
      const currentMode = modeManager.getMode();
  
      const allowedTools = currentMode === 'planning' ? this.PLANNING_TOOLS : this.EXECUTION_TOOLS;
  
      if (!allowedTools.includes(toolName)) {
        const modeLabel = currentMode === 'planning' ? 'Planning' : 'Execution';
        return {
          valid: false,
          error: `Tool '${toolName}' is not available in ${modeLabel} Mode. Available tools: ${allowedTools.join(', ')}`
        };
      }
  
      return { valid: true };
    },
  
    executeTool: async function(tool) {
      const fileSystem = window.module['file-system.js'];
  
      // Validate tool availability in current mode
      const validation = this.validateToolAvailability(tool.name);
      if (!validation.valid) {
        return {
          tool: tool.name,
          success: false,
          error: validation.error,
          args: tool.args
        };
      }
  
      try {
        switch (tool.name) {
          case 'list_folder':
            return await this.listFolder(tool.args);
  
          case 'read_file':
            return await this.readFile(tool.args);
  
          case 'create_file':
            return await this.createFile(tool.args);
  
          case 'edit_file':
            return await this.editFile(tool.args);
  
          case 'exit_planning':
            return await this.exitPlanning(tool.args);
  
          case 'item_completed':
            return await this.itemCompleted(tool.args);
  
          case 'item_failed':
            return await this.itemFailed(tool.args);
  
          default:
            return {
              tool: tool.name,
              success: false,
              error: `Unknown tool: ${tool.name}`,
              args: tool.args
            };
        }
      } catch (error) {
        return {
          tool: tool.name,
          success: false,
          error: error.message,
          args: tool.args
        };
      }
    },
  
    listFolder: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'list_folder',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the folder in the file tree
      const folder = this.findFolderInTree(fileSystem.fileTree, args.path);
      if (!folder) {
        return {
          tool: 'list_folder',
          success: false,
          error: `Directory not found: ${args.path}`,
          args: args
        };
      }
  
      // Return children
      const entries = folder.children.map(child => ({
        name: child.name,
        type: child.type,
        size_bytes: child.type === 'file' ? child.charCount : 0
      }));
  
      return {
        tool: 'list_folder',
        success: true,
        result: entries,
        args: args
      };
    },
  
    readFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'read_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the file in the file tree
      const file = this.findFileInTree(fileSystem.fileTree, args.path);
      if (!file) {
        return {
          tool: 'read_file',
          success: false,
          error: `File not found: ${args.path}`,
          args: args
        };
      }
  
      // Read the file
      const content = await fileSystem.readFile(file);
      if (content === null) {
        return {
          tool: 'read_file',
          success: false,
          error: `Failed to read file: ${args.path}`,
          args: args
        };
      }
  
      // TODO: Handle start_line and end_line parameters
      return {
        tool: 'read_file',
        success: true,
        result: content,
        args: args
      };
    },
  
    findFolderInTree: function(tree, path) {
      if (!path || path === '' || path === '.') {
        return { children: tree };
      }
  
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'directory') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFolderInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    },
  
    findFileInTree: function(tree, path) {
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'file') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFileInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    },
  
    createFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'create_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      if (!args.path) {
        return {
          tool: 'create_file',
          success: false,
          error: 'Missing required argument: path',
          args: args
        };
      }
  
      if (!args.content && args.content !== '') {
        return {
          tool: 'create_file',
          success: false,
          error: 'Missing required argument: content',
          args: args
        };
      }
  
      try {
        await fileSystem.createFile(args.path, args.content);
        return {
          tool: 'create_file',
          success: true,
          result: { path: args.path, size_bytes: args.content.length },
          args: args
        };
      } catch (error) {
        return {
          tool: 'create_file',
          success: false,
          error: error.message,
          args: args
        };
      }
    },
  
    editFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      if (!args.path) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: path',
          args: args
        };
      }
  
      if (!args.old_text) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: old_text',
          args: args
        };
      }
  
      if (!args.new_text && args.new_text !== '') {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: new_text',
          args: args
        };
      }
  
      try {
        await fileSystem.editFile(args.path, args.old_text, args.new_text);
        return {
          tool: 'edit_file',
          success: true,
          result: { path: args.path },
          args: args
        };
      } catch (error) {
        return {
          tool: 'edit_file',
          success: false,
          error: error.message,
          args: args
        };
      }
    },
  
    exitPlanning: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (!args.checklist || !Array.isArray(args.checklist)) {
        return {
          tool: 'exit_planning',
          success: false,
          error: 'Missing or invalid checklist argument',
          args: args
        };
      }
  
      // Validate checklist items
      for (let i = 0; i < args.checklist.length; i++) {
        const item = args.checklist[i];
        if (!item.short_desc || !item.long_desc) {
          return {
            tool: 'exit_planning',
            success: false,
            error: `Checklist item ${i} missing short_desc or long_desc`,
            args: args
          };
        }
      }
  
      // Transition to execution mode
      modeManager.transitionToExecution(args.checklist);
  
      return {
        tool: 'exit_planning',
        success: true,
        result: {
          mode: 'execution',
          checklist_items: args.checklist.length,
          current_item: 0,
          checklist: args.checklist
        },
        args: args
      };
    },
  
    itemCompleted: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (modeManager.getMode() !== 'execution') {
        return {
          tool: 'item_completed',
          success: false,
          error: 'Not in execution mode',
          args: args
        };
      }
  
      const currentIndex = modeManager.state.current_item_index;
      const totalItems = modeManager.state.checklist.length;
  
      // Move to next item or return to planning
      if (currentIndex + 1 < totalItems) {
        modeManager.state.current_item_index++;
        return {
          tool: 'item_completed',
          success: true,
          result: {
            completed_item: currentIndex,
            next_item: currentIndex + 1,
            remaining: totalItems - (currentIndex + 1),
            checklist: modeManager.state.checklist
          },
          args: args
        };
      } else {
        // All items complete, return to planning
        modeManager.transitionToPlanning('All checklist items completed');
        return {
          tool: 'item_completed',
          success: true,
          result: {
            completed_item: currentIndex,
            all_complete: true,
            mode: 'planning',
            checklist: modeManager.state.checklist
          },
          args: args
        };
      }
    },
  
    itemFailed: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (modeManager.getMode() !== 'execution') {
        return {
          tool: 'item_failed',
          success: false,
          error: 'Not in execution mode',
          args: args
        };
      }
  
      // Return to planning mode
      const currentIndex = modeManager.state.current_item_index;
      const checklist = modeManager.state.checklist;
      const reason = args.reason || 'Task failed';
      modeManager.transitionToPlanning(reason);
  
      return {
        tool: 'item_failed',
        success: true,
        result: {
          mode: 'planning',
          reason: reason,
          failed_item: currentIndex,
          checklist: checklist
        },
        args: args
      };
    }
  };
  

  // Module: ui-manager.js
  // UI Manager v2.0
  // Coordinates UI rendering and handles user interactions
  window.module['ui-manager.js'] = {
    init: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const modeManager = window.module['mode-manager.js'];
      const apiClient = window.module['api-client.js'];
  
      conversationManager.init();
      modeManager.init();
      apiClient.init();
  
      this.showIntroScreen();
    },
  
    showIntroScreen: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Create intro container
      const container = document.createElement('div');
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
  
      const content = document.createElement('div');
      content.style.cssText = `
        text-align: center;
        max-width: 500px;
        padding: 40px;
      `;
  
      content.innerHTML = `
        <h1 style="font-size: 32px; margin-bottom: 16px; font-weight: 600;">
          API Test Interface v2.0
        </h1>
        <p style="font-size: 16px; color: #858585; margin-bottom: 32px;">
          Planning Mode • AI-Driven Development
        </p>
        <p style="font-size: 14px; margin-bottom: 32px; line-height: 1.6;">
          Select a project folder to begin. The AI will use tools to explore
          and modify files as you work together.
        </p>
        <button id="selectFolderIntro" style="
          background: #0e639c;
          color: white;
          border: none;
          padding: 12px 32px;
          border-radius: 3px;
          cursor: pointer;
          font-size: 15px;
          font-weight: 500;
        ">Select Folder</button>
      `;
  
      container.appendChild(content);
      document.body.appendChild(container);
  
      document.getElementById('selectFolderIntro').addEventListener('click', () => this.selectFolderAndStart());
    },
  
    selectFolderAndStart: async function() {
      const fileSystem = window.module['file-system.js'];
      const success = await fileSystem.requestDirectory();
  
      if (success) {
        this.initChatUI();
      }
    },
  
    initChatUI: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Add animation styles
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulse {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 1; }
        }
      `;
      document.head.appendChild(style);
  
      // Create main container
      const container = document.createElement('div');
      container.id = 'test-interface';
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      // Chat area (full width, no header)
      const chatPanel = document.createElement('div');
      chatPanel.style.cssText = `
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      const chatArea = document.createElement('div');
      chatArea.id = 'chatArea';
      chatArea.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        padding-bottom: 140px;
      `;
      chatPanel.appendChild(chatArea);
  
      // Test button for continuation debugging
      const testButton = document.createElement('button');
      testButton.id = 'testContinuationBtn';
      testButton.textContent = 'Test Continuation';
      testButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 8px 12px;
        background: #3c3c3c;
        color: white;
        border: 1px solid #3e3e42;
        border-radius: 4px;
        cursor: pointer;
        font-family: monospace;
        font-size: 11px;
        z-index: 100;
      `;
      testButton.addEventListener('click', () => this.testContinuation());
      chatPanel.appendChild(testButton);
  
      // Gradient overlay - fades chat history behind input
      const gradientOverlay = document.createElement('div');
      gradientOverlay.style.cssText = `
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 160px;
        background: linear-gradient(to bottom, transparent 0%, #1e1e1e 80%);
        pointer-events: none;
        z-index: 50;
      `;
      chatPanel.appendChild(gradientOverlay);
  
      // Input area - floats at bottom, no padding or shadow
      const inputArea = document.createElement('div');
      inputArea.style.cssText = `
        position: absolute;
        bottom: 8px;
        left: 20px;
        right: 20px;
        z-index: 60;
      `;
      inputArea.innerHTML = `
        <div style="border: 1px solid #3e3e42; border-radius: 4px; overflow: hidden;">
          <textarea id="userInput" style="
            width: 100%;
            min-height: 20px;
            max-height: calc(33vh);
            background: #3c3c3c;
            color: white;
            border: none;
            outline: none;
            margin: 0;
            padding: 10px;
            font-family: monospace;
            font-size: 13px;
            resize: none;
            overflow-y: auto;
            line-height: 1.4;
            display: block;
          "></textarea>
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background: #252526; border-top: 1px solid #3e3e42;">
            <span id="folderName" style="font-size: 11px; color: #858585;"></span>
            <span id="charCount" style="font-size: 11px; color: #858585;"></span>
          </div>
        </div>
        <div id="errorMsg" style="margin-top: 4px; color: #f48771; font-size: 13px;"></div>
      `;
      chatPanel.appendChild(inputArea);
  
      container.appendChild(chatPanel);
      document.body.appendChild(container);
  
      // Event listeners
      const userInput = document.getElementById('userInput');
  
      // Auto-resize textarea as content changes
      const autoResize = () => {
        userInput.style.height = '20px'; // Reset to min height
        userInput.style.height = Math.min(userInput.scrollHeight, window.innerHeight / 3) + 'px';
      };
  
      userInput.addEventListener('input', autoResize);
      userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSubmit();
        }
        // Shift+Enter allows newline (default textarea behavior)
        // Trigger resize after key is processed
        setTimeout(autoResize, 0);
      });
  
      // Set folder name
      const fileSystem = window.module['file-system.js'];
      const folderNameElement = document.getElementById('folderName');
      if (fileSystem.directoryHandle) {
        folderNameElement.textContent = fileSystem.directoryHandle.name;
      }
  
      this.updateCharCounter();
    },
  
    handleSubmit: async function() {
      const input = document.getElementById('userInput');
      const content = input.value.trim();
  
      if (!content) return;
  
      // Clear input and reset height
      input.value = '';
      input.style.height = '20px';
  
      // Hide any previous error
      this.hideError();
  
      try {
        // Add user message
        await this.addUserMessage(content);
  
        // Get AI response
        await this.getAIResponse();
  
      } catch (error) {
        console.error('Error:', error);
        this.showError(error.message);
      }
    },
  
    addUserMessage: async function(content) {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
  
      const userMessage = {
        type: 'user',
        content: content
      };
  
      conversationManager.addMessage(userMessage);
      this.renderChat();
      this.updateCharCounter();
    },
  
    getAIResponse: async function() {
      const conversationManager = window.module['conversation-manager.js'];
      const apiRenderer = window.module['api-renderer.js'];
      const apiClient = window.module['api-client.js'];
      const messageProcessor = window.module['message-processor.js'];
      const toolExecutor = window.module['tool-executor.js'];
      const utils = window.module['utils.js'];
      const config = window.module['config.js'];
  
      // Show loading indicator
      this.showLoading('Thinking...');
  
      // Render messages for API
      const messages = conversationManager.getMessages();
      const apiMessages = apiRenderer.renderMessagesForAPI(messages);
  
      // Create chat if needed
      if (!apiClient.chatId && messages.length > 0) {
        const firstUserMsg = messages.find(m => m.type === 'user');
        if (firstUserMsg) {
          await apiClient.createNewChat(firstUserMsg.content);
        }
      }
  
      // Get completion with streaming
      const assistantMessageId = utils.generateUUID();
  
      let retryCount = 0;
      let success = false;
      let accumulatedContent = '';
      let streamingMessageId = null;
      let responseType = null; // 'message' or 'tools'
  
      while (retryCount < config.MAX_RETRIES && !success) {
        try {
          const response = await apiClient.getCompletion(apiMessages, assistantMessageId);
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
  
          while (true) {
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Timeout')), config.TIMEOUT_MS);
            });
  
            const readPromise = reader.read();
            const result = await Promise.race([readPromise, timeoutPromise]);
  
            if (result.done) break;
  
            const chunk = decoder.decode(result.value, { stream: true });
            const lines = chunk.split('\n');
  
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const data = line.slice(6);
                if (data === '[DONE]') continue;
  
                try {
                  const parsed = JSON.parse(data);
                  if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                    const deltaContent = parsed.choices[0].delta.content;
                    accumulatedContent += deltaContent;
  
                    // Detect response type from first character
                    if (responseType === null && accumulatedContent.length > 0) {
                      const firstChar = accumulatedContent.charAt(0);
                      if (firstChar === '=') {
                        responseType = 'message';
                        // Create streaming message
                        streamingMessageId = utils.generateUUID();
                        conversationManager.addMessage({
                          id: streamingMessageId,
                          type: 'assistant',
                          content: '',
                          streaming: true
                        });
                      } else if (firstChar === '{') {
                        responseType = 'tools';
                        // Don't create message yet, wait for complete JSON
                      }
                    }
  
                    // Update streaming message in real-time
                    if (responseType === 'message' && streamingMessageId) {
                      // Extract message content (remove = prefix and terminator if present)
                      let messageContent = accumulatedContent.substring(1); // Remove =
                      const terminatorIndex = messageContent.indexOf(messageProcessor.TERMINATOR);
                      if (terminatorIndex !== -1) {
                        messageContent = messageContent.substring(0, terminatorIndex);
                      }
  
                      // Update the streaming message
                      const msgs = conversationManager.getMessages();
                      const streamingMsg = msgs.find(m => m.id === streamingMessageId);
                      if (streamingMsg) {
                        streamingMsg.content = messageContent;
                        this.renderChat();
                        this.updateCharCounter();
                      }
                    }
                  }
                } catch (e) {
                  // Ignore parse errors in streaming data
                }
              }
            }
          }
  
          // Process the accumulated response
          let processed = messageProcessor.processStreamedResponse(accumulatedContent);
  
          if (processed.error) {
            // Add system error message
            conversationManager.addMessage({
              type: 'system_error',
              error: processed.error,
              originalContent: processed.originalContent || accumulatedContent
            });
            this.renderChat();
            this.updateCharCounter();
            this.hideLoading();
            return;
          }
  
          // Handle incomplete responses - try up to 20 continuation attempts
          let continuationAttempts = 0;
          const MAX_CONTINUATION_ATTEMPTS = 20;
          let lastChunkContent = '';
  
          while (!processed.complete && continuationAttempts < MAX_CONTINUATION_ATTEMPTS) {
            continuationAttempts++;
            console.log(`Response incomplete, requesting continuation (attempt ${continuationAttempts}/${MAX_CONTINUATION_ATTEMPTS})...`);
            this.showLoading(`Requesting continuation (${continuationAttempts}/${MAX_CONTINUATION_ATTEMPTS})...`);
  
            try {
              // Extract the actual message content (remove = prefix if present)
              let partialMessage = accumulatedContent;
              if (partialMessage.startsWith('=')) {
                partialMessage = partialMessage.substring(1);
              }
  
              console.log('BEFORE CONTINUATION:');
              console.log('  accumulatedContent length:', accumulatedContent.length);
              console.log('  accumulatedContent ends with:', accumulatedContent.substring(accumulatedContent.length - 200));
              console.log('  partialMessage length:', partialMessage.length);
              console.log('  partialMessage ends with:', partialMessage.substring(partialMessage.length - 200));
  
              const continueResponse = await apiClient.getContinuation(apiMessages, assistantMessageId, partialMessage);
              const continueReader = continueResponse.body.getReader();
              const continueDecoder = new TextDecoder();
              let continuationContent = '';
  
              while (true) {
                const timeoutPromise = new Promise((_, reject) => {
                  setTimeout(() => reject(new Error('Timeout')), config.TIMEOUT_MS);
                });
  
                const readPromise = continueReader.read();
                const result = await Promise.race([readPromise, timeoutPromise]);
  
                if (result.done) break;
  
                const chunk = continueDecoder.decode(result.value, { stream: true });
                const lines = chunk.split('\n');
  
                for (const line of lines) {
                  if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    if (data === '[DONE]') continue;
  
                    try {
                      const parsed = JSON.parse(data);
                      if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                        const deltaContent = parsed.choices[0].delta.content;
                        continuationContent += deltaContent;
  
                        // Stream continuation to UI in real-time
                        if (streamingMessageId) {
                          const msgs = conversationManager.getMessages();
                          const streamingMsg = msgs.find(m => m.id === streamingMessageId);
                          if (streamingMsg) {
                            streamingMsg.content = accumulatedContent + continuationContent;
                            this.renderChat();
                          }
                        }
                      }
                    } catch (e) {
                      // Ignore parse errors
                    }
                  }
                }
              }
  
              console.log('AFTER CONTINUATION:');
              console.log('  continuationContent length:', continuationContent.length);
              console.log('  continuationContent starts with:', continuationContent.substring(0, 200));
              console.log('  continuationContent ends with:', continuationContent.substring(continuationContent.length - 200));
  
              // Validate that continuation starts with ~ (as requested)
              if (!continuationContent.startsWith('~')) {
                console.error('Continuation did not start with ~ as requested');
                conversationManager.addMessage({
                  type: 'system_error',
                  error: `Continuation validation failed: Expected response to start with ~ but got "${continuationContent.substring(0, 50)}..."`,
                  originalContent: accumulatedContent
                });
                this.renderChat();
                this.updateCharCounter();
                this.hideLoading();
                return;
              }
  
              // Check for repeating content (AI is stuck)
              if (continuationContent.length > 100 && continuationContent === lastChunkContent) {
                console.warn('Continuation repeating same content, stopping attempts');
                conversationManager.addMessage({
                  type: 'system_error',
                  error: 'Response incomplete: AI started repeating content',
                  originalContent: accumulatedContent + continuationContent
                });
                this.renderChat();
                this.updateCharCounter();
                this.hideLoading();
                return;
              }
              lastChunkContent = continuationContent;
  
              // Clean up the continuation content
              let cleanedContinuation = continuationContent;
  
              // Handle different continuation types:
              // = → complete message (replace)
              // ~ → raw continuation text (append)
              // { → complete tool call (replace)
  
              if (cleanedContinuation.startsWith('~')) {
                // It's a continuation - strip ~ and append
                cleanedContinuation = cleanedContinuation.substring(1);
                console.log('Continuation type: raw text (starts with ~), will append');
                console.log('  Continuation length:', cleanedContinuation.length);
  
                // Append to accumulated content
                accumulatedContent += cleanedContinuation;
  
              } else if (cleanedContinuation.startsWith('=')) {
                // It's a complete message response - this shouldn't happen for continuations but handle it
                console.log('Continuation is a complete message (starts with =), will replace');
                accumulatedContent = cleanedContinuation;
  
              } else {
                // It's a tool call JSON - strip any wrapper text before first "{" and after last "}"
                const firstBrace = cleanedContinuation.indexOf('{');
                const lastBrace = cleanedContinuation.lastIndexOf('}');
  
                if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                  const originalLength = cleanedContinuation.length;
                  cleanedContinuation = cleanedContinuation.substring(firstBrace, lastBrace + 1);
                  if (originalLength !== cleanedContinuation.length) {
                    console.log('Stripped wrapper text from JSON, extracted from first { to last }');
                    console.log('  Original length:', originalLength, '-> Cleaned length:', cleanedContinuation.length);
                  }
                }
  
                // For tool calls, replace (this is a fallback if AI didn't use ~)
                console.log('Continuation is complete JSON, will replace');
                accumulatedContent = cleanedContinuation;
              }
  
              console.log('Combined content length:', accumulatedContent.length);
  
              // Try processing the combined content
              processed = messageProcessor.processStreamedResponse(accumulatedContent);
  
              if (processed.complete) {
                console.log(`Continuation successful after ${continuationAttempts} attempt(s), response now complete`);
                // Will exit while loop and continue with normal processing
              }
            } catch (continueError) {
              console.error('Continuation failed:', continueError);
              conversationManager.addMessage({
                type: 'system_error',
                error: `Continuation failed after ${continuationAttempts} attempt(s): ${continueError.message}`,
                originalContent: accumulatedContent
              });
              this.renderChat();
              this.updateCharCounter();
              this.hideLoading();
              return;
            }
          }
  
          // If we exhausted all continuation attempts without getting terminator
          if (!processed.complete) {
            console.error(`Response still incomplete after ${MAX_CONTINUATION_ATTEMPTS} continuation attempts`);
            conversationManager.addMessage({
              type: 'system_error',
              error: `Response incomplete after ${MAX_CONTINUATION_ATTEMPTS} continuation attempts`,
              originalContent: accumulatedContent
            });
            this.renderChat();
            this.updateCharCounter();
            this.hideLoading();
            return;
          }
  
          // Successfully got complete response
          const aiResponse = processed.content;
  
          if (aiResponse.type === 'message') {
            // Message was already streamed, just mark as complete
            if (streamingMessageId) {
              const msgs = conversationManager.getMessages();
              const streamingMsg = msgs.find(m => m.id === streamingMessageId);
              if (streamingMsg) {
                streamingMsg.streaming = false;
                streamingMsg.content = aiResponse.text;
              }
            } else {
              // Fallback: add message if streaming didn't work
              conversationManager.addMessage({
                type: 'assistant',
                content: aiResponse.text
              });
            }
            this.renderChat();
            this.updateCharCounter();
            this.hideLoading();
            success = true;
  
          } else if (aiResponse.type === 'execute') {
            // Tool execution - execute tools one at a time, interleaving use/result messages
            const utils = window.module['utils.js'];
  
            for (const tool of aiResponse.tools) {
              const toolId = utils.generateUUID();
  
              // Add tool_use message
              conversationManager.addMessage({
                type: 'tool_use',
                toolId: toolId,
                tool: tool
              });
  
              this.renderChat();
              this.updateCharCounter();
  
              // Update loading indicator for this specific tool
              this.showLoading(`Executing ${tool.name}...`);
  
              // Execute this single tool
              const toolResults = await toolExecutor.executeTools([tool]);
              const result = toolResults[0];
  
              // Add tool_result message immediately after
              conversationManager.addMessage({
                type: 'tool_result',
                toolId: toolId,
                tool: result.tool,
                success: result.success,
                result: result.result,
                error: result.error,
                args: result.args
              });
  
              this.renderChat();
              this.updateCharCounter();
            }
  
            this.hideLoading();
  
            // Auto-call API again to let AI respond to tool results
            await this.getAIResponse();
            success = true;
          }
  
        } catch (error) {
          retryCount++;
          console.warn(`Attempt ${retryCount} failed:`, error.message);
  
          if (retryCount >= config.MAX_RETRIES) {
            this.hideLoading();
            throw error;
          }
  
          // Wait 1 second before retry
          await new Promise(resolve => setTimeout(resolve, 1000));
          accumulatedContent = ''; // Reset for retry
          streamingMessageId = null;
          responseType = null;
        }
      }
  
      this.hideLoading();
      this.updateCharCounter();
    },
  
    renderChat: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const uiRenderer = window.module['ui-renderer.js'];
      const chatArea = document.getElementById('chatArea');
  
      chatArea.innerHTML = '';
  
      const messages = conversationManager.getMessages();
      messages.forEach(msg => {
        const msgElement = uiRenderer.renderMessage(msg);
        chatArea.appendChild(msgElement);
      });
  
      // Scroll to bottom
      chatArea.scrollTop = chatArea.scrollHeight;
    },
  
    updateCharCounter: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
      const charCount = document.getElementById('charCount');
  
      const total = conversationManager.getTotalCharacterCount();
      charCount.textContent = `Total: ${utils.formatCharCount(total)}`;
    },
  
    showError: function(message) {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = message;
    },
  
    hideError: function() {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = '';
    },
  
    showLoading: function(text = 'Processing...') {
      const chatArea = document.getElementById('chatArea');
      if (!chatArea) return;
  
      // Remove any existing loading message
      const existing = document.getElementById('loading-message');
      if (existing) {
        existing.remove();
      }
  
      // Create loading pseudo-message
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'loading-message';
      loadingDiv.style.cssText = 'display: flex; gap: 12px; margin-bottom: 4px; align-items: flex-start; font-family: monospace; font-size: 13px;';
  
      // Gray circle indicator that pulses
      const indicator = document.createElement('div');
      indicator.style.cssText = 'width: 8px; height: 8px; border-radius: 50%; margin-top: 6px; flex-shrink: 0; background: #858585; animation: pulse 1.5s ease-in-out infinite;';
  
      // Text content
      const content = document.createElement('div');
      content.style.cssText = 'flex: 1; min-width: 0; color: #858585; padding: 2px 0;';
      content.textContent = text;
  
      loadingDiv.appendChild(indicator);
      loadingDiv.appendChild(content);
      chatArea.appendChild(loadingDiv);
  
      // Scroll to bottom
      chatArea.scrollTop = chatArea.scrollHeight;
    },
  
    hideLoading: function() {
      const loadingMessage = document.getElementById('loading-message');
      if (loadingMessage) {
        loadingMessage.remove();
      }
    },
  
    testContinuation: async function() {
      console.log('=== CONTINUATION TEST STARTED ===');
  
      const apiClient = window.module['api-client.js'];
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      try {
        // First make a real API call asking for a large response that will get cut off
        const testPrompt = 'Please write a very long detailed explanation about how computers work, starting from transistors all the way to operating systems. Make it at least 5000 words.';
  
        console.log('1. Making initial request for large response...');
  
        const initialPayload = {
          stream: true,
          model: config.MODEL,
          messages: [{
            role: 'user',
            content: testPrompt
          }],
          params: {},
          features: { web_search: false },
          session_id: utils.generateSessionId(),
          chat_id: null,
          id: utils.generateUUID()
        };
  
        const initialResponse = await fetch(`${config.API_BASE}/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(initialPayload)
        });
  
        console.log(`   Response status: ${initialResponse.status}`);
  
        // Read partial response (simulate getting cut off)
        const reader = initialResponse.body.getReader();
        const decoder = new TextDecoder();
        let partialContent = '';
        let chunkCount = 0;
  
        // Read only 50 chunks to simulate cutoff
        for (let i = 0; i < 50; i++) {
          const { done, value } = await reader.read();
          if (done) break;
  
          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split('\n');
  
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') break;
              try {
                const parsed = JSON.parse(data);
                if (parsed.choices?.[0]?.delta?.content) {
                  partialContent += parsed.choices[0].delta.content;
                }
              } catch (e) {}
            }
          }
          chunkCount++;
        }
  
        console.log(`2. Partial response received: ${chunkCount} chunks, ${partialContent.length} chars`);
        console.log(`   First 100 chars: "${partialContent.substring(0, 100)}..."`);
        console.log(`   Last 100 chars: "...${partialContent.substring(partialContent.length - 100)}"`);
  
        // Now test continuation
        console.log('3. Testing continuation with partial content...');
  
        // Extract without = prefix if present
        let cleanPartial = partialContent;
        if (cleanPartial.startsWith('=')) {
          cleanPartial = cleanPartial.substring(1);
          console.log('   Removed = prefix from partial');
        }
  
        const continueMessages = [{
          role: 'user',
          content: testPrompt
        }, {
          role: 'assistant',
          content: cleanPartial
        }, {
          role: 'user',
          content: '[System: Your previous response was cut off. Please continue from where you left off, starting with the exact continuation of your last incomplete response. Do not restart or summarize - just continue the exact text.]'
        }];
  
        console.log(`   Sending continuation request with ${cleanPartial.length} char partial`);
  
        const continuePayload = {
          stream: true,
          model: config.MODEL,
          messages: continueMessages,
          params: {},
          features: { web_search: false },
          session_id: utils.generateSessionId(),
          chat_id: null,
          id: utils.generateUUID(),
          background_tasks: {
            title_generation: false,
            tags_generation: false
          }
        };
  
        const continueResponse = await fetch(`${config.API_BASE}/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(continuePayload)
        });
  
        console.log(`   Continuation response status: ${continueResponse.status}`);
  
        // Read first chunks of continuation
        const continueReader = continueResponse.body.getReader();
        const continueDecoder = new TextDecoder();
        let continuationContent = '';
        let continueChunkCount = 0;
  
        for (let i = 0; i < 10; i++) {
          const { done, value } = await continueReader.read();
          if (done) break;
  
          const chunk = continueDecoder.decode(value, { stream: true });
          const lines = chunk.split('\n');
  
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.choices?.[0]?.delta?.content) {
                  continuationContent += parsed.choices[0].delta.content;
                }
              } catch (e) {}
            }
          }
          continueChunkCount++;
        }
  
        console.log(`4. Continuation received: ${continueChunkCount} chunks, ${continuationContent.length} chars`);
        console.log(`   First 200 chars of continuation: "${continuationContent.substring(0, 200)}"`);
        console.log(`   First char: "${continuationContent.charAt(0)}" (ASCII ${continuationContent.charCodeAt(0)})`);
  
        // Analysis
        const startsWithEquals = continuationContent.startsWith('=');
        const lastWords = cleanPartial.split(' ').slice(-5).join(' ');
        const firstWords = continuationContent.split(' ').slice(0, 5).join(' ');
  
        console.log('\n5. ANALYSIS:');
        console.log(`   Partial ended with: "...${lastWords}"`);
        console.log(`   Continuation started with: "${firstWords}..."`);
        console.log(`   Starts with =: ${startsWithEquals} ${startsWithEquals ? '❌ BAD - restarting' : '✅ GOOD'}`);
        console.log(`   Looks like continuation: ${!startsWithEquals && continuationContent.length > 0 ? '✅ GOOD' : '❌ BAD'}`);
  
        console.log('\n=== TEST COMPLETE ===');
  
      } catch (error) {
        console.error('TEST FAILED:', error.message, error);
      }
    }
  };
  

  // Module: ui-renderer.js
  // UI Renderer v3.0
  // Clean design with status indicators in gutter
  window.module['ui-renderer.js'] = {
    renderMessage: function(message) {
      const container = document.createElement('div');
      container.style.cssText = 'display: flex; gap: 12px; margin-bottom: 4px; align-items: flex-start; font-family: monospace; font-size: 13px;';
  
      // Create gutter indicator
      const indicator = document.createElement('div');
      indicator.style.cssText = 'width: 8px; height: 8px; border-radius: 50%; margin-top: 6px; flex-shrink: 0;';
  
      // Create content area
      const content = document.createElement('div');
      content.style.cssText = 'flex: 1; min-width: 0;';
  
      if (message.type === 'user') {
        // Gray background with white text for user messages
        indicator.style.display = 'none'; // No indicator for user messages
        content.style.cssText += 'background: #3c3c3c; color: white; padding: 8px 12px; border-radius: 4px;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.content;
  
      } else if (message.type === 'assistant') {
        // White circle indicator, no background
        indicator.style.backgroundColor = 'white';
        content.style.cssText += 'color: #d4d4d4; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.content;
  
      } else if (message.type === 'tool_use') {
        // Show circle for tool use
        indicator.style.backgroundColor = '#569cd6'; // Blue for tool use
  
        content.style.cssText += 'color: #d4d4d4; padding: 2px 0; cursor: pointer;';
  
        // Render single tool as clean one-liner
        const tool = message.tool;
        const toolName = this.formatToolName(tool.name);
        const params = this.formatToolParams(tool.name, tool.args);
        content.innerHTML = `<span style="font-weight: bold;">${this.escapeHtml(toolName)}</span><span style="color: #858585;"> ${params}</span>`;
  
        content.addEventListener('click', () => this.showToolModal('Tool Use', tool));
  
      } else if (message.type === 'tool_result') {
        // Add circle indicator for the result
        indicator.style.backgroundColor = message.success ? '#4ec9b0' : '#f48771'; // Green or red
  
        // Special rendering for checklist tools
        if (message.tool === 'exit_planning' || message.tool === 'item_completed' || message.tool === 'item_failed') {
          // Hide indicator for these special tools - we'll show checklist instead
          indicator.style.display = 'none';
  
          if (message.result && message.result.checklist) {
            content.style.cssText += 'padding: 2px 0; padding-left: 20px;';
            content.innerHTML = this.renderChecklist(message.result.checklist, message.result.completed_item, message.result.failed_item);
          } else {
            content.style.cssText += 'color: #858585; padding: 2px 0; padding-left: 20px;';
            content.textContent = this.formatToolResult(message);
          }
        } else {
          // Normal tool results - no indicator, just text indented to align with content
          indicator.style.display = 'none';
          content.style.cssText += 'color: #858585; padding: 2px 0; padding-left: 20px; cursor: pointer;';
          content.textContent = this.formatToolResult(message);
          content.addEventListener('click', () => this.showToolModal(`Tool Result: ${message.tool}`, message.result));
        }
  
      } else if (message.type === 'system_error') {
        indicator.style.backgroundColor = '#f48771'; // Red
        content.style.cssText += 'color: #f48771; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = `Error: ${message.error}`;
  
      } else if (message.type === 'system_warning') {
        indicator.style.backgroundColor = '#dcdcaa'; // Yellow
        content.style.cssText += 'color: #dcdcaa; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.warning;
  
      } else {
        // Unknown type
        indicator.style.backgroundColor = '#858585';
        content.style.cssText += 'color: #858585; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = JSON.stringify(message, null, 2);
      }
  
      container.appendChild(indicator);
      container.appendChild(content);
      return container;
    },
  
    escapeHtml: function(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    },
  
    formatToolName: function(name) {
      // Convert snake_case to Title Case
      return name.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
    },
  
    formatToolParams: function(toolName, args) {
      // Format parameters based on tool type
      if (toolName === 'read_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'list_folder') {
        return this.escapeHtml(args.path || '.');
      } else if (toolName === 'create_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'edit_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'exit_planning') {
        const count = args.checklist ? args.checklist.length : 0;
        return `${count} item${count !== 1 ? 's' : ''}`;
      } else if (toolName === 'item_completed' || toolName === 'item_failed') {
        return args.reason ? this.escapeHtml(args.reason) : '';
      } else {
        // Generic fallback - show all args
        return this.escapeHtml(JSON.stringify(args));
      }
    },
  
    formatToolResult: function(message) {
      if (!message.success) {
        return `Error: ${message.error}`;
      }
  
      const result = message.result;
  
      // Format based on tool type
      if (message.tool === 'read_file') {
        if (result.content) {
          const lines = result.content.split('\n').length;
          return `${lines} line${lines !== 1 ? 's' : ''} read`;
        }
        return 'File read';
      } else if (message.tool === 'list_folder') {
        if (result.entries) {
          const count = result.entries.length;
          return `${count} item${count !== 1 ? 's' : ''} found`;
        }
        return 'Folder listed';
      } else if (message.tool === 'create_file') {
        return 'File created';
      } else if (message.tool === 'edit_file') {
        return 'File edited';
      } else if (message.tool === 'exit_planning') {
        return 'Entering execution mode';
      } else if (message.tool === 'item_completed') {
        return 'Task completed';
      } else if (message.tool === 'item_failed') {
        return 'Task failed';
      } else {
        // Generic fallback
        return JSON.stringify(result);
      }
    },
  
    renderChecklist: function(checklist, completedIndex, failedIndex) {
      if (!checklist || !Array.isArray(checklist)) {
        return 'Invalid checklist';
      }
  
      const items = checklist.map((item, index) => {
        let statusIcon = '○'; // Pending
        let color = '#858585'; // Gray
  
        if (completedIndex !== undefined && index <= completedIndex) {
          statusIcon = '✓'; // Completed
          color = '#4ec9b0'; // Green
        } else if (failedIndex !== undefined && index === failedIndex) {
          statusIcon = '✗'; // Failed
          color = '#f48771'; // Red
        }
  
        return `<div style="color: ${color}; margin-bottom: 2px;">${statusIcon} ${this.escapeHtml(item.short_desc)}</div>`;
      }).join('');
  
      return items;
    },
  
    showToolModal: function(title, content) {
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      `;
  
      // Create modal container
      const modal = document.createElement('div');
      modal.style.cssText = `
        background: #252526;
        border-radius: 8px;
        max-width: 80vw;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      `;
  
      // Modal header
      const header = document.createElement('div');
      header.style.cssText = `
        padding: 16px 20px;
        border-bottom: 1px solid #3e3e42;
        display: flex;
        justify-content: space-between;
        align-items: center;
      `;
      header.innerHTML = `
        <div style="color: #d4d4d4; font-weight: bold; font-size: 14px;">${this.escapeHtml(title)}</div>
        <button id="closeModal" style="
          background: none;
          border: none;
          color: #858585;
          font-size: 20px;
          cursor: pointer;
          padding: 0;
          width: 24px;
          height: 24px;
          line-height: 1;
        ">&times;</button>
      `;
  
      // Modal content
      const contentDiv = document.createElement('div');
      contentDiv.style.cssText = `
        padding: 20px;
        overflow-y: auto;
        flex: 1;
        font-family: monospace;
        font-size: 12px;
        color: #d4d4d4;
        white-space: pre-wrap;
      `;
      contentDiv.textContent = JSON.stringify(content, null, 2);
  
      modal.appendChild(header);
      modal.appendChild(contentDiv);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
  
      // Close handlers
      const closeModal = () => {
        document.body.removeChild(overlay);
      };
  
      document.getElementById('closeModal').addEventListener('click', closeModal);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeModal();
        }
      });
  
      // Close on escape key
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
    }
  };
  

  // Module: utils.js
  // Utility Functions
  window.module['utils.js'] = {
    generateUUID: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    },
  
    generateSessionId: function() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
      let result = '';
      for (let i = 0; i < 20; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    },
  
    getTimestamp: function() {
      return Math.floor(Date.now() / 1000);
    },
  
    countCharacters: function(messages) {
      // Count entire JSON structure, not just content
      // This matches the spec requirement for 500K limit
      return messages.reduce((total, msg) => total + JSON.stringify(msg).length, 0);
    },
  
    formatCharCount: function(count) {
      return `${(count / 1000).toFixed(1)}K`;
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
