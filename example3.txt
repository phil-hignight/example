// AI Agent - Built 2025-12-03T17:25:26.049Z
(function() {
  window.module = {};

  // Module: api-client.js
  // API Client
  window.module['api-client.js'] = {
    chatId: null,
    sessionId: null,
  
    init: function() {
      const utils = window.module['utils.js'];
      this.sessionId = utils.generateSessionId();
    },
  
    testOutputLimit: async function() {
      console.log('\n' + '='.repeat(80));
      console.log('TESTING OUTPUT LIMIT');
      console.log('='.repeat(80));
  
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      // Test with increasing max_tokens values
      // 1 token ≈ 4 chars, so: 4K, 8K, 16K, 32K, 64K tokens = 16K, 32K, 64K, 128K, 256K chars
      const testSizes = [
        { tokens: 4096, chars: 16384 },
        { tokens: 8192, chars: 32768 },
        { tokens: 16384, chars: 65536 },
        { tokens: 32768, chars: 131072 }
      ];
  
      console.log('Testing with simple request: "Write a very long technical explanation"');
      console.log('');
  
      let maxSuccessful = 0;
  
      for (const test of testSizes) {
        console.log(`Testing ${test.tokens} tokens (≈${test.chars} chars)...`);
  
        const userMessage = 'Write a very long, detailed technical explanation about computer memory. Include multiple sections. Make it as long as possible.';
  
        try {
          const startTime = Date.now();
  
          // Step 1: Create chat using /new
          const { chatId, messageId } = await this.createNewChat(userMessage);
  
          // Step 2: Update chat using /chats/{id}
          const userMsgObj = {
            id: messageId,
            parentId: null,
            childrenIds: [],
            role: 'user',
            content: userMessage,
            timestamp: Date.now()
          };
  
          await this.updateChat([userMsgObj]);
  
          // Step 3: Get completion using /chat/completions with max_tokens override
          const assistantMessageId = utils.generateUUID();
          const apiMessages = [{
            role: 'user',
            content: userMessage
          }];
  
          const payload = {
            stream: true,
            model: config.MODEL,
            messages: apiMessages,
            max_tokens: test.tokens,
            session_id: this.sessionId,
            chat_id: chatId,
            id: assistantMessageId,
            params: {},
            features: { web_search: false },
            background_tasks: { title_generation: false, tags_generation: false }
          };
  
          const response = await fetch(`${config.API_BASE}/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
          });
  
          if (!response.ok) {
            const errorText = await response.text();
            console.log(`  ✗ FAILED: ${response.status} ${response.statusText}`);
            console.log(`    Error: ${errorText.substring(0, 200)}`);
            break;
          }
  
          // Read the streaming response (just count chars, don't process)
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let content = '';
  
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
  
            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');
  
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const data = line.slice(6);
                if (data === '[DONE]') continue;
  
                try {
                  const parsed = JSON.parse(data);
                  const delta = parsed.choices?.[0]?.delta?.content;
                  if (delta) {
                    content += delta;
                  }
                } catch (e) {
                  // Ignore parse errors
                }
              }
            }
          }
  
          const totalDuration = Date.now() - startTime;
          const actualChars = content.length;
  
          console.log(`  ✓ SUCCESS: ${actualChars} chars received (${totalDuration}ms)`);
          maxSuccessful = test.chars;
  
        } catch (error) {
          console.log(`  ✗ ERROR: ${error.message}`);
          break;
        }
  
        // Small delay between tests
        await new Promise(resolve => setTimeout(resolve, 500));
      }
  
      console.log('');
      console.log('='.repeat(80));
      if (maxSuccessful > 0) {
        console.log(`RESULT: Max successful output: ${maxSuccessful} chars`);
        console.log(`Recommended safe limit: ${Math.floor(maxSuccessful * 0.8)} chars (80% of max)`);
      } else {
        console.log('RESULT: Unable to determine output limit (all tests failed)');
        console.log('HINT: Check the error messages above for details');
      }
      console.log('='.repeat(80));
      console.log('');
  
      return maxSuccessful;
    },
  
    createNewChat: async function(firstMessage) {
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      const messageId = utils.generateUUID();
      const timestamp = utils.getTimestamp();
  
      const payload = {
        chat: {
          id: '',
          title: 'Chat Pending',
          models: [config.MODEL],
          params: {},
          history: {
            messages: {
              [messageId]: {
                id: messageId,
                parentId: null,
                childrenIds: [],
                role: 'user',
                content: firstMessage,
                timestamp: timestamp,
                models: [config.MODEL]
              }
            },
            currentId: messageId
          },
          messages: [
            {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: 'user',
              content: firstMessage,
              timestamp: timestamp,
              models: [config.MODEL]
            }
          ],
          tags: [],
          timestamp: Date.now()
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/new`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to create chat: ${response.status} ${response.statusText}`);
      }
  
      const data = await response.json();
      this.chatId = data.id;
  
      return { chatId: data.id, messageId };
    },
  
    updateChat: async function(messages) {
      const config = window.module['config.js'];
  
      // Build history object
      const historyMessages = {};
      messages.forEach((msg) => {
        historyMessages[msg.id] = {
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp,
          ...(msg.role === 'user' ? { models: [config.MODEL] } : {
            model: config.MODEL,
            modelIdx: 0,
            modelName: config.MODEL,
            userContext: null
          })
        };
      });
  
      const currentId = messages[messages.length - 1].id;
  
      const payload = {
        chat: {
          models: [config.MODEL],
          files: [],
          params: {},
          history: {
            messages: historyMessages,
            currentId: currentId
          },
          messages: messages.map(msg => ({
            id: msg.id,
            parentId: msg.parentId,
            childrenIds: msg.childrenIds,
            content: msg.content,
            role: msg.role,
            timestamp: msg.timestamp,
            ...(msg.role === 'user' ? { models: [config.MODEL] } : {
              model: config.MODEL,
              modelIdx: 0,
              modelName: config.MODEL,
              userContext: null
            })
          }))
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/${this.chatId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to update chat: ${response.status} ${response.statusText}`);
      }
  
      return await response.json();
    },
  
    getCompletion: async function(apiMessages, assistantMessageId) {
      const config = window.module['config.js'];
  
      // apiMessages is already in API format from api-renderer
      const payload = {
        stream: true,
        model: config.MODEL,
        messages: apiMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: true,
          tags_generation: true
        }
      };
  
      console.log('=== GET COMPLETION REQUEST ===');
      console.log('Messages count:', apiMessages.length);
      console.log('Last message:', apiMessages[apiMessages.length - 1]);
      console.log('Full payload:', payload);
  
      const response = await fetch(`${config.API_BASE}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to get completion: ${response.status} ${response.statusText}`);
      }
  
      console.log('Response status:', response.status);
  
      return response;
    }
  };
  

  // Module: api-renderer.js
  // API Renderer
  // Transforms internal message format to API format
  window.module['api-renderer.js'] = {
    renderMessagesForAPI: function(messages) {
      console.log(`[APIRenderer] renderMessagesForAPI called with ${messages.length} total messages`);
      const modeManager = window.module['mode-manager.js'];
      const apiMessages = [];
  
      // Find the latest summary (if any) and start from there
      // This gives us: [latest summary, all messages after it]
      let startIndex = 0;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].type === 'summary') {
          startIndex = i;
          console.log(`[APIRenderer] Found latest summary at index ${i}, id: ${messages[i].id}`);
          break;
        }
      }
  
      // Get messages from latest summary onward (or all messages if no summary)
      const activeMsgs = messages.slice(startIndex);
      console.log(`[APIRenderer] Active messages (from index ${startIndex}): ${activeMsgs.length} messages`);
  
      let firstUserMessageIndex = -1;
      let pendingWarnings = []; // Can accumulate multiple warnings
      let pendingToolUses = []; // Can accumulate multiple tool uses to combine into one assistant message
      let pendingToolResults = []; // Can accumulate multiple tool results
      let pendingPartials = []; // Can accumulate consecutive partial messages
  
      for (let i = 0; i < activeMsgs.length; i++) {
        const msg = activeMsgs[i];
  
        // Handle summary messages - treat them as user messages
        if (msg.type === 'summary') {
          console.log(`[APIRenderer] Processing summary message - id: ${msg.id}`);
          let content = msg.content;
  
          // Is this the first message? Add system prompt
          if (firstUserMessageIndex === -1) {
            firstUserMessageIndex = apiMessages.length;
            const prefix = modeManager.getSystemPrompt();
            content = prefix + '\n\n' + content;
            console.log(`[APIRenderer] Added system prompt to first message (summary)`);
          }
  
          apiMessages.push({
            role: 'user',
            content: content
          });
          console.log(`[APIRenderer] Added summary as user message to API`);
          continue;
        }
  
        // Collect system_warning messages to merge with next user message
        if (msg.type === 'system_warning') {
          pendingWarnings.push(msg.warning);
          continue;
        }
  
        // Collect consecutive partial messages to combine
        if (msg.type === 'partial') {
          // But first, flush any pending tools (they come before this partial in message order)
          if (pendingToolUses.length > 0) {
            apiMessages.push({
              role: 'assistant',
              content: JSON.stringify({ tools: pendingToolUses }) + '|||||END|||||'
            });
            pendingToolUses = [];
          }
          if (pendingToolResults.length > 0) {
            const combinedResults = pendingToolResults.map(result => {
              if (result.success) {
                const path = result.args?.path || '';
                const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
                return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
              } else {
                return `Tool: ${result.tool}\nError: ${result.error}`;
              }
            }).join('\n\n');
            apiMessages.push({
              role: 'user',
              content: combinedResults
            });
            pendingToolResults = [];
          }
  
          pendingPartials.push(msg);
          continue;
        }
  
        // Flush pending partials before processing other message types (tool_use, tool_result, user, assistant)
        if (pendingPartials.length > 0) {
          // Combine all partial content into single assistant message
          const combinedContent = pendingPartials.map(p => p.content).join('');
          apiMessages.push({
            role: 'assistant',
            content: combinedContent + '|||||END|||||'
          });
          pendingPartials = [];
        }
  
        // Collect tool uses to combine into single assistant message
        if (msg.type === 'tool_use') {
          // Handle both old format (msg.tool) and new format (msg.tools array)
          const tools = msg.tools || [msg.tool];
          pendingToolUses.push(...tools);
          continue;
        }
  
        // Collect tool results to combine
        if (msg.type === 'tool_result') {
          pendingToolResults.push(msg);
          continue;
        }
  
        // Flush pending tool uses before processing other message types
        if (pendingToolUses.length > 0) {
          apiMessages.push({
            role: 'assistant',
            content: JSON.stringify({ tools: pendingToolUses }) + '|||||END|||||'
          });
          pendingToolUses = [];
        }
  
        // Flush pending tool results before processing other message types
        if (pendingToolResults.length > 0) {
          const combinedResults = pendingToolResults.map(result => {
            if (result.success) {
              // Include the file path in the result for read_file
              const path = result.args?.path || '';
              const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
              return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
            } else {
              return `Tool: ${result.tool}\nError: ${result.error}`;
            }
          }).join('\n\n');
  
          apiMessages.push({
            role: 'user',
            content: combinedResults
          });
          pendingToolResults = [];
        }
  
        // Handle different message types
        if (msg.type === 'user') {
          let content = msg.content;
  
          // Is this the first user message we're adding to API?
          if (firstUserMessageIndex === -1) {
            firstUserMessageIndex = apiMessages.length;
  
            // Prepend system prompt to first user message
            const prefix = modeManager.getSystemPrompt();
            content = prefix + '\n\n' + content;
          }
  
          // Prepend any pending warnings
          if (pendingWarnings.length > 0) {
            const warningsText = pendingWarnings.map(w => `[System: ${w}]`).join('\n');
            content = warningsText + '\n\n' + content;
            pendingWarnings = [];
          }
  
          apiMessages.push({
            role: 'user',
            content: content
          });
  
        } else if (msg.type === 'assistant') {
          // Assistant message responses use = prefix
          apiMessages.push({
            role: 'assistant',
            content: msg.content + '|||||END|||||'
          });
  
        } else if (msg.type === 'system_error') {
          apiMessages.push({
            role: 'user',
            content: `Error: ${msg.error}`
          });
        }
      }
  
      // Flush any remaining tool uses at the end (in order of appearance)
      if (pendingPartials.length > 0) {
        const combinedContent = pendingPartials.map(p => p.content).join('');
        apiMessages.push({
          role: 'assistant',
          content: combinedContent + '|||||END|||||'
        });
      }
  
      if (pendingToolUses.length > 0) {
        apiMessages.push({
          role: 'assistant',
          content: JSON.stringify({ tools: pendingToolUses }) + '|||||END|||||'
        });
      }
  
      if (pendingToolResults.length > 0) {
        const combinedResults = pendingToolResults.map(result => {
          if (result.success) {
            const path = result.args?.path || '';
            const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
            return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
          } else {
            return `Tool: ${result.tool}\nError: ${result.error}`;
          }
        }).join('\n\n');
  
        apiMessages.push({
          role: 'user',
          content: combinedResults
        });
      }
  
      console.log(`[APIRenderer] Final API messages count: ${apiMessages.length}`);
      console.log(`[APIRenderer] First 3 API messages:`, apiMessages.slice(0, 3).map(m => ({ role: m.role, contentLength: m.content.length })));
      return apiMessages;
    }
  };
  

  // Module: config.js
  // Configuration
  window.module['config.js'] = {
    API_BASE: 'https://chat.niprgpt.mil/api',
    MODEL: 'Anthropic Claude 4 Sonnet',
    MAX_RETRIES: 5,
    TIMEOUT_MS: 30000, // 30 seconds
    MAX_CONVERSATION_CHARS: 500000 // 500K character limit before summarization
  };
  

  // Module: conversation-flow.js
  // Conversation Flow Manager
  // Pure logic module for handling AI conversation flow
  // NO DOM dependencies - can be tested in Node.js
  
  window.module['conversation-flow.js'] = {
    /**
     * Main conversation loop - handles the complete AI conversation cycle
     * This is the auto-call loop extracted from UI layer for testability
     *
     * @param {Object} options - Configuration options
     * @param {Function} options.onProgress - Called with status updates (optional)
     * @param {Function} options.onUpdate - Called after state changes for UI updates (optional)
     * @param {number} options.maxLoops - Maximum number of loops to prevent infinite loops (default: 1000, essentially unlimited)
     * @returns {Promise<Object>} - { success: boolean, loopCount: number, error: string|null }
     */
    runConversationLoop: async function(options = {}) {
      const conversationManager = window.module['conversation-manager.js'];
      const apiRenderer = window.module['api-renderer.js'];
      const apiClient = window.module['api-client.js'];
      const toolExecutor = window.module['tool-executor.js'];
      const utils = window.module['utils.js'];
      const config = window.module['config.js'];
  
      const maxLoops = options.maxLoops || 1000;
      const onProgress = options.onProgress || (() => {});
      const onUpdate = options.onUpdate || (() => {});
  
      let loopCount = 0;
  
      // Keep calling AI until it sends a message (not tools)
      while (loopCount < maxLoops) {
        loopCount++;
        onProgress(`Loop ${loopCount}...`);
  
        // Get messages for API
        const messages = conversationManager.getMessages();
        const apiMessages = apiRenderer.renderMessagesForAPI(messages);
  
        // Create chat if needed
        if (!apiClient.chatId && messages.length > 0) {
          const firstUserMsg = messages.find(m => m.type === 'user');
          if (firstUserMsg) {
            await apiClient.createNewChat(firstUserMsg.content);
          }
        }
  
        // Get completion with streaming
        const assistantMessageId = utils.generateUUID();
  
        let retryCount = 0;
        let success = false;
  
        while (retryCount < config.MAX_RETRIES && !success) {
          try {
            const response = await apiClient.getCompletion(apiMessages, assistantMessageId);
  
            // Handle the streaming response
            const result = await this.handleAIResponse(
              response,
              assistantMessageId,
              apiMessages,
              {
                onProgress: onProgress,
                onChunk: options.onChunk
              }
            );
  
            // Handle the result
            if (result.success) {
              const aiResponse = result.content;
  
              if (aiResponse.type === 'message') {
                // AI sent a message - conversation complete
                conversationManager.addMessage({
                  type: 'assistant',
                  content: aiResponse.text
                });
                onUpdate();
  
                // Success - exit the loop
                return {
                  success: true,
                  loopCount: loopCount,
                  error: null
                };
  
              } else if (aiResponse.type === 'execute') {
                // Tool execution - create ONE tool_use message with ALL tools
                const { message: toolUseMessage } = conversationManager.addMessage({
                  type: 'tool_use',
                  tools: aiResponse.tools
                });
                onUpdate();
  
                // Execute tools sequentially, creating individual tool_result messages
                for (const tool of aiResponse.tools) {
                  onProgress(`Executing ${tool.name}...`);
  
                  const toolResults = await toolExecutor.executeTools([tool]);
                  const toolResult = toolResults[0];
  
                  conversationManager.addMessage({
                    type: 'tool_result',
                    parentId: toolUseMessage.id,
                    tool: toolResult.tool,
                    success: toolResult.success,
                    result: toolResult.result,
                    error: toolResult.error,
                    args: toolResult.args
                  });
                  onUpdate();
                }
  
                // If the response was truncated and auto-executed, tell the AI
                if (aiResponse.wasTruncated) {
                  const truncatedTool = aiResponse.tools[0];
                  const toolName = truncatedTool.name;
                  const contentLength = truncatedTool.args.content ? truncatedTool.args.content.length : 0;
  
                  let message = '';
                  if (toolName === 'create_file') {
                    message = `Note: Your ${toolName} response was truncated at ${aiResponse.truncatedLength} characters. I auto-completed the JSON and wrote ${contentLength} characters to ${truncatedTool.args.path}. If you need to add more content, use append_file.`;
                  } else if (toolName === 'append_file') {
                    message = `Note: Your ${toolName} response was truncated at ${aiResponse.truncatedLength} characters. I auto-completed the JSON and appended ${contentLength} characters to ${truncatedTool.args.path}. If you need to add more content, use append_file again.`;
                  }
  
                  conversationManager.addMessage({
                    type: 'system_warning',
                    warning: message
                  });
                  onUpdate();
                }
  
                // Auto-call API again to let AI respond to tool results
                // Continue to next iteration of the while loop
                success = true;
              }
  
            } else if (result.cancelled) {
              // User cancelled - exit immediately
              console.log('[ConvFlow] User cancellation detected, exiting conversation loop');
              return {
                success: false,
                loopCount: loopCount,
                error: 'CANCELLED_BY_USER',
                cancelled: true
              };
  
            } else if (result.needsRetry) {
              // Error already added to conversation by handleAIResponse
              onUpdate();
  
              // Continue to next loop iteration to let AI see the error
              success = true;
  
            } else {
              // Fatal error
              return {
                success: false,
                loopCount: loopCount,
                error: result.error
              };
            }
  
          } catch (error) {
            retryCount++;
            console.warn(`Attempt ${retryCount} failed:`, error.message);
  
            if (retryCount >= config.MAX_RETRIES) {
              return {
                success: false,
                loopCount: loopCount,
                error: error.message
              };
            }
  
            // Wait 1 second before retry
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
      }
  
      // Hit max loops
      return {
        success: false,
        loopCount: loopCount,
        error: `Hit maximum loop limit (${maxLoops})`
      };
    },
  
    /**
     * Process a streaming AI response with continuation and error handling
     * This is the core conversation loop extracted from ui-manager
     *
     * @param {ReadableStream} streamingResponse - The streaming response from API
     * @param {string} assistantMessageId - ID for the assistant's message
     * @param {Array} apiMessages - Current conversation messages in API format
     * @param {Object} callbacks - Callbacks for progress updates
     * @param {Function} callbacks.onProgress - Called with status updates (optional)
     * @param {Function} callbacks.onChunk - Called with each content chunk (optional)
     * @returns {Promise<Object>} - { success: boolean, content: Object|string, error: string|null }
     */
    handleAIResponse: async function(streamingResponse, assistantMessageId, apiMessages, callbacks = {}) {
      const conversationManager = window.module['conversation-manager.js'];
      const messageProcessor = window.module['message-processor.js'];
      const config = window.module['config.js'];
  
      let accumulatedContent = '';
  
      try {
        // Stream the initial response
        const reader = streamingResponse.body.getReader();
        const decoder = new TextDecoder();
  
        while (true) {
          // Check for cancellation during streaming
          const uiManager = window.module['ui-manager.js'];
          if (uiManager && uiManager.cancelRequested) {
            console.log('[ConvFlow] Streaming cancelled by user');
            reader.cancel(); // Cancel the stream
            throw new Error('CANCELLED_BY_USER');
          }
  
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Timeout')), config.TIMEOUT_MS);
          });
  
          const readPromise = reader.read();
          const result = await Promise.race([readPromise, timeoutPromise]);
  
          if (result.done) break;
  
          const chunk = decoder.decode(result.value, { stream: true });
          const lines = chunk.split('\n');
  
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') continue;
  
              try {
                const parsed = JSON.parse(data);
                if (parsed.choices?.[0]?.delta?.content) {
                  const content = parsed.choices[0].delta.content;
                  accumulatedContent += content;
  
                  if (callbacks.onChunk) {
                    callbacks.onChunk(content, accumulatedContent);
                  }
                }
              } catch (e) {
                console.error('Failed to parse SSE data:', e);
              }
            }
          }
        }
  
        console.log(`[ConvFlow] Finished streaming, accumulated content length: ${accumulatedContent.length}`);
  
        // Check if response exceeds 100K character limit
        const MAX_RESPONSE_CHARS = 100000;
        if (accumulatedContent.length > MAX_RESPONSE_CHARS) {
          console.log(`[ConvFlow] Response EXCEEDED ${MAX_RESPONSE_CHARS} char limit`);
          conversationManager.addMessage({
            type: 'system_warning',
            warning: `Response exceeded ${MAX_RESPONSE_CHARS} character limit (got ${accumulatedContent.length} chars). Response was truncated. For large files, use create_file for the first chunk, then append_file for additional chunks.`
          });
        }
  
        // Process the accumulated response
        console.log(`[ConvFlow] Processing accumulated response...`);
        let processed = messageProcessor.processStreamedResponse(accumulatedContent);
        console.log(`[ConvFlow] Processing result - complete: ${processed.complete}, error: ${processed.error}, type: ${processed.content?.type}`);
  
        // Add system warning if text was trimmed
        if (processed.systemWarning) {
          conversationManager.addMessage(processed.systemWarning);
        }
  
        if (processed.error) {
          // Add the AI's failed response to conversation first
          conversationManager.addMessage({
            type: 'assistant',
            id: assistantMessageId,
            content: accumulatedContent,
            timestamp: Date.now(),
            parentId: null,
            childrenIds: []
          });
  
          // Then add system error message
          conversationManager.addMessage({
            type: 'system_error',
            error: processed.error,
            originalContent: processed.originalContent || accumulatedContent
          });
  
          // Return error to caller - they can decide to retry
          return {
            success: false,
            content: null,
            error: processed.error,
            needsRetry: true
          };
        }
  
        // Check if response is incomplete (missing terminator)
        // Try to auto-close JSON and execute it if possible
        if (!processed.complete) {
          console.log(`[ConvFlow] Response INCOMPLETE - missing terminator`);
          console.log(`[ConvFlow] Response length: ${accumulatedContent.length}`);
          console.log(`[ConvFlow] Last 100 chars:`, accumulatedContent.substring(Math.max(0, accumulatedContent.length - 100)));
  
          // Strip leading = if present (Claude sometimes adds this prefix)
          let cleanContent = accumulatedContent;
          if (cleanContent.startsWith('=')) {
            cleanContent = cleanContent.substring(1);
            console.log('[Truncation] Stripped leading = from response');
          }
  
          // Try to auto-close and parse the JSON
          const autoCloseResult = messageProcessor.attemptAutoClose(cleanContent);
  
          if (autoCloseResult.success && autoCloseResult.tools) {
            // Successfully parsed! Check if it's a tool we can auto-execute
            const tools = autoCloseResult.tools;
            console.log(`[Truncation] Auto-closed JSON successfully, found ${tools.length} tool(s)`);
  
            // Check if ALL tools are create_file or append_file (safe to auto-execute)
            const allSafeTools = tools.every(t => t.name === 'create_file' || t.name === 'append_file');
  
            if (allSafeTools && tools.length > 0) {
              // Execute the tools and tell AI we did it
              console.log('[Truncation] All tools are create_file/append_file - auto-executing');
  
              return {
                success: true,
                content: {
                  type: 'execute',
                  tools: tools,
                  wasTruncated: true,
                  truncatedLength: cleanContent.length
                },
                error: null
              };
            } else if (tools.some(t => t.name === 'edit_file')) {
              // edit_file was truncated - ask AI to resend smaller
              console.log('[Truncation] Found edit_file tool - cannot auto-execute, asking for smaller edit');
  
              conversationManager.addMessage({
                type: 'assistant',
                id: assistantMessageId,
                content: cleanContent,
                timestamp: Date.now(),
                parentId: null,
                childrenIds: []
              });
  
              conversationManager.addMessage({
                type: 'system_error',
                error: `Your edit_file tool call was truncated at ${cleanContent.length} characters. The edit content is too large to send in one request. Please break it into smaller edits or use create_file + append_file for large file creation.`,
                originalContent: cleanContent
              });
  
              return {
                success: false,
                content: null,
                error: 'edit_file truncated',
                needsRetry: true
              };
            } else {
              // Other tool types - ask AI to resend smaller
              console.log('[Truncation] Found other tool types - asking for smaller request');
  
              conversationManager.addMessage({
                type: 'assistant',
                id: assistantMessageId,
                content: cleanContent,
                timestamp: Date.now(),
                parentId: null,
                childrenIds: []
              });
  
              conversationManager.addMessage({
                type: 'system_error',
                error: `Your tool call was truncated at ${cleanContent.length} characters. Please send a smaller request that fits within the response limit.`,
                originalContent: cleanContent
              });
  
              return {
                success: false,
                content: null,
                error: 'Tool call truncated',
                needsRetry: true
              };
            }
          } else {
            // Couldn't auto-close JSON - ask AI to resend smaller
            console.log('[Truncation] Could not auto-close JSON - asking for smaller request');
  
            conversationManager.addMessage({
              type: 'assistant',
              id: assistantMessageId,
              content: cleanContent,
              timestamp: Date.now(),
              parentId: null,
              childrenIds: []
            });
  
            conversationManager.addMessage({
              type: 'system_error',
              error: `Your response was truncated at ${cleanContent.length} characters and could not be parsed as valid JSON. Please send a smaller request that fits within the response limit.`,
              originalContent: cleanContent
            });
  
            return {
              success: false,
              content: null,
              error: 'Response truncated - invalid JSON',
              needsRetry: true
            };
          }
        }
  
        // Success! Return the processed content
        return {
          success: true,
          content: processed.content,
          error: null,
          rawResponse: accumulatedContent
        };
  
      } catch (error) {
        console.error('handleAIResponse error:', error);
  
        // Handle user cancellation specially
        if (error.message === 'CANCELLED_BY_USER') {
          console.log('[ConvFlow] User cancellation detected in catch block');
          // Don't add error message - the cancelCurrentTask() method will add the cancelled message
          return {
            success: false,
            content: null,
            error: 'CANCELLED_BY_USER',
            needsRetry: false,
            cancelled: true
          };
        }
  
        conversationManager.addMessage({
          type: 'system_error',
          error: error.message,
          originalContent: accumulatedContent
        });
  
        return {
          success: false,
          content: null,
          error: error.message,
          needsRetry: false
        };
      }
    }
  };
  

  // Module: conversation-manager.js
  // Conversation Manager
  // Manages message array, character counting, and (TODO) summarization
  window.module['conversation-manager.js'] = {
    messages: [],
  
    init: async function(folderPath) {
      console.log('[ConversationManager] init called with folderPath:', folderPath);
      this.messages = [];
  
      // Initialize persistence if folder path provided (including empty string for root)
      if (folderPath !== undefined && folderPath !== null) {
        const persistence = window.module['conversation-persistence.js'];
        await persistence.init(folderPath);
  
        // Load existing conversation
        const loadedMessages = await persistence.loadConversation();
        this.messages = loadedMessages;
  
        console.log(`[ConversationManager] Loaded ${this.messages.length} messages from disk`);
      }
    },
  
    addMessage: function(message, skipPersist = false) {
      const utils = window.module['utils.js'];
      const config = window.module['config.js'];
  
      console.log(`[ConvMgr] addMessage called - type: ${message.type}, skipPersist: ${skipPersist}`);
  
      // Ensure message has required fields
      if (!message.id) {
        message.id = utils.generateUUID();
      }
      if (!message.timestamp) {
        message.timestamp = utils.getTimestamp();
      }
      if (!message.parentId) {
        message.parentId = this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null;
      }
      if (!message.childrenIds) {
        message.childrenIds = [];
      }
  
      // Update parent's childrenIds
      if (message.parentId) {
        const parent = this.messages.find(m => m.id === message.parentId);
        if (parent) {
          parent.childrenIds.push(message.id);
        }
      }
  
      // Check 500K character limit before adding
      const currentCount = this.getTotalCharacterCount();
      const messageCharCount = utils.countCharacters([message]);
      const wouldExceedLimit = (currentCount + messageCharCount) > config.MAX_CONVERSATION_CHARS;
  
      console.log(`[ConvMgr] Character count - current: ${currentCount}, adding: ${messageCharCount}, limit: ${config.MAX_CONVERSATION_CHARS}, wouldExceed: ${wouldExceedLimit}`);
  
      if (wouldExceedLimit) {
        console.log(`[ConvMgr] ⚠️ TRIGGERING SUMMARIZATION - limit would be exceeded`);
        // Trigger summarization asynchronously (don't block)
        this.summarize().catch(err => console.error('[ConvMgr] Summarization error:', err));
      }
  
      // Add the message to memory immediately
      this.messages.push(message);
  
      // Create persist function
      const persistFn = () => {
        const persistence = window.module['conversation-persistence.js'];
        if (persistence.isInitialized) {
          return persistence.saveMessage(message).catch(err =>
            console.error('[ConversationManager] Failed to persist message:', err)
          );
        }
        return Promise.resolve();
      };
  
      // Auto-persist unless skipPersist is true
      if (!skipPersist) {
        persistFn();
      }
  
      // Return object with message and persist function
      return {
        message: message,
        persist: persistFn
      };
    },
  
    getMessages: function() {
      return this.messages;
    },
  
    getTotalCharacterCount: function() {
      const utils = window.module['utils.js'];
      return utils.countCharacters(this.messages);
    },
  
    /**
     * Summarizes conversation when it exceeds 500K characters
     * Creates a summary message and marks which messages it summarizes
     */
    summarize: async function() {
      console.log(`[ConvMgr] ========== SUMMARIZATION STARTED ==========`);
      const utils = window.module['utils.js'];
      const apiClient = window.module['api-client.js'];
      const config = window.module['config.js'];
  
      console.log(`[ConvMgr] Current message count: ${this.messages.length}`);
      console.log(`[ConvMgr] Current character count: ${this.getTotalCharacterCount()}`);
  
      // 1. Gather messages to summarize
      let messagesToSummarize = [];
      let latestSummaryIndex = -1;
  
      // Find the latest summary (if any)
      for (let i = this.messages.length - 1; i >= 0; i--) {
        if (this.messages[i].type === 'summary') {
          latestSummaryIndex = i;
          break;
        }
      }
  
      if (latestSummaryIndex === -1) {
        // No summaries exist - summarize all messages
        messagesToSummarize = this.messages.slice();
        console.log(`[ConvMgr] No existing summaries - summarizing ALL ${messagesToSummarize.length} messages`);
      } else {
        // Summaries exist - summarize from latest summary to end
        messagesToSummarize = this.messages.slice(latestSummaryIndex);
        console.log(`[ConvMgr] Found existing summary at index ${latestSummaryIndex} - summarizing ${messagesToSummarize.length} messages from there`);
      }
  
      console.log(`[ConvMgr] Summarizing ${messagesToSummarize.length} messages...`);
  
      // 2. Convert messages to text for summarization
      const messagesText = messagesToSummarize.map(msg => {
        switch (msg.type) {
          case 'user':
            return `User: ${msg.content}`;
          case 'assistant':
            return `Assistant: ${msg.content}`;
          case 'tool_use':
            return `Tool Use: ${JSON.stringify(msg.tool || msg.tools)}`;
          case 'tool_result':
            return `Tool Result (${msg.tool}): ${msg.success ? 'Success' : 'Error'}\n${msg.result || msg.error}`;
          case 'system_error':
            return `System Error: ${msg.error}`;
          case 'system_warning':
            return `System Warning: ${msg.warning}`;
          case 'summary':
            return `Previous Summary: ${msg.content}`;
          default:
            return `${msg.type}: ${JSON.stringify(msg)}`;
        }
      }).join('\n\n');
  
      // Get the last user message for context
      let lastUserMessage = '';
      for (let i = this.messages.length - 1; i >= 0; i--) {
        if (this.messages[i].type === 'user') {
          lastUserMessage = this.messages[i].content;
          break;
        }
      }
  
      // 3. Create summary prompt
      const summaryPrompt = `<system-reminder>
  Summarize the previous work and provide context for the current task.
  
  Be concise but include:
  - What the user originally requested
  - What has been accomplished
  - Current state of the codebase
  - Any important context for continuing
  
  Format as a brief summary.
  </system-reminder>
  
  ${messagesText}
  
  Last user request: ${lastUserMessage}`;
  
      // 4. Call API to generate summary
      const summaryMessages = [{
        role: 'user',
        content: summaryPrompt
      }];
  
      try {
        console.log(`[ConvMgr] Calling API for summarization...`);
        const response = await fetch(`${config.API_BASE}/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            stream: false, // Non-streaming for simplicity
            model: config.MODEL,
            messages: summaryMessages,
            params: {},
            features: { web_search: false },
            session_id: utils.generateSessionId(),
            chat_id: apiClient.chatId,
            id: utils.generateUUID()
          })
        });
  
        console.log(`[ConvMgr] API response status: ${response.status}`);
        if (!response.ok) {
          throw new Error(`Summary API call failed: ${response.status}`);
        }
  
        const data = await response.json();
        const summaryContent = data.choices?.[0]?.message?.content || 'Summary generation failed';
        console.log(`[ConvMgr] Received summary content (length: ${summaryContent.length})`);
        console.log(`[ConvMgr] Summary preview:`, summaryContent.substring(0, 200));
  
        // 5. Create summary message as a USER message that will be sent to API
        // This tells the AI: "Here's what happened, now continue with the latest request"
        const summaryUserMessage = `<system-reminder>
  The conversation has exceeded the character limit. Here's a summary of what happened so far:
  
  ${summaryContent}
  
  The user's latest request was: ${lastUserMessage}
  
  Please continue from where we left off and respond to the user's latest request.
  </system-reminder>`;
  
        // Add summary as a special user message that marks the compaction point
        console.log(`[ConvMgr] Adding summary message to conversation...`);
        this.addMessage({
          type: 'summary',
          content: summaryUserMessage
        });
  
        console.log(`[ConvMgr] ========== SUMMARIZATION COMPLETE ==========`);
        console.log(`[ConvMgr] ✓ Created summary message. Total messages now: ${this.messages.length}`);
        console.log(`[ConvMgr] Summary preview: ${summaryContent.substring(0, 200)}...`);
  
        return { success: true, summary: summaryContent };
  
      } catch (error) {
        console.error('Summarization failed:', error);
        // If summarization fails, just warn and continue
        // This prevents blocking the user from continuing work
        console.warn('Continuing without summarization - conversation may become very large');
        return null;
      }
    }
  };
  

  // Module: conversation-persistence.js
  // Conversation Persistence
  // Manages saving/loading conversations to .agent/internal/conversation.jsonl
  window.module['conversation-persistence.js'] = {
    conversationFilePath: null,
    archiveFolderPath: null,
    isInitialized: false,
  
    /**
     * Initialize persistence for a given folder
     * @param {string} folderPath - The folder where user opened the app
     */
    init: async function(folderPath) {
      const fileSystem = window.module['file-system.js'];
  
      // Create .agent folder if needed
      // Handle empty folderPath to avoid leading slash
      const agentFolder = folderPath ? folderPath + '/.agent' : '.agent';
      console.log('[Persistence] Agent folder path:', agentFolder);
      try {
        await fileSystem.listFolder({ path: agentFolder });
        console.log('[Persistence] .agent folder already exists');
      } catch (e) {
        // Folder doesn't exist, create it
        console.log('[Persistence] Creating .agent folder...');
        try {
          await fileSystem.createFolder({ path: agentFolder });
          console.log('[Persistence] .agent folder created successfully');
        } catch (createError) {
          console.error('[Persistence] Failed to create .agent folder:', createError);
          throw createError;
        }
      }
  
      // Create .agent/internal folder if needed
      const internalFolder = agentFolder + '/internal';
      console.log('[Persistence] Internal folder path:', internalFolder);
      try {
        await fileSystem.listFolder({ path: internalFolder });
        console.log('[Persistence] .agent/internal folder already exists');
      } catch (e) {
        console.log('[Persistence] Creating .agent/internal folder...');
        try {
          await fileSystem.createFolder({ path: internalFolder });
          console.log('[Persistence] .agent/internal folder created successfully');
        } catch (createError) {
          console.error('[Persistence] Failed to create .agent/internal folder:', createError);
          throw createError;
        }
      }
  
      // Set file paths
      this.conversationFilePath = internalFolder + '/conversation.jsonl';
      this.archiveFolderPath = internalFolder + '/conversation_archive';
  
      this.isInitialized = true;
      console.log('[Persistence] Initialized at:', this.conversationFilePath);
    },
  
    /**
     * Load existing conversation from disk
     * @returns {Array} Array of message objects
     */
    loadConversation: async function() {
      if (!this.isInitialized) {
        console.error('[Persistence] Not initialized');
        return [];
      }
  
      const fileSystem = window.module['file-system.js'];
  
      try {
        // Read the file
        const result = await fileSystem.readFile({ path: this.conversationFilePath });
        const content = result.content;
  
        if (!content || content.trim() === '') {
          console.log('[Persistence] No existing conversation found');
          return [];
        }
  
        // Parse JSONL (one JSON object per line)
        const lines = content.split('\n').filter(line => line.trim() !== '');
        const messages = [];
  
        for (const line of lines) {
          try {
            const msg = JSON.parse(line);
            messages.push(msg);
          } catch (e) {
            console.error('[Persistence] Failed to parse line:', e.message);
          }
        }
  
        console.log(`[Persistence] Loaded ${messages.length} messages from disk`);
  
        // Check if we need to archive old messages
        if (lines.length > 10000) {
          console.log('[Persistence] Conversation file has more than 10000 lines, archiving...');
          await this.archiveOldMessages(lines);
        }
  
        return messages;
  
      } catch (error) {
        if (error.message && error.message.includes('not found')) {
          console.log('[Persistence] No existing conversation file');
          return [];
        }
        console.error('[Persistence] Error loading conversation:', error);
        return [];
      }
    },
  
    /**
     * Archive the first 1000 lines of conversation
     * @param {Array} lines - All lines from the conversation file
     */
    archiveOldMessages: async function(lines) {
      const fileSystem = window.module['file-system.js'];
  
      // Create archive folder if needed
      try {
        await fileSystem.listFolder({ path: this.archiveFolderPath });
      } catch (e) {
        console.log('[Persistence] Creating archive folder...');
        await fileSystem.createFolder({ path: this.archiveFolderPath });
      }
  
      // Create archive file with timestamp
      const now = new Date();
      const timestamp = now.toISOString().replace(/:/g, '-').replace(/\..+/, '').replace('T', '_');
      const archiveFile = `${this.archiveFolderPath}/conversation_${timestamp}.jsonl`;
  
      // Take first 1000 lines for archive
      const toArchive = lines.slice(0, 1000);
      const remaining = lines.slice(1000);
  
      // Write archive file
      console.log(`[Persistence] Archiving ${toArchive.length} lines to ${archiveFile}`);
      await fileSystem.createFile({
        path: archiveFile,
        content: toArchive.join('\n')
      });
  
      // Rewrite main file with remaining lines
      console.log(`[Persistence] Rewriting conversation file with ${remaining.length} lines`);
      await fileSystem.createFile({
        path: this.conversationFilePath,
        content: remaining.join('\n')
      });
    },
  
    /**
     * Save a single message to disk (append to JSONL)
     * @param {Object} message - The message to save
     */
    saveMessage: async function(message) {
      if (!this.isInitialized) {
        console.error('[Persistence] Not initialized');
        return;
      }
  
      const fileSystem = window.module['file-system.js'];
  
      // Convert message to JSON line
      const line = JSON.stringify(message) + '\n';
      console.log(`[Persistence] saveMessage called - type: ${message.type}, id: ${message.id}, content length: ${message.content?.length || 0}`);
  
      try {
        // Check if file exists
        let fileExists = false;
        try {
          await fileSystem.readFile({ path: this.conversationFilePath });
          fileExists = true;
        } catch (e) {
          // File doesn't exist yet
        }
  
        if (fileExists) {
          // Append to existing file
          console.log(`[Persistence] File exists, appending message...`);
          await fileSystem.appendFile({
            path: this.conversationFilePath,
            content: line
          });
          console.log(`[Persistence] ✓ Successfully appended message to file`);
        } else {
          // Create new file
          console.log(`[Persistence] File does not exist, creating new file...`);
          await fileSystem.createFile({
            path: this.conversationFilePath,
            content: line
          });
          console.log(`[Persistence] ✓ Successfully created file with first message`);
        }
  
      } catch (error) {
        console.error('[Persistence] Error saving message:', error);
      }
    },
  
    /**
     * Clear all conversation data (useful for reset)
     */
    clearConversation: async function() {
      if (!this.isInitialized) {
        console.error('[Persistence] Not initialized');
        return;
      }
  
      const fileSystem = window.module['file-system.js'];
  
      try {
        // Overwrite with empty file
        await fileSystem.createFile({
          path: this.conversationFilePath,
          content: ''
        });
        console.log('[Persistence] Conversation cleared');
      } catch (error) {
        console.error('[Persistence] Error clearing conversation:', error);
      }
    }
  };
  

  // Module: file-system.js
  // File System Handler
  window.module['file-system.js'] = {
    directoryHandle: null,
    fileTree: [],
  
    requestDirectory: async function() {
      try {
        this.directoryHandle = await window.showDirectoryPicker();
        this.fileTree = await this.buildFileTree(this.directoryHandle);
        return true;
      } catch (err) {
        console.error('Directory access error:', err);
        return false;
      }
    },
  
    buildFileTree: async function(dirHandle, path = '') {
      const entries = [];
  
      for await (const entry of dirHandle.values()) {
        const fullPath = path ? `${path}/${entry.name}` : entry.name;
  
        if (entry.kind === 'directory') {
          const children = await this.buildFileTree(entry, fullPath);
          entries.push({
            name: entry.name,
            type: 'directory',
            path: fullPath,
            children: children,
            handle: entry
          });
        } else {
          // Read file to get character count
          let charCount = 0;
          try {
            const file = await entry.getFile();
            const text = await file.text();
            charCount = text.length;
          } catch (err) {
            console.warn('Could not read file for char count:', entry.name);
          }
  
          entries.push({
            name: entry.name,
            type: 'file',
            path: fullPath,
            handle: entry,
            charCount: charCount
          });
        }
      }
  
      return entries.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
    },
  
    readFile: async function(args) {
      // Support both old API (fileEntry object) and new API ({ path: string })
      if (args.path) {
        // New API: find file by path
        const fileEntry = this.findFileInTree(this.fileTree, args.path);
        if (!fileEntry) {
          throw new Error(`File not found: ${args.path}`);
        }
        const file = await fileEntry.handle.getFile();
        const content = await file.text();
        return { content };
      } else {
        // Old API: fileEntry object
        try {
          const file = await args.handle.getFile();
          const text = await file.text();
          return text;
        } catch (err) {
          console.error('File read error:', err);
          return null;
        }
      }
    },
  
    listFolder: async function(args) {
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      // Navigate to the target folder
      const parts = args.path.split('/').filter(p => p);
      let currentHandle = this.directoryHandle;
  
      for (const part of parts) {
        try {
          currentHandle = await currentHandle.getDirectoryHandle(part);
        } catch (err) {
          throw new Error(`Folder not found: ${args.path}`);
        }
      }
  
      // List contents
      const entries = [];
      for await (const entry of currentHandle.values()) {
        entries.push({
          name: entry.name,
          type: entry.kind
        });
      }
  
      return { entries };
    },
  
    createFile: async function(args) {
      // Support both old API (path, content) and new API ({ path, content })
      const path = args.path || args;
      const content = args.content || arguments[1] || '';
  
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      try {
        // Split path into parts
        const parts = path.split('/').filter(p => p);
        const fileName = parts.pop();
  
        // Navigate to the target directory, creating folders as needed
        let currentHandle = this.directoryHandle;
        for (const part of parts) {
          if (part) {
            currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
          }
        }
  
        // Create the file
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        // Rebuild file tree to include new file
        this.fileTree = await this.buildFileTree(this.directoryHandle);
  
        return true;
      } catch (err) {
        console.error('File create error:', err);
        throw err;
      }
    },
  
    createFolder: async function(args) {
      const path = args.path || args;
  
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      try {
        // Split path into parts
        const parts = path.split('/').filter(p => p);
  
        // Navigate/create all folders in the path
        let currentHandle = this.directoryHandle;
        for (const part of parts) {
          currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
        }
  
        // Rebuild file tree
        this.fileTree = await this.buildFileTree(this.directoryHandle);
  
        return true;
      } catch (err) {
        console.error('Folder create error:', err);
        throw err;
      }
    },
  
    appendFile: async function(args) {
      const path = args.path;
      const content = args.content;
  
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      try {
        // Split path into parts
        const parts = path.split('/').filter(p => p);
        const fileName = parts.pop();
  
        // Navigate to the target directory
        let currentHandle = this.directoryHandle;
        for (const part of parts) {
          currentHandle = await currentHandle.getDirectoryHandle(part);
        }
  
        // Get the file handle
        const fileHandle = await currentHandle.getFileHandle(fileName);
  
        // Read existing content
        const file = await fileHandle.getFile();
        const existingContent = await file.text();
  
        // Write combined content
        const writable = await fileHandle.createWritable();
        await writable.write(existingContent + content);
        await writable.close();
  
        return true;
      } catch (err) {
        console.error('File append error:', err);
        throw err;
      }
    },
  
    editFile: async function(path, oldText, newText) {
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      try {
        // Find the file in the tree
        const fileEntry = this.findFileInTree(this.fileTree, path);
        if (!fileEntry) {
          throw new Error(`File not found: ${path}`);
        }
  
        // Read current content
        const currentContent = await this.readFile(fileEntry);
        if (currentContent === null) {
          throw new Error(`Failed to read file: ${path}`);
        }
  
        // Replace old text with new text
        const newContent = currentContent.replace(oldText, newText);
  
        // Check if replacement happened
        if (newContent === currentContent) {
          throw new Error('Old text not found in file');
        }
  
        // Write new content
        const writable = await fileEntry.handle.createWritable();
        await writable.write(newContent);
        await writable.close();
  
        // Update char count in tree
        fileEntry.charCount = newContent.length;
  
        return true;
      } catch (err) {
        console.error('File edit error:', err);
        throw err;
      }
    },
  
    findFileInTree: function(tree, path) {
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'file') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFileInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    }
  };
  

  // Module: main.js
  // Main entry point
  window.module['main.js'] = {
    version: '2.0.0-alpha',
  
    run: async function() {
      console.log('Initializing API Test Interface v2.0...');
      console.log('Version:', this.version);
      console.log('Mode: Planning Mode (Execution Mode not yet implemented)');
  
      // Initialize all modules (they self-initialize when ui-manager.init() calls them)
      const uiManager = window.module['ui-manager.js'];
      uiManager.init();
  
      console.log('API Test Interface ready!');
      console.log('');
      console.log('v2.0 Features:');
      console.log('✓ New message system with types');
      console.log('✓ JSON response format with terminator');
      console.log('✓ Planning Mode with system prompt');
      console.log('✓ Tool system (list_folder, read_file)');
      console.log('✓ Message processor (parse & validate)');
      console.log('');
      console.log('TODO:');
      console.log('- Execution Mode');
      console.log('- Tool execution (create_file, edit_file)');
      console.log('- Summarization (500K limit)');
      console.log('- Partial message continuation');
      console.log('- Auto-call after tool execution');
  
      // Start keepalive mechanism - ping every 5 minutes to keep session alive
      this.startKeepalive();
    },
  
    startKeepalive: function() {
      const KEEPALIVE_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds
  
      setInterval(async () => {
        try {
          const config = window.module['config.js'];
          // Simple ping to /v1/chats/new to keep session alive
          await fetch(`${config.API_BASE}/v1/chats/new`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          console.log('[Keepalive] Session ping sent');
        } catch (error) {
          // Ignore errors - this is just a keepalive
          console.log('[Keepalive] Ping failed (ignored):', error.message);
        }
      }, KEEPALIVE_INTERVAL);
  
      console.log('[Keepalive] Started - will ping every 5 minutes');
    }
  };
  

  // Module: message-processor.js
  // Message Processor
  // Handles processing of streamed responses with = prefix (message), { prefix (tools), or ~ prefix (continuation)
  // Implements 3-layer processing: Text Trimming → JSON Repair → Validation
  window.module['message-processor.js'] = {
    TERMINATOR: '|||||END|||||',
  
    processStreamedResponse: function(rawText) {
      // Check for terminator
      if (!rawText.includes(this.TERMINATOR)) {
        return {
          complete: false,
          content: rawText,
          error: null
        };
      }
  
      // Extract content before terminator
      const terminatorIndex = rawText.indexOf(this.TERMINATOR);
      const content = rawText.substring(0, terminatorIndex);
  
      // Detect if this is a tool call by looking for the pattern: {"tools":[{"name":
      // This regex allows for whitespace and is case-sensitive
      const toolPattern = /\{\s*"tools"\s*:\s*\[\s*\{\s*"name"\s*:/;
      const isToolCall = toolPattern.test(content);
  
      if (isToolCall) {
        // Tool execution response - may have text before/after JSON, apply full 3-layer processing
        // Layer 1 will trim any text before { and after }
        return this.processTools(content);
      } else {
        // Message response - just return the text as-is
        return this.processMessage(content);
      }
    },
  
    processMessage: function(text) {
      return {
        complete: true,
        content: {
          type: 'message',
          text: text
        },
        error: null,
        systemWarning: null
      };
    },
  
    processTools: function(rawJsonText) {
      console.log('[PROCESS TOOLS] Processing tool call, length:', rawJsonText.length);
      console.log('[PROCESS TOOLS] First 200 chars:', rawJsonText.substring(0, 200));
      console.log('[PROCESS TOOLS] Last 200 chars:', rawJsonText.substring(Math.max(0, rawJsonText.length - 200)));
  
      // ===== LAYER 1: TEXT TRIMMING =====
      const trimResult = this.trimToJson(rawJsonText);
      const jsonText = trimResult.trimmed;
      const systemWarning = trimResult.systemWarning;
  
      // ===== LAYER 2: JSON PARSING & REPAIR =====
      const parseResult = this.parseAndRepairJson(jsonText);
      if (parseResult.error) {
        return {
          complete: true,
          content: null,
          error: parseResult.error,
          originalContent: rawJsonText,
          systemWarning: systemWarning
        };
      }
  
      const data = parseResult.data;
  
      // ===== LAYER 3: VALIDATION =====
      const validationResult = this.validateToolsResponse(data, jsonText);
      if (validationResult.error) {
        return {
          complete: true,
          content: null,
          error: validationResult.error,
          originalContent: rawJsonText,
          systemWarning: systemWarning
        };
      }
  
      return {
        complete: true,
        content: {
          type: 'execute',
          tools: data.tools
        },
        error: null,
        systemWarning: systemWarning
      };
    },
  
    // ===== LAYER 1: TEXT TRIMMING =====
    trimToJson: function(text) {
      console.log(`[MsgProcessor] trimToJson - input length: ${text.length}`);
      const openBrace = text.indexOf('{');
      const closeBrace = text.lastIndexOf('}');
      console.log(`[MsgProcessor] trimToJson - openBrace at: ${openBrace}, closeBrace at: ${closeBrace}`);
  
      if (openBrace === -1 || closeBrace === -1 || closeBrace < openBrace) {
        // No valid JSON structure found
        console.log(`[MsgProcessor] trimToJson - NO valid JSON structure found`);
        return {
          trimmed: text,
          systemWarning: null
        };
      }
  
      const trimmedPrefix = text.substring(0, openBrace);
      const trimmedSuffix = text.substring(closeBrace + 1);
      const jsonText = text.substring(openBrace, closeBrace + 1);
  
      // Check if anything was trimmed
      if (trimmedPrefix.length > 0 || trimmedSuffix.length > 0) {
        console.log(`[MsgProcessor] trimToJson - Trimmed ${trimmedPrefix.length} chars before, ${trimmedSuffix.length} chars after`);
        return {
          trimmed: jsonText,
          systemWarning: {
            type: 'system_warning',
            warning: `Trimmed ${trimmedPrefix.length} characters before JSON and ${trimmedSuffix.length} characters after`,
            trimmed_prefix: trimmedPrefix,
            trimmed_suffix: trimmedSuffix
          }
        };
      }
  
      console.log(`[MsgProcessor] trimToJson - No trimming needed, JSON is clean`);
      return {
        trimmed: jsonText,
        systemWarning: null
      };
    },
  
    // ===== LAYER 2: JSON PARSING & REPAIR =====
    parseAndRepairJson: function(jsonText) {
      // IMPORTANT: The AI sometimes sends JSON with literal newlines despite instructions not to
      // We need to replace literal newlines with \n escape sequences before parsing
      // But we need to be careful not to break JSON strings that legitimately contain \n
      const normalizedJson = jsonText.replace(/\n/g, '\\n').replace(/\r/g, '');
  
      let lastError = null;
  
      // Try parsing as-is first
      try {
        const data = JSON.parse(normalizedJson);
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Parsing failed, attempt repairs
      }
  
      // Repair 1: Add missing trailing }
      try {
        const withBrace = normalizedJson + '}';
        const data = JSON.parse(withBrace);
        console.log('[JSON Repair] Added missing trailing }');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Continue to next repair
      }
  
      // Repair 2: Add missing trailing ]
      try {
        const withBracket = normalizedJson + ']';
        const data = JSON.parse(withBracket);
        console.log('[JSON Repair] Added missing trailing ]');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Continue to next repair
      }
  
      // Repair 3: Add missing trailing ]}
      try {
        const withBoth = normalizedJson + ']}';
        const data = JSON.parse(withBoth);
        console.log('[JSON Repair] Added missing trailing ]}');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Continue to next repair
      }
  
      // Repair 4: Remove trailing commas
      try {
        const withoutTrailingCommas = normalizedJson
          .replace(/,(\s*[}\]])/g, '$1');  // Remove commas before closing braces/brackets
        const data = JSON.parse(withoutTrailingCommas);
        console.log('[JSON Repair] Removed trailing commas');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Continue to next repair
      }
  
      // Repair 5: Fix double-escaped backslashes (\\\\n -> \\n)
      try {
        const withFixedDoubleEscapes = normalizedJson.replace(/\\\\\\\\/g, '\\\\');
        const data = JSON.parse(withFixedDoubleEscapes);
        console.log('[JSON Repair] Fixed double-escaped backslashes');
        return { data, error: null };
      } catch (e) {
        lastError = e;
      }
  
      // Repair 6: Fix literal backslash-n that should be escaped (when \n appears as two chars)
      try {
        // Replace sequences like \n that aren't properly escaped JSON
        const withFixedLiteralBackslashN = normalizedJson.replace(/\\n/g, '\\\\n');
        const data = JSON.parse(withFixedLiteralBackslashN);
        console.log('[JSON Repair] Fixed literal backslash-n sequences');
        return { data, error: null };
      } catch (e) {
        lastError = e;
      }
  
      // Repair 7: Fix bad escape sequences near quotes
      try {
        // Sometimes continuation creates sequences like \"Line instead of \\"Line
        const withFixedEscapeQuotes = normalizedJson.replace(/\\"/g, '\\\\"');
        const data = JSON.parse(withFixedEscapeQuotes);
        console.log('[JSON Repair] Fixed escape sequences near quotes');
        return { data, error: null };
      } catch (e) {
        lastError = e;
      }
  
      // Repair 8: Try truncating at the error position and adding proper terminators
      try {
        // Extract position from error message like "at position 84175"
        const posMatch = lastError.message.match(/position (\d+)/);
        if (posMatch) {
          const errorPos = parseInt(posMatch[1]);
          // Truncate a bit before the error and try to close the JSON properly
          const truncated = normalizedJson.substring(0, Math.max(0, errorPos - 10));
  
          // Find the last complete line entry and close from there
          const lastCompleteEntry = truncated.lastIndexOf('\\n');
          if (lastCompleteEntry > 0) {
            const cleaned = truncated.substring(0, lastCompleteEntry + 2); // Include the \n
            const withProperEnd = cleaned + '"}]}';
            const data = JSON.parse(withProperEnd);
            console.log('[JSON Repair] Truncated at error position and closed JSON');
            return { data, error: null };
          }
        }
      } catch (e) {
        lastError = e;
      }
  
      // Repair 9: Fix unescaped quotes (basic attempt)
      try {
        // This is a simple heuristic - replace \" inside string values with '
        // More sophisticated repair would require proper parsing
        const withFixedQuotes = normalizedJson.replace(/"([^"]*)"([^"]*?)"/g, (match, p1, p2) => {
          if (p2.includes('"')) {
            return `"${p1}${p2.replace(/"/g, "'")}"`;
          }
          return match;
        });
        const data = JSON.parse(withFixedQuotes);
        console.log('[JSON Repair] Fixed unescaped quotes');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // All repairs failed
      }
  
      // All attempts failed
      return {
        data: null,
        error: `JSON parse error: ${lastError.message}`
      };
    },
  
    // ===== LAYER 3: VALIDATION =====
    validateToolsResponse: function(data, originalJson) {
      // Check basic structure
      if (!data || typeof data !== 'object') {
        return {
          error: 'Invalid tools response: not an object'
        };
      }
  
      if (!Array.isArray(data.tools)) {
        return {
          error: 'Invalid tools response: tools must be an array'
        };
      }
  
      if (data.tools.length === 0) {
        return {
          error: 'Invalid tools response: tools array is empty'
        };
      }
  
      // Validate each tool
      const validToolNames = [
        'list_folder',
        'read_file',
        'create_file',
        'append_file',
        'edit_file',
        'exit_planning',
        'item_completed',
        'item_failed'
      ];
  
      for (let i = 0; i < data.tools.length; i++) {
        const tool = data.tools[i];
  
        // Check tool has name
        if (!tool.name) {
          return {
            error: `Invalid tool at index ${i}: missing "name" field`
          };
        }
  
        // Check tool name is valid
        if (!validToolNames.includes(tool.name)) {
          console.log(`[VALIDATION ERROR] Invalid tool name: "${tool.name}"`);
          console.log(`[VALIDATION ERROR] Valid tools: ${validToolNames.join(', ')}`);
          console.log(`[VALIDATION ERROR] Full tool object:`, JSON.stringify(tool, null, 2));
  
          // Try to suggest similar tool names
          const suggestions = validToolNames.filter(name =>
            name.includes(tool.name) || tool.name.includes(name.replace('_', ''))
          );
          const suggestionText = suggestions.length > 0
            ? ` Did you mean: ${suggestions.join(', ')}?`
            : '';
          return {
            error: `Invalid tool name: "${tool.name}"${suggestionText}`
          };
        }
  
        // Check tool has args
        if (!tool.args || typeof tool.args !== 'object') {
          return {
            error: `Invalid tool at index ${i}: "${tool.name}" must have "args" object`
          };
        }
  
        // Validate mode-specific tool availability
        const modeValidation = this.validateToolMode(tool.name);
        if (modeValidation.error) {
          return modeValidation;
        }
      }
  
      return { error: null };
    },
  
    // Check if tool is available in current mode
    validateToolMode: function(toolName) {
      const modeManager = window.module['mode-manager.js'];
      if (!modeManager) {
        // Mode manager not available, skip validation
        return { error: null };
      }
  
      const currentMode = modeManager.getMode();
      const sharedTools = ['list_folder', 'read_file'];
      const planningOnlyTools = ['exit_planning'];
      const executionOnlyTools = ['create_file', 'append_file', 'edit_file', 'item_completed', 'item_failed'];
  
      // Check if tool is restricted to a specific mode
      if (currentMode === 'planning' && executionOnlyTools.includes(toolName)) {
        return {
          error: `Tool "${toolName}" is not available in Planning Mode. Available tools: ${sharedTools.concat(planningOnlyTools).join(', ')}`
        };
      }
  
      if (currentMode === 'execution' && planningOnlyTools.includes(toolName)) {
        return {
          error: `Tool "${toolName}" is not available in Execution Mode. Available tools: ${sharedTools.concat(executionOnlyTools).join(', ')}`
        };
      }
  
      return { error: null };
    },
  
    // Attempt to auto-close truncated JSON for create_file/append_file tools
    attemptAutoClose: function(truncatedContent) {
      // First trim to JSON (remove any text before { and after })
      const trimResult = this.trimToJson(truncatedContent);
      let jsonText = trimResult.trimmed;
  
      // Try adding closing characters in this order:
      const closingPatterns = [
        '"}}]}',     // Most common: close string, close args object, close tool object, close tools array
        '}}]}',      // If string was already closed
        '"}}]}}',    // If inside exit_planning checklist
        '}]}',       // If both string and args were closed
        '"]}}]}',    // If cut off in middle of array
        '"}]}}]}'    // Complex nested case
      ];
  
      for (const closing of closingPatterns) {
        const attempt = jsonText + closing;
        const parseResult = this.parseAndRepairJson(attempt);
  
        if (parseResult.data && !parseResult.error) {
          // Successfully parsed! Validate it has the right structure
          if (parseResult.data.tools && Array.isArray(parseResult.data.tools) && parseResult.data.tools.length > 0) {
            console.log(`[Auto-close] Successfully closed JSON with pattern: ${closing}`);
            return {
              success: true,
              tools: parseResult.data.tools
            };
          }
        }
      }
  
      // Could not auto-close
      console.log('[Auto-close] Failed to auto-close JSON with any pattern');
      return {
        success: false,
        tools: null
      };
    }
  };
  

  // Module: mode-manager.js
  // Mode Manager
  // Manages mode state, transitions, and prompt selection
  window.module['mode-manager.js'] = {
    state: {
      mode: 'planning', // Always start in planning mode
      checklist: [],
      current_item_index: 0
    },
  
    init: function() {
      this.state = {
        mode: 'planning',
        checklist: [],
        current_item_index: 0
      };
    },
  
    getMode: function() {
      return this.state.mode;
    },
  
    getSystemPrompt: function() {
      if (this.state.mode === 'planning') {
        return this.getPlanningModePrompt();
      } else {
        return this.getExecutionModePrompt();
      }
    },
  
    getPlanningModePrompt: function() {
      return `<system-reminder>
  You are a helpful AI coding assistant in PLANNING MODE.
  
  ⚠️ CRITICAL: When outputting JSON for tool calls, you MUST write it as a SINGLE CONTINUOUS LINE with NO line breaks, NO indentation, NO formatting. Do NOT press Enter/Return anywhere inside the JSON. Use \\n for newlines in string values.
  
  Your goal is to understand what the user wants to accomplish through conversation.
  
  ## What you should do:
  
  1. Ask clarifying questions about the task
  2. Explore the codebase using list_folder and read_file (as many files as needed)
  3. Understand the current state and requirements
  4. When ready to make CHANGES, create a checklist and exit to execution mode
  
  IMPORTANT: You can read as many files as you want in planning mode. Only exit to execution mode when you need to CREATE or MODIFY files. Reading is part of planning.
  
  ## Response Format
  
  ALL responses must end with |||||END|||||
  
  Two response types in planning mode:
  
  ### 1. Message Response
  When you want to ask questions or discuss:
  
  Your message to the user here. Can be multiple lines.
  You can include newlines and formatting.|||||END|||||
  
  ### 2. Tool Execution
  When you need to use tools, provide valid JSON:
  
  {"tools":[{"name":"list_folder","args":{"path":"src/"}},{"name":"read_file","args":{"path":"src/main.js"}}]}|||||END|||||
  
  CRITICAL RULES FOR TOOL USE:
  1. ALL JSON must be on a SINGLE line. NO literal line breaks anywhere in the JSON.
  2. For newlines within JSON string values, use \\n (backslash-n), never press Enter/Return.
  3. Example CORRECT: {"long_desc":"Line 1\\nLine 2\\nLine 3"}
  4. Example WRONG: {"long_desc":"Line 1
  Line 2"}  ← Literal line break breaks JSON!
  5. You can include explanatory text before the JSON if needed, the system will extract the JSON automatically.
  
  ## Available Tools in Planning Mode
  
  ⚠️ ONLY THESE 3 TOOLS ARE AVAILABLE IN PLANNING MODE:
  - list_folder: Explore directories (non-recursive)
  - read_file: Read file contents
  - exit_planning: Exit planning with checklist
  
  ❌ File creation and modification tools are NOT available in planning mode!
  
  If the user asks you to create or modify files, you MUST:
  1. Call exit_planning with a checklist
  2. The system will switch you to execution mode
  3. Then you can use file operation tools
  
  Example exit_planning:
  {"tools":[{"name":"exit_planning","args":{"checklist":[{"short_desc":"Brief description for UI","long_desc":"Detailed description for execution. Use \\n for line breaks in long_desc."}]}}]}|||||END|||||
  
  ## Rules
  
  1. Be conversational and ask questions when requirements are unclear
  2. Don't start implementing until you call exit_planning
  3. If user asks to create/modify files, immediately call exit_planning - do NOT try to use file operation tools in planning mode
  4. Break down complex tasks into discrete checklist items
  5. Each checklist item should be independently verifiable
  6. Keep short_desc concise (for UI display)
  7. Make long_desc detailed (for execution context)
  8. **ACTION OVER ANNOUNCEMENT**: When you need to use tools, just use them immediately. Don't send a message saying "Let me check..." or "I'll read..." - just execute the tools. The user will see the tool results.
  
  </system-reminder>`;
    },
  
    getExecutionModePrompt: function() {
      // TODO: Implement execution mode
      const currentItem = this.state.checklist[this.state.current_item_index];
      const taskDesc = currentItem ? currentItem.long_desc : 'No task assigned';
  
      return `<system-reminder>
  You are a helpful AI coding assistant in EXECUTION MODE.
  
  ⚠️ CRITICAL: When outputting JSON for tool calls, you MUST write it as a SINGLE CONTINUOUS LINE with NO line breaks, NO indentation, NO formatting. Do NOT press Enter/Return anywhere inside the JSON. Use \\n for newlines in string values.
  
  Your ONLY job is to complete the current checklist item.
  
  ## Current Task
  
  ${taskDesc}
  
  ## What you should do:
  
  1. Focus ONLY on this task
  2. Use file operations as needed
  3. When finished, call item_completed
  4. If you can't complete it, call item_failed with a reason
  
  ## Response Format
  
  ALL responses must end with |||||END|||||
  
  Two response types:
  
  ### 1. Message Response
  Send a message to the user:
  
  Task completed successfully.|||||END|||||
  
  ### 2. Tool Execution
  Provide valid JSON:
  
  {"tools":[{"name":"create_file","args":{"path":"src/new.js","content":"console.log('hello');"}}]}|||||END|||||
  
  IMPORTANT JSON FORMATTING:
  - CRITICAL: ALL JSON must be on a SINGLE line. NO literal line breaks anywhere in the JSON.
  - For newlines within JSON string values, use \\n (backslash-n), never press Enter/Return.
  - For file content with multiple lines, use \\n between lines.
  - Example CORRECT: {"content":"line1\\nline2\\nline3"}
  - Example WRONG: {"content":"line1
  line2"}  ← This breaks JSON parsing!
  - You can include explanatory text before the JSON if needed, the system will extract the JSON automatically.
  
  ## Available Tools in Execution Mode
  
  ### list_folder
  Explore directory contents (non-recursive).
  Args: { "path": "folder/path" }  // Use "." for root
  Returns: List of files and folders with types and sizes
  
  ### read_file
  Read file contents.
  Args: { "path": "file/path.js" }
  Returns: File content as text
  
  ### create_file
  Create a new file with content.
  Args: { "path": "new/file.js", "content": "file content here" }
  Note: Use \\n for newlines in content
  
  ### edit_file
  Edit existing file by replacing text.
  Args: { "path": "file.js", "old_text": "exact text to find", "new_text": "replacement text" }
  CRITICAL: old_text must match EXACTLY (including whitespace, indentation, newlines)
  Only replaces first occurrence. For multiple edits, use multiple edit_file calls.
  
  ### append_file
  Append content to end of existing file (RARELY USED - see below).
  Args: { "path": "file.js", "content": "content to append" }
  
  ### item_completed
  Mark current task as completed.
  Args: { "reason": "optional completion note" }
  
  ### item_failed
  Mark current task as failed, returns to planning mode.
  Args: { "reason": "why task failed" }
  
  ## CRITICAL: When to use append_file vs edit_file
  
  ⚠️ **append_file is ONLY for these specific cases:**
  1. Adding content to a file YOU JUST CREATED in the same conversation that was truncated due to size limits
  2. Appending to log files or data files where order matters
  3. The user explicitly asks you to append to a file
  
  ⚠️ **For ALL code modifications, use edit_file:**
  - Adding methods to a class → use edit_file
  - Adding functions to a module → use edit_file
  - Adding imports → use edit_file
  - Adding test cases → use edit_file
  - ANY change to existing code structure → use edit_file
  
  **Why?** append_file literally adds to the END of the file. This will place code OUTSIDE class definitions, AFTER closing braces, and break the file structure. Always use edit_file to insert code at the correct location.
  
  ## File Size Handling
  
  - For NEW files >30K chars: use create_file for first chunk, then append_file for additional chunks
  - If your tool call gets truncated due to size, the system will auto-complete and tell you to use append_file to continue
  - For edit_file: if edit is too large and gets truncated, resend with smaller changes
  
  ## Rules
  
  1. Focus ONLY on the current task
  2. Don't try to complete other checklist items
  3. Be concise in execution mode
  4. Always call item_completed or item_failed when done
  5. If uncertain or blocked, call item_failed to return to planning
  
  </system-reminder>`;
    },
  
    transitionToExecution: function(checklist) {
      this.state.mode = 'execution';
      this.state.checklist = checklist;
      this.state.current_item_index = 0;
      console.log('Transitioned to execution mode with', checklist.length, 'items');
    },
  
    transitionToPlanning: function(reason) {
      this.state.mode = 'planning';
      this.state.current_item_index = 0;
      console.log('Transitioned to planning mode:', reason);
    }
  };
  

  // Module: tool-executor.js
  // Tool Executor
  // Executes tools and returns results
  window.module['tool-executor.js'] = {
    // Define tool availability by mode
    PLANNING_TOOLS: ['list_folder', 'read_file', 'exit_planning'],
    EXECUTION_TOOLS: ['list_folder', 'read_file', 'create_file', 'append_file', 'edit_file', 'item_completed', 'item_failed'],
  
    executeTools: async function(tools) {
      const results = [];
  
      // Execute tools sequentially
      for (let i = 0; i < tools.length; i++) {
        const tool = tools[i];
        const result = await this.executeTool(tool);
  
        results.push(result);
  
        // Stop on first error
        if (!result.success) {
          break;
        }
      }
  
      return results;
    },
  
    validateToolAvailability: function(toolName) {
      const modeManager = window.module['mode-manager.js'];
      const currentMode = modeManager.getMode();
  
      const allowedTools = currentMode === 'planning' ? this.PLANNING_TOOLS : this.EXECUTION_TOOLS;
  
      if (!allowedTools.includes(toolName)) {
        const modeLabel = currentMode === 'planning' ? 'Planning' : 'Execution';
        return {
          valid: false,
          error: `Tool '${toolName}' is not available in ${modeLabel} Mode. Available tools: ${allowedTools.join(', ')}`
        };
      }
  
      return { valid: true };
    },
  
    executeTool: async function(tool) {
      const fileSystem = window.module['file-system.js'];
  
      // Validate tool availability in current mode
      const validation = this.validateToolAvailability(tool.name);
      if (!validation.valid) {
        return {
          tool: tool.name,
          success: false,
          error: validation.error,
          args: tool.args
        };
      }
  
      try {
        switch (tool.name) {
          case 'list_folder':
            return await this.listFolder(tool.args);
  
          case 'read_file':
            return await this.readFile(tool.args);
  
          case 'create_file':
            return await this.createFile(tool.args);
  
          case 'append_file':
            return await this.appendFile(tool.args);
  
          case 'edit_file':
            return await this.editFile(tool.args);
  
          case 'exit_planning':
            return await this.exitPlanning(tool.args);
  
          case 'item_completed':
            return await this.itemCompleted(tool.args);
  
          case 'item_failed':
            return await this.itemFailed(tool.args);
  
          default:
            return {
              tool: tool.name,
              success: false,
              error: `Unknown tool: ${tool.name}`,
              args: tool.args
            };
        }
      } catch (error) {
        return {
          tool: tool.name,
          success: false,
          error: error.message,
          args: tool.args
        };
      }
    },
  
    listFolder: async function(args) {
      console.log(`[ToolExec] listFolder called with path: "${args.path}"`);
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        console.log(`[ToolExec] listFolder ERROR - no directory handle`);
        return {
          tool: 'list_folder',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the folder in the file tree
      const folder = this.findFolderInTree(fileSystem.fileTree, args.path);
      console.log(`[ToolExec] findFolderInTree result:`, folder ? `found, ${folder.children?.length || 0} children` : 'NOT FOUND');
  
      if (!folder) {
        console.log(`[ToolExec] listFolder ERROR - folder not found: ${args.path}`);
        return {
          tool: 'list_folder',
          success: false,
          error: `Directory not found: ${args.path}`,
          args: args
        };
      }
  
      // Return children
      const entries = folder.children.map(child => ({
        name: child.name,
        type: child.type,
        size_bytes: child.type === 'file' ? child.charCount : 0
      }));
  
      console.log(`[ToolExec] listFolder SUCCESS - returning ${entries.length} entries`);
      return {
        tool: 'list_folder',
        success: true,
        result: { entries: entries }, // IMPORTANT: Wrap in { entries: ... } object
        args: args
      };
    },
  
    readFile: async function(args) {
      console.log(`[ToolExec] readFile called with path: "${args.path}"`);
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        console.log(`[ToolExec] readFile ERROR - no directory handle`);
        return {
          tool: 'read_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the file in the file tree
      const file = this.findFileInTree(fileSystem.fileTree, args.path);
      if (!file) {
        console.log(`[ToolExec] readFile ERROR - file not found: ${args.path}`);
        return {
          tool: 'read_file',
          success: false,
          error: `File not found: ${args.path}`,
          args: args
        };
      }
  
      // Read the file
      const fileResult = await fileSystem.readFile(file);
      if (fileResult === null) {
        console.log(`[ToolExec] readFile ERROR - failed to read file: ${args.path}`);
        return {
          tool: 'read_file',
          success: false,
          error: `Failed to read file: ${args.path}`,
          args: args
        };
      }
  
      // fileSystem.readFile returns { content: "..." } so extract the content
      const content = typeof fileResult === 'string' ? fileResult : fileResult.content;
      console.log(`[ToolExec] readFile SUCCESS - read ${content.length} chars from ${args.path}`);
  
      // TODO: Handle start_line and end_line parameters
      return {
        tool: 'read_file',
        success: true,
        result: { content: content }, // IMPORTANT: Wrap in { content: ... } object
        args: args
      };
    },
  
    findFolderInTree: function(tree, path) {
      if (!path || path === '' || path === '.') {
        return { children: tree };
      }
  
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'directory') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFolderInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    },
  
    findFileInTree: function(tree, path) {
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'file') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFileInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    },
  
    createFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'create_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      if (!args.path) {
        return {
          tool: 'create_file',
          success: false,
          error: 'Missing required argument: path',
          args: args
        };
      }
  
      if (!args.content && args.content !== '') {
        return {
          tool: 'create_file',
          success: false,
          error: 'Missing required argument: content',
          args: args
        };
      }
  
      try {
        await fileSystem.createFile(args.path, args.content);
  
        return {
          tool: 'create_file',
          success: true,
          result: {
            path: args.path,
            size_bytes: args.content.length,
            message: `Created ${args.path} with ${args.content.length} chars.`
          },
          args: args
        };
      } catch (error) {
        return {
          tool: 'create_file',
          success: false,
          error: error.message,
          args: args
        };
      }
    },
  
    appendFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'append_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      if (!args.path) {
        return {
          tool: 'append_file',
          success: false,
          error: 'Missing required argument: path',
          args: args
        };
      }
  
      if (!args.content && args.content !== '') {
        return {
          tool: 'append_file',
          success: false,
          error: 'Missing required argument: content',
          args: args
        };
      }
  
      try {
        await fileSystem.appendFile(args);
  
        // Check for continue flag
        const hasContinue = args.continue === true;
        const message = hasContinue
          ? `Appended ${args.content.length} chars to ${args.path}. Continue with next chunk.`
          : `Appended ${args.content.length} chars to ${args.path}. File complete.`;
  
        return {
          tool: 'append_file',
          success: true,
          result: {
            path: args.path,
            appended_bytes: args.content.length,
            continue_expected: hasContinue,
            message: message
          },
          args: args
        };
      } catch (error) {
        return {
          tool: 'append_file',
          success: false,
          error: error.message,
          args: args
        };
      }
    },
  
    editFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      if (!args.path) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: path',
          args: args
        };
      }
  
      if (!args.old_text) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: old_text',
          args: args
        };
      }
  
      if (!args.new_text && args.new_text !== '') {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: new_text',
          args: args
        };
      }
  
      try {
        await fileSystem.editFile(args.path, args.old_text, args.new_text);
        return {
          tool: 'edit_file',
          success: true,
          result: { path: args.path },
          args: args
        };
      } catch (error) {
        return {
          tool: 'edit_file',
          success: false,
          error: error.message,
          args: args
        };
      }
    },
  
    exitPlanning: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (!args.checklist || !Array.isArray(args.checklist)) {
        return {
          tool: 'exit_planning',
          success: false,
          error: 'Missing or invalid checklist argument',
          args: args
        };
      }
  
      // Validate checklist items
      for (let i = 0; i < args.checklist.length; i++) {
        const item = args.checklist[i];
        if (!item.short_desc || !item.long_desc) {
          return {
            tool: 'exit_planning',
            success: false,
            error: `Checklist item ${i} missing short_desc or long_desc`,
            args: args
          };
        }
      }
  
      // Transition to execution mode
      modeManager.transitionToExecution(args.checklist);
  
      return {
        tool: 'exit_planning',
        success: true,
        result: {
          mode: 'execution',
          checklist_items: args.checklist.length,
          current_item: 0,
          checklist: args.checklist
        },
        args: args
      };
    },
  
    itemCompleted: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (modeManager.getMode() !== 'execution') {
        return {
          tool: 'item_completed',
          success: false,
          error: 'Not in execution mode',
          args: args
        };
      }
  
      const currentIndex = modeManager.state.current_item_index;
      const totalItems = modeManager.state.checklist.length;
  
      // Move to next item or return to planning
      if (currentIndex + 1 < totalItems) {
        modeManager.state.current_item_index++;
        return {
          tool: 'item_completed',
          success: true,
          result: {
            completed_item: currentIndex,
            next_item: currentIndex + 1,
            remaining: totalItems - (currentIndex + 1),
            checklist: modeManager.state.checklist
          },
          args: args
        };
      } else {
        // All items complete, return to planning
        modeManager.transitionToPlanning('All checklist items completed');
        return {
          tool: 'item_completed',
          success: true,
          result: {
            completed_item: currentIndex,
            all_complete: true,
            mode: 'planning',
            checklist: modeManager.state.checklist
          },
          args: args
        };
      }
    },
  
    itemFailed: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (modeManager.getMode() !== 'execution') {
        return {
          tool: 'item_failed',
          success: false,
          error: 'Not in execution mode',
          args: args
        };
      }
  
      // Return to planning mode
      const currentIndex = modeManager.state.current_item_index;
      const checklist = modeManager.state.checklist;
      const reason = args.reason || 'Task failed';
      modeManager.transitionToPlanning(reason);
  
      return {
        tool: 'item_failed',
        success: true,
        result: {
          mode: 'planning',
          reason: reason,
          failed_item: currentIndex,
          checklist: checklist
        },
        args: args
      };
    }
  };
  

  // Module: ui-manager.js
  // UI Manager v2.0
  // Coordinates UI rendering and handles user interactions
  window.module['ui-manager.js'] = {
    // Track cancellation state
    cancelRequested: false,
    isProcessing: false,
  
    init: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const modeManager = window.module['mode-manager.js'];
      const apiClient = window.module['api-client.js'];
  
      conversationManager.init();
      modeManager.init();
      apiClient.init();
  
      this.showIntroScreen();
    },
  
    showIntroScreen: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Create intro container
      const container = document.createElement('div');
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
  
      const content = document.createElement('div');
      content.style.cssText = `
        text-align: center;
        max-width: 500px;
        padding: 40px;
      `;
  
      content.innerHTML = `
        <h1 style="font-size: 32px; margin-bottom: 16px; font-weight: 600;">
          API Test Interface v2.0
        </h1>
        <p style="font-size: 16px; color: #858585; margin-bottom: 32px;">
          Planning Mode • AI-Driven Development
        </p>
        <p style="font-size: 14px; margin-bottom: 32px; line-height: 1.6;">
          Select a project folder to begin. The AI will use tools to explore
          and modify files as you work together.
        </p>
        <button id="selectFolderIntro" style="
          background: #0e639c;
          color: white;
          border: none;
          padding: 12px 32px;
          border-radius: 3px;
          cursor: pointer;
          font-size: 15px;
          font-weight: 500;
        ">Select Folder</button>
      `;
  
      container.appendChild(content);
      document.body.appendChild(container);
  
      document.getElementById('selectFolderIntro').addEventListener('click', () => this.selectFolderAndStart());
    },
  
    selectFolderAndStart: async function() {
      const fileSystem = window.module['file-system.js'];
      const conversationManager = window.module['conversation-manager.js'];
  
      const success = await fileSystem.requestDirectory();
  
      if (success) {
        // Use empty string as folder path since fileSystem is already at the root
        const folderPath = '';
  
        // Initialize conversation manager with folder path for persistence
        await conversationManager.init(folderPath);
  
        this.initChatUI();
      }
    },
  
    initChatUI: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Add animation styles
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulse {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 1; }
        }
      `;
      document.head.appendChild(style);
  
      // Create main container
      const container = document.createElement('div');
      container.id = 'test-interface';
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      // Chat area (full width, no header)
      const chatPanel = document.createElement('div');
      chatPanel.style.cssText = `
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      const chatArea = document.createElement('div');
      chatArea.id = 'chatArea';
      chatArea.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        padding-bottom: 140px;
      `;
      chatPanel.appendChild(chatArea);
  
      // Gradient overlay - fades chat history behind input
      const gradientOverlay = document.createElement('div');
      gradientOverlay.style.cssText = `
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 160px;
        background: linear-gradient(to bottom, transparent 0%, #1e1e1e 80%);
        pointer-events: none;
        z-index: 50;
      `;
      chatPanel.appendChild(gradientOverlay);
  
      // Input area - floats at bottom, no padding or shadow
      const inputArea = document.createElement('div');
      inputArea.style.cssText = `
        position: absolute;
        bottom: 8px;
        left: 20px;
        right: 20px;
        z-index: 60;
      `;
      inputArea.innerHTML = `
        <div style="border: 1px solid #3e3e42; border-radius: 4px; overflow: hidden;">
          <textarea id="userInput" style="
            width: 100%;
            height: 38px;
            max-height: calc(33vh);
            background: #3c3c3c;
            color: white;
            border: none;
            outline: none;
            margin: 0;
            padding: 10px;
            font-family: monospace;
            font-size: 13px;
            resize: none;
            overflow-y: auto;
            line-height: 1.4;
            display: block;
          "></textarea>
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background: #252526; border-top: 1px solid #3e3e42;">
            <span id="folderName" style="font-size: 11px; color: #858585;"></span>
            <div style="display: flex; align-items: center; gap: 8px;">
              <span id="charCount" style="font-size: 11px; color: #858585;"></span>
              <button id="menuButton" style="
                background: transparent;
                border: none;
                color: #858585;
                cursor: pointer;
                font-size: 14px;
                padding: 0 4px;
                line-height: 1;
              ">⋮</button>
            </div>
          </div>
        </div>
        <div id="errorMsg" style="margin-top: 4px; color: #f48771; font-size: 13px;"></div>
      `;
      chatPanel.appendChild(inputArea);
  
      container.appendChild(chatPanel);
      document.body.appendChild(container);
  
      // Create menu dropdown (hidden by default)
      const menuDropdown = document.createElement('div');
      menuDropdown.id = 'menuDropdown';
      menuDropdown.style.cssText = `
        position: absolute;
        bottom: 50px;
        right: 30px;
        background: #2d2d30;
        border: 1px solid #3e3e42;
        border-radius: 3px;
        padding: 4px 0;
        display: none;
        z-index: 100;
        min-width: 160px;
      `;
      menuDropdown.innerHTML = `
        <button id="clearConversationBtn" style="
          width: 100%;
          background: transparent;
          border: none;
          color: #d4d4d4;
          padding: 6px 12px;
          text-align: left;
          cursor: pointer;
          font-size: 13px;
        " onmouseover="this.style.background='#094771'" onmouseout="this.style.background='transparent'">Clear Conversation</button>
      `;
      document.body.appendChild(menuDropdown);
  
      // Event listeners
      const userInput = document.getElementById('userInput');
      const menuButton = document.getElementById('menuButton');
      const clearConversationBtn = document.getElementById('clearConversationBtn');
  
      // Auto-resize textarea as content changes
      const autoResize = () => {
        userInput.style.height = '38px'; // Reset to initial height (1 line)
        userInput.style.height = Math.min(userInput.scrollHeight, window.innerHeight / 3) + 'px';
      };
  
      userInput.addEventListener('input', autoResize);
      userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSubmit();
        } else if (e.key === 'Escape' && this.isProcessing) {
          e.preventDefault();
          this.cancelCurrentTask();
        }
        // Shift+Enter allows newline (default textarea behavior)
        // Trigger resize after key is processed
        setTimeout(autoResize, 0);
      });
  
      // Menu button click handler
      menuButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const menu = document.getElementById('menuDropdown');
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
      });
  
      // Clear conversation button
      clearConversationBtn.addEventListener('click', () => {
        if (confirm('Are you sure you want to clear the conversation? This cannot be undone.')) {
          this.clearConversation();
        }
        document.getElementById('menuDropdown').style.display = 'none';
      });
  
      // Close menu when clicking outside
      document.addEventListener('click', (e) => {
        const menu = document.getElementById('menuDropdown');
        if (menu && !menuButton.contains(e.target) && !menu.contains(e.target)) {
          menu.style.display = 'none';
        }
      });
  
      // Set folder name
      const fileSystem = window.module['file-system.js'];
      const folderNameElement = document.getElementById('folderName');
      if (fileSystem.directoryHandle) {
        folderNameElement.textContent = fileSystem.directoryHandle.name;
      }
  
      this.updateCharCounter();
  
      // Render any existing conversation messages
      this.renderChat();
    },
  
    handleSubmit: async function() {
      const input = document.getElementById('userInput');
      const content = input.value.trim();
  
      if (!content) return;
  
      // Don't allow submit while processing (unless canceling)
      if (this.isProcessing) {
        return;
      }
  
      // Clear input and reset height
      input.value = '';
      input.style.height = '38px';
  
      // Hide any previous error
      this.hideError();
  
      try {
        // Add user message (synchronous, renders immediately)
        this.addUserMessage(content);
  
        // Get AI response (starts immediately, persisting happens async in background)
        this.isProcessing = true;
        this.cancelRequested = false;
        await this.getAIResponse();
  
      } catch (error) {
        console.error('Error:', error);
        this.showError(error.message);
      } finally {
        this.isProcessing = false;
        this.cancelRequested = false;
      }
    },
  
    cancelCurrentTask: function() {
      console.log('[UI] Cancellation requested');
      this.cancelRequested = true;
      this.hideLoading();
  
      // Add a cancelled assistant message to maintain the user/assistant pattern
      const conversationManager = window.module['conversation-manager.js'];
      conversationManager.addMessage({
        type: 'assistant',
        content: '[Cancelled by user]'
      });
  
      this.renderChat();
      this.updateCharCounter();
      this.isProcessing = false;
    },
  
    addUserMessage: function(content) {
      const conversationManager = window.module['conversation-manager.js'];
  
      const userMessage = {
        type: 'user',
        content: content
      };
  
      // Add to conversation (synchronous, persists async in background)
      conversationManager.addMessage(userMessage);
  
      // Render immediately
      this.renderChat();
      this.updateCharCounter();
    },
  
    getAIResponse: async function() {
      const conversationManager = window.module['conversation-manager.js'];
      const apiRenderer = window.module['api-renderer.js'];
      const apiClient = window.module['api-client.js'];
      const messageProcessor = window.module['message-processor.js'];
      const conversationFlow = window.module['conversation-flow.js'];
      const toolExecutor = window.module['tool-executor.js'];
      const utils = window.module['utils.js'];
      const config = window.module['config.js'];
  
      // Show loading indicator
      this.showLoading('Thinking...');
  
      // Render messages for API
      const messages = conversationManager.getMessages();
      const apiMessages = apiRenderer.renderMessagesForAPI(messages);
  
      // Create chat if needed
      if (!apiClient.chatId && messages.length > 0) {
        const firstUserMsg = messages.find(m => m.type === 'user');
        if (firstUserMsg) {
          await apiClient.createNewChat(firstUserMsg.content);
        }
      }
  
      // Get completion with streaming
      const assistantMessageId = utils.generateUUID();
  
      let retryCount = 0;
      let success = false;
  
      while (retryCount < config.MAX_RETRIES && !success) {
        try {
          const response = await apiClient.getCompletion(apiMessages, assistantMessageId);
  
          // Track streaming message for real-time UI updates
          let streamingMessageId = null;
          let streamingPersistFn = null;
          let responseType = null;
  
          // Use extracted conversation-flow module
          const result = await conversationFlow.handleAIResponse(
            response,
            assistantMessageId,
            apiMessages,
            {
              onProgress: (status) => this.showLoading(status),
              onChunk: (chunk, accumulated) => {
                // Detect response type using pattern matching (not prefix-based)
                if (responseType === null && accumulated.length > 10) {
                  // Check for tool call pattern: {"tools":[{"name":
                  const toolPattern = /\{\s*"tools"\s*:\s*\[\s*\{\s*"name"\s*:/;
                  if (toolPattern.test(accumulated)) {
                    responseType = 'tools';
                  } else {
                    // Assume message if no tool pattern detected
                    responseType = 'message';
                    // Create streaming message (skip persistence until complete)
                    const result = conversationManager.addMessage({
                      type: 'assistant',
                      content: '',
                      streaming: true
                    }, true); // skipPersist = true
  
                    streamingMessageId = result.message.id;
                    streamingPersistFn = result.persist; // Save persist function for later
                  }
                }
  
                // Update streaming message in real-time
                if (responseType === 'message' && streamingMessageId) {
                  // Extract content (trim before terminator if present)
                  let messageContent = accumulated;
                  const terminatorIndex = messageContent.indexOf(messageProcessor.TERMINATOR);
                  if (terminatorIndex !== -1) {
                    messageContent = messageContent.substring(0, terminatorIndex);
                  }
  
                  const msgs = conversationManager.getMessages();
                  const streamingMsg = msgs.find(m => m.id === streamingMessageId);
                  if (streamingMsg) {
                    streamingMsg.content = messageContent;
                    this.renderChat();
                    this.updateCharCounter();
                  }
                }
              }
            }
          );
  
          // Handle the result
          if (result.success) {
            const aiResponse = result.content;
  
            if (aiResponse.type === 'message') {
              // Message was already streamed, just mark as complete
              if (streamingMessageId && streamingPersistFn) {
                const msgs = conversationManager.getMessages();
                const streamingMsg = msgs.find(m => m.id === streamingMessageId);
                if (streamingMsg) {
                  streamingMsg.streaming = false;
                  streamingMsg.content = aiResponse.text;
  
                  // Now persist the completed message
                  streamingPersistFn();
                }
              } else {
                // Fallback: add message if streaming didn't work
                conversationManager.addMessage({
                  type: 'assistant',
                  content: aiResponse.text
                });
              }
              this.renderChat();
              this.updateCharCounter();
              this.hideLoading();
              success = true;
  
            } else if (aiResponse.type === 'execute') {
              // Tool execution - create ONE tool_use message with ALL tools
              const { message: toolUseMessage } = conversationManager.addMessage({
                type: 'tool_use',
                tools: aiResponse.tools
              });
  
              this.renderChat();
              this.updateCharCounter();
  
              // Execute tools sequentially, creating individual tool_result messages
              for (const tool of aiResponse.tools) {
                // Check for cancellation before each tool execution
                if (this.cancelRequested) {
                  console.log('[UI] Tool execution cancelled');
                  this.hideLoading();
                  return;
                }
  
                this.showLoading(`Executing ${tool.name}...`);
  
                const toolResults = await toolExecutor.executeTools([tool]);
                const toolResult = toolResults[0];
  
                conversationManager.addMessage({
                  type: 'tool_result',
                  parentId: toolUseMessage.id,
                  tool: toolResult.tool,
                  success: toolResult.success,
                  result: toolResult.result,
                  error: toolResult.error,
                  args: toolResult.args
                });
  
                this.renderChat();
                this.updateCharCounter();
              }
  
              this.hideLoading();
  
              // Check for cancellation before auto-calling AI again
              if (this.cancelRequested) {
                console.log('[UI] Auto-call cancelled after tool execution');
                return;
              }
  
              // Auto-call API again to let AI respond to tool results
              await this.getAIResponse();
              success = true;
            }
  
          } else if (result.cancelled) {
            // User cancelled - don't continue, don't throw error
            console.log('[UI] Cancellation detected in result, calling cancelCurrentTask');
            this.cancelCurrentTask();
            return;
  
          } else if (result.needsRetry) {
            // Error already added to conversation by conversation-flow
            this.renderChat();
            this.updateCharCounter();
  
            // Call AI again so it can see the error and fix it
            console.log('Error detected, calling AI again with error context');
            await this.getAIResponse();
            return;
  
          } else {
            // Fatal error
            console.error('Fatal error:', result.error);
            this.hideLoading();
            throw new Error(result.error);
          }
  
        } catch (error) {
          retryCount++;
          console.warn(`Attempt ${retryCount} failed:`, error.message);
  
          if (retryCount >= config.MAX_RETRIES) {
            this.hideLoading();
            throw error;
          }
  
          // Wait 1 second before retry
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
  
      this.hideLoading();
      this.updateCharCounter();
    },
  
    renderChat: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const uiRenderer = window.module['ui-renderer.js'];
      const chatArea = document.getElementById('chatArea');
  
      // Check if user is near bottom before re-rendering (within 100px)
      const wasNearBottom = chatArea.scrollHeight - chatArea.scrollTop - chatArea.clientHeight < 100;
  
      chatArea.innerHTML = '';
  
      const messages = conversationManager.getMessages();
  
      // Store messages in ui-renderer for tool_use/result lookups
      uiRenderer.allMessages = messages;
  
      messages.forEach(msg => {
        const msgElement = uiRenderer.renderMessage(msg);
        chatArea.appendChild(msgElement);
      });
  
      // Only auto-scroll if user was already near the bottom
      if (wasNearBottom) {
        chatArea.scrollTop = chatArea.scrollHeight;
      }
    },
  
    updateCharCounter: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
      const charCount = document.getElementById('charCount');
  
      const total = conversationManager.getTotalCharacterCount();
      charCount.textContent = `Total: ${utils.formatCharCount(total)}`;
    },
  
    showError: function(message) {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = message;
    },
  
    hideError: function() {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = '';
    },
  
    showLoading: function(text = 'Processing...') {
      const chatArea = document.getElementById('chatArea');
      if (!chatArea) return;
  
      // Remove any existing loading message
      const existing = document.getElementById('loading-message');
      if (existing) {
        existing.remove();
      }
  
      // Create loading pseudo-message
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'loading-message';
      loadingDiv.style.cssText = 'display: flex; gap: 12px; margin-bottom: 4px; align-items: flex-start; font-family: monospace; font-size: 13px;';
  
      // Gray circle indicator that pulses
      const indicator = document.createElement('div');
      indicator.style.cssText = 'width: 8px; height: 8px; border-radius: 50%; margin-top: 6px; flex-shrink: 0; background: #858585; animation: pulse 1.5s ease-in-out infinite;';
  
      // Text content
      const content = document.createElement('div');
      content.style.cssText = 'flex: 1; min-width: 0; color: #858585; padding: 2px 0;';
      content.textContent = text;
  
      loadingDiv.appendChild(indicator);
      loadingDiv.appendChild(content);
      chatArea.appendChild(loadingDiv);
  
      // Scroll to bottom
      chatArea.scrollTop = chatArea.scrollHeight;
    },
  
    hideLoading: function() {
      const loadingMessage = document.getElementById('loading-message');
      if (loadingMessage) {
        loadingMessage.remove();
      }
    },
  
    clearConversation: async function() {
      const conversationManager = window.module['conversation-manager.js'];
      const conversationPersistence = window.module['conversation-persistence.js'];
      const apiClient = window.module['api-client.js'];
  
      // Clear in-memory conversation
      conversationManager.messages = [];
  
      // Clear persistence file
      if (conversationPersistence.isInitialized) {
        await conversationPersistence.clearConversation();
      }
  
      // Reset chat ID so new conversation starts fresh
      apiClient.chatId = null;
  
      // Hide any loading indicators
      this.hideLoading();
  
      // Clear UI
      this.renderChat();
      this.updateCharCounter();
  
      console.log('[UI] Conversation cleared');
    }
  };
  

  // Module: ui-renderer.js
  // UI Renderer v3.0
  // Clean design with status indicators in gutter
  window.module['ui-renderer.js'] = {
    allMessages: [], // Store reference to all messages for lookups
    expandedSummaries: new Set(), // Track which summaries are expanded
  
    renderMessage: function(message) {
      console.log(`[UIRenderer] Rendering message - type: ${message.type}, id: ${message.id}`);
      const container = document.createElement('div');
      container.style.cssText = 'display: flex; gap: 12px; margin-bottom: 4px; align-items: flex-start; font-family: monospace; font-size: 13px;';
  
      // Create gutter indicator
      const indicator = document.createElement('div');
      indicator.style.cssText = 'width: 8px; height: 8px; border-radius: 50%; margin-top: 6px; flex-shrink: 0;';
  
      // Create content area
      const content = document.createElement('div');
      content.style.cssText = 'flex: 1; min-width: 0;';
  
      if (message.type === 'user') {
        // Gray background with white text for user messages
        indicator.style.display = 'none'; // No indicator for user messages
        content.style.cssText += 'background: #3c3c3c; color: white; padding: 8px 12px; border-radius: 4px;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.content;
  
      } else if (message.type === 'assistant') {
        // White circle indicator, no background
        indicator.style.backgroundColor = 'white';
        content.style.cssText += 'color: #d4d4d4; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.content;
  
      } else if (message.type === 'tool_use') {
        // Don't show tool_use messages - we'll show the individual tool results instead
        // This eliminates the "3 tools (List Folder, List Folder, List Folder)" line
        container.style.display = 'none';
  
      } else if (message.type === 'tool_result') {
        // Special rendering for checklist tools
        if (message.tool === 'exit_planning' || message.tool === 'item_completed' || message.tool === 'item_failed') {
          // Hide indicator for these special tools - we'll show checklist card instead
          indicator.style.display = 'none';
  
          if (message.result && message.result.checklist) {
            // Create a checklist card with min-width to fit content
            content.style.cssText += 'padding: 0; margin-left: -20px;';
            content.innerHTML = this.renderChecklistCard(
              message.result.checklist,
              message.result.completed_item,
              message.result.failed_item,
              message.tool
            );
          } else {
            content.style.cssText += 'color: #858585; padding: 2px 0; padding-left: 20px;';
            content.textContent = this.formatToolResult(message);
          }
        } else {
          // Normal tool results - show green/red indicator
          indicator.style.backgroundColor = message.success ? '#4ec9b0' : '#f48771'; // Green or red
          content.style.cssText += 'color: #858585; padding: 2px 0; cursor: pointer; white-space: pre-wrap;';
          content.textContent = this.formatToolResult(message);
          content.addEventListener('click', () => this.showToolModal(`Tool Result: ${message.tool}`, message.result));
        }
  
      } else if (message.type === 'system_error') {
        indicator.style.backgroundColor = '#f48771'; // Red
        content.style.cssText += 'color: #f48771; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = `Error: ${message.error}`;
  
      } else if (message.type === 'system_warning') {
        indicator.style.backgroundColor = '#dcdcaa'; // Yellow
        content.style.cssText += 'color: #dcdcaa; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.warning;
  
      } else if (message.type === 'summary') {
        // Yellow indicator for summary
        indicator.style.backgroundColor = '#dcdcaa'; // Yellow
        content.style.cssText += 'color: #858585; padding: 2px 0; cursor: pointer;';
  
        // Create collapsed summary view
        const summaryId = 'summary-' + message.id;
        const isExpanded = this.expandedSummaries && this.expandedSummaries.has(message.id);
  
        // Log summary rendering info
        console.log(`[UIRenderer] Rendering summary - id: ${message.id}, summarizes_from: ${message.summarizes_from}, summarizes_to: ${message.summarizes_to}, isExpanded: ${isExpanded}`);
  
        // Calculate message count - check if summarizes_from and summarizes_to exist
        const messageCount = (message.summarizes_to !== undefined && message.summarizes_from !== undefined)
          ? (message.summarizes_to - message.summarizes_from + 1)
          : 'N/A';
  
        if (isExpanded) {
          content.innerHTML = `<div style="font-weight: bold; margin-bottom: 4px;">📋 Summary (summarizes ${messageCount} messages) [Click to collapse]</div><div style="white-space: pre-wrap;">${this.escapeHtml(message.content)}</div>`;
        } else {
          content.innerHTML = `<div style="font-weight: bold;">📋 Summary (summarizes ${messageCount} messages) [Click to expand]</div>`;
        }
  
        content.addEventListener('click', () => this.toggleSummary(message.id));
  
      } else if (message.type === 'partial') {
        // White circle indicator for partial (like assistant)
        indicator.style.backgroundColor = 'white';
        content.style.cssText += 'color: #d4d4d4; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
  
        // Show streaming indicator if incomplete
        if (message.completion === false) {
          content.innerHTML = `${this.escapeHtml(message.content)}<span style="color: #858585; font-style: italic;"> (streaming...)</span>`;
        } else {
          content.textContent = message.content;
        }
  
      } else {
        // Unknown type
        indicator.style.backgroundColor = '#858585';
        content.style.cssText += 'color: #858585; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = JSON.stringify(message, null, 2);
      }
  
      container.appendChild(indicator);
      container.appendChild(content);
      return container;
    },
  
    findToolResult: function(toolUseId) {
      // Look through all messages to find tool_result with matching parentId
      for (const msg of this.allMessages) {
        if (msg.type === 'tool_result' && msg.parentId === toolUseId) {
          return msg;
        }
      }
      return null;
    },
  
    escapeHtml: function(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    },
  
    formatToolName: function(name) {
      // Convert snake_case to Title Case
      return name.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
    },
  
    formatToolParams: function(toolName, args) {
      // Format parameters based on tool type
      if (toolName === 'read_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'list_folder') {
        return this.escapeHtml(args.path || '.');
      } else if (toolName === 'create_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'edit_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'exit_planning') {
        const count = args.checklist ? args.checklist.length : 0;
        return `${count} item${count !== 1 ? 's' : ''}`;
      } else if (toolName === 'item_completed' || toolName === 'item_failed') {
        return args.reason ? this.escapeHtml(args.reason) : '';
      } else {
        // Generic fallback - show all args
        return this.escapeHtml(JSON.stringify(args));
      }
    },
  
    formatToolResult: function(message) {
      console.log(`[UIRenderer] Formatting tool result - tool: ${message.tool}, success: ${message.success}`);
      if (!message.success) {
        return `Error: ${message.error}`;
      }
  
      const result = message.result;
      const args = message.args || {};
      console.log(`[UIRenderer] Tool result content:`, result);
  
      // Format based on tool type
      if (message.tool === 'read_file') {
        const path = args.path || '';
        if (result.content) {
          const lines = result.content.split('\n').length;
          return `Read ${path}\n${lines} line${lines !== 1 ? 's' : ''} read`;
        }
        return `Read ${path}`;
      } else if (message.tool === 'list_folder') {
        const path = args.path || '.';
        if (result.entries) {
          const count = result.entries.length;
          console.log(`[UIRenderer] list_folder result has ${count} entries`);
          return `List ${path}\n${count} item${count !== 1 ? 's' : ''} found`;
        }
        console.log(`[UIRenderer] list_folder result has NO entries property`);
        return `List ${path}`;
      } else if (message.tool === 'create_file') {
        const path = args.path || '';
        return `Created ${path}`;
      } else if (message.tool === 'edit_file') {
        const path = args.path || '';
        return `Edited ${path}`;
      } else if (message.tool === 'append_file') {
        const path = args.path || '';
        return `Appended to ${path}`;
      } else if (message.tool === 'exit_planning') {
        return 'Entering execution mode';
      } else if (message.tool === 'item_completed') {
        return 'Task completed';
      } else if (message.tool === 'item_failed') {
        return 'Task failed';
      } else {
        // Generic fallback
        return JSON.stringify(result);
      }
    },
  
    renderChecklist: function(checklist, completedIndex, failedIndex) {
      if (!checklist || !Array.isArray(checklist)) {
        return 'Invalid checklist';
      }
  
      const items = checklist.map((item, index) => {
        let statusIcon = '○'; // Pending
        let color = '#858585'; // Gray
  
        if (completedIndex !== undefined && index <= completedIndex) {
          statusIcon = '✓'; // Completed
          color = '#4ec9b0'; // Green
        } else if (failedIndex !== undefined && index === failedIndex) {
          statusIcon = '✗'; // Failed
          color = '#f48771'; // Red
        }
  
        return `<div style="color: ${color}; margin-bottom: 2px;">${statusIcon} ${this.escapeHtml(item.short_desc)}</div>`;
      }).join('');
  
      return items;
    },
  
    renderChecklistCard: function(checklist, completedIndex, failedIndex, toolName) {
      if (!checklist || !Array.isArray(checklist)) {
        return '<div style="color: #f48771;">Invalid checklist</div>';
      }
  
      // Determine header text based on tool
      let headerText = '📋 Task Checklist';
      if (toolName === 'exit_planning') {
        headerText = '📋 Task Checklist';
      } else if (toolName === 'item_completed') {
        headerText = '✓ Task Completed';
      } else if (toolName === 'item_failed') {
        headerText = '✗ Task Failed';
      }
  
      const items = checklist.map((item, index) => {
        let statusIcon = '○'; // Pending
        let color = '#858585'; // Gray
        let fontWeight = 'normal';
  
        if (completedIndex !== undefined && index <= completedIndex) {
          statusIcon = '✓'; // Completed
          color = '#4ec9b0'; // Green
        } else if (failedIndex !== undefined && index === failedIndex) {
          statusIcon = '✗'; // Failed
          color = '#f48771'; // Red
          fontWeight = 'bold';
        } else if ((completedIndex !== undefined && index === completedIndex + 1) ||
                   (failedIndex !== undefined && index === failedIndex + 1)) {
          // Current task (next after completed/failed)
          fontWeight = 'bold';
        }
  
        return `<div style="color: ${color}; margin-bottom: 4px; font-weight: ${fontWeight}; padding-left: 8px;">${statusIcon} ${this.escapeHtml(item.short_desc)}</div>`;
      }).join('');
  
      return `
        <div style="
          display: inline-block;
          background: #2d2d30;
          border: 1px solid #3e3e42;
          border-radius: 4px;
          padding: 12px;
          margin: 4px 0;
          min-width: 300px;
        ">
          <div style="color: #d4d4d4; font-weight: bold; margin-bottom: 8px; font-size: 13px;">
            ${headerText}
          </div>
          ${items}
        </div>
      `;
    },
  
    showToolModal: function(title, content) {
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      `;
  
      // Create modal container
      const modal = document.createElement('div');
      modal.style.cssText = `
        background: #252526;
        border-radius: 8px;
        max-width: 80vw;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      `;
  
      // Modal header
      const header = document.createElement('div');
      header.style.cssText = `
        padding: 16px 20px;
        border-bottom: 1px solid #3e3e42;
        display: flex;
        justify-content: space-between;
        align-items: center;
      `;
      header.innerHTML = `
        <div style="color: #d4d4d4; font-weight: bold; font-size: 14px;">${this.escapeHtml(title)}</div>
        <button id="closeModal" style="
          background: none;
          border: none;
          color: #858585;
          font-size: 20px;
          cursor: pointer;
          padding: 0;
          width: 24px;
          height: 24px;
          line-height: 1;
        ">&times;</button>
      `;
  
      // Modal content
      const contentDiv = document.createElement('div');
      contentDiv.style.cssText = `
        padding: 20px;
        overflow-y: auto;
        flex: 1;
        font-family: monospace;
        font-size: 12px;
        color: #d4d4d4;
        white-space: pre-wrap;
      `;
      contentDiv.textContent = JSON.stringify(content, null, 2);
  
      modal.appendChild(header);
      modal.appendChild(contentDiv);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
  
      // Close handlers
      const closeModal = () => {
        document.body.removeChild(overlay);
      };
  
      document.getElementById('closeModal').addEventListener('click', closeModal);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeModal();
        }
      });
  
      // Close on escape key
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
    },
  
    toggleSummary: function(messageId) {
      // Toggle expanded state
      if (this.expandedSummaries.has(messageId)) {
        this.expandedSummaries.delete(messageId);
      } else {
        this.expandedSummaries.add(messageId);
      }
  
      // Trigger re-render (the ui-manager should call this)
      const uiManager = window.module['ui-manager.js'];
      if (uiManager && uiManager.renderChat) {
        uiManager.renderChat();
      }
    }
  };
  

  // Module: utils.js
  // Utility Functions
  window.module['utils.js'] = {
    generateUUID: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    },
  
    generateSessionId: function() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
      let result = '';
      for (let i = 0; i < 20; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    },
  
    getTimestamp: function() {
      return Math.floor(Date.now() / 1000);
    },
  
    countCharacters: function(messages) {
      // Count entire JSON structure, not just content
      // This matches the spec requirement for 500K limit
      return messages.reduce((total, msg) => total + JSON.stringify(msg).length, 0);
    },
  
    formatCharCount: function(count) {
      return `${(count / 1000).toFixed(1)}K`;
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
