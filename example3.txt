// AI Agent - Built 2025-12-01T19:49:00.899Z
(function() {
  window.module = {};

  // Module: api-client.js
  // API Client
  window.module['api-client.js'] = {
    chatId: null,
    sessionId: null,
  
    init: function() {
      const utils = window.module['utils.js'];
      this.sessionId = utils.generateSessionId();
    },
  
    createNewChat: async function(firstMessage) {
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      const messageId = utils.generateUUID();
      const timestamp = utils.getTimestamp();
  
      const payload = {
        chat: {
          id: '',
          title: 'Chat Pending',
          models: [config.MODEL],
          params: {},
          history: {
            messages: {
              [messageId]: {
                id: messageId,
                parentId: null,
                childrenIds: [],
                role: 'user',
                content: firstMessage,
                timestamp: timestamp,
                models: [config.MODEL]
              }
            },
            currentId: messageId
          },
          messages: [
            {
              id: messageId,
              parentId: null,
              childrenIds: [],
              role: 'user',
              content: firstMessage,
              timestamp: timestamp,
              models: [config.MODEL]
            }
          ],
          tags: [],
          timestamp: Date.now()
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/new`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to create chat: ${response.status} ${response.statusText}`);
      }
  
      const data = await response.json();
      this.chatId = data.id;
  
      return { chatId: data.id, messageId };
    },
  
    updateChat: async function(messages) {
      const config = window.module['config.js'];
  
      // Build history object
      const historyMessages = {};
      messages.forEach((msg) => {
        historyMessages[msg.id] = {
          id: msg.id,
          parentId: msg.parentId,
          childrenIds: msg.childrenIds,
          content: msg.content,
          role: msg.role,
          timestamp: msg.timestamp,
          ...(msg.role === 'user' ? { models: [config.MODEL] } : {
            model: config.MODEL,
            modelIdx: 0,
            modelName: config.MODEL,
            userContext: null
          })
        };
      });
  
      const currentId = messages[messages.length - 1].id;
  
      const payload = {
        chat: {
          models: [config.MODEL],
          files: [],
          params: {},
          history: {
            messages: historyMessages,
            currentId: currentId
          },
          messages: messages.map(msg => ({
            id: msg.id,
            parentId: msg.parentId,
            childrenIds: msg.childrenIds,
            content: msg.content,
            role: msg.role,
            timestamp: msg.timestamp,
            ...(msg.role === 'user' ? { models: [config.MODEL] } : {
              model: config.MODEL,
              modelIdx: 0,
              modelName: config.MODEL,
              userContext: null
            })
          }))
        }
      };
  
      const response = await fetch(`${config.API_BASE}/v1/chats/${this.chatId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to update chat: ${response.status} ${response.statusText}`);
      }
  
      return await response.json();
    },
  
    getCompletion: async function(apiMessages, assistantMessageId) {
      const config = window.module['config.js'];
  
      // apiMessages is already in API format from api-renderer
      const payload = {
        stream: true,
        model: config.MODEL,
        messages: apiMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: true,
          tags_generation: true
        }
      };
  
      console.log('=== GET COMPLETION REQUEST ===');
      console.log('Messages count:', apiMessages.length);
      console.log('Last message:', apiMessages[apiMessages.length - 1]);
      console.log('Full payload:', payload);
  
      const response = await fetch(`${config.API_BASE}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to get completion: ${response.status} ${response.statusText}`);
      }
  
      console.log('Response status:', response.status);
  
      return response;
    },
  
    getContinuation: async function(apiMessages, assistantMessageId, partialContent) {
      const config = window.module['config.js'];
  
      console.log('\n' + '='.repeat(80));
      console.log('CONTINUATION REQUEST');
      console.log('='.repeat(80));
      console.log('Messages in conversation:', apiMessages.length);
      console.log('Partial content length:', partialContent.length, 'chars');
      console.log('First 50 chars:', JSON.stringify(partialContent.substring(0, 50)));
      console.log('Last 50 chars:', JSON.stringify(partialContent.substring(Math.max(0, partialContent.length - 50))));
  
      // Determine if this is a message or tool call
      // The AI sometimes adds text before the JSON, so we need to check if JSON exists anywhere
      // Use regex to be whitespace-tolerant
      const toolJsonMatch = partialContent.match(/\{\s*"tools"\s*:\s*\[/);
      const hasToolJson = toolJsonMatch !== null;
      const isToolCall = partialContent.trimStart().startsWith('{') || hasToolJson;
      const isMessage = partialContent.startsWith('=');
  
      console.log('Response type: ' + (isToolCall ? 'TOOL_CALL' : isMessage ? 'MESSAGE' : 'UNKNOWN'));
  
      let wrappedContent;
      let continuationPrompt;
  
      if (isToolCall) {
        // If there's text before the JSON, extract just the JSON part for wrapping
        let jsonPart = partialContent;
        if (hasToolJson && !partialContent.trimStart().startsWith('{')) {
          const jsonStart = toolJsonMatch.index;
          jsonPart = partialContent.substring(jsonStart);
          console.log(`[WARN] AI added text before JSON. Extracted JSON starting at position ${jsonStart}`);
        }
  
        // For tool calls, ask for a CONTINUATION (not complete JSON)
        // Use ~ prefix to indicate it's a continuation that should be appended
        wrappedContent = `Here's a partial response that got cut off:\n\`\`\`json\n${jsonPart}\n\`\`\``;
  
        continuationPrompt = `Your previous response was cut off mid-JSON. Send ONLY the continuation text that should be appended.
  
  The response ended with: "${jsonPart.substring(Math.max(0, jsonPart.length - 100))}"
  
  Start your response with ~ followed by the exact text that should come next. Do NOT send complete JSON, do NOT start with {, just send the raw continuation text that will be appended to what you already wrote.
  
  Example: if the partial ended with "...delay", you might send:
  ~ed memory access made them impractical for large-scale use."}}]}|||||END|||||
  
  The ~ tells the system this is a continuation to be appended, not a new complete response.`;
      } else if (isMessage) {
        // For messages: also use ~ for continuation
        const messageContent = partialContent.substring(1); // Remove = prefix
        wrappedContent = `Here's a partial message that got cut off:\n\`\`\`\n${messageContent}\n\`\`\``;
  
        continuationPrompt = `Your previous message was cut off. Send ONLY the continuation text.
  
  The message ended with: "${messageContent.substring(messageContent.length - 100)}"
  
  Start your response with ~ followed by the next words. This will be appended to what you already wrote.
  
  Example: if it ended with "...early memory solution", you might send:
  ~. These devices stored data as acoustic pulses...|||||END|||||`;
      } else {
        // Unknown format, send as-is
        wrappedContent = partialContent;
        continuationPrompt = '[System: Your previous response was cut off. Please continue from where you left off with ~ prefix.]';
      }
  
      // Build continuation messages with wrapped content
      const continueMessages = [
        ...apiMessages,
        {
          role: 'assistant',
          content: wrappedContent
        },
        {
          role: 'user',
          content: continuationPrompt
        }
      ];
  
      console.log('Sending continuation request...');
      console.log('='.repeat(80));
  
      const payload = {
        stream: true,
        model: config.MODEL,
        messages: continueMessages,
        params: {},
        features: {
          web_search: false
        },
        session_id: this.sessionId,
        chat_id: this.chatId,
        id: assistantMessageId,
        background_tasks: {
          title_generation: false,
          tags_generation: false
        }
      };
  
      const response = await fetch(`${config.API_BASE}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
  
      if (!response.ok) {
        throw new Error(`Failed to get continuation: ${response.status} ${response.statusText}`);
      }
  
      console.log('Continuation response status:', response.status);
  
      return response;
    }
  };
  

  // Module: api-renderer.js
  // API Renderer
  // Transforms internal message format to API format
  window.module['api-renderer.js'] = {
    renderMessagesForAPI: function(messages) {
      const modeManager = window.module['mode-manager.js'];
      const apiMessages = [];
  
      // Find latest summary
      let latestSummaryIndex = -1;
      let summaryContent = null;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].type === 'summary') {
          latestSummaryIndex = i;
          summaryContent = messages[i].content;
          break;
        }
      }
  
      // Start converting messages after the summary (or from beginning if no summary)
      const startIndex = latestSummaryIndex >= 0 ? latestSummaryIndex + 1 : 0;
  
      let firstUserMessageIndex = -1;
      let pendingWarnings = []; // Can accumulate multiple warnings
      let pendingToolUses = []; // Can accumulate multiple tool uses to combine into one assistant message
      let pendingToolResults = []; // Can accumulate multiple tool results
      let pendingPartials = []; // Can accumulate consecutive partial messages
  
      for (let i = startIndex; i < messages.length; i++) {
        const msg = messages[i];
  
        // Collect system_warning messages to merge with next user message
        if (msg.type === 'system_warning') {
          pendingWarnings.push(msg.warning);
          continue;
        }
  
        // Collect consecutive partial messages to combine
        if (msg.type === 'partial') {
          // But first, flush any pending tools (they come before this partial in message order)
          if (pendingToolUses.length > 0) {
            apiMessages.push({
              role: 'assistant',
              content: JSON.stringify({ tools: pendingToolUses }) + '|||||END|||||'
            });
            pendingToolUses = [];
          }
          if (pendingToolResults.length > 0) {
            const combinedResults = pendingToolResults.map(result => {
              if (result.success) {
                const path = result.args?.path || '';
                const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
                return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
              } else {
                return `Tool: ${result.tool}\nError: ${result.error}`;
              }
            }).join('\n\n');
            apiMessages.push({
              role: 'user',
              content: combinedResults
            });
            pendingToolResults = [];
          }
  
          pendingPartials.push(msg);
          continue;
        }
  
        // Flush pending partials before processing other message types (tool_use, tool_result, user, assistant)
        if (pendingPartials.length > 0) {
          // Combine all partial content into single assistant message
          const combinedContent = pendingPartials.map(p => p.content).join('');
          apiMessages.push({
            role: 'assistant',
            content: '=' + combinedContent + '|||||END|||||'
          });
          pendingPartials = [];
        }
  
        // Collect tool uses to combine into single assistant message
        if (msg.type === 'tool_use') {
          // Handle both old format (msg.tool) and new format (msg.tools array)
          const tools = msg.tools || [msg.tool];
          pendingToolUses.push(...tools);
          continue;
        }
  
        // Collect tool results to combine
        if (msg.type === 'tool_result') {
          pendingToolResults.push(msg);
          continue;
        }
  
        // Flush pending tool uses before processing other message types
        if (pendingToolUses.length > 0) {
          apiMessages.push({
            role: 'assistant',
            content: JSON.stringify({ tools: pendingToolUses }) + '|||||END|||||'
          });
          pendingToolUses = [];
        }
  
        // Flush pending tool results before processing other message types
        if (pendingToolResults.length > 0) {
          const combinedResults = pendingToolResults.map(result => {
            if (result.success) {
              // Include the file path in the result for read_file
              const path = result.args?.path || '';
              const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
              return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
            } else {
              return `Tool: ${result.tool}\nError: ${result.error}`;
            }
          }).join('\n\n');
  
          apiMessages.push({
            role: 'user',
            content: combinedResults
          });
          pendingToolResults = [];
        }
  
        // Handle different message types
        if (msg.type === 'user') {
          let content = msg.content;
  
          // Is this the first user message we're adding to API?
          if (firstUserMessageIndex === -1) {
            firstUserMessageIndex = apiMessages.length;
  
            // Build prefix: system prompt + summary (if exists)
            let prefix = modeManager.getSystemPrompt();
  
            if (summaryContent) {
              prefix += '\n\n' + summaryContent;
            }
  
            content = prefix + '\n\n' + content;
          }
  
          // Prepend any pending warnings
          if (pendingWarnings.length > 0) {
            const warningsText = pendingWarnings.map(w => `[System: ${w}]`).join('\n');
            content = warningsText + '\n\n' + content;
            pendingWarnings = [];
          }
  
          apiMessages.push({
            role: 'user',
            content: content
          });
  
        } else if (msg.type === 'assistant') {
          // Assistant message responses use = prefix
          apiMessages.push({
            role: 'assistant',
            content: '=' + msg.content + '|||||END|||||'
          });
  
        } else if (msg.type === 'system_error') {
          apiMessages.push({
            role: 'user',
            content: `Error: ${msg.error}`
          });
        }
      }
  
      // Flush any remaining tool uses at the end (in order of appearance)
      if (pendingPartials.length > 0) {
        const combinedContent = pendingPartials.map(p => p.content).join('');
        apiMessages.push({
          role: 'assistant',
          content: '=' + combinedContent + '|||||END|||||'
        });
      }
  
      if (pendingToolUses.length > 0) {
        apiMessages.push({
          role: 'assistant',
          content: JSON.stringify({ tools: pendingToolUses }) + '|||||END|||||'
        });
      }
  
      if (pendingToolResults.length > 0) {
        const combinedResults = pendingToolResults.map(result => {
          if (result.success) {
            const path = result.args?.path || '';
            const prefix = path ? `Tool: ${result.tool} (${path})` : `Tool: ${result.tool}`;
            return `${prefix}\nResult: ${JSON.stringify(result.result)}`;
          } else {
            return `Tool: ${result.tool}\nError: ${result.error}`;
          }
        }).join('\n\n');
  
        apiMessages.push({
          role: 'user',
          content: combinedResults
        });
      }
  
      return apiMessages;
    }
  };
  

  // Module: config.js
  // Configuration
  window.module['config.js'] = {
    API_BASE: 'https://chat.niprgpt.mil/api',
    MODEL: 'Anthropic Claude 4 Sonnet',
    MAX_RETRIES: 5,
    TIMEOUT_MS: 30000, // 30 seconds
    MAX_CONVERSATION_CHARS: 500000 // 500K character limit before summarization
  };
  

  // Module: conversation-flow.js
  // Conversation Flow Manager
  // Pure logic module for handling AI conversation flow
  // NO DOM dependencies - can be tested in Node.js
  
  window.module['conversation-flow.js'] = {
    /**
     * Process a streaming AI response with continuation and error handling
     * This is the core conversation loop extracted from ui-manager
     *
     * @param {ReadableStream} streamingResponse - The streaming response from API
     * @param {string} assistantMessageId - ID for the assistant's message
     * @param {Array} apiMessages - Current conversation messages in API format
     * @param {Object} callbacks - Callbacks for progress updates
     * @param {Function} callbacks.onProgress - Called with status updates (optional)
     * @param {Function} callbacks.onChunk - Called with each content chunk (optional)
     * @returns {Promise<Object>} - { success: boolean, content: Object|string, error: string|null }
     */
    handleAIResponse: async function(streamingResponse, assistantMessageId, apiMessages, callbacks = {}) {
      const conversationManager = window.module['conversation-manager.js'];
      const messageProcessor = window.module['message-processor.js'];
      const apiClient = window.module['api-client.js'];
      const config = window.module['config.js'];
  
      const MAX_CONTINUATION_ATTEMPTS = 20;
      let accumulatedContent = '';
  
      try {
        // Stream the initial response
        const reader = streamingResponse.body.getReader();
        const decoder = new TextDecoder();
  
        while (true) {
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Timeout')), config.TIMEOUT_MS);
          });
  
          const readPromise = reader.read();
          const result = await Promise.race([readPromise, timeoutPromise]);
  
          if (result.done) break;
  
          const chunk = decoder.decode(result.value, { stream: true });
          const lines = chunk.split('\n');
  
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') continue;
  
              try {
                const parsed = JSON.parse(data);
                if (parsed.choices?.[0]?.delta?.content) {
                  const content = parsed.choices[0].delta.content;
                  accumulatedContent += content;
  
                  if (callbacks.onChunk) {
                    callbacks.onChunk(content, accumulatedContent);
                  }
                }
              } catch (e) {
                console.error('Failed to parse SSE data:', e);
              }
            }
          }
        }
  
        // Process the accumulated response
        let processed = messageProcessor.processStreamedResponse(accumulatedContent);
  
        // Add system warning if text was trimmed
        if (processed.systemWarning) {
          await conversationManager.addMessage(processed.systemWarning);
        }
  
        if (processed.error) {
          // Add the AI's failed response to conversation first
          await conversationManager.addMessage({
            type: 'assistant',
            id: assistantMessageId,
            content: accumulatedContent,
            timestamp: Date.now(),
            parentId: null,
            childrenIds: []
          });
  
          // Then add system error message
          await conversationManager.addMessage({
            type: 'system_error',
            error: processed.error,
            originalContent: processed.originalContent || accumulatedContent
          });
  
          // Return error to caller - they can decide to retry
          return {
            success: false,
            content: null,
            error: processed.error,
            needsRetry: true
          };
        }
  
        // Handle incomplete responses - try continuation
        let continuationAttempts = 0;
  
        while (!processed.complete && continuationAttempts < MAX_CONTINUATION_ATTEMPTS) {
          continuationAttempts++;
  
          if (continuationAttempts === 1) {
            // Log once at the start of continuation loop
            console.log('\n' + '!'.repeat(80));
            console.log('RESPONSE INCOMPLETE - STARTING CONTINUATION LOOP');
            console.log('!'.repeat(80));
            console.log('Accumulated so far:', accumulatedContent.length, 'chars');
            console.log('Has terminator:', accumulatedContent.includes('|||||END|||||'));
            console.log('Last 50 chars:', JSON.stringify(accumulatedContent.substring(Math.max(0, accumulatedContent.length - 50))));
            console.log('!'.repeat(80));
          }
  
          if (callbacks.onProgress) {
            callbacks.onProgress(`Requesting continuation (${continuationAttempts}/${MAX_CONTINUATION_ATTEMPTS})...`);
          }
  
          try {
            // Extract the actual message content (remove = prefix if present)
            let partialMessage = accumulatedContent;
            if (partialMessage.startsWith('=')) {
              partialMessage = partialMessage.substring(1);
            }
  
            const continueResponse = await apiClient.getContinuation(apiMessages, assistantMessageId, partialMessage);
            const continueReader = continueResponse.body.getReader();
            const continueDecoder = new TextDecoder();
            let continuationContent = '';
  
            while (true) {
              const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout')), config.TIMEOUT_MS);
              });
  
              const readPromise = continueReader.read();
              const result = await Promise.race([readPromise, timeoutPromise]);
  
              if (result.done) break;
  
              const chunk = continueDecoder.decode(result.value, { stream: true });
              const lines = chunk.split('\n');
  
              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  const data = line.slice(6);
                  if (data === '[DONE]') continue;
  
                  try {
                    const parsed = JSON.parse(data);
                    if (parsed.choices?.[0]?.delta?.content) {
                      const content = parsed.choices[0].delta.content;
                      continuationContent += content;
  
                      if (callbacks.onChunk) {
                        callbacks.onChunk(content, accumulatedContent + continuationContent);
                      }
                    }
                  } catch (e) {
                    console.error('Failed to parse continuation SSE data:', e);
                  }
                }
              }
            }
  
            // Check if AI used ~ prefix for continuation
            console.log('\n' + '='.repeat(80));
            console.log('CONTINUATION RECEIVED (attempt ' + continuationAttempts + ')');
            console.log('='.repeat(80));
            console.log('Continuation length:', continuationContent.length, 'chars');
            console.log('First char:', JSON.stringify(continuationContent.charAt(0)));
            console.log('Starts with ~:', continuationContent.startsWith('~'));
            console.log('First 50 chars:', JSON.stringify(continuationContent.substring(0, 50)));
            console.log('='.repeat(80));
  
            if (continuationContent.startsWith('~')) {
              console.log('✓ AI correctly used ~ prefix');
              // Strip ~ and append to accumulated content
              const cleaned = continuationContent.substring(1);
              accumulatedContent += cleaned;
              console.log('Combined length now:', accumulatedContent.length, 'chars');
  
              // Re-process the combined response
              processed = messageProcessor.processStreamedResponse(accumulatedContent);
  
              // Add system warning if text was trimmed (from continuation processing)
              if (processed.systemWarning) {
                await conversationManager.addMessage(processed.systemWarning);
              }
  
              if (processed.complete && !processed.error) {
                // Success!
                break;
              } else if (processed.error) {
                // Still has error after continuation
                await conversationManager.addMessage({
                  type: 'assistant',
                  id: assistantMessageId,
                  content: accumulatedContent,
                  timestamp: Date.now(),
                  parentId: null,
                  childrenIds: []
                });
  
                await conversationManager.addMessage({
                  type: 'system_error',
                  error: processed.error,
                  originalContent: processed.originalContent || accumulatedContent
                });
  
                return {
                  success: false,
                  content: null,
                  error: processed.error,
                  needsRetry: true
                };
              }
              // else: still incomplete, loop continues
            } else {
              // AI didn't use ~ prefix - not a proper continuation
              console.log('✗ ERROR: AI did NOT use ~ prefix!');
              console.log('This means AI restarted instead of continuing.');
              console.log('Continuation response was:', JSON.stringify(continuationContent.substring(0, 100)));
  
              await conversationManager.addMessage({
                type: 'system_error',
                error: 'Response incomplete: AI did not continue properly',
                originalContent: accumulatedContent
              });
  
              return {
                success: false,
                content: null,
                error: 'AI did not continue properly',
                needsRetry: true
              };
            }
  
          } catch (error) {
            console.error('Continuation attempt failed:', error);
  
            await conversationManager.addMessage({
              type: 'system_error',
              error: `Continuation error: ${error.message}`,
              originalContent: accumulatedContent
            });
  
            return {
              success: false,
              content: null,
              error: error.message,
              needsRetry: false
            };
          }
        }
  
        // Check if we exhausted continuation attempts
        if (!processed.complete) {
          await conversationManager.addMessage({
            type: 'system_error',
            error: `Response incomplete after ${MAX_CONTINUATION_ATTEMPTS} continuation attempts`,
            originalContent: accumulatedContent
          });
  
          return {
            success: false,
            content: null,
            error: `Too many continuation attempts (${MAX_CONTINUATION_ATTEMPTS})`,
            needsRetry: false
          };
        }
  
        // Success! Return the processed content
        return {
          success: true,
          content: processed.content,
          error: null,
          rawResponse: accumulatedContent
        };
  
      } catch (error) {
        console.error('handleAIResponse error:', error);
  
        await conversationManager.addMessage({
          type: 'system_error',
          error: error.message,
          originalContent: accumulatedContent
        });
  
        return {
          success: false,
          content: null,
          error: error.message,
          needsRetry: false
        };
      }
    }
  };
  

  // Module: conversation-manager.js
  // Conversation Manager
  // Manages message array, character counting, and (TODO) summarization
  window.module['conversation-manager.js'] = {
    messages: [],
  
    init: function() {
      this.messages = [];
    },
  
    addMessage: async function(message) {
      const utils = window.module['utils.js'];
      const config = window.module['config.js'];
  
      // Ensure message has required fields
      if (!message.id) {
        message.id = utils.generateUUID();
      }
      if (!message.timestamp) {
        message.timestamp = utils.getTimestamp();
      }
      if (!message.parentId) {
        message.parentId = this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null;
      }
      if (!message.childrenIds) {
        message.childrenIds = [];
      }
  
      // Update parent's childrenIds
      if (message.parentId) {
        const parent = this.messages.find(m => m.id === message.parentId);
        if (parent) {
          parent.childrenIds.push(message.id);
        }
      }
  
      // Check 500K character limit before adding
      const currentCount = this.getTotalCharacterCount();
      const messageCharCount = utils.countCharacters([message]);
      const wouldExceedLimit = (currentCount + messageCharCount) > config.MAX_CONVERSATION_CHARS;
  
      if (wouldExceedLimit) {
        console.log(`Would exceed ${config.MAX_CONVERSATION_CHARS} char limit (current: ${currentCount}, adding: ${messageCharCount}). Triggering summarization...`);
        await this.summarize();
      }
  
      // Add the message
      this.messages.push(message);
  
      return message;
    },
  
    getMessages: function() {
      return this.messages;
    },
  
    getTotalCharacterCount: function() {
      const utils = window.module['utils.js'];
      return utils.countCharacters(this.messages);
    },
  
    /**
     * Summarizes conversation when it exceeds 500K characters
     * Creates a summary message and marks which messages it summarizes
     */
    summarize: async function() {
      const utils = window.module['utils.js'];
      const apiClient = window.module['api-client.js'];
      const config = window.module['config.js'];
  
      // 1. Gather messages to summarize
      let messagesToSummarize = [];
      let latestSummaryIndex = -1;
  
      // Find the latest summary (if any)
      for (let i = this.messages.length - 1; i >= 0; i--) {
        if (this.messages[i].type === 'summary') {
          latestSummaryIndex = i;
          break;
        }
      }
  
      if (latestSummaryIndex === -1) {
        // No summaries exist - summarize all messages
        messagesToSummarize = this.messages.slice();
      } else {
        // Summaries exist - summarize from latest summary to end
        messagesToSummarize = this.messages.slice(latestSummaryIndex);
      }
  
      console.log(`Summarizing ${messagesToSummarize.length} messages...`);
  
      // 2. Convert messages to text for summarization
      const messagesText = messagesToSummarize.map(msg => {
        switch (msg.type) {
          case 'user':
            return `User: ${msg.content}`;
          case 'assistant':
            return `Assistant: ${msg.content}`;
          case 'tool_use':
            return `Tool Use: ${JSON.stringify(msg.tool || msg.tools)}`;
          case 'tool_result':
            return `Tool Result (${msg.tool}): ${msg.success ? 'Success' : 'Error'}\n${msg.result || msg.error}`;
          case 'system_error':
            return `System Error: ${msg.error}`;
          case 'system_warning':
            return `System Warning: ${msg.warning}`;
          case 'summary':
            return `Previous Summary: ${msg.content}`;
          default:
            return `${msg.type}: ${JSON.stringify(msg)}`;
        }
      }).join('\n\n');
  
      // Get the last user message for context
      let lastUserMessage = '';
      for (let i = this.messages.length - 1; i >= 0; i--) {
        if (this.messages[i].type === 'user') {
          lastUserMessage = this.messages[i].content;
          break;
        }
      }
  
      // 3. Create summary prompt
      const summaryPrompt = `<system-reminder>
  Summarize the previous work and provide context for the current task.
  
  Be concise but include:
  - What the user originally requested
  - What has been accomplished
  - Current state of the codebase
  - Any important context for continuing
  
  Format as a brief summary.
  </system-reminder>
  
  ${messagesText}
  
  Last user request: ${lastUserMessage}`;
  
      // 4. Call API to generate summary
      const summaryMessages = [{
        role: 'user',
        content: summaryPrompt
      }];
  
      try {
        const response = await fetch(`${config.API_BASE}/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            stream: false, // Non-streaming for simplicity
            model: config.MODEL,
            messages: summaryMessages,
            params: {},
            features: { web_search: false },
            session_id: utils.generateSessionId(),
            chat_id: apiClient.chatId,
            id: utils.generateUUID()
          })
        });
  
        if (!response.ok) {
          throw new Error(`Summary API call failed: ${response.status}`);
        }
  
        const data = await response.json();
        const summaryContent = data.choices?.[0]?.message?.content || 'Summary generation failed';
  
        // 5. Create summary message
        const summaryMessage = {
          type: 'summary',
          id: utils.generateUUID(),
          timestamp: utils.getTimestamp(),
          content: summaryContent,
          summarizes_from: messagesToSummarize[0].id,
          summarizes_to: messagesToSummarize[messagesToSummarize.length - 1].id,
          parentId: this.messages[this.messages.length - 1].id,
          childrenIds: []
        };
  
        // 6. Remove summarized messages (but keep old summaries as history markers)
        if (latestSummaryIndex !== -1) {
          // Keep everything up to and including the latest summary
          // Remove only the messages after it (they're now summarized)
          this.messages = this.messages.slice(0, latestSummaryIndex + 1);
        } else {
          // No summary exists, remove all messages (they'll be summarized)
          this.messages = [];
        }
  
        // Add the new summary
        this.messages.push(summaryMessage);
  
        console.log(`✓ Summarization complete. Reduced to ${this.messages.length} messages.`);
        console.log(`Summary: ${summaryContent.substring(0, 200)}...`);
  
        return summaryMessage;
  
      } catch (error) {
        console.error('Summarization failed:', error);
        // If summarization fails, just warn and continue
        // This prevents blocking the user from continuing work
        console.warn('Continuing without summarization - conversation may become very large');
        return null;
      }
    }
  };
  

  // Module: file-system.js
  // File System Handler
  window.module['file-system.js'] = {
    directoryHandle: null,
    fileTree: [],
  
    requestDirectory: async function() {
      try {
        this.directoryHandle = await window.showDirectoryPicker();
        this.fileTree = await this.buildFileTree(this.directoryHandle);
        return true;
      } catch (err) {
        console.error('Directory access error:', err);
        return false;
      }
    },
  
    buildFileTree: async function(dirHandle, path = '') {
      const entries = [];
  
      for await (const entry of dirHandle.values()) {
        const fullPath = path ? `${path}/${entry.name}` : entry.name;
  
        if (entry.kind === 'directory') {
          const children = await this.buildFileTree(entry, fullPath);
          entries.push({
            name: entry.name,
            type: 'directory',
            path: fullPath,
            children: children,
            handle: entry
          });
        } else {
          // Read file to get character count
          let charCount = 0;
          try {
            const file = await entry.getFile();
            const text = await file.text();
            charCount = text.length;
          } catch (err) {
            console.warn('Could not read file for char count:', entry.name);
          }
  
          entries.push({
            name: entry.name,
            type: 'file',
            path: fullPath,
            handle: entry,
            charCount: charCount
          });
        }
      }
  
      return entries.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
    },
  
    readFile: async function(fileEntry) {
      try {
        const file = await fileEntry.handle.getFile();
        const text = await file.text();
        return text;
      } catch (err) {
        console.error('File read error:', err);
        return null;
      }
    },
  
    createFile: async function(path, content) {
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      try {
        // Split path into parts
        const parts = path.split('/');
        const fileName = parts.pop();
  
        // Navigate to the target directory, creating folders as needed
        let currentHandle = this.directoryHandle;
        for (const part of parts) {
          if (part) {
            currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
          }
        }
  
        // Create the file
        const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
  
        // Rebuild file tree to include new file
        this.fileTree = await this.buildFileTree(this.directoryHandle);
  
        return true;
      } catch (err) {
        console.error('File create error:', err);
        throw err;
      }
    },
  
    editFile: async function(path, oldText, newText) {
      if (!this.directoryHandle) {
        throw new Error('No directory selected');
      }
  
      try {
        // Find the file in the tree
        const fileEntry = this.findFileInTree(this.fileTree, path);
        if (!fileEntry) {
          throw new Error(`File not found: ${path}`);
        }
  
        // Read current content
        const currentContent = await this.readFile(fileEntry);
        if (currentContent === null) {
          throw new Error(`Failed to read file: ${path}`);
        }
  
        // Replace old text with new text
        const newContent = currentContent.replace(oldText, newText);
  
        // Check if replacement happened
        if (newContent === currentContent) {
          throw new Error('Old text not found in file');
        }
  
        // Write new content
        const writable = await fileEntry.handle.createWritable();
        await writable.write(newContent);
        await writable.close();
  
        // Update char count in tree
        fileEntry.charCount = newContent.length;
  
        return true;
      } catch (err) {
        console.error('File edit error:', err);
        throw err;
      }
    },
  
    findFileInTree: function(tree, path) {
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'file') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFileInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    }
  };
  

  // Module: main.js
  // Main entry point
  window.module['main.js'] = {
    version: '2.0.0-alpha',
  
    run: function() {
      console.log('Initializing API Test Interface v2.0...');
      console.log('Version:', this.version);
      console.log('Mode: Planning Mode (Execution Mode not yet implemented)');
  
      // Initialize all modules (they self-initialize when ui-manager.init() calls them)
      const uiManager = window.module['ui-manager.js'];
      uiManager.init();
  
      console.log('API Test Interface ready!');
      console.log('');
      console.log('v2.0 Features:');
      console.log('✓ New message system with types');
      console.log('✓ JSON response format with terminator');
      console.log('✓ Planning Mode with system prompt');
      console.log('✓ Tool system (list_folder, read_file)');
      console.log('✓ Message processor (parse & validate)');
      console.log('');
      console.log('TODO:');
      console.log('- Execution Mode');
      console.log('- Tool execution (create_file, edit_file)');
      console.log('- Summarization (500K limit)');
      console.log('- Partial message continuation');
      console.log('- Auto-call after tool execution');
    }
  };
  

  // Module: message-processor.js
  // Message Processor
  // Handles processing of streamed responses with = prefix (message), { prefix (tools), or ~ prefix (continuation)
  // Implements 3-layer processing: Text Trimming → JSON Repair → Validation
  window.module['message-processor.js'] = {
    TERMINATOR: '|||||END|||||',
  
    processStreamedResponse: function(rawText) {
      // Check for terminator
      if (!rawText.includes(this.TERMINATOR)) {
        return {
          complete: false,
          content: rawText,
          error: null
        };
      }
  
      // Extract content before terminator
      const terminatorIndex = rawText.indexOf(this.TERMINATOR);
      const content = rawText.substring(0, terminatorIndex);
  
      // Detect response type by first character
      const firstChar = content.charAt(0);
  
      if (firstChar === '=' || firstChar === '~') {
        // Message or continuation response - no trimming needed
        return this.processMessage(content, firstChar);
      } else if (content.includes('{')) {
        // Tool execution response - may have text before/after JSON, apply full 3-layer processing
        // Layer 1 will trim any text before { and after }
        return this.processTools(content);
      } else {
        // Invalid format - doesn't start with =, ~, or contain { anywhere
        return {
          complete: true,
          content: null,
          error: `Invalid response format: must start with = (message), ~ (continuation), or contain { (tools)`,
          originalContent: rawText,
          systemWarning: null
        };
      }
    },
  
    processMessage: function(text, prefix) {
      // Remove prefix (= or ~)
      const message = text.substring(1);
  
      return {
        complete: true,
        content: {
          type: 'message',
          text: message
        },
        error: null,
        systemWarning: null
      };
    },
  
    processTools: function(rawJsonText) {
      // ===== LAYER 1: TEXT TRIMMING =====
      const trimResult = this.trimToJson(rawJsonText);
      const jsonText = trimResult.trimmed;
      const systemWarning = trimResult.systemWarning;
  
      // ===== LAYER 2: JSON PARSING & REPAIR =====
      const parseResult = this.parseAndRepairJson(jsonText);
      if (parseResult.error) {
        return {
          complete: true,
          content: null,
          error: parseResult.error,
          originalContent: rawJsonText,
          systemWarning: systemWarning
        };
      }
  
      const data = parseResult.data;
  
      // ===== LAYER 3: VALIDATION =====
      const validationResult = this.validateToolsResponse(data, jsonText);
      if (validationResult.error) {
        return {
          complete: true,
          content: null,
          error: validationResult.error,
          originalContent: rawJsonText,
          systemWarning: systemWarning
        };
      }
  
      return {
        complete: true,
        content: {
          type: 'execute',
          tools: data.tools
        },
        error: null,
        systemWarning: systemWarning
      };
    },
  
    // ===== LAYER 1: TEXT TRIMMING =====
    trimToJson: function(text) {
      const openBrace = text.indexOf('{');
      const closeBrace = text.lastIndexOf('}');
  
      if (openBrace === -1 || closeBrace === -1 || closeBrace < openBrace) {
        // No valid JSON structure found
        return {
          trimmed: text,
          systemWarning: null
        };
      }
  
      const trimmedPrefix = text.substring(0, openBrace);
      const trimmedSuffix = text.substring(closeBrace + 1);
      const jsonText = text.substring(openBrace, closeBrace + 1);
  
      // Check if anything was trimmed
      if (trimmedPrefix.length > 0 || trimmedSuffix.length > 0) {
        return {
          trimmed: jsonText,
          systemWarning: {
            type: 'system_warning',
            warning: `Trimmed ${trimmedPrefix.length} characters before JSON and ${trimmedSuffix.length} characters after`,
            trimmed_prefix: trimmedPrefix,
            trimmed_suffix: trimmedSuffix
          }
        };
      }
  
      return {
        trimmed: jsonText,
        systemWarning: null
      };
    },
  
    // ===== LAYER 2: JSON PARSING & REPAIR =====
    parseAndRepairJson: function(jsonText) {
      // IMPORTANT: The AI sometimes sends JSON with literal newlines despite instructions not to
      // We need to replace literal newlines with \n escape sequences before parsing
      // But we need to be careful not to break JSON strings that legitimately contain \n
      const normalizedJson = jsonText.replace(/\n/g, '\\n').replace(/\r/g, '');
  
      let lastError = null;
  
      // Try parsing as-is first
      try {
        const data = JSON.parse(normalizedJson);
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Parsing failed, attempt repairs
      }
  
      // Repair 1: Add missing trailing }
      try {
        const withBrace = normalizedJson + '}';
        const data = JSON.parse(withBrace);
        console.log('[JSON Repair] Added missing trailing }');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Continue to next repair
      }
  
      // Repair 2: Add missing trailing ]
      try {
        const withBracket = normalizedJson + ']';
        const data = JSON.parse(withBracket);
        console.log('[JSON Repair] Added missing trailing ]');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Continue to next repair
      }
  
      // Repair 3: Add missing trailing ]}
      try {
        const withBoth = normalizedJson + ']}';
        const data = JSON.parse(withBoth);
        console.log('[JSON Repair] Added missing trailing ]}');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Continue to next repair
      }
  
      // Repair 4: Remove trailing commas
      try {
        const withoutTrailingCommas = normalizedJson
          .replace(/,(\s*[}\]])/g, '$1');  // Remove commas before closing braces/brackets
        const data = JSON.parse(withoutTrailingCommas);
        console.log('[JSON Repair] Removed trailing commas');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // Continue to next repair
      }
  
      // Repair 5: Fix unescaped quotes (basic attempt)
      try {
        // This is a simple heuristic - replace \" inside string values with '
        // More sophisticated repair would require proper parsing
        const withFixedQuotes = normalizedJson.replace(/"([^"]*)"([^"]*?)"/g, (match, p1, p2) => {
          if (p2.includes('"')) {
            return `"${p1}${p2.replace(/"/g, "'")}"`;
          }
          return match;
        });
        const data = JSON.parse(withFixedQuotes);
        console.log('[JSON Repair] Fixed unescaped quotes');
        return { data, error: null };
      } catch (e) {
        lastError = e;
        // All repairs failed
      }
  
      // All attempts failed
      return {
        data: null,
        error: `JSON parse error: ${lastError.message}`
      };
    },
  
    // ===== LAYER 3: VALIDATION =====
    validateToolsResponse: function(data, originalJson) {
      // Check basic structure
      if (!data || typeof data !== 'object') {
        return {
          error: 'Invalid tools response: not an object'
        };
      }
  
      if (!Array.isArray(data.tools)) {
        return {
          error: 'Invalid tools response: tools must be an array'
        };
      }
  
      if (data.tools.length === 0) {
        return {
          error: 'Invalid tools response: tools array is empty'
        };
      }
  
      // Validate each tool
      const validToolNames = [
        'list_folder',
        'read_file',
        'create_file',
        'edit_file',
        'exit_planning',
        'item_completed',
        'item_failed'
      ];
  
      for (let i = 0; i < data.tools.length; i++) {
        const tool = data.tools[i];
  
        // Check tool has name
        if (!tool.name) {
          return {
            error: `Invalid tool at index ${i}: missing "name" field`
          };
        }
  
        // Check tool name is valid
        if (!validToolNames.includes(tool.name)) {
          // Try to suggest similar tool names
          const suggestions = validToolNames.filter(name =>
            name.includes(tool.name) || tool.name.includes(name.replace('_', ''))
          );
          const suggestionText = suggestions.length > 0
            ? ` Did you mean: ${suggestions.join(', ')}?`
            : '';
          return {
            error: `Invalid tool name: "${tool.name}"${suggestionText}`
          };
        }
  
        // Check tool has args
        if (!tool.args || typeof tool.args !== 'object') {
          return {
            error: `Invalid tool at index ${i}: "${tool.name}" must have "args" object`
          };
        }
  
        // Validate mode-specific tool availability
        const modeValidation = this.validateToolMode(tool.name);
        if (modeValidation.error) {
          return modeValidation;
        }
      }
  
      return { error: null };
    },
  
    // Check if tool is available in current mode
    validateToolMode: function(toolName) {
      const modeManager = window.module['mode-manager.js'];
      if (!modeManager) {
        // Mode manager not available, skip validation
        return { error: null };
      }
  
      const currentMode = modeManager.getMode();
      const sharedTools = ['list_folder', 'read_file'];
      const planningOnlyTools = ['exit_planning'];
      const executionOnlyTools = ['create_file', 'edit_file', 'item_completed', 'item_failed'];
  
      // Check if tool is restricted to a specific mode
      if (currentMode === 'planning' && executionOnlyTools.includes(toolName)) {
        return {
          error: `Tool "${toolName}" is not available in Planning Mode. Available tools: ${sharedTools.concat(planningOnlyTools).join(', ')}`
        };
      }
  
      if (currentMode === 'execution' && planningOnlyTools.includes(toolName)) {
        return {
          error: `Tool "${toolName}" is not available in Execution Mode. Available tools: ${sharedTools.concat(executionOnlyTools).join(', ')}`
        };
      }
  
      return { error: null };
    }
  };
  

  // Module: mode-manager.js
  // Mode Manager
  // Manages mode state, transitions, and prompt selection
  window.module['mode-manager.js'] = {
    state: {
      mode: 'planning', // Always start in planning mode
      checklist: [],
      current_item_index: 0
    },
  
    init: function() {
      this.state = {
        mode: 'planning',
        checklist: [],
        current_item_index: 0
      };
    },
  
    getMode: function() {
      return this.state.mode;
    },
  
    getSystemPrompt: function() {
      if (this.state.mode === 'planning') {
        return this.getPlanningModePrompt();
      } else {
        return this.getExecutionModePrompt();
      }
    },
  
    getPlanningModePrompt: function() {
      return `<system-reminder>
  You are a helpful AI coding assistant in PLANNING MODE.
  
  ⚠️ CRITICAL: When outputting JSON for tool calls, you MUST write it as a SINGLE CONTINUOUS LINE with NO line breaks, NO indentation, NO formatting. Do NOT press Enter/Return anywhere inside the JSON. Use \\n for newlines in string values.
  
  Your goal is to understand what the user wants to accomplish through conversation.
  
  ## What you should do:
  
  1. Ask clarifying questions about the task
  2. Explore the codebase using list_folder and read_file (as many files as needed)
  3. Understand the current state and requirements
  4. When ready to make CHANGES, create a checklist and exit to execution mode
  
  IMPORTANT: You can read as many files as you want in planning mode. Only exit to execution mode when you need to CREATE or MODIFY files. Reading is part of planning.
  
  ## Response Format
  
  ALL responses must end with |||||END|||||
  
  Two response types in planning mode:
  
  ### 1. Message Response
  When you want to ask questions or discuss, start with = followed by your message:
  
  =Your message to the user here. Can be multiple lines.
  You can include newlines and formatting.|||||END|||||
  
  ### 2. Tool Execution
  When you need to use tools, start with { and provide valid JSON:
  
  {"tools":[{"name":"list_folder","args":{"path":"src/"}},{"name":"read_file","args":{"path":"src/main.js"}}]}|||||END|||||
  
  CRITICAL RULES FOR TOOL USE:
  1. When using tools, respond with ONLY the JSON. Nothing else. No explanatory text before or after.
  2. Start your response with { immediately. Do NOT write "I'll use..." or "Let me..." first.
  3. ALL JSON must be on a SINGLE line. NO literal line breaks anywhere in the JSON.
  4. For newlines within JSON string values, use \\n (backslash-n), never press Enter/Return.
  5. Example CORRECT: {"long_desc":"Line 1\\nLine 2\\nLine 3"}
  6. Example WRONG: "I'll use exit_planning.\n{"tools":[...  ← Extra text breaks parsing!
  7. Example WRONG: {"long_desc":"Line 1
  Line 2"}  ← Literal line break breaks JSON!
  
  ## Available Tools in Planning Mode
  
  ⚠️ ONLY THESE 3 TOOLS ARE AVAILABLE IN PLANNING MODE:
  - list_folder: Explore directories (non-recursive)
  - read_file: Read file contents
  - exit_planning: Exit planning with checklist
  
  ❌ File creation and modification tools are NOT available in planning mode!
  
  If the user asks you to create or modify files, you MUST:
  1. Call exit_planning with a checklist
  2. The system will switch you to execution mode
  3. Then you can use file operation tools
  
  Example exit_planning:
  {"tools":[{"name":"exit_planning","args":{"checklist":[{"short_desc":"Brief description for UI","long_desc":"Detailed description for execution. Use \\n for line breaks in long_desc."}]}}]}|||||END|||||
  
  ## Rules
  
  1. Be conversational and ask questions when requirements are unclear
  2. Don't start implementing until you call exit_planning
  3. If user asks to create/modify files, immediately call exit_planning - do NOT try to use file operation tools in planning mode
  4. Break down complex tasks into discrete checklist items
  5. Each checklist item should be independently verifiable
  6. Keep short_desc concise (for UI display)
  7. Make long_desc detailed (for execution context)
  8. **ACTION OVER ANNOUNCEMENT**: When you need to use tools, just use them immediately. Don't send a message saying "Let me check..." or "I'll read..." - just execute the tools. The user will see the tool results.
  
  </system-reminder>`;
    },
  
    getExecutionModePrompt: function() {
      // TODO: Implement execution mode
      const currentItem = this.state.checklist[this.state.current_item_index];
      const taskDesc = currentItem ? currentItem.long_desc : 'No task assigned';
  
      return `<system-reminder>
  You are a helpful AI coding assistant in EXECUTION MODE.
  
  ⚠️ CRITICAL: When outputting JSON for tool calls, you MUST write it as a SINGLE CONTINUOUS LINE with NO line breaks, NO indentation, NO formatting. Do NOT press Enter/Return anywhere inside the JSON. Use \\n for newlines in string values.
  
  Your ONLY job is to complete the current checklist item.
  
  ## Current Task
  
  ${taskDesc}
  
  ## What you should do:
  
  1. Focus ONLY on this task
  2. Use file operations as needed
  3. When finished, call item_completed
  4. If you can't complete it, call item_failed with a reason
  
  ## Response Format
  
  ALL responses must end with |||||END|||||
  
  Two response types:
  
  ### 1. Message Response
  Start with = followed by your message:
  
  =Task completed successfully.|||||END|||||
  
  ### 2. Tool Execution
  Start with { and provide valid JSON:
  
  {"tools":[{"name":"create_file","args":{"path":"src/new.js","content":"console.log('hello');"}}]}|||||END|||||
  
  IMPORTANT JSON FORMATTING:
  - CRITICAL: ALL JSON must be on a SINGLE line. NO literal line breaks anywhere in the JSON.
  - For newlines within JSON string values, use \\n (backslash-n), never press Enter/Return.
  - For file content with multiple lines, use \\n between lines.
  - Example CORRECT: {"content":"line1\\nline2\\nline3"}
  - Example WRONG: {"content":"line1
  line2"}  ← This breaks JSON parsing!
  
  ## Available Tools in Execution Mode
  
  - list_folder: Explore directories
  - read_file: Read files
  - create_file: Create new files
  - edit_file: Edit existing files
  - item_completed: Mark task complete
  - item_failed: Mark task failed
  
  ## Rules
  
  1. Focus ONLY on the current task
  2. Don't try to complete other checklist items
  3. Be concise in execution mode
  4. Always call item_completed or item_failed when done
  5. If uncertain or blocked, call item_failed to return to planning
  
  </system-reminder>`;
    },
  
    transitionToExecution: function(checklist) {
      this.state.mode = 'execution';
      this.state.checklist = checklist;
      this.state.current_item_index = 0;
      console.log('Transitioned to execution mode with', checklist.length, 'items');
    },
  
    transitionToPlanning: function(reason) {
      this.state.mode = 'planning';
      this.state.current_item_index = 0;
      console.log('Transitioned to planning mode:', reason);
    }
  };
  

  // Module: tool-executor.js
  // Tool Executor
  // Executes tools and returns results
  window.module['tool-executor.js'] = {
    // Define tool availability by mode
    PLANNING_TOOLS: ['list_folder', 'read_file', 'exit_planning'],
    EXECUTION_TOOLS: ['list_folder', 'read_file', 'create_file', 'edit_file', 'item_completed', 'item_failed'],
  
    executeTools: async function(tools) {
      const results = [];
  
      // Execute tools sequentially
      for (let i = 0; i < tools.length; i++) {
        const tool = tools[i];
        const result = await this.executeTool(tool);
  
        results.push(result);
  
        // Stop on first error
        if (!result.success) {
          break;
        }
      }
  
      return results;
    },
  
    validateToolAvailability: function(toolName) {
      const modeManager = window.module['mode-manager.js'];
      const currentMode = modeManager.getMode();
  
      const allowedTools = currentMode === 'planning' ? this.PLANNING_TOOLS : this.EXECUTION_TOOLS;
  
      if (!allowedTools.includes(toolName)) {
        const modeLabel = currentMode === 'planning' ? 'Planning' : 'Execution';
        return {
          valid: false,
          error: `Tool '${toolName}' is not available in ${modeLabel} Mode. Available tools: ${allowedTools.join(', ')}`
        };
      }
  
      return { valid: true };
    },
  
    executeTool: async function(tool) {
      const fileSystem = window.module['file-system.js'];
  
      // Validate tool availability in current mode
      const validation = this.validateToolAvailability(tool.name);
      if (!validation.valid) {
        return {
          tool: tool.name,
          success: false,
          error: validation.error,
          args: tool.args
        };
      }
  
      try {
        switch (tool.name) {
          case 'list_folder':
            return await this.listFolder(tool.args);
  
          case 'read_file':
            return await this.readFile(tool.args);
  
          case 'create_file':
            return await this.createFile(tool.args);
  
          case 'edit_file':
            return await this.editFile(tool.args);
  
          case 'exit_planning':
            return await this.exitPlanning(tool.args);
  
          case 'item_completed':
            return await this.itemCompleted(tool.args);
  
          case 'item_failed':
            return await this.itemFailed(tool.args);
  
          default:
            return {
              tool: tool.name,
              success: false,
              error: `Unknown tool: ${tool.name}`,
              args: tool.args
            };
        }
      } catch (error) {
        return {
          tool: tool.name,
          success: false,
          error: error.message,
          args: tool.args
        };
      }
    },
  
    listFolder: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'list_folder',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the folder in the file tree
      const folder = this.findFolderInTree(fileSystem.fileTree, args.path);
      if (!folder) {
        return {
          tool: 'list_folder',
          success: false,
          error: `Directory not found: ${args.path}`,
          args: args
        };
      }
  
      // Return children
      const entries = folder.children.map(child => ({
        name: child.name,
        type: child.type,
        size_bytes: child.type === 'file' ? child.charCount : 0
      }));
  
      return {
        tool: 'list_folder',
        success: true,
        result: entries,
        args: args
      };
    },
  
    readFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'read_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      // Find the file in the file tree
      const file = this.findFileInTree(fileSystem.fileTree, args.path);
      if (!file) {
        return {
          tool: 'read_file',
          success: false,
          error: `File not found: ${args.path}`,
          args: args
        };
      }
  
      // Read the file
      const content = await fileSystem.readFile(file);
      if (content === null) {
        return {
          tool: 'read_file',
          success: false,
          error: `Failed to read file: ${args.path}`,
          args: args
        };
      }
  
      // TODO: Handle start_line and end_line parameters
      return {
        tool: 'read_file',
        success: true,
        result: content,
        args: args
      };
    },
  
    findFolderInTree: function(tree, path) {
      if (!path || path === '' || path === '.') {
        return { children: tree };
      }
  
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'directory') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFolderInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    },
  
    findFileInTree: function(tree, path) {
      for (const entry of tree) {
        if (entry.path === path && entry.type === 'file') {
          return entry;
        }
        if (entry.type === 'directory' && entry.children) {
          const found = this.findFileInTree(entry.children, path);
          if (found) return found;
        }
      }
      return null;
    },
  
    createFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'create_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      if (!args.path) {
        return {
          tool: 'create_file',
          success: false,
          error: 'Missing required argument: path',
          args: args
        };
      }
  
      if (!args.content && args.content !== '') {
        return {
          tool: 'create_file',
          success: false,
          error: 'Missing required argument: content',
          args: args
        };
      }
  
      try {
        await fileSystem.createFile(args.path, args.content);
        return {
          tool: 'create_file',
          success: true,
          result: { path: args.path, size_bytes: args.content.length },
          args: args
        };
      } catch (error) {
        return {
          tool: 'create_file',
          success: false,
          error: error.message,
          args: args
        };
      }
    },
  
    editFile: async function(args) {
      const fileSystem = window.module['file-system.js'];
  
      if (!fileSystem.directoryHandle) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'No directory selected. Please select a folder first.',
          args: args
        };
      }
  
      if (!args.path) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: path',
          args: args
        };
      }
  
      if (!args.old_text) {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: old_text',
          args: args
        };
      }
  
      if (!args.new_text && args.new_text !== '') {
        return {
          tool: 'edit_file',
          success: false,
          error: 'Missing required argument: new_text',
          args: args
        };
      }
  
      try {
        await fileSystem.editFile(args.path, args.old_text, args.new_text);
        return {
          tool: 'edit_file',
          success: true,
          result: { path: args.path },
          args: args
        };
      } catch (error) {
        return {
          tool: 'edit_file',
          success: false,
          error: error.message,
          args: args
        };
      }
    },
  
    exitPlanning: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (!args.checklist || !Array.isArray(args.checklist)) {
        return {
          tool: 'exit_planning',
          success: false,
          error: 'Missing or invalid checklist argument',
          args: args
        };
      }
  
      // Validate checklist items
      for (let i = 0; i < args.checklist.length; i++) {
        const item = args.checklist[i];
        if (!item.short_desc || !item.long_desc) {
          return {
            tool: 'exit_planning',
            success: false,
            error: `Checklist item ${i} missing short_desc or long_desc`,
            args: args
          };
        }
      }
  
      // Transition to execution mode
      modeManager.transitionToExecution(args.checklist);
  
      return {
        tool: 'exit_planning',
        success: true,
        result: {
          mode: 'execution',
          checklist_items: args.checklist.length,
          current_item: 0,
          checklist: args.checklist
        },
        args: args
      };
    },
  
    itemCompleted: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (modeManager.getMode() !== 'execution') {
        return {
          tool: 'item_completed',
          success: false,
          error: 'Not in execution mode',
          args: args
        };
      }
  
      const currentIndex = modeManager.state.current_item_index;
      const totalItems = modeManager.state.checklist.length;
  
      // Move to next item or return to planning
      if (currentIndex + 1 < totalItems) {
        modeManager.state.current_item_index++;
        return {
          tool: 'item_completed',
          success: true,
          result: {
            completed_item: currentIndex,
            next_item: currentIndex + 1,
            remaining: totalItems - (currentIndex + 1),
            checklist: modeManager.state.checklist
          },
          args: args
        };
      } else {
        // All items complete, return to planning
        modeManager.transitionToPlanning('All checklist items completed');
        return {
          tool: 'item_completed',
          success: true,
          result: {
            completed_item: currentIndex,
            all_complete: true,
            mode: 'planning',
            checklist: modeManager.state.checklist
          },
          args: args
        };
      }
    },
  
    itemFailed: async function(args) {
      const modeManager = window.module['mode-manager.js'];
  
      if (modeManager.getMode() !== 'execution') {
        return {
          tool: 'item_failed',
          success: false,
          error: 'Not in execution mode',
          args: args
        };
      }
  
      // Return to planning mode
      const currentIndex = modeManager.state.current_item_index;
      const checklist = modeManager.state.checklist;
      const reason = args.reason || 'Task failed';
      modeManager.transitionToPlanning(reason);
  
      return {
        tool: 'item_failed',
        success: true,
        result: {
          mode: 'planning',
          reason: reason,
          failed_item: currentIndex,
          checklist: checklist
        },
        args: args
      };
    }
  };
  

  // Module: ui-manager.js
  // UI Manager v2.0
  // Coordinates UI rendering and handles user interactions
  window.module['ui-manager.js'] = {
    init: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const modeManager = window.module['mode-manager.js'];
      const apiClient = window.module['api-client.js'];
  
      conversationManager.init();
      modeManager.init();
      apiClient.init();
  
      this.showIntroScreen();
    },
  
    showIntroScreen: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Create intro container
      const container = document.createElement('div');
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
  
      const content = document.createElement('div');
      content.style.cssText = `
        text-align: center;
        max-width: 500px;
        padding: 40px;
      `;
  
      content.innerHTML = `
        <h1 style="font-size: 32px; margin-bottom: 16px; font-weight: 600;">
          API Test Interface v2.0
        </h1>
        <p style="font-size: 16px; color: #858585; margin-bottom: 32px;">
          Planning Mode • AI-Driven Development
        </p>
        <p style="font-size: 14px; margin-bottom: 32px; line-height: 1.6;">
          Select a project folder to begin. The AI will use tools to explore
          and modify files as you work together.
        </p>
        <button id="selectFolderIntro" style="
          background: #0e639c;
          color: white;
          border: none;
          padding: 12px 32px;
          border-radius: 3px;
          cursor: pointer;
          font-size: 15px;
          font-weight: 500;
        ">Select Folder</button>
      `;
  
      container.appendChild(content);
      document.body.appendChild(container);
  
      document.getElementById('selectFolderIntro').addEventListener('click', () => this.selectFolderAndStart());
    },
  
    selectFolderAndStart: async function() {
      const fileSystem = window.module['file-system.js'];
      const success = await fileSystem.requestDirectory();
  
      if (success) {
        this.initChatUI();
      }
    },
  
    initChatUI: function() {
      // Remove existing UI
      document.body.innerHTML = '';
  
      // Add animation styles
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulse {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 1; }
        }
      `;
      document.head.appendChild(style);
  
      // Create main container
      const container = document.createElement('div');
      container.id = 'test-interface';
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      // Chat area (full width, no header)
      const chatPanel = document.createElement('div');
      chatPanel.style.cssText = `
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      `;
  
      const chatArea = document.createElement('div');
      chatArea.id = 'chatArea';
      chatArea.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        padding-bottom: 140px;
      `;
      chatPanel.appendChild(chatArea);
  
      // Test button for continuation debugging
      const testButton = document.createElement('button');
      testButton.id = 'testContinuationBtn';
      testButton.textContent = 'Test Continuation';
      testButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 8px 12px;
        background: #3c3c3c;
        color: white;
        border: 1px solid #3e3e42;
        border-radius: 4px;
        cursor: pointer;
        font-family: monospace;
        font-size: 11px;
        z-index: 100;
      `;
      testButton.addEventListener('click', () => this.testContinuation());
      chatPanel.appendChild(testButton);
  
      // Gradient overlay - fades chat history behind input
      const gradientOverlay = document.createElement('div');
      gradientOverlay.style.cssText = `
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 160px;
        background: linear-gradient(to bottom, transparent 0%, #1e1e1e 80%);
        pointer-events: none;
        z-index: 50;
      `;
      chatPanel.appendChild(gradientOverlay);
  
      // Input area - floats at bottom, no padding or shadow
      const inputArea = document.createElement('div');
      inputArea.style.cssText = `
        position: absolute;
        bottom: 8px;
        left: 20px;
        right: 20px;
        z-index: 60;
      `;
      inputArea.innerHTML = `
        <div style="border: 1px solid #3e3e42; border-radius: 4px; overflow: hidden;">
          <textarea id="userInput" style="
            width: 100%;
            min-height: 20px;
            max-height: calc(33vh);
            background: #3c3c3c;
            color: white;
            border: none;
            outline: none;
            margin: 0;
            padding: 10px;
            font-family: monospace;
            font-size: 13px;
            resize: none;
            overflow-y: auto;
            line-height: 1.4;
            display: block;
          "></textarea>
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background: #252526; border-top: 1px solid #3e3e42;">
            <span id="folderName" style="font-size: 11px; color: #858585;"></span>
            <span id="charCount" style="font-size: 11px; color: #858585;"></span>
          </div>
        </div>
        <div id="errorMsg" style="margin-top: 4px; color: #f48771; font-size: 13px;"></div>
      `;
      chatPanel.appendChild(inputArea);
  
      container.appendChild(chatPanel);
      document.body.appendChild(container);
  
      // Event listeners
      const userInput = document.getElementById('userInput');
  
      // Auto-resize textarea as content changes
      const autoResize = () => {
        userInput.style.height = '20px'; // Reset to min height
        userInput.style.height = Math.min(userInput.scrollHeight, window.innerHeight / 3) + 'px';
      };
  
      userInput.addEventListener('input', autoResize);
      userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.handleSubmit();
        }
        // Shift+Enter allows newline (default textarea behavior)
        // Trigger resize after key is processed
        setTimeout(autoResize, 0);
      });
  
      // Set folder name
      const fileSystem = window.module['file-system.js'];
      const folderNameElement = document.getElementById('folderName');
      if (fileSystem.directoryHandle) {
        folderNameElement.textContent = fileSystem.directoryHandle.name;
      }
  
      this.updateCharCounter();
    },
  
    handleSubmit: async function() {
      const input = document.getElementById('userInput');
      const content = input.value.trim();
  
      if (!content) return;
  
      // Clear input and reset height
      input.value = '';
      input.style.height = '20px';
  
      // Hide any previous error
      this.hideError();
  
      try {
        // Add user message
        await this.addUserMessage(content);
  
        // Get AI response
        await this.getAIResponse();
  
      } catch (error) {
        console.error('Error:', error);
        this.showError(error.message);
      }
    },
  
    addUserMessage: async function(content) {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
  
      const userMessage = {
        type: 'user',
        content: content
      };
  
      await conversationManager.addMessage(userMessage);
      this.renderChat();
      this.updateCharCounter();
    },
  
    getAIResponse: async function() {
      const conversationManager = window.module['conversation-manager.js'];
      const apiRenderer = window.module['api-renderer.js'];
      const apiClient = window.module['api-client.js'];
      const messageProcessor = window.module['message-processor.js'];
      const conversationFlow = window.module['conversation-flow.js'];
      const toolExecutor = window.module['tool-executor.js'];
      const utils = window.module['utils.js'];
      const config = window.module['config.js'];
  
      // Show loading indicator
      this.showLoading('Thinking...');
  
      // Render messages for API
      const messages = conversationManager.getMessages();
      const apiMessages = apiRenderer.renderMessagesForAPI(messages);
  
      // Create chat if needed
      if (!apiClient.chatId && messages.length > 0) {
        const firstUserMsg = messages.find(m => m.type === 'user');
        if (firstUserMsg) {
          await apiClient.createNewChat(firstUserMsg.content);
        }
      }
  
      // Get completion with streaming
      const assistantMessageId = utils.generateUUID();
  
      let retryCount = 0;
      let success = false;
  
      while (retryCount < config.MAX_RETRIES && !success) {
        try {
          const response = await apiClient.getCompletion(apiMessages, assistantMessageId);
  
          // Track streaming message for real-time UI updates
          let streamingMessageId = null;
          let responseType = null;
  
          // Use extracted conversation-flow module
          const result = await conversationFlow.handleAIResponse(
            response,
            assistantMessageId,
            apiMessages,
            {
              onProgress: (status) => this.showLoading(status),
              onChunk: (chunk, accumulated) => {
                // Detect response type and create streaming message if needed
                if (responseType === null && accumulated.length > 0) {
                  const firstChar = accumulated.charAt(0);
                  if (firstChar === '=') {
                    responseType = 'message';
                    streamingMessageId = utils.generateUUID();
                    // Note: We add this synchronously - onChunk can't be async
                    // The 500K limit check happens in addMessage, but we're creating a placeholder here
                    // that will be removed if summarization occurs before the full message completes
                    conversationManager.messages.push({
                      id: streamingMessageId,
                      type: 'assistant',
                      content: '',
                      streaming: true,
                      timestamp: Date.now(),
                      parentId: conversationManager.messages.length > 0 ? conversationManager.messages[conversationManager.messages.length - 1].id : null,
                      childrenIds: []
                    });
                  } else if (firstChar === '{') {
                    responseType = 'tools';
                  }
                }
  
                // Update streaming message in real-time
                if (responseType === 'message' && streamingMessageId) {
                  let messageContent = accumulated.substring(1); // Remove = prefix
                  const terminatorIndex = messageContent.indexOf(messageProcessor.TERMINATOR);
                  if (terminatorIndex !== -1) {
                    messageContent = messageContent.substring(0, terminatorIndex);
                  }
  
                  const msgs = conversationManager.getMessages();
                  const streamingMsg = msgs.find(m => m.id === streamingMessageId);
                  if (streamingMsg) {
                    streamingMsg.content = messageContent;
                    this.renderChat();
                    this.updateCharCounter();
                  }
                }
              }
            }
          );
  
          // Handle the result
          if (result.success) {
            const aiResponse = result.content;
  
            if (aiResponse.type === 'message') {
              // Message was already streamed, just mark as complete
              if (streamingMessageId) {
                const msgs = conversationManager.getMessages();
                const streamingMsg = msgs.find(m => m.id === streamingMessageId);
                if (streamingMsg) {
                  streamingMsg.streaming = false;
                  streamingMsg.content = aiResponse.text;
                }
              } else {
                // Fallback: add message if streaming didn't work
                await conversationManager.addMessage({
                  type: 'assistant',
                  content: aiResponse.text
                });
              }
              this.renderChat();
              this.updateCharCounter();
              this.hideLoading();
              success = true;
  
            } else if (aiResponse.type === 'execute') {
              // Tool execution - create ONE tool_use message with ALL tools
              const toolUseMessage = await conversationManager.addMessage({
                type: 'tool_use',
                tools: aiResponse.tools
              });
  
              this.renderChat();
              this.updateCharCounter();
  
              // Execute tools sequentially, creating individual tool_result messages
              for (const tool of aiResponse.tools) {
                this.showLoading(`Executing ${tool.name}...`);
  
                const toolResults = await toolExecutor.executeTools([tool]);
                const toolResult = toolResults[0];
  
                await conversationManager.addMessage({
                  type: 'tool_result',
                  parentId: toolUseMessage.id,
                  tool: toolResult.tool,
                  success: toolResult.success,
                  result: toolResult.result,
                  error: toolResult.error,
                  args: toolResult.args
                });
  
                this.renderChat();
                this.updateCharCounter();
              }
  
              this.hideLoading();
  
              // Auto-call API again to let AI respond to tool results
              await this.getAIResponse();
              success = true;
            }
  
          } else if (result.needsRetry) {
            // Error already added to conversation by conversation-flow
            this.renderChat();
            this.updateCharCounter();
  
            // Call AI again so it can see the error and fix it
            console.log('Error detected, calling AI again with error context');
            await this.getAIResponse();
            return;
  
          } else {
            // Fatal error
            console.error('Fatal error:', result.error);
            this.hideLoading();
            throw new Error(result.error);
          }
  
        } catch (error) {
          retryCount++;
          console.warn(`Attempt ${retryCount} failed:`, error.message);
  
          if (retryCount >= config.MAX_RETRIES) {
            this.hideLoading();
            throw error;
          }
  
          // Wait 1 second before retry
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
  
      this.hideLoading();
      this.updateCharCounter();
    },
  
    renderChat: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const uiRenderer = window.module['ui-renderer.js'];
      const chatArea = document.getElementById('chatArea');
  
      chatArea.innerHTML = '';
  
      const messages = conversationManager.getMessages();
  
      // Store messages in ui-renderer for tool_use/result lookups
      uiRenderer.allMessages = messages;
  
      messages.forEach(msg => {
        const msgElement = uiRenderer.renderMessage(msg);
        chatArea.appendChild(msgElement);
      });
  
      // Scroll to bottom
      chatArea.scrollTop = chatArea.scrollHeight;
    },
  
    updateCharCounter: function() {
      const conversationManager = window.module['conversation-manager.js'];
      const utils = window.module['utils.js'];
      const charCount = document.getElementById('charCount');
  
      const total = conversationManager.getTotalCharacterCount();
      charCount.textContent = `Total: ${utils.formatCharCount(total)}`;
    },
  
    showError: function(message) {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = message;
    },
  
    hideError: function() {
      const errorMsg = document.getElementById('errorMsg');
      errorMsg.textContent = '';
    },
  
    showLoading: function(text = 'Processing...') {
      const chatArea = document.getElementById('chatArea');
      if (!chatArea) return;
  
      // Remove any existing loading message
      const existing = document.getElementById('loading-message');
      if (existing) {
        existing.remove();
      }
  
      // Create loading pseudo-message
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'loading-message';
      loadingDiv.style.cssText = 'display: flex; gap: 12px; margin-bottom: 4px; align-items: flex-start; font-family: monospace; font-size: 13px;';
  
      // Gray circle indicator that pulses
      const indicator = document.createElement('div');
      indicator.style.cssText = 'width: 8px; height: 8px; border-radius: 50%; margin-top: 6px; flex-shrink: 0; background: #858585; animation: pulse 1.5s ease-in-out infinite;';
  
      // Text content
      const content = document.createElement('div');
      content.style.cssText = 'flex: 1; min-width: 0; color: #858585; padding: 2px 0;';
      content.textContent = text;
  
      loadingDiv.appendChild(indicator);
      loadingDiv.appendChild(content);
      chatArea.appendChild(loadingDiv);
  
      // Scroll to bottom
      chatArea.scrollTop = chatArea.scrollHeight;
    },
  
    hideLoading: function() {
      const loadingMessage = document.getElementById('loading-message');
      if (loadingMessage) {
        loadingMessage.remove();
      }
    },
  
    testContinuation: async function() {
      console.log('=== CONTINUATION TEST STARTED ===');
  
      const apiClient = window.module['api-client.js'];
      const config = window.module['config.js'];
      const utils = window.module['utils.js'];
  
      try {
        // First make a real API call asking for a large response that will get cut off
        const testPrompt = 'Please write a very long detailed explanation about how computers work, starting from transistors all the way to operating systems. Make it at least 5000 words.';
  
        console.log('1. Making initial request for large response...');
  
        const initialPayload = {
          stream: true,
          model: config.MODEL,
          messages: [{
            role: 'user',
            content: testPrompt
          }],
          params: {},
          features: { web_search: false },
          session_id: utils.generateSessionId(),
          chat_id: null,
          id: utils.generateUUID()
        };
  
        const initialResponse = await fetch(`${config.API_BASE}/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(initialPayload)
        });
  
        console.log(`   Response status: ${initialResponse.status}`);
  
        // Read partial response (simulate getting cut off)
        const reader = initialResponse.body.getReader();
        const decoder = new TextDecoder();
        let partialContent = '';
        let chunkCount = 0;
  
        // Read only 50 chunks to simulate cutoff
        for (let i = 0; i < 50; i++) {
          const { done, value } = await reader.read();
          if (done) break;
  
          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split('\n');
  
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') break;
              try {
                const parsed = JSON.parse(data);
                if (parsed.choices?.[0]?.delta?.content) {
                  partialContent += parsed.choices[0].delta.content;
                }
              } catch (e) {}
            }
          }
          chunkCount++;
        }
  
        console.log(`2. Partial response received: ${chunkCount} chunks, ${partialContent.length} chars`);
        console.log(`   First 100 chars: "${partialContent.substring(0, 100)}..."`);
        console.log(`   Last 100 chars: "...${partialContent.substring(partialContent.length - 100)}"`);
  
        // Now test continuation
        console.log('3. Testing continuation with partial content...');
  
        // Extract without = prefix if present
        let cleanPartial = partialContent;
        if (cleanPartial.startsWith('=')) {
          cleanPartial = cleanPartial.substring(1);
          console.log('   Removed = prefix from partial');
        }
  
        const continueMessages = [{
          role: 'user',
          content: testPrompt
        }, {
          role: 'assistant',
          content: cleanPartial
        }, {
          role: 'user',
          content: '[System: Your previous response was cut off. Please continue from where you left off, starting with the exact continuation of your last incomplete response. Do not restart or summarize - just continue the exact text.]'
        }];
  
        console.log(`   Sending continuation request with ${cleanPartial.length} char partial`);
  
        const continuePayload = {
          stream: true,
          model: config.MODEL,
          messages: continueMessages,
          params: {},
          features: { web_search: false },
          session_id: utils.generateSessionId(),
          chat_id: null,
          id: utils.generateUUID(),
          background_tasks: {
            title_generation: false,
            tags_generation: false
          }
        };
  
        const continueResponse = await fetch(`${config.API_BASE}/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(continuePayload)
        });
  
        console.log(`   Continuation response status: ${continueResponse.status}`);
  
        // Read first chunks of continuation
        const continueReader = continueResponse.body.getReader();
        const continueDecoder = new TextDecoder();
        let continuationContent = '';
        let continueChunkCount = 0;
  
        for (let i = 0; i < 10; i++) {
          const { done, value } = await continueReader.read();
          if (done) break;
  
          const chunk = continueDecoder.decode(value, { stream: true });
          const lines = chunk.split('\n');
  
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.choices?.[0]?.delta?.content) {
                  continuationContent += parsed.choices[0].delta.content;
                }
              } catch (e) {}
            }
          }
          continueChunkCount++;
        }
  
        console.log(`4. Continuation received: ${continueChunkCount} chunks, ${continuationContent.length} chars`);
        console.log(`   First 200 chars of continuation: "${continuationContent.substring(0, 200)}"`);
        console.log(`   First char: "${continuationContent.charAt(0)}" (ASCII ${continuationContent.charCodeAt(0)})`);
  
        // Analysis
        const startsWithEquals = continuationContent.startsWith('=');
        const lastWords = cleanPartial.split(' ').slice(-5).join(' ');
        const firstWords = continuationContent.split(' ').slice(0, 5).join(' ');
  
        console.log('\n5. ANALYSIS:');
        console.log(`   Partial ended with: "...${lastWords}"`);
        console.log(`   Continuation started with: "${firstWords}..."`);
        console.log(`   Starts with =: ${startsWithEquals} ${startsWithEquals ? '❌ BAD - restarting' : '✅ GOOD'}`);
        console.log(`   Looks like continuation: ${!startsWithEquals && continuationContent.length > 0 ? '✅ GOOD' : '❌ BAD'}`);
  
        console.log('\n=== TEST COMPLETE ===');
  
      } catch (error) {
        console.error('TEST FAILED:', error.message, error);
      }
    }
  };
  

  // Module: ui-renderer.js
  // UI Renderer v3.0
  // Clean design with status indicators in gutter
  window.module['ui-renderer.js'] = {
    allMessages: [], // Store reference to all messages for lookups
    expandedSummaries: new Set(), // Track which summaries are expanded
  
    renderMessage: function(message) {
      const container = document.createElement('div');
      container.style.cssText = 'display: flex; gap: 12px; margin-bottom: 4px; align-items: flex-start; font-family: monospace; font-size: 13px;';
  
      // Create gutter indicator
      const indicator = document.createElement('div');
      indicator.style.cssText = 'width: 8px; height: 8px; border-radius: 50%; margin-top: 6px; flex-shrink: 0;';
  
      // Create content area
      const content = document.createElement('div');
      content.style.cssText = 'flex: 1; min-width: 0;';
  
      if (message.type === 'user') {
        // Gray background with white text for user messages
        indicator.style.display = 'none'; // No indicator for user messages
        content.style.cssText += 'background: #3c3c3c; color: white; padding: 8px 12px; border-radius: 4px;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.content;
  
      } else if (message.type === 'assistant') {
        // White circle indicator, no background
        indicator.style.backgroundColor = 'white';
        content.style.cssText += 'color: #d4d4d4; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.content;
  
      } else if (message.type === 'tool_use') {
        // Handle both old format (msg.tool) and new format (msg.tools array)
        const tools = message.tools || [message.tool];
  
        // Check if this is a checklist tool (only show special UI for single checklist tools)
        const isChecklistTool = tools.length === 1 &&
          (tools[0].name === 'exit_planning' || tools[0].name === 'item_completed' || tools[0].name === 'item_failed');
  
        if (isChecklistTool) {
          // Hide indicator for checklist tools - we'll show the checklist instead
          indicator.style.display = 'none';
          const tool = tools[0];
          const result = this.findToolResult(message.id);
  
          // Show checklist with current state
          if (tool.name === 'exit_planning' && tool.args && tool.args.checklist) {
            content.style.cssText += 'padding: 2px 0; padding-left: 20px;';
            content.innerHTML = this.renderChecklist(tool.args.checklist);
          } else if (tool.name === 'item_completed' || tool.name === 'item_failed') {
            // For item updates, get current checklist state from result
            if (result && result.result && result.result.checklist) {
              content.style.cssText += 'padding: 2px 0; padding-left: 20px;';
              content.innerHTML = this.renderChecklist(
                result.result.checklist,
                result.result.completed_item,
                result.result.failed_item
              );
            } else {
              content.style.cssText += 'color: #858585; padding: 2px 0; padding-left: 20px;';
              content.textContent = this.formatToolName(tool.name);
            }
          }
        } else {
          // Normal tools - check if ALL tools have results
          const allToolsComplete = tools.every(tool => {
            // Find result for this specific tool by checking tool name
            return this.allMessages.some(m =>
              m.type === 'tool_result' &&
              m.parentId === message.id &&
              m.tool === tool.name
            );
          });
  
          if (allToolsComplete) {
            // All tools done - check if any failed
            const anyFailed = this.allMessages.some(m =>
              m.type === 'tool_result' &&
              m.parentId === message.id &&
              !m.success
            );
            indicator.style.backgroundColor = anyFailed ? '#f48771' : '#4ec9b0';
          } else {
            // Still executing - show pulsing gray
            indicator.style.backgroundColor = '#858585';
            indicator.style.animation = 'pulse 1.5s ease-in-out infinite';
          }
  
          content.style.cssText += 'color: #d4d4d4; padding: 2px 0; cursor: pointer;';
  
          // Render tools list
          if (tools.length === 1) {
            // Single tool - show as one-liner
            const toolName = this.formatToolName(tools[0].name);
            const params = this.formatToolParams(tools[0].name, tools[0].args);
            content.innerHTML = `<span style="font-weight: bold;">${this.escapeHtml(toolName)}</span><span style="color: #858585;"> ${params}</span>`;
          } else {
            // Multiple tools - show count
            content.innerHTML = `<span style="font-weight: bold;">${tools.length} tools</span><span style="color: #858585;"> (${tools.map(t => this.formatToolName(t.name)).join(', ')})</span>`;
          }
  
          content.addEventListener('click', () => this.showToolModal('Tool Use', tools));
        }
  
      } else if (message.type === 'tool_result') {
        // Add circle indicator for the result
        indicator.style.backgroundColor = message.success ? '#4ec9b0' : '#f48771'; // Green or red
  
        // Special rendering for checklist tools
        if (message.tool === 'exit_planning' || message.tool === 'item_completed' || message.tool === 'item_failed') {
          // Hide indicator for these special tools - we'll show checklist instead
          indicator.style.display = 'none';
  
          if (message.result && message.result.checklist) {
            content.style.cssText += 'padding: 2px 0; padding-left: 20px;';
            content.innerHTML = this.renderChecklist(message.result.checklist, message.result.completed_item, message.result.failed_item);
          } else {
            content.style.cssText += 'color: #858585; padding: 2px 0; padding-left: 20px;';
            content.textContent = this.formatToolResult(message);
          }
        } else {
          // Normal tool results - no indicator, just text indented to align with content
          indicator.style.display = 'none';
          content.style.cssText += 'color: #858585; padding: 2px 0; padding-left: 20px; cursor: pointer;';
          content.textContent = this.formatToolResult(message);
          content.addEventListener('click', () => this.showToolModal(`Tool Result: ${message.tool}`, message.result));
        }
  
      } else if (message.type === 'system_error') {
        indicator.style.backgroundColor = '#f48771'; // Red
        content.style.cssText += 'color: #f48771; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = `Error: ${message.error}`;
  
      } else if (message.type === 'system_warning') {
        indicator.style.backgroundColor = '#dcdcaa'; // Yellow
        content.style.cssText += 'color: #dcdcaa; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = message.warning;
  
      } else if (message.type === 'summary') {
        // Yellow indicator for summary
        indicator.style.backgroundColor = '#dcdcaa'; // Yellow
        content.style.cssText += 'color: #858585; padding: 2px 0; cursor: pointer;';
  
        // Create collapsed summary view
        const summaryId = 'summary-' + message.id;
        const isExpanded = this.expandedSummaries && this.expandedSummaries.has(message.id);
  
        if (isExpanded) {
          content.innerHTML = `<div style="font-weight: bold; margin-bottom: 4px;">📋 Summary (summarizes ${message.summarizes_to - message.summarizes_from + 1} messages) [Click to collapse]</div><div style="white-space: pre-wrap;">${this.escapeHtml(message.content)}</div>`;
        } else {
          content.innerHTML = `<div style="font-weight: bold;">📋 Summary (summarizes ${message.summarizes_to - message.summarizes_from + 1} messages) [Click to expand]</div>`;
        }
  
        content.addEventListener('click', () => this.toggleSummary(message.id));
  
      } else if (message.type === 'partial') {
        // White circle indicator for partial (like assistant)
        indicator.style.backgroundColor = 'white';
        content.style.cssText += 'color: #d4d4d4; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
  
        // Show streaming indicator if incomplete
        if (message.completion === false) {
          content.innerHTML = `${this.escapeHtml(message.content)}<span style="color: #858585; font-style: italic;"> (streaming...)</span>`;
        } else {
          content.textContent = message.content;
        }
  
      } else {
        // Unknown type
        indicator.style.backgroundColor = '#858585';
        content.style.cssText += 'color: #858585; padding: 2px 0;';
        content.style.whiteSpace = 'pre-wrap';
        content.textContent = JSON.stringify(message, null, 2);
      }
  
      container.appendChild(indicator);
      container.appendChild(content);
      return container;
    },
  
    findToolResult: function(toolUseId) {
      // Look through all messages to find tool_result with matching parentId
      for (const msg of this.allMessages) {
        if (msg.type === 'tool_result' && msg.parentId === toolUseId) {
          return msg;
        }
      }
      return null;
    },
  
    escapeHtml: function(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    },
  
    formatToolName: function(name) {
      // Convert snake_case to Title Case
      return name.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
    },
  
    formatToolParams: function(toolName, args) {
      // Format parameters based on tool type
      if (toolName === 'read_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'list_folder') {
        return this.escapeHtml(args.path || '.');
      } else if (toolName === 'create_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'edit_file') {
        return this.escapeHtml(args.path || '');
      } else if (toolName === 'exit_planning') {
        const count = args.checklist ? args.checklist.length : 0;
        return `${count} item${count !== 1 ? 's' : ''}`;
      } else if (toolName === 'item_completed' || toolName === 'item_failed') {
        return args.reason ? this.escapeHtml(args.reason) : '';
      } else {
        // Generic fallback - show all args
        return this.escapeHtml(JSON.stringify(args));
      }
    },
  
    formatToolResult: function(message) {
      if (!message.success) {
        return `Error: ${message.error}`;
      }
  
      const result = message.result;
  
      // Format based on tool type
      if (message.tool === 'read_file') {
        if (result.content) {
          const lines = result.content.split('\n').length;
          return `${lines} line${lines !== 1 ? 's' : ''} read`;
        }
        return 'File read';
      } else if (message.tool === 'list_folder') {
        if (result.entries) {
          const count = result.entries.length;
          return `${count} item${count !== 1 ? 's' : ''} found`;
        }
        return 'Folder listed';
      } else if (message.tool === 'create_file') {
        return 'File created';
      } else if (message.tool === 'edit_file') {
        return 'File edited';
      } else if (message.tool === 'exit_planning') {
        return 'Entering execution mode';
      } else if (message.tool === 'item_completed') {
        return 'Task completed';
      } else if (message.tool === 'item_failed') {
        return 'Task failed';
      } else {
        // Generic fallback
        return JSON.stringify(result);
      }
    },
  
    renderChecklist: function(checklist, completedIndex, failedIndex) {
      if (!checklist || !Array.isArray(checklist)) {
        return 'Invalid checklist';
      }
  
      const items = checklist.map((item, index) => {
        let statusIcon = '○'; // Pending
        let color = '#858585'; // Gray
  
        if (completedIndex !== undefined && index <= completedIndex) {
          statusIcon = '✓'; // Completed
          color = '#4ec9b0'; // Green
        } else if (failedIndex !== undefined && index === failedIndex) {
          statusIcon = '✗'; // Failed
          color = '#f48771'; // Red
        }
  
        return `<div style="color: ${color}; margin-bottom: 2px;">${statusIcon} ${this.escapeHtml(item.short_desc)}</div>`;
      }).join('');
  
      return items;
    },
  
    showToolModal: function(title, content) {
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      `;
  
      // Create modal container
      const modal = document.createElement('div');
      modal.style.cssText = `
        background: #252526;
        border-radius: 8px;
        max-width: 80vw;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      `;
  
      // Modal header
      const header = document.createElement('div');
      header.style.cssText = `
        padding: 16px 20px;
        border-bottom: 1px solid #3e3e42;
        display: flex;
        justify-content: space-between;
        align-items: center;
      `;
      header.innerHTML = `
        <div style="color: #d4d4d4; font-weight: bold; font-size: 14px;">${this.escapeHtml(title)}</div>
        <button id="closeModal" style="
          background: none;
          border: none;
          color: #858585;
          font-size: 20px;
          cursor: pointer;
          padding: 0;
          width: 24px;
          height: 24px;
          line-height: 1;
        ">&times;</button>
      `;
  
      // Modal content
      const contentDiv = document.createElement('div');
      contentDiv.style.cssText = `
        padding: 20px;
        overflow-y: auto;
        flex: 1;
        font-family: monospace;
        font-size: 12px;
        color: #d4d4d4;
        white-space: pre-wrap;
      `;
      contentDiv.textContent = JSON.stringify(content, null, 2);
  
      modal.appendChild(header);
      modal.appendChild(contentDiv);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
  
      // Close handlers
      const closeModal = () => {
        document.body.removeChild(overlay);
      };
  
      document.getElementById('closeModal').addEventListener('click', closeModal);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeModal();
        }
      });
  
      // Close on escape key
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
    },
  
    toggleSummary: function(messageId) {
      // Toggle expanded state
      if (this.expandedSummaries.has(messageId)) {
        this.expandedSummaries.delete(messageId);
      } else {
        this.expandedSummaries.add(messageId);
      }
  
      // Trigger re-render (the ui-manager should call this)
      const uiManager = window.module['ui-manager.js'];
      if (uiManager && uiManager.renderChat) {
        uiManager.renderChat();
      }
    }
  };
  

  // Module: utils.js
  // Utility Functions
  window.module['utils.js'] = {
    generateUUID: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    },
  
    generateSessionId: function() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
      let result = '';
      for (let i = 0; i < 20; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    },
  
    getTimestamp: function() {
      return Math.floor(Date.now() / 1000);
    },
  
    countCharacters: function(messages) {
      // Count entire JSON structure, not just content
      // This matches the spec requirement for 500K limit
      return messages.reduce((total, msg) => total + JSON.stringify(msg).length, 0);
    },
  
    formatCharCount: function(count) {
      return `${(count / 1000).toFixed(1)}K`;
    }
  };
  

  // Run main module
  if (window.module['main.js']) {
    window.module['main.js'].run();
  } else {
    console.error('Error: main.js module not found');
  }
})();
